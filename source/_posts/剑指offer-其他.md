---
title: '剑指offer-其他'
date: 2019-06-21 13:52:09
tags:
	- 剑指offer
categories: 
	- 数据结构与算法
	- 剑指offer
---

## 目录

位运算：

| 题目                                                         | 难度 |                                                              |
| ------------------------------------------------------------ | ---- | ------------------------------------------------------------ |
| [不用加减乘除做加法.note](note://016376B881D24D5DA4E1252EBAAD3CBB) | ☆☆   | a^b代表不进位的二进制加法，(a&b)<<1为二进制加法所有的进位信息，然后通过循环或者递归，直到进位为0。   扩展题：不使用新的变量，交换两个变量的值 |

动态规划：

| 题目                                                         | 难度 |                                                          |
| ------------------------------------------------------------ | ---- | -------------------------------------------------------- |
| [9.变态跳台阶.note](note://E574D3AC0C7D4F1994EE0A3196695E28) | ☆    | 和动态规划中的跳台阶类似                                 |
| [10.矩形覆盖.note](note://EE2B5194B93E47D7856EB6CCFA736BF9)  | ☆    | 从简单例子开始推导，得到状态转移方程和斐波那契数列一致。 |

思维严密性：

| 题目                                                         | 难度 |                                  |
| ------------------------------------------------------------ | ---- | -------------------------------- |
| [16.数值的整数次方.note](note://C7ED1D57EA364E5C9299E2F20BD87951) | ☆    | 考虑base正负零，exponent正负零。 |

## 不用加减乘除做加法

**题目：**

不用加减乘除做加法

写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。

**解析：**

　　首先看十进制是如何做的： 5+7=12，三步走

第一步：相加各位的值，不算进位，得到2。

第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。

第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。

　　

同样我们可以用三步走的方式计算二进制值相加： 5-101，7-111

第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。

第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&111)<<1。

第三步重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&1010)<<1。 继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果。

```c++
class Solution {
public:
    int Add(int num1, int num2)
    {
        while(num2 != 0){
            int temp = num1^num2; //二进制不带进位的加法
            num2 = (num1 & num2)<<1; //二进制加法的每一位进位情况
            num1 = temp;
        }
        return num1;  //直到进位为0，返回num1
    }
};
```

**扩展题目：**

不使用新的变量，交换两个变量的值

①基于加减法

```c++
a = a + b; 
b = a - b; 
a = a - b; 
```

②基于异或运算

```c++
a = a ^ b; 
b = a ^ b; 
a = a ^ b;
```

## 变态跳台阶

**题目描述**

一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。

**思路：动态规划**

```c++
class Solution {
public:
    int jumpFloorII(int number) {
        vector<int> dp(number+1,0);
        if(number==0)
            return 0;
        else if(number == 1)
            return 1;
        else if(number == 2)
            return 2;
        dp[0] = 1;
        dp[1] = 1;
        dp[2] = 2;
        for(int i=3;i<=number;i++){
            for(int j=0;j<i;j++)
                dp[i] += dp[j];
        }
        return dp[number];
    }
};
```

## 矩形覆盖

**题目描述**

我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？

思路：

依旧是斐波那契数列

2*n的大矩形，和n个2*1的小矩形

其中target*2为大矩阵的大小

有以下几种情形：

1⃣️      target <= 0 大矩形为<= 2*0,直接return 1；

2⃣️      target = 1大矩形为2*1，只有一种摆放方法，return1；

3⃣️      target = 2 大矩形为2*2，有两种摆放方法，return2；

4⃣️      target = n 分为两步考虑：

​        第一次摆放一块 2*1 的小矩阵，则摆放方法总共为f(target - 1)

{%asset_img 01.png%}

第一次摆放一块1*2的小矩阵，则摆放方法总共为f(target-2)

因为，摆放了一块1*2的小矩阵（用√√表示），对应下方的1*2（用××表示）摆放方法就确定了，所以为f(targte-2)

{%asset_img 02.png%}

实际是一个动态规划，也是一个斐波那契数列，此处按照斐波那契数列求解;

```c++
class Solution {
public:
    int rectCover(int number) {
        int prepre = 1;
        int pre = 2;
        int cur;
        if(number ==0)
            return 0;
        else if(number == 1)
            return 1;
        else if(number == 2)
            return 2;
        else{
            for(int i=3;i<=number;i++){
                cur = prepre + pre;
                prepre = pre;
                pre = cur;
            }
        }
        return cur;
    }
};
```

## 数值的整数次方

**题目描述**

给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。

思路：重点考察思维的严密性，对于double int 这种数据类型，不能上来就默认为正，分别考虑正、负和零的情况，从而发现以下几种特殊情况：

（1）底数为0.0，指数为负数，会导致分母为零的异常；

（2）底数为0.0，指数为0，无意义；

（3）注意指数分正负两种情况时，数学表达式不同。

优化：常规思路，在循环中，一直底数*底数，但是当指数不太大时可以考虑采用递归的方式实现如下算式，时间复杂度会大大降低。

{%asset_img 03.png%}

```c++
class Solution {
public:
    double Power(double base, int exponent) {
        if(base==0.0)
            return 0.0;
        if(exponent == 0)
            return 1.0;
        else if(exponent > 0){
            return pow(base,exponent);
        }
        else
            return 1.0/pow(base,-exponent);
    }
};
```

