---
title: '设计模式'
date: 2019-03-17 13:52:09
tags:
	- 设计模式
categories: 
	- 设计模式
	- 设计模式(23)
---

## 1.设计模式概述

历史性著作《设计模式：可复用面向对象软件的基础》一书中描述了23种经典面向对象设计模式，创立了模式在软件设计中的地位。

{%asset_img 01.jpg%}

### 什么是好的软件设计？

软件设计的金科玉律：
**复用！**
变化是复用的天敌！
面向对象设计最大的优势在于：
**抵御变化！**



### 重新认识面向对象

\>**理解隔离变化**·从宏观层面来看，面向对象的构建方式更能适应软件的变化，能将变化所带来的影响减为最小

**>各司其职·**从微观层面来看，面向对象的方式更强调各个类的“责任"·由于需求变化导致的新增类型不应该影响原来类型的实现——是所谓各负其责(比如，line类draw()负责画线,rect类draw()负责画矩形..)

**>对象是什么？**

·从语言实现层面来看，对象封装了代码和数据。

·从规格层面讲，对象是一系列可被使用的公共接口。

·从概念层面讲，对象是某种拥有责任的抽象。



#### 面向对象设计原则

**1.依赖倒置原则（DIP）**

- 高层模块(稳定)不应该依赖于低层模块(变化)，二者都应该依赖于抽象(稳定) 。
- 抽象(稳定)不应该依赖于实现细节(变化) ，实现细节应该依赖于抽象(稳定)。

{%asset_img 02.png%}

**上面第二种方式隔离了变化。**



2.开放封闭原则（OCP）

- 对扩展开放，对更改封闭。
- 类模块应该是可扩展的，但是不可修改。

3单一职责原则（SRP）

- 一个类应该仅有一个引起它变化的原因。
- 变化的方向隐含着类的责任。

4.Liskov 替换原则（LSP）

- 子类必须能够替换它们的基类(IS-A)。
- 继承表达类型抽象。

5.接口隔离原则（ISP）

- 不应该强迫客户程序依赖它们不用的方法。
- 接口应该小而完备。

6.优先使用对象组合，而不是类继承

- 类继承通常为“白箱复用”，对象组合通常为“黑箱复用” 。
- 继承在某种程度上破坏了封装性，子类父类耦合度高。
- 而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。

7.封装变化点

- 使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。
- 

**8.针对接口编程**，而不是针对实现编程

- 不将变量类型声明为某个特定的具体类，而是声明为某个接口。
- 客户程序无需获知对象的具体类型，只需要知道对象所具有的接口。
- 减少系统中各部分的依赖关系，从而实现“高内聚、松耦合”的类型设计方案。

### 从封装变化角度对模式分类

组件协作：

- [Template Method（模板模式）](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Template Method)
- [Observer/Event（观察者模式）](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Observer)
- [Strategy（策略模式）](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Strategy)

单一职责：

- [Decorator（装饰模式）](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Decorator)
- [Bridge（桥模式）](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Bridge)

对象创建:

- [Factory Method（工厂模式）](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Factory Method)
- [Abstract Factory（抽象工厂）](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Abstract Factory)
- [Prototype（原型模式）](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Prototype)
- [Builder（构建器）](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Builder)

对象性能：

- [Singleton（单例模式）](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Singleton)
- [Flyweight(享元模式)](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Flyweight)

接口隔离:

- [Façade(门面模式)](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Facade)
- [Proxy（代理模式）](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Proxy)
- [Mediator(中介者)](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Mediator)
- [Adapter（适配器）](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Adapter)

状态变化：

- [Memento(中介者模式)](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Memento)
- [State（状态模式）](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/State)

数据结构：

- [Composite(组合模式)](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Composite)
- [Iterator（迭代器）](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Iterator)
- [Chain of Resposibility(职责链)](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Chain of Resposibility)

行为变化：

- [Command（命令模式）](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Command)
- [Visitor（访问器）](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Visitor)

领域问题：

- [Interpreter（解析器）](https://github.com/liu-jianhao/Cpp-Design-Patterns/tree/master/Interpreter)

总结

现代较少用的模式

- Builder
- Mediator
- Memento
- Iterator
- Chain of Resposibility
- Command
- Visitor
- Interpreter

### **重构关键技法**

\>静态  > 动态

\>早绑定  > 晚绑定

\>继承  > 组合

\>编译时依赖  > 运行时依赖

\>紧耦合  > 松耦合

## 2.Template Method（模板模式）

### 动机（Motivation）

在软件构建过程中，**对于某一项任务，它常常有稳定的整体操作结构，但各个子步骤却有很多改变的需求**，或者由于固有的原因（比如框架与应用之间的关系）而无法 和任务的整体结构同时实现。

如何在确定稳定操作结构的前提下，来灵活应对各个子步骤的变化或者晚期实现需求？

{%asset_img 03.png%}

**例如如下的结构化设计流程：**

template1_lib.cpp

```c++
#include <iostream>
using namespace std;
//程序库开发人员
class Library
{
public:
	void Step1()   //稳定
	{
		cout << "Step1" << endl;
	}
	void Step3()   //稳定
	{
		cout << "Step3" << endl;
	}
	void Step5()   //稳定
	{
		cout << "Step5" << endl;
	}
};
```

template1_app.cpp

```c++
#include "template1_lib.cpp"
//应用程序开发人员
class Application
{
  public:
	bool Step2()   //变化
	{
		cout << "myStep2" << endl;
		return true;
	}
	void Step4()    //变化
	{
		cout << "myStep4" << endl;
	}
};

int main()
{
	Library lib;
	Application app;
 ////////////写程序主流程start///////////////////
	lib.Step1();
	if (app.Step2())
	{
		lib.Step3();
	}

	for (int i = 0; i < 4; i++)
	{
		app.Step4();
	}
	lib.Step5();
 ////////////写程序主流程end///////////////////
     return 0;
}
```

{%asset_img 04.png%}

template2_lib.cpp

```c++

```

