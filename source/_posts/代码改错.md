---
title: '代码改错'
date: 2019-04-1 13:52:09
tags:
	- C++基础
	- 代码改错
categories: 
	- C++基础
---

### 1.分析下面代码有什么问题？

```c++
void test1()
{
 char string[10];
 char* str1 = "0123456789";
 strcpy( string, str1 );
}
```

字符串str1需要11个字节才能存放下（包括末尾的’\0’），而string只有10个字节的空间，strcpy会导致数组越界；  

### 2.分析下面代码有什么问题？

```c++
void test2()
{
 char string[10], str1[10];
 int i;
 for(i=0; i<10; i++)
 {
 str1  = 'a';
 }
strcpy( string, str1 );
}
```

首先，代码根本不能通过编译。因为数组名str1为 char *const类型的右值类型，根本不能赋值。
再者，即使想对数组的第一个元素赋值，也要使用 *str1 = 'a'; 
其次，对字符数组赋值后，使用库函数strcpy进行拷贝操作，strcpy会从源地址一直往后拷贝，直到遇到'\0'为止。所以拷贝的长度是不定的。如果一直没有遇到'\0'导致越界访问非法内存，程序就崩了。
完美修改方案为：

```c++
void test2()
{
    char string[10], str1[10];
    int i;
    for(i=0; i<9; i++)
    {
        str1[i]  = 'a';
    }
    str1[9] = '\0';
    strcpy( string, str1 );
}
```

3.指出下面代码有什么问题？

```c++
void test3(char* str1)
{
 if(str1 == NULL){
        return ;
 }
 char string[10];
 if( strlen( str1 ) <= 10 )
 {
 strcpy( string, str1 );
 }
}
```

if(strlen(str1) <= 10)应改为if(strlen(str1) < 10)，因为strlen的结果未统计’\0’所占用的1个字节。

### 4.写出完整版的strcpy函数

如果编写一个标准strcpy函数的总分值为10，下面给出几个不同得分的答案： 2分 

```c++
void strcpy( char *strDest, char *strSrc )
{
  while( (*strDest++ = * strSrc++) != ‘\0’ );
}
```

4分 

```c++
void strcpy( char *strDest, const char *strSrc ) 
//将源字符串加const，表明其为输入参数，加2分
{
  while( (*strDest++ = * strSrc++) != ‘\0’ );
}
```

7分 

```c++
void strcpy(char *strDest, const char *strSrc) 
{
 //对源地址和目的地址加非0断言，加3分
 assert( (strDest != NULL) && (strSrc != NULL) );
 while( (*strDest++ = * strSrc++) != ‘\0’ );
}
```

10分 //为了实现链式操作，将目的地址返回，加3分！ 

```c++
char * strcpy( char *strDest, const char *strSrc ) 
{
 assert( (strDest != NULL) && (strSrc != NULL) );
 char *address = strDest; 
 while( (*strDest++ = * strSrc++) != ‘\0’ ); 
 return address;
}
```

### 5.检查下面代码有什么问题？

```c++
void GetMemory( char *p )
{
 p = (char *) malloc( 100 );
}
void Test( void ) 
{
 char *str = NULL;
 GetMemory( str ); 
 strcpy( str, "hello world" );
 printf( str );
}
```

传入中GetMemory( char *p )函数的形参为字符串指针，在函数内部修改形参并不能真正的改变传入形参的实参值，执行完 

```c++
char *str = NULL;
GetMemory( str ); 
```

后的str仍然为NULL；
1：传入形参并不能真正改变形参的值，执行完之后为空；
2：在函数GetMemory中和Test中没有malloc对应的free，造成内存泄露



### 6.下面代码会出现什么问题？

```c++
char *GetMemory( void )
{ 
 char p[] = "hello world"; 
 return p; 
}
void Test( void )
{ 
 char *str = NULL; 
 str = GetMemory(); 
 printf( str ); 
}
```

```c++
char p[] = "hello world"; 
return p; 
```

的p[]数组为函数内的局部自动变量，在函数返回后，内存已经被释放。这是许多程序员常犯的错误，其根源在于不理解变量的生存期。  

### 7.下面代码会出现什么问题？

```c++
void GetMemory( char **p, int num )
{
 *p = (char *) malloc( num );
}
void Test( void )
{
 char *str = NULL;
 GetMemory( &str, 100 );
 strcpy( str, "hello" ); 
 printf( str ); 
}
```

1. 传入GetMemory的参数为字符串指针的指针，但是在GetMemory中执行申请内存及赋值语句 
 *p = (char *) malloc( num );
后未判断内存是否申请成功，应加上： 

```c++
if ( *p == NULL )
{
 ...//进行申请内存失败处理
}
同时应考虑num>0；
```



2. 未释放堆内存 动态分配的内存在程序结束之前没有释放，应该调用free, 把malloc生成的内存释放掉

3. printf(str) 改为 printf("%s",str),否则可使用格式化 字符串攻击



### 8.下面代码会出现什么问题？

```c++
void Test( void )
{
 char *str = (char *) malloc( 100 );
 strcpy( str, "hello" );
 free( str ); 
 ... //省略的其它语句
}
```

在执行   
char *str = (char *) malloc(100);   
后未进行内存是否申请成功的判断；另外，在free(str)后未置str为空，导致可能变成一个“野”指针，应加上：   
str = NULL;   
试题6的Test函数中也未对malloc的内存进行释放。 

### 9.看看下面的一段程序有什么错误?

```c++
swap( int* p1,int* p2 )
{
 int *p;
 *p = *p1;
 *p1 = *p2;
 *p2 = *p;
}
```

1.需要一个返回值void 
2在swap函数中，p是一个“野”指针，有可能指向系统区，导致程序运行的崩溃。在VC++中DEBUG运行时提示错误“Access Violation”。该程序应该改为：

```c++
void swap( int* p1,int* p2 )
{
 int p;
 p = *p1;
 *p1 = *p2;
 *p2 = p;
}
```

### 10.float 与“零值”比较的 if 语句

float型变量：   
const float EPSINON = 0.00001;   
if ((x >= - EPSINON) && (x <= EPSINON)   

### 11.以下为Windows NT下的32位C++程序，请计算sizeof的值

```c++
#include <iostream>
using namespace std;
void Func(char str[100])
{
	cout << sizeof(str) << endl;
}
int main(){
	
	char a[100] = { 0 };
	Func(a);
	cout << sizeof(a) << endl;
	void *p = malloc(100);
	cout << sizeof(p) << endl;
	return 0;
}
```

输出结果：

```c++
4
100
4
```

【剖析】   
Func ( char str[100] )函数中数组名作为函数形参时，在函数体内，数组名失去了本身的内涵，仅仅只是一个指针；在失去其内涵的同时，它还失去了其常量特性，**可以作自增、自减等操作，可以被修改。**(但是上例中的数组元素无法传入函数)   
数组名的本质如下：   
（1）数组名指代一种数据结构，这种数据结构就是数组；   
例如：   
char str[10];
cout ＜＜ sizeof(str) ＜＜ endl;
输出结果为10，str指代数据结构char[10]。   
（2）数组名可以转换为指向其指代实体的指针，而且是一个指针常量，**不能作自增、自减等操作，不能被修改；** 
char str[10];    
str++; //编译出错，提示str不是左值  
（3）数组名作为函数形参时，沦为普通指针。  
Windows NT 32位平台下，指针的长度（占用内存的大小）为4字节，故sizeof( str ) 、sizeof ( p ) 都为4。  

### 12.写一个“标准”宏MIN

这个宏输入两个参数并返回较小的一个。另外，当你写下面的代码时会发生什么事？  
least = MIN(*p++, b);  

解答：   

#define MIN(A,B) ((A) <= (B) ? (A) : (B))   
MIN(*p++, b)会产生宏的副作用   
*剖析： 
这个面试题主要考查面试者对宏定义的使用，宏定义可以实现类似于函数的功能，但是它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，在宏展开的时候对“参数”进行的是一对一的替换。   
程序员对宏定义的使用要非常小心，特别要注意两个问题：   
（1）谨慎地将宏定义中的“参数”和整个宏用用括弧括起来。所以，严格地讲，下述解答：   
#define MIN(A,B) (A) <= (B) ? (A) : (B)
#define MIN(A,B) (A <= B ? A : B )
都应判0分；   
（2）防止宏的副作用。   
宏定义#define MIN(A,B) ((A) <= (B) ? (A) : (B))对MIN(p++, b)的作用结果是：   
((p++) <= (b) ? (p++) : (b))*   
这个表达式会产生副作用，指针p会作2次++自增操作。  
除此之外，另一个应该判0分的解答是：   
#define MIN(A,B) ((A) <= (B) ? (A) : (B)); 
这个解答在宏定义的后面加“;”，显示编写者对宏的概念模糊不清


