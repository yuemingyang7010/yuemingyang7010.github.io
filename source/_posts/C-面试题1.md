---
title: C++面试题(1)
date: 2019-04-3 13:52:09
tags:
	- C++基础
	- 面试题
categories: 
	- C++基础
---

### 1.为什么标准头文件都有类似以下的结构？

```c++
#ifndef __INCvxWorksh
#define __INCvxWorksh 
#ifdef __cplusplus
extern "C" {
#endif 
/*...*/ 
#ifdef __cplusplus
}
#endif 
#endif /* __INCvxWorksh */
```

头文件中的编译宏 
#ifndef　INCvxWorksh
#define　__INCvxWorksh
#endif 
的作用是防止被重复引用。 



后的str仍然为NULL；
1：传入形参并不能真正改变形参的值，执行完之后为空；
2：在函数GetMemory中和Test中没有malloc对应的free，造成内存泄露

### 2.请写一个C函数，若处理器是Big_endian的，则返回0；若是Little_endian的，则返回1

【解答】 

```c++
int checkCPU()
{
	union w{ 
		int a;
		char b;
	} c;
	c.a = 1;
	return (c.b == 1);
}
```

【剖析】 
嵌入式系统开发者应该对Little-endian和Big-endian模式非常了解。采用Little-endian模式的CPU对操作数的存放方式是从低字节到高字节，而Big-endian模式对操作数的存放方式是从高字节到低字节。

32bit宽的数0x12345678在Little-endian模式CPU内存中的存放方式（假设从地址0x4000开始存放）为： 

| 内存地址 | 存放内容 |
| -------- | -------- |
| 0x4000   | 0x78     |
| 0x4001   | 0x56     |
| 0x4002   | 0x34     |
| 0x4003   | 0x12     |

结构体和共用体的区别在于：结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。

结构体占用的内存大于等于所有成员占用的内存的总和（成员之间可能会存在缝隙），共用体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。

**分析：**共用体的各个成员是共用一段内存的。1 是数据的低位，如果 1 被存储在 data 的低字节，就是小端模式，这个时候 data.ch 的值也是 1。如果 1 被存储在 data 的高字节，就是大端模式，这个时候 data.ch 的值就是 0。

### 3.说一下C++和C的区别

参考回答:

设计思想上：
C++是面向对象的语言，而C是面向过程的结构化编程语言

语法上：

C++具有封装、继承和多态三种特性

C++相比C，增加多许多类型安全的功能，比如强制类型转换、

C++支持范式编程，比如模板类、函数模板等

### 4.说一说c++中四种cast转换

[参考1](https://blog.csdn.net/xiaonan153/article/details/81381381)

[参考2](https://www.cnblogs.com/cauchy007/p/4968707.html)

**static_cast转换**

　　1.基本用法：static_cast<type-id> expression

　　2.使用场景：

　　**a、**用于类层次结构中**基类和派生类之间**指针或引用的转换(**不一定构成多态**)

　　上行转换（派生类---->基类）是安全的；

　　下行转换（基类---->派生类）由于没有动态类型检查，所以是不安全的。

　　b、用于**基本数据类型之间**的转换，如把int转换为char，这种带来安全性问题由程序员来保证

　　c、把空指针转换成目标类型的空指针

　　d、把任何类型的表达式转为void类型

　　3.使用特点

　　a、主要执行非多态的转换操作，用于代替C中通常的转换操作

　　b、隐式转换都建议使用static_cast进行标明和替换

**dynamic_cast转换**

基本用法：dynamic_cast<type-id> expression
（1）其他三种都是编译时完成的，dynamic_cast是运行时处理的，**运行时要进行类型检查。**
（2）不能用于内置的基本数据类型的强制转换。
（3）dynamic_cast转换如果成功的话返回的是指向类的指针或引用，转换失败的话则会返回NULL。
（4）**使用dynamic_cast进行转换的，基类中一定要有虚函数，否则编译不通过。**
        需要检测有虚函数的原因：类中存在虚函数，就说明它有想要让基类指针或引用指向派生类对象的情况，此时转换才有意义。 
        这是由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表（关于虚函数表的概念，详细可见<Inside c++ object model>）中，
        只有定义了虚函数的类才有虚函数表。
（5） **在类的转换时，在类层次间进行上行转换**时，dynamic_cast和static_cast的效果是一样的。在进行下行转换 时，dynamic_cast具有类型检查的功能，比static_cast更安全。向上转换即为指向子类对象的向下转换，即将父类指针转化子类指针。向下转换的成功与否还与将要转换的类型有关，即要转换的指针指向的对象的实际类型与转换以后的对象类型一定要相同，否则转换失败。

**const_cast转换**

　　1.基本用法：const_cast<type-id>expression

　　2.使用场景：**const转非const**

　　a、常量指针转换为非常量指针，并且仍然指向原来的对象

　　b、常量引用被转换为非常量引用，并且仍然指向原来的对象

　　3.使用特点：

　　a、cosnt_cast是四种类型转换符中唯一可以对常量进行操作的转换符

　　b、去除常量性是一个危险的动作，尽量避免使用。一个特定的场景是：类通过const提供重载时，一般都是非常量函数调用const_cast<const T>将参数转换为常量，然后调用常量函数，然后得到结果再调用const_cast <T>去除常量性。

**reinterpret_cast转换**

　　1.基本用法:reinterpret_cast<type-id>expression

　　2.使用场景：**不到万不得已，不用使用这个转换符，高危操作**

　　3.使用特点：　　

　　a、reinterpret_cast是从底层对数据进行重新解释，依赖具体的平台，可移植性差

　　b、reinterpret_cast可以将整型转换为指针，也可以把指针转换为数组

　　c、reinterpret_cast可以在指针和引用里进行肆无忌惮的转换

**为什么不使用C的强制转换？**

C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。

### 5.请说一下C/C++ 中指针和引用的区别？

参考回答:

1.指针有自己的一块空间，而引用只是一个别名；

2.使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；

3.指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象 的引用；

4.作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；

5.可以有const指针，但是没有const引用；

6.指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；

7.指针可以有多级指针（**p），而引用至于一级；

8.指针和引用使用++运算符的意义不一样；

9.如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。

### 6.简述智能指针原理

[参考1](https://mp.weixin.qq.com/s/x--v5kPtrA8NQpzAmhj_Yw)

[参考2](https://www.cnblogs.com/lanxuezaipiao/p/4132096.html)

[参考3](https://www.cnblogs.com/wxquare/p/4759020.html)

**【1】为什么提出智能指针**

在智能指针出现以前，我们通常使用 new 和 delete 来管理动态分配的内存，但这种方式存在几个常见的问题：

**(1)忘记 delete 内存：**会导致内存泄漏问题，且除非是内存耗尽否则很难检测到这种错误。

**(2)使用已经释放掉的对象：**如果能够记得在释放掉内存后将指针置空并在下次使用前判空，尚可避免这种错误。

**(3)同一块内存释放两次：**如果有两个指针指向相同的动态分配对象，则很容易发生这种错误。

**(4)发生异常时的内存泄漏：**若在 new 和 delete 之间发生异常，则会导致内存泄漏。



**【2】智能指针的设计思想**

简单的总结下就是：**将基本类型指针封装为类对象指针（这个类肯定是个模板，以适应不同基本类型的需求），并在析构函数里编写delete语句删除指针指向的内存空间。**



**【3】智能指针的使用**

C++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且第一个已经被11弃用。

为什么要使用智能指针：

智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。

1. **auto_ptr（c++98的方案，cpp11已经抛弃）**

采用所有权模式。

```c++
auto_ptr< string> p1 (new string ("I reigned lonely as a cloud.”));
auto_ptr<string> p2;
p2 = p1; //auto_ptr不会报错.
```

此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃问题！

2. **unique_ptr（替换auto_ptr）**

unique_ptr实现独占式拥有或严格拥有概念，**保证同一时间内只有一个智能指针可以指向该对象**。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。

采用所有权模式，还是上面那个例子

```c++
`unique_ptr<string> p3 (``new` `string (``"auto"``));   ``//#4``unique_ptr<string> p4；                       ``//#5``p4 = p3;``//此时会报错！！`
```

编译器认为p4=p3非法，避免了p3不再指向有效数据的问题。因此，unique_ptr比auto_ptr更安全。

另外unique_ptr还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：

```c++
unique_ptr<string> pu1(new string ("hello world"));
unique_ptr<string> pu2;
pu2 = pu1;                                      // #1 not allowed
unique_ptr<string> pu3;
pu3 = unique_ptr<string>(new string ("You"));   // #2 allowed
```

其中#1留下悬挂的unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的auto_ptr 。

注：如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个unique_ptr赋给另一个。例如：

```c++
unique_ptr<string> ps1, ps2;
ps1 = demo("hello");
ps2 = move(ps1);
ps1 = demo("alexia");
cout << *ps2 << *ps1 << endl;
```

3. **shared_ptr**

shared_ptr实现共享式拥有概念。**多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。**从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。

shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。

成员函数：

use_count 返回引用计数的个数

unique 返回是否是独占所有权( use_count 为 1)

swap 交换两个 shared_ptr 对象(即交换所拥有的对象)

reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少

get 返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如 shared_ptr<int> sp(new int(1)); sp 与 sp.get()是等价的

4. **weak_ptr**（解决shared_ptr循环引用引出的）

weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象. 进行该对象的内存管理的是那个强引用的 shared_ptr. weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。**weak_ptr是用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。**它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。

以下实例为智能指针的循环引用

```c++
#include <memory>
#include <iostream>
using namespace std;
class B;
class A
{
public:
	shared_ptr<B> pb_;  //只是定义了指针，并没有资源
	~A()
	{
		cout << "A delete\n";
	}
};

class B
{
public:
	shared_ptr<A> pa_; //只是定义了指针，并没有资源
	~B()
	{
		cout << "B delete\n";
	}
};

void fun()
{
	shared_ptr<B> pb(new B());   
	cout << pb.use_count() << endl;      //pb占用了new出来的资源  输出1
	cout << pb->pa_.use_count() << endl; //pb->pa_ 只是定义了指针，并没有资源  输出0
	shared_ptr<A> pa(new A());
	cout << pb.use_count() << endl;      //输出1
	cout << pa.use_count() << endl;      //输出1
	pb->pa_ = pa;
	pa->pb_ = pb;
	cout << pb.use_count() << endl;      //输出2
	cout << pa.use_count() << endl;      //输出2
}
int main()
{
	fun();
	return 0;
}

```

**结果：没析构**

```
1
0
1
1
2
2
```

### 7.请你回答一下智能指针有没有内存泄露的情况

当两个对象相互使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。例如：6中代码

上述代码中，A有一个shared_ptr类型的成员指向B，而B也有一个shared_ptr类型的成员指向A。然后在创建A和B对象时也使用了智能指针pa和pb，随后将pa和pb分别又赋值给B的智能指针成员A和A的智能指针成员B。从而形成了一个循环引用：

如何解决：

为了解决循环引用导致的内存泄漏，引入了weak_ptr弱指针，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。

**把类A中的share_ptr改成之后能析构掉资源：**

```
1
0
1
1
1
2
B delete
A delete
```

### 8.请你来回答一下什么是memory leak，也就是内存泄漏

参考回答:

内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，**失去了对该段内存的控制，因而造成了内存的浪费。**
内存泄漏的分类：

1. 堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过**malloc,realloc new**等从堆中分配的一块内存，再是完成后必须通过调用对应的 **free或者delete** 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak.
2. 系统资源泄露（Resource Leak）。**主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉**，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。
3. **没有将基类的析构函数定义为虚函数。**当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。

### 9.请你回答一下如何判断内存泄漏？

参考回答:

内存泄漏通常是由于调用了malloc/new等内存申请的操作，但是缺少了对应的free/delete。为了判断内存是否泄露，我们一方面可以使用linux环境下的内存泄漏检查工具**Valgrind**(音标|‘vælgrind|),windows下由MicroSoft公司自己开发的一个工具——**LeakDiag**，另一方面我们在**写代码时可以添加内存申请和释放的统计功能**，统计当前申请和释放的内存是否一致，以此来判断内存是否泄露。（即在对象的构造函数,中对全局变量进行+1，在析函数中-1）

### 10.请回答一下数组和指针的区别

参考回答:

指针和数组的主要区别如下：

| 指针                                                         | 数组                                 |
| ------------------------------------------------------------ | ------------------------------------ |
| 保存数据的地址                                               | 保存数据                             |
| 间接访问数据，首先获得指针的内容，然后将其作为地址，从该地址中提取数据 | 直接访问数据，                       |
| 通常用于动态的数据结构                                       | 通常用于固定数目且数据类型相同的元素 |
| 通过Malloc分配内存，free释放内存                             | 隐式的分配和删除                     |
| 通常指向匿名数据，操作匿名函数                               | 自身即为数据名                       |

### 11.请你回答一下野指针是什么？

参考回答:

野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针

### 12.请你理解的c++中的引用和指针

**定义：**
1、引用：

C++是C语言的继承，它可进行过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行以继承和多态为特点的面向对象的程序设计。引用就是C++对C语言的重要扩充。引用就是某一变量的一个别名，对引用的操作与对变量直接操作完全一样。引用的声明方法：类型标识符 &引用名=目标变量名；引用引入了对象的一个同义词。定义引用的表示方法与定义指针相似，只是用&代替了*。

2、指针：

指针利用地址，它的值直接指向存在电脑存储器中另一个地方的值。由于通过地址能找到所需的变量单元，可以说，地址指向该变量单元。因此，将地址形象化的称为“指针”。意思是通过它能找到以它为地址的内存单元。

**区别：**

1)   **指针是一个实体**，需要分配内存空间。引用只是变量的别名，不需要分配内存空间。

2)   **引用在定义的时候必须进行初始化，并且不能够改变。**指针在定义的时候不一定要初始化，并且指向的空间可变。（注：不能有引用的值不能为NULL）

3)   **有多级指针，但是没有多级引用**，只能有一级引用。

4)   **指针和引用的自增运算**结果不一样。（指针是指向下一个空间，引用时引用的变量值加1）

5)   **sizeof** 引用得到的是所指向的变量（对象）的大小，而sizeof 指针得到的是指针本身的大小。

6)   **引用访问一个变量是直接访问，而指针访问一个变量是间接访问。**

7)   **使用指针前最好做类型检查**，防止野指针的出现；

8)   **引用底层是通过指针实现的**；

9)   作为参数时也不同，传指针的实质是传值，传递的值是指针的地址；传引用的实质是传地址，传递的是变量的地址。

### 13.请你回答一下为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数

将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。

C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。

### 14.请你来说一下函数指针

参考回答:

1、定义
函数指针是指向函数的指针变量。

函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数。

C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。

2、用途：

调用函数和做函数的参数，比如回调函数。

3、示例：

```c++
char * fun(char * p)  {…}       // 函数fun
char * (*pf)(char * p);             // 函数指针pf
pf = fun;                        // 函数指针pf指向函数fun
pf(p);                        // 通过函数指针pf调用函数fun
```

15.请你来说一下fork函数

参考回答:

Fork：创建一个和当前进程映像一样的进程可以通过fork( )系统调用：

```c++
#include <sys/types.h>
#include <unistd.h>
pid_t fork(void);
```

成功调用fork( )会创建一个新的进程，它几乎与调用fork( )的进程一模一样，这两个进程都会继续运行。在子进程中，成功的fork( )调用会返回0。在父进程中fork( )返回子进程的pid。如果出现错误，fork( )返回一个负值。

最常见的fork( )用法是创建一个新的进程，然后使用exec( )载入二进制映像，替换当前进程的映像。这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。这种“派生加执行”的方式是很常见的。

在早期的Unix系统中，创建进程比较原始。当调用fork时，内核会把所有的内部数据结构复制一份，复制进程的页表项，然后把父进程的地址空间中的内容逐页的复制到子进程的地址空间中。但从内核角度来说，逐页的复制方式是十分耗时的。现代的Unix系统采取了更多的优化，例如Linux，采用了写时复制的方法，而不是对父进程空间进程整体复制。

