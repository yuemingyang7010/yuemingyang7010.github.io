---
title: '操作系统-进程管理'
date: 2019-03-20 13:52:09
tags:
	- 操作系统
categories: 
	- 操作系统
	- 操作系统概念
---



# 中断与异常

{%asset_img 12.jpg%}

# 进程与线程

### 0.重点梳理

★★★ 进程与线程的本质区别、以及各自的使用场景。

★★★ 进程调度算法的特点以及使用场景。

★★★ 进程通信方法的特点以及使用场景。

★★☆ 协程的作用。
★★☆ 常见进程同步问题。

★☆☆ 进程状态。

★☆☆ 线程实现的方式。



## 1. 进程

{%asset_img 13.jpg%}

{%asset_img 09.png%}

解答：D。程序一开始，产生一个进程Pl执行此程序，P1进入程序后，此时i=0，于是进入循环体，fork()产生一个子进程P2，接着Pl执行下一条语句输出一个"-"（其实是放入缓冲区，等合适的时候再输出，我们将此'-'记为a）；

P2成为一个独立的子进程，继承P1的诸如环境变量、PC等环境，P2也执行下一条语句输出一个'-'（其实是放入缓冲区，等合适的时候再输出，我们将此记为b），同时P2中此时i=1，继续执行for 循环P2先forkO出一个子进程P3，然后P2再执行下一条语句输出一个一（其实是放入缓冲区，等合适的时候再输出，我们将此记为c）。

P3进程为P2的子进程，它会复制其父进程P2的诸如环境变量、PC等环境，它执行下一条语句（输出语句）本应该输出一个，但事实上因为这里P3会继承P2的缓冲区，而P2的缓冲区中有一个（P2调用fork产生P3时缓冲区里有b），所以P3会输出两个。

Pl产生子进程P2后，继续下一轮循环，当i=1时，fork()产生另一个它的子进程P4，同时P1执行输出语句输出一个'-'。

## 2. 线程

**线程是独立调度的基本单位。**

{%asset_img 15.jpg%}

**例1：**同一进程下的线程可以共享（）。（2012·搜狗）

A.stack                                B.data section                             C.register set                        D.thread ID             

解答：B。B中data section存放全局变量等内容，显然是可以被同一进程下的线程共享的。

**例2：**线程与进程比较而言，下面论述成立的有（）。（不定项选择）（2007·百度）

A.一个线程可以由多个进程组成                                      B.一个进程可以由多个线程组成

C.相对而言，线程运行需要更多的资源                       D.线程比进程运行需要更少的系统资源

解答：BD。

**例3：**进程和线程的差别有（）。（2010·网易）

A.操作系统只调度进程，不调度线程                                      B.线程共享内存地址空间，进程不共享C.线程可以共享内存数据，但进程不可以                         D.进程间可以通过IPC通信，但线程不可以

解答：B。**进程之间的地址空间是独享的，而线程共享进程的地址空间。**

**例4：**两个线程：

```c
threadl:x=1；         
		r1=y； 

thread2：y=1；         
		r2=x； 
```

x和y初始值为0，两者皆为全局变量，程序运行过后r1和r2的值可能是（）。（2012·微软） 

A.rl=1，r2=1                     B.rl=1，r2=0                         C.rl=0，r2=1                               D.rl=0，r2=0  

解答：ABC。 首先执行x=1，然后中断，执行y=1，r2=x，然后执行rl=y，可得r1=1，r2=1； 首先执行thread1，再执行thread2，可得r1=0，r2=1； 首先执行thread2，再执行thread1，可得r1=1，r2=0。 

**引入线程主要有以下4个优点：**

（1）易于调度。

（2）提高并发性。

（3）开销小。

（4）有利于发挥多处理器的功能。

## 3. 区别

Ⅰ 拥有资源

进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。

Ⅱ 调度

线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。

Ⅲ 系统开销

由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。

Ⅳ 通信方面

线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。

# 进程状态的切换

{%asset_img 14.jpg%}

{%asset_img 16.jpg%}

# 进程调度算法

可以参考[大话操作系统之调度算法](https://mp.weixin.qq.com/s/D_woyVReMhAXH-sHx7eZfA)   重要！！！

不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。

调度的基本准则包括CPU利用率、系统吞吐量、周转时间、等待时间、响应时间等。

**系统吞吐量**表示单位时间内CPU完成作业的数量。

**周转时间**为作业完成时刻减去作业到达的时刻。

**等待时间**是指进程处于等处理器状态的时间之和，等待时间越长，用户满意度越低。

**响应时间**是指从用户提交请求到系统首次产生响应所用的时间。

典型调度算法包括：先来先服务算法（FCFS）、短作业优先算法（SJF）、优先级调度算法、高响应比优先调度算法、时间片轮转算法、多级反馈队列调度算法。**其中SJF的平均等待时间、平均周转时间最少。**

## 2.练习

例1：一种既有利于短作业又兼顾长作业的调度方式是（）。（2012·搜狗）

A.先来先服务                 B.均衡调度                  C.最短作业优先               D.最高响应比优先

解答：D。

例2：假定我们有3个程序，每个程序花费80%的时间进行I/0，20%的时间使用CPU。每个程序启动时间和其需要使用进行计算的分钟数如下，不考虑进程切换时间：

{%asset_img 10.png%}

请问，在多线程/进程环境下，系统的总周转时间为（）。（2012·腾讯）

A.22.5                    B.23.5                     C.24.5                              D.25.5



解答：B。从0点0分开始到0点10分，系统里只有1个程序，因此属于单道编程状态。单道编程时CPU的利用率为20%，因此第1个程序在该10分钟里总共使用了CPU达2分钟（其他8分钟都用来进行I/0了）。0点10分到0点15分，系统里面有两个程序，因此属于2道编程。**2道编程时CPU利用率为36%（两个进程同时不使用CPU的概率是0.8\*0.8-0.64）**，则在5分钟时间内，CPU使用了1.8分钟。假定这两个程序完全平等，则每个程序使用CPU的时间是0.9分钟。至此，程序1总共运行了2.9分钟CPU时间，程序2运行了0.9分钟CPU时间。

从0点15分开始，系统里面有3个程序，因此属于3道编程状态。3道编程时CPU的利用率为48.8%（三个进程同时不使用CPU的概率是0.8*0.8*0.8=0.512），同样，假定所有程序完全平等，此时，程序1离结束所需要的CPU时间最短，仅为0.6分钟。而如果程序1想再运行0.6分钟CPU时间，则整个系统需运行时间约为3.7分钟（3.7分钟时间内CPU共被使用1.8分钟，平均每个程序使用CPU时间为0.6分钟），因此在0点18.7分时，**第一个程序执行完毕，系统变为2道编程。**

**2道编程时CPU利用率为36%**，此时程序2运行了0.9+0.6-1.5分钟，程序3运行了0.6分钟，此时，程序2离结束所需要的CPU时间最短，仅为0.5分钟。而如果程序2想再运行0.5分钟CPU时间，则整个系统需运行时间约为2.8分钟（2.8分钟时间内CPU共被使用1分钟，平均每个程序使用CPU时间为0.5分钟），因此在0点**21.5分**时，第二个程序执行完毕，系统变为1道编程。

系统里只有1个程序，因此属于单道编程状态。单道编程时CPU的利用率为20%，此时程序3运行了0.6+0.5=1.1分钟，还需要运行0.4分钟的CPU时间，故整个系统需要2分钟（2分钟内CPU被利用0.4分钟），故程序3在0点**23.5分**时结束。

{%asset_img 11.png%}

# 进程同步

## 1. 临界区

对临界资源进行访问的那段代码称为临界区。

为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。

```html
// entry section
// critical section;
// exit section
```

## 2. 同步与互斥

- 同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。
- 互斥：多个进程在同一时刻只有一个进程能进入临界区。

## 3. 信号量

信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。

-  **down**  : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；
-  **up** ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。

down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。

如果信号量的取值只能为 0 或者 1，那么就成为了  **互斥量（Mutex）** ，0 表示临界区已经加锁，1 表示临界区解锁。

```c
typedef int semaphore;
semaphore mutex = 1;
void P1() {
    down(&mutex);
    // 临界区
    up(&mutex);
}

void P2() {
    down(&mutex);
    // 临界区
    up(&mutex);
}
```

<font size=3>  **使用信号量实现生产者-消费者问题**  </font> </br>

问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。

因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。

为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。

注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。

```c
#define N 100
typedef int semaphore;
semaphore mutex = 1;
semaphore empty = N;
semaphore full = 0;

void producer() {
    while(TRUE) {
        int item = produce_item();
        down(&empty);
        down(&mutex);
        insert_item(item);
        up(&mutex);
        up(&full);
    }
}

void consumer() {
    while(TRUE) {
        down(&full);
        down(&mutex);
        int item = remove_item();
        consume_item(item);
        up(&mutex);
        up(&empty);
    }
}
```

## 4. 管程

使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。**管程是对信号量更高层次的抽象，用类进行封装。**

c 语言不支持管程，下面的示例代码使用了类 Pascal 语言来描述管程。示例代码的管程提供了 insert() 和 remove() 方法，客户端代码通过调用这两个方法来解决生产者-消费者问题。

```pascal
monitor ProducerConsumer
    integer i;
    condition c;

    procedure insert();
    begin
        // ...
    end;

    procedure remove();
    begin
        // ...
    end;
end monitor;
```

管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。

管程引入了  **条件变量**  以及相关的操作：**wait()** 和 **signal()** 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。

<font size=3> **使用管程实现生产者-消费者问题** </font><br>

```pascal
// 管程
monitor ProducerConsumer
    condition full, empty;
    integer count := 0;
    condition c;

    procedure insert(item: integer);
    begin
        if count = N then wait(full);
        insert_item(item);
        count := count + 1;
        if count = 1 then signal(empty);
    end;

    function remove: integer;
    begin
        if count = 0 then wait(empty);
        remove = remove_item;
        count := count - 1;
        if count = N -1 then signal(full);
    end;
end monitor;

// 生产者客户端
procedure producer
begin
    while true do
    begin
        item = produce_item;
        ProducerConsumer.insert(item);
    end
end;

// 消费者客户端
procedure consumer
begin
    while true do
    begin
        item = ProducerConsumer.remove;
        consume_item(item);
    end
end;
```

# 线程同步

临界区：通过多线程的串行化来访问公共资源或一段代码，速度快，**适合控制数据访问；**

互斥量Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以**可以保证公共资源不会被多个线程同时访问**

信号量Semphare：为控制具有有限数量的用户资源而设计的，**它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。**

事件(信号)，Wait/Notify：**通过通知操作的方式来保持多线程同步**，还可以方便的实现多线程优先级的比较操作

# 经典同步问题

生产者和消费者问题前面已经讨论过了。

## 1. 读者-写者问题

**允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。**

一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。

```c
typedef int semaphore;
semaphore count_mutex = 1;
semaphore data_mutex = 1;
int count = 0;

void reader() {
    while(TRUE) {
        down(&count_mutex);
        count++;
        if(count == 1) down(&data_mutex); // 第一个读者需要对数据进行加锁，防止写进程访问
        up(&count_mutex);
        read();
        down(&count_mutex);
        count--;
        if(count == 0) up(&data_mutex);
        up(&count_mutex);
    }
}

void writer() {
    while(TRUE) {
        down(&data_mutex);
        write();
        up(&data_mutex);
    }
}
```




## 2. 哲学家进餐问题

{%asset_img 0.jpg%}

五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。

下面是一种错误的解法，考虑到如果所有哲学家同时拿起左手边的筷子，那么就无法拿起右手边的筷子，造成死锁。

```c
#define N 5

void philosopher(int i) {
    while(TRUE) {
        think();
        take(i);       // 拿起左边的筷子
        take((i+1)%N); // 拿起右边的筷子
        eat();
        put(i);
        put((i+1)%N);
    }
}
```

为了防止死锁的发生，可以设置两个条件：

- 必须同时拿起左右两根筷子；
- 只有在两个邻居都没有进餐的情况下才允许进餐。

```c
#define N 5
#define LEFT (i + N - 1) % N // 左邻居
#define RIGHT (i + 1) % N    // 右邻居
#define THINKING 0
#define HUNGRY   1
#define EATING   2
typedef int semaphore;
int state[N];                // 跟踪每个哲学家的状态
semaphore mutex = 1;         // 临界区的互斥
semaphore s[N];              // 每个哲学家一个信号量

void philosopher(int i) {
    while(TRUE) {
        think();
        take_two(i);
        eat();
        put_two(i);
    }
}

void take_two(int i) {
    down(&mutex);
    state[i] = HUNGRY;
    test(i);
    up(&mutex);
    down(&s[i]);
}

void put_two(i) {
    down(&mutex);
    state[i] = THINKING;
    test(LEFT);
    test(RIGHT);
    up(&mutex);
}

void test(i) {         // 尝试拿起两把筷子
    if(state[i] == HUNGRY && state[LEFT] != EATING && state[RIGHT] !=EATING) {
        state[i] = EATING;
        up(&s[i]);
    }
}
```

# 进程通信

进程同步与进程通信很容易混淆，它们的区别在于：

- 进程同步：控制多个进程按一定顺序执行；
- 进程通信：进程间传输信息。

进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。

## 1. 管道

管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。

```c
#include <unistd.h>
int pipe(int fd[2]);
```

它具有以下限制：

- 只支持半双工通信（单向交替传输）；
- 只能在父子进程或者兄弟进程中使用。

{%asset_img 07.png%}

## 2. FIFO

也称为命名管道，去除了管道只能在父子进程中使用的限制。

```c
#include <sys/stat.h>
int mkfifo(const char *path, mode_t mode);
int mkfifoat(int fd, const char *path, mode_t mode);
```

FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。

{%asset_img 08.png%}

## 3. 消息队列

相比于 FIFO，消息队列具有以下优点：

- 消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；
- 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；
- 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。

## 4. 信号量

它是一个计数器，用于为多个进程提供对共享数据对象的访问。

## 5. 共享存储

允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。

需要使用信号量用来同步对共享存储的访问。

多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。

## 6. 套接字

与其它通信机制不同的是，它可用于不同机器间的进程通信。

# 协程是什么

1) 是**一种比线程更加轻量级的存在**。正如一个进程可以拥有多个线程一样，**一个线程可以拥有多个协程**；协程不是被操作系统内核管理，而完全是由程序所控制。

2) **协程的开销远远小于线程；**

3) 协程拥有自己寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切换回来的时候，恢复先前保存的寄存器上下文和栈。

4) 每个协程表示一个执行单元，有自己的本地数据，与其他协程共享全局数据和其他资源。

5) **跨平台、跨体系架构、无需线程上下文切换的开销、方便切换控制流，简化编程模型**；

6) 协程又称为微线程，协程的完成主要靠yeild关键字，协程执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行；

7) **协程极高的执行效率，和多线程相比，线程数量越多，协程的性能优势就越明显；**

8) **不需要多线程的锁机制；**

# 孤儿进程和僵尸进程的区别？怎么避免这两类进程？守护进程？

1、 一般情况下，**子进程是由父进程创建**，而子进程和父进程的退出是无顺序的，两者之间都不知道谁先退出。正常情况下**父进程先结束会调用 wait 或者 waitpid 函数等待子进程完成再退出，而一旦父进程不等待直接退出，则剩下的子进程会被init(pid=1)进程接收，成会孤儿进程。**（进程树中除了init都会有父进程）。

2、 **如果子进程先退出了，父进程还未结束并且没有调用 wait 或者 waitpid 函数获取子进程的状态信息，则子进程残留的状态信息（ task_struct 结构和少量资源信息）会变成僵尸进程。**



**僵尸处理方式：**

**子进程退出时向父进程发送SIGCHILD信号**，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程。

原理是将子进程成为孤儿进程，从而其的父进程变为init进程，通过init进程可以处理僵尸进程。

3、 **守护进程（ daemon) 是指在后台运行，没有控制终端与之相连的进程。**它独立于控制终端，通常周期性地执行某种任务 。守护进程脱离于终端是为了避免进程在执行过程中的信息在任何终端上显示并且进程也不会被任何终端所产生的终端信息所打断。

[参考github资料](https://cyc2018.github.io/CS-Notes/#/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86)

## 进程上下文切换与和线程上下文切换有什么不同？

## （1）什么是上下文切换？（面试题） 

上下文切换就是从当前执行任务切换到另一个任务执行的过程。但是，为了确保下次能从正确的位置继续执行，在切换之前，会保存上一个任务的状态。

## （2）区别

**最主要的区别**就是线程的切换虚拟空间内存是相同的（因为都是属于自己的进程），但是，进程切换的虚拟空间内存则是不同的。

以下是相同:

同时，这两种上下文切换的处理都是通过操作系统内核来完成的。内核的这种切换过程伴随的最显著的性能损耗是将寄存器中的内容切换出。

# 函数调用和系统调用的区别？

1)     系统调用

①     操作系统提供给用户程序调用的一组特殊的接口。用户程序可以通过这组特殊接口来获得操作系统内核提供的服务；

②     系统调用可以用来控制硬件；设置系统状态或读取内核数据；进程管理，系统调用接口用来保证系统中进程能以多任务在虚拟环境下运行；

③     Linux中实现系统调用利用了x86体系结构中的软件中断；

2)     函数调用

①     函数调用运行在用户空间；

②     它主要是通过压栈操作来进行函数调用；

# 执行一个系统调用时，OS发生的过程(?)

  1．执行用户程序(如:fork) 

 2． 根据glibc中的函数实现，取得系统调用号并执行int $0x80产生中断。
 3． 进行地址空间的转换和堆栈的切换，执行SAVE_ALL。（进行内核模式）
 4． 进行中断处理，根据系统调用表调用内核函数。
 5． 执行内核函数。
 6． 执行RESTORE_ALL并返回用户模式

