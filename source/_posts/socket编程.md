---
title: 'socket编程'
date: 2019-03-17 14:52:09
tags:
	- 计算机网络
	- socket编程
categories: 
	- 计算机网络
	- socket编程
---

## 数据传输方式

计算机之间有很多数据传输方式，各有优缺点，常用的有两种：SOCK_STREAM 和 SOCK_DGRAM。

1) SOCK_STREAM 表示**面向连接的数据传输方式**。可靠性高、效率稍低；

2) SOCK_DGRAM **表示无连接的数据传输方式**。效率高、小概率情况下会出错。

QQ 视频聊天和语音聊天就使用 SOCK_DGRAM 传输数据，因为首先要保证通信的效率，尽量减小延迟，而数据的正确性是次要的，即使丢失很小的一部分数据，视频和音频也可以正常解析，最多出现噪点或杂音，不会对通信质量有实质的影响。

## socket缓冲区

每个 socket 被创建后，都会分配两个缓冲区，输入缓冲区和输出缓冲区。

{%asset_img 01.jpg%}

这些I/O缓冲区特性可整理如下：

- I/O缓冲区在每个TCP套接字中单独存在；
- I/O缓冲区在创建套接字时自动生成；
- 即使关闭套接字也会继续传送输出缓冲区中遗留的数据；
- 关闭套接字将丢失输入缓冲区中的数据。

## socket三种通信模型，BIO，NIO，AIO 

BIO是同步阻塞IO，NIO是同步非阻塞IO，AIO是异步非阻塞IO；三种IO方式相比较而言，BIO是一个客户端对应一个线程，NIO是多个客户端对应一个线程，服务器端和客户端均使用缓冲区的方式进行读写，AIO是简化的NIO；  

## 高并发中的select与epoll(I/O复用)

[参考网页](https://blog.51cto.com/yaocoder/888374)

select 和 epoll效率差异的原因：select采用轮询方式处理连接，epoll是触发式处理连接。 

  **Select:** 

  1.Socket数量限制：该限制可操作的Socket数由FD_SETSIZE决定，内核默认32*32=1024. 

  2.操作限制：通过遍历FD_SETSIZE(1024)个Socket来完成调度，不管哪个Socket是活跃的，都遍历一遍。 

  **Epoll** 

  1.Socket数量无限制：该模式下的Socket对应的fd列表由一个数组来保存，大小不限制（默认4k）。 

  2.操作无限制：基于内核提供的反射模式，有活跃Socket时，内核访问该Socket的callback，不需要遍历轮询。 

  但当所有的Socket都活跃的时候，所有的callback都被唤醒，会导致资源的竞争。既然都是要处理所有的Socket， 

  那么遍历是最简单最有效的实现方式。



【例1】关于linux的I/O复用接口select和epoll,下列说法错误的是()

**A. select调用时会进行线性遍历,epoll采用回调函数机制,不需要线性遍历**

**B. select的最大连接数为FD_SETSIZE**

C. select较适合于有大量并发连接,且活跃链接较多的场景

**D. epoll较适用于有大量并发连接，但活跃连接不多的场景**

**E. epoll的效率不随FD数目增加而线性下降**

**F. epoll通过共享存储实现内核和用户的数据交互**

选C



【例2】关于epoll和select的区别，哪些说法是正确的？
**A. epoll和select都是I/O多路复用的技术，都可以实现同时监听多个I/O事件的状态**
**B. epoll相比select效率更高，主要是基于其操作系统支持的I/O事件通知机制，而select是基于轮询机制**
**C. epoll支持水平触发和边沿触发两种模式**
D. select能并行支持I/O比较小，且无法修改

选ABC

**nginx就是采用epoll的方式**

## **epoll使用**

讲解完了Epoll的机理，我们便能很容易掌握epoll的用法了。一句话描述就是：三步曲。

第一步：**epoll_create()**系统调用。此调用返回一个句柄，之后所有的使用都依靠这个句柄来标识。

第二步：**epoll_ctl()**系统调用。通过此调用向epoll对象中添加、删除、修改感兴趣的事件，返回0标识成功，返回-1表示失败。

第三部：**epoll_wait()**系统调用。通过此调用收集收集在epoll监控中已经发生的事件。