---
title: '操作系统-内存管理'
date: 2019-03-22 13:52:09
tags:
	- 操作系统
categories: 
	- 操作系统
	- 操作系统概念
---

★★★ 虚拟内存的作用，分页系统实现虚拟内存原理。
★★★ 页面置换算法的原理，特别是 LRU 的实现原理，最好能手写，再说明它在 Redis 等作为缓存置换算法。
★★★ 比较分页与分段的区别。

★★★ 分析静态链接的不足，以及动态链接的特点。

## 2.1逻辑地址空间与物理地址空间

Eg：**编译时只需确定**变量x存放的相对地址是100（也就是说相对于进程在内存中的起始地址而言的地址）。CPU想要找到x在内存中的实际存放位置，只需要用进程的起始地址+100即可。

**相对地址又称逻辑地址，绝对地址又称物理地址**。

## **2.2内存分配管理方式**

包括连续分配管理方式与非连续分配管理方式。

**连续分配方式**，是指为一个用户程序分配一个连续的内存空间。它主要包括单一连续分配、固定分区分配和动态分区分配。

**非连续分配管理方式**允许一个程序分散地装入到不相邻的内存分区中，根据分区的大小是否固定分为**分页存储管理方式**和**分段存储管理方式**。分页存储管理方式中，又根据运行作业时是否要把作业的所有页面都装入内存才能运行分为**基本分页存储管理方式**和**请求分页存储管理方式**。

### **2.2.1基本分页存储管理方式**

固定分区会产生内部碎片，动态分区会产生外部碎片，这两种技术对内存的利用率都比较低。**我们希望内存的使用能尽量避免碎片的产生，这就引入了分页的思想：**把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。每个进程也以块为单位进行划分，进程在执行时，以块为单位逐个申请主存中的块空间。

分页的方法从形式上看，像分区相等的固定分区技术，**分页管理不会产生外部碎片**。但它又有本质的不同点：块的大小相对分区要小很多，而且进程也按照块进行划分，进程运行时按块申请主存可用空间并执行。这样，**进程只会在为最后一个不完整的块申请一个主存块空间时，才产生主存碎片，所以尽管会产生内部碎片，但是这种碎片相对于进程来说也是很小的**，每个进程平均只产生半个块大小的内部碎片（也称页内碎片）。

1）分页存储的几个基本概念

①页面和页面大小。进程中的块称为页（Page），内存中的块称为页框（Page Frame，或页帧）。外存也以同样的单位进行划分，称为块（Block）。进程在执行时需要申请主存空间，就是要为每个页面分配主存中的可用页框，这就产生了页和页框的一一对应。

**为方便地址转换，页面大小应是2的整数幂。**同时页面大小应该适中，如果页面太小，会使进程的页面数过多，这样页表就过长，占用大量内存，而且也会增加硬件地址转换的开销，降低页面换/

换出的效率；页面过大又会使页面内碎片增大，降低内存的利用率。所以页面的大小应该适中，考虑到空间效率和时间效率的权衡。

②地址结构。分页存储管理的逻辑地址结构如下图所示：

{%asset_img 01.png%}

地址结构包含两部分：前一部分为页号P，后一部分为页内偏移量M。地址长度为32位，其中0～11位为页内地址，即每页大小为4KB；12~31位为页号，地址空间最多允许有2^20页。

③页表。为了便于在内存中找到进程的每个页面所对应的物理块，系统为每个进程建立一张页表，记录页面在内存中对应的物理块号，**页表一般存放在内存中。**在配置了页表后，进程执行时，通过查找该表，即可找到每页在内存中的物理块号。可见，页表的作用是实现从页号到物理块号的地址映射。

{%asset_img 02.png%}

**如何计算(以手动计算为例)：**

**页号**=逻辑地址/页面长度（取除法的整数部分）  

**页内偏移量**=逻辑地址%页面长度（取除法的余数部分）

**页面在内存中的起始位置**：操作系统需要用某种数据结构记录进程各个页面的起始位置。 **存在页表中**

页号=80/50=1

页内偏移量=80%50=3

01号页在内存中存放的起始位置450    物理地址为450+3=453



### **2.2.2基本分段存储管理方式**

段式管理方式按照用户进程中的自然段划分逻辑空间。例如，用户进程由主程序、两个子程序、栈和一段数据组成，于是可以把这个用户进程划分为5个段，每段从0开始编址，并分配一段连续的地址空间（段内要求连续，段间不要求连续，因此整个作业的地址空间是二维的）。其逻辑地址由段号S与段内偏移量W两部分组成。

在下图中，段号为16位，段内偏移量为16位，则一个作业最多可有216-65536个段，最大段长为64KB。

{%asset_img 03.png%}

在页式系统中，逻辑地址的页号和页内偏移量对用户是透明的，但在段式系统中，段号和段内偏移量必须由用户显示提供，在高级程序设计语言中，这个工作由编译程序完成。

{%asset_img 04.png%}

### **2.2.3段页式管理方式**

{%asset_img 06.png%}

{%asset_img 07.png%}

例1：关于段页式管理中，地址映像表是（）。

A.每个进程一张段表，一张页表B.进程的每个段一张段表，一张页表C.每个进程一张段表，每个段一张页表D.每个进程一张页表，每个段一张段表解答：C。

## **2.3虚拟内存管理**

上一节所讨论的各种内存管理策略都是为了同时将多个进程保存在内存中以便允许多道程序设计。它们都具有以下两个共同的特征：作业必须一次性全部装入内存后，方能开始运行；驻留性：作业被装入内存后，就一直驻留在内存中，其任何部分都不会被换出，直至作业运行结束。

由以上分析可知，许多在程序运行中不用或暂时不用的程序（数据）占据了大量的内存空间，而一些需要运行的作业又无法装入运行，显然浪费了宝贵的内存资源。

### **2.3.1虚拟存储器的定义和特征**

基于局部性原理，在程序装入时，可以**将程序的一部分装入内存，而将其余部分留在外存，就可以启动程序执行。**在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换出到外存上，从而腾出空间存放将要调入内存的信息。这样，**系统好像为用户提供了一个比实际内存大得多的存储器，称为虚拟存储器。**

之所以将其称为虚拟存储器，是因为这种存储器实际上并不存在，只是由于系统提供了部分装入、**请求调入和置换功能**后（对用户完全透明），给用户的感觉是好像存在一个比实际物理内存大得多的存储器。

虚拟内存的实现有以下三种方式：

1）请求分页存储管理。

2）请求分段存储管理。

3）请求段页式存储管理。

不管哪种方式，都需要有一定的硬件支持。一般需要的支持有以下几个方面：

1）一定容量的内存和外存。

2）页表机制（或段表机制），作为主要的数据结构。

3）中断机构，当用户程序要访问的部分尚未调入内存，则产生缺页中断。

4）地址变换机构，逻辑地址到物理地址的变换。

例1：段页式虚拟存储管理方案的特点是（）。（2012·腾讯）

A.空间浪费大、存储共享不易，存储保护容易、不能动态链接

B.空间浪费小、存储共享容易、存储保护不易、不能动态链接

C.空间浪费大、存储共享不易、存储保护容易、能动态链接

D.空间浪费小、存储共享容易、存储保护容易、能动态链接

解答：D。为了能够同时获得段式虚拟存储器在程序模块化方面的优点和页式虚拟存储器在管理主存和辅存物理空间方面的优点，把两种虚拟存储器结合起来就成为段页式虚拟存储器。其基本思想是对用户原来编写程序的虚拟存储空间采用分段的方法管理，而对主存储器的物理空间采用分页的方法管理。

段页式虚拟存储器**一方面具有段式虚拟存储器的主要优点**。例如，**用户程序可以模块化编写，程序段的共享和信息的保护都比较方便，程序可以在执行时再动态链接等。**

另**一方面也具有页式虚拟存储器的主要优点**。例如：**主存储器的利用率比较高，对辅助存储器的管理比较容易等。**

### 2.3.2请求分页管理方式

请求分页系统建立在基本分页系统基础之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。

在请求分页系统中，只要求将当前需要的一部分页面装入内存，便可以启动作业运行。在作业执行过程中，**当所要访问的页面不在内存时，再通过调页功能将其调入，同时还可以通过置换功能将暂时不用的页面换出到外存上，以便腾出内存空间。**

为了实现请求分页，系统必须提供一定的硬件支持。除了需要一定容量的内存及外存的计算机系统，还需要有页表机制(在基本分页的页表基础上对每个页加了状态位、访问字段等，用于判断是否调入内存，以及最近访问的次数等..)、缺页中断机构和地址变换机构。

常见的置换算法有以下三种：**最佳置换算法、先进先出（FIFO）页面置换算法、最近最久未使用（LRU）置换算法。**

{%asset_img 05.png%}

## **2.4抖动：**

在页面置换过程中的一种最糟糕的情形是，刚刚换出的页面马上又要换入主存，刚刚换入的页面马上就要换出主存，这种频繁的页面调度行为称为抖动，或颠簸。如果一个进程在换页上用的时间多于执行时间，那么这个进程就在颠簸。

频繁的发生缺页中断，其主要原因是**某个进程频繁访问的页面数目高于可用的物理页帧数目**。

## 2.5缺页中断与最近最久未使用置换算法（ LRU）

**缺页中断:**
在地址映射过程中，**若在页表中发现所要访问的页面不在内存，则产生中断，当发生中断时，系统必须在内存选择一个页面移出内存，以便为调入新的页面让出空间**，尽管每次可以随机选选择一个页面置换，但选择不常使用的页面会是系统性能好的多，减少不必要的额外开销，就产生了页面置换算法。

参考leetcode上的解答：

146. LRU缓存机制

运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。

获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。
写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。

进阶:

你是否可以在 O(1) 时间复杂度内完成这两种操作？

示例:

```c++
LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // 返回  1
cache.put(3, 3);    // 该操作会使得密钥 2 作废
cache.get(2);       // 返回 -1 (未找到)
cache.put(4, 4);    // 该操作会使得密钥 1 作废
cache.get(1);       // 返回 -1 (未找到)
cache.get(3);       // 返回  3
cache.get(4);       // 返回  4
```

思路分析：

{%asset_img 08.png%}

```c++
#include <map>
#include <list>
class LRUCache {
public:
    LRUCache(int capacity) {
        m_capacity = capacity;
    }
    
    int get(int key) {
        const auto it = cacheMap.find(key);
        //如果key不存在
        if(it == cacheMap.end()) 
            return -1;
        //如果key存在，将其值（最近操作的）对应的节点移到链表头，O(1)时间
        cacheList.splice(cacheList.begin(),cacheList,it->second);
        return it->second->second;
    }
    //put()之前需要检查，key是否已经存在，存在则更新值，存在的话分为两种情况：
    //第一种：容器已经满，需要先剔除链表尾部元素，第二种：容器未满，正常添加。
    void put(int key, int value) {
        const auto it = cacheMap.find(key);
        //如果key存在,更新值
        if(it != cacheMap.end()){
            it->second->second = value;
            //如果key存在，将其值（最近操作的）对应的节点移到链表头，O(1)时间
            cacheList.splice(cacheList.begin(),cacheList,it->second);
            return;
        }
        //key不存在情况下，cacheMap已经满了
        if(cacheMap.size()==m_capacity){
            const auto& node = cacheList.back();
            cacheMap.erase(node.first);
            cacheList.pop_back();            
        }
        //key不存在情况下，cacheMap未满，正常插入
        cacheList.emplace_front(key,value); //直接插到顺序容器头部，C++11出的新方法
        cacheMap[key] = cacheList.begin();      
    }
private:
    int m_capacity;
    list<pair<int,int> > cacheList;
    unordered_map<int,list<pair<int,int> >::iterator> cacheMap;
    
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj = new LRUCache(capacity);
 * int param_1 = obj->get(key);
 * obj->put(key,value);
 */
```



