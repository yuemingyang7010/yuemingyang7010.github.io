---
title: MySQL中的索引
date: 2019-07-24 16:28:27
tags:
	- 数据库
categories: 
	- 数据库
	- MySQL
---

# 索引

## 什么是索引？

排好序的快速查询的数据结构，常常类比为字典目录。

优点：**大大加快数据的检索速度**；

缺点：**创建索引和维护索引要花费一定的时间**。

## 索引的分类

主键索引（PRIMAY KEY）

普通索引（INDEX）

唯一索引（UNIQUE）

联合索引（FULLTEXT）

InnoDB和MyISAM会自动为**主键**或者声明为**UNIQUE**的列去自动建立B+树索引。

### 主键索引（最常用，最好用自增ID）

为表设置了主键，数据库将自动创建主键索引

（一个表只能有一个主键，主键的值不可重复，也不可为空（NULL）。）

### 普通索引（一表可建多个，尽量避免NULL）

注意：可以有NULL，但是**尽量避免NULL**：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化。因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值。

### 唯一索引

与普通索引类似，不同的是，Mysql的索引列值必须唯一，但普通索引值可重复。

### 联合索引

联合索引即联合若干列组成索引，这种情况下和普通索引类似，可不唯一，可以有NULL，如果加上unique，可以使其为联合唯一索引，如下：

```sql
alter table t_aa add unique index(aa,bb);
```

## MySQL中创建和删除索引的语句

我们可以在创建表的时候指定需要建立索引的单个列或者建立联合索引的多个列：

```sql
CREATE TALBE 表名 (
    各种列的信息 ··· , 
    [KEY|INDEX] 索引名 (需要被索引的单个列或多个列)
)
```

其中的KEY和INDEX是同义词，任意选用一个就可以。我们也可以在修改表结构的时候添加索引：

```sql
ALTER TABLE 表名 ADD [INDEX|KEY] 索引名 (需要被索引的单个列或多个列);
```

也可以在修改表结构的时候删除索引：

```sql
ALTER TABLE 表名 DROP [INDEX|KEY] 索引名;
```

比方说我们想在创建index_demo表的时候就为c2和c3列添加一个联合索引，可以这么写建表语句：

```sql
CREATE TABLE index_demo(
    c1 INT,
    c2 INT,
    c3 CHAR(1),
    PRIMARY KEY(c1),
    INDEX idx_c2_c3 (c2, c3)
);
```

在这个建表语句中我们创建的索引名是idx_c2_c3，这个名称可以随便起，不过我们还是建议以idx_为前缀，后边跟着需要建立索引的列名，多个列名之间用下划线_分隔开。

如果我们想删除这个索引，可以这么写：

```sql
ALTER TABLE index_demo DROP INDEX idx_c2_c3;
```

注意：主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。



## 各种索引的区别与联系

| 索引类型 | 是否要求值唯一 | 是否要求值不能有NULL |
| -------- | -------------- | -------------------- |
| 主键索引 | 是             | 是                   |
| 唯一索引 | 是             | 否                   |
| 普通索引 | 否             | 否                   |



### 主键索引与普通索引的区别

如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；
如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。
也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。

总结：（1）主键索引查询一次B+树，普通索引有回表操作；（2）主键索引要求列值唯一，且无NULL，普通索引没这两个限制。

### 主键索引与唯一索引的区别

（1）主键索引查询一次B+树，唯一索引有回表操作；（2）主键索引要求列值唯一，且无NULL，唯一索引列值唯一，但是**可以有NULL**。





# 索引底层数据结构

[本文主要参考博客](<https://www.cnblogs.com/xiaoxi/p/6894610.html?utm_source=itdadao&utm_medium=referral>)

[对于磁道、扇区和磁盘块的理解1](<https://blog.csdn.net/q503267755/article/details/50791794>)

[对于磁道、扇区和磁盘块的理解2](<https://www.cnblogs.com/yi-mu-xi/p/10939612.html>)

## 磁盘I/O原理

### 扇区与磁盘块(block)的区别

**磁盘在物理层面上分为磁道，扇区**（通常大小为512K），磁盘驱动器操作磁盘数据，硬盘的最小存储单位是扇区，硬盘本身没有block的概念。

**文件系统：**

文件系统若按照一个扇区一个扇区读数据速度太慢，所以有了**block（磁盘块）**的概念，是一个块一个块读取的，block才是文件存取的最小单位。通常一个block是4K，该文件系统中1个块是由连续的8个扇区组成。一个块大小=一个扇区大小*2的n次方。N是可以修改的。

**总结：扇区是对硬盘而言，块是对文件系统而言。**

索引是帮助MySQL高效获取数据的排好序的数据结构



## **B树（平衡多路查找树）**

B-Tree是为磁盘等外存储设备设计的一种平衡查找树。因此在讲B-Tree之前先了解下磁盘的相关知识。

系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。

**InnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB存储引擎中默认每个页的大小为16KB，可通过参数innodb_page_size将页的大小设置为4K、8K、16K，在MySQL中可通过如下命令查看页的大小（可以将其设置为4K）：**

```
mysql> show variables like 'innodb_page_size';
```

而系统一个磁盘块的存储空间往往没有这么大，因此InnoDB每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小16KB。InnoDB在把磁盘数据读入到内存时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。

B-Tree结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述B-Tree，首先定义一条记录为一个二元组[key, data] ，key为记录的键值，对应表中的主键值，data为一行记录中除主键外的数据。对于不同的记录，key值互不相同。

**一棵m阶的B-Tree有如下特性：** 

1. 每个节点最多有m个孩子。 
2. 除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子。 
3. 若根节点不是叶子节点，则至少有2个孩子。
4. 所有叶子节点都在同一层，且不包含其它关键字信息。 
5. 每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn） 
6. 关键字的个数n满足：ceil(m/2)-1 <= n <= m-1 
7. ki(i=1,…n)为关键字，且关键字升序排序。 
8. Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)。

B-Tree中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个3阶的B-Tree：

{%asset_img 01.png%}

两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。

模拟查找关键字29的过程：

根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】
比较关键字29在区间（17,35），找到磁盘块1的指针P2。
根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】
比较关键字29在区间（26,30），找到磁盘块3的指针P2。
根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】
在磁盘块8中的关键字列表中找到关键字29。

分析上面过程，发现需要**3次磁盘I/O操作，和3次内存查找操作。**由于内存中的关键字是一个有序表结构，**可以利用二分法查找提高效率**。而**<u>3次磁盘I/O操作是影响整个B-Tree查找效率的决定因素</u>**。B-Tree相对于AVLTree缩减了节点个数，使每次磁盘I/O取到内存的数据都发挥了作用，从而提高了查询效率。



## B+Tree**

B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。

从上一节中的B-Tree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。**在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息**，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。

**B+Tree相对于B-Tree有几点不同：**

1. 非叶子节点只存储键值信息。
2. 所有叶子节点之间都有一个链指针。
3. 数据记录都存放在叶子节点中。

将上一节中的B-Tree优化，由于B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示：

{%asset_img 02.png%}

通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对B+Tree进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。

## 为什么使用B-Tree（B+Tree）

一般来说，索引本身也很大，**不可能全部存储在内存中**，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是要**尽量减少查找过程中磁盘I/O的存取次数**。

**与红黑树的比较：**

红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因：

（一）更少的查找次数

平衡树查找操作的时间复杂度和树高 h 相关，O(h)=O(log<sub>d</sub>N)，其中 d 为每个节点的出度。

红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。

（二）利用磁盘预读特性

为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。

操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。



## **B+树索引和hash索引的区别**

hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的**查询效率要远高于 B-Tree 索引。**

既然 Hash 索引的效率要比 B-Tree 高很多，为什么大家不都用 Hash 索引而还要使用 B-Tree 索引呢？ Hash 索引本身由于其特殊性也带来了很多限制和弊端，主要有以下这些。

**（1）Hash 索引仅仅能满足”=”,”IN”和”<=>”查询，不能使用范围查询。**

由于 Hash 索引比较的是进行 Hash 运算之后的 Hash 值，所以它**只能用于等值的过滤，不能用于基于范围的过滤**，因为经过相应的 Hash 算法处理之后的 Hash 值的大小关系，并不能保证和Hash运算前完全一样。

（2）Hash 索引**无法被用来避免数据的排序操作。**

由于 Hash 索引中存放的是经过 Hash 计算之后的 Hash 值，而且Hash值的大小关系并不一定和 Hash 运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算；

（3）Hash 索引不能利用部分索引键查询。

对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。

**（4）Hash 索引在任何时候都不能避免表扫描。**

前面已经知道，**Hash 索引是将索引键通过 Hash 运算之后**，将 Hash运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中，**由于不同索引键存在相同 Hash 值\****，所以即使取满足某个 Hash 键值的数据的记录条数，也无法从 Hash 索引中直接完成查询**，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。**当Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。

## **磁盘存取原理**

​      上面说过，索引一般以文件形式存储在磁盘上，索引检索需要磁盘I/O操作。与主存不同，磁盘I/O存在机械运动耗费，因此磁盘I/O的时间消耗是巨大的。

​      下图是磁盘的整体结构示意图。

{%asset_img 03.png%}

一个磁盘由大小相同且同轴的圆形盘片组成，磁盘可以转动（各个磁盘必须同步转动）。在磁盘的一侧有磁头支架，磁头支架固定了一组磁头，每个磁头负责存取一个磁盘的内容。磁头不能转动，但是可以沿磁盘半径方向运动（实际是斜切向运动），每个磁头同一时刻也必须是同轴的，即从正上方向下看，所有磁头任何时候都是重叠的（不过目前已经有多磁头独立技术，可不受此限制）。

​      下图是磁盘结构的示意图。

{%asset_img 04.png%}

盘片被划分成一系列同心环，圆心是盘片中心，每个同心环叫做一个磁道，所有半径相同的磁道组成一个柱面。磁道被沿半径线划分成一个个小的段，每个段叫做一个扇区，每个扇区是磁盘的最小存储单元。为了简单起见，我们下面假设磁盘只有一个盘片和一个磁头。

​      当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间。

## **局部性原理与磁盘预读**

 由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：

​      当一个数据被用到时，其附近的数据也通常会马上被使用。

## **B-/+Tree索引的性能分析**

​      到这里终于可以分析B-/+Tree索引的性能了。

​	数据库系统的设计者巧**妙利用了磁盘预读原理**，**将一个节点的大小设为等于一个页**，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：

​     每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。

​     B-Tree中一次检索最多需要h-1次I/O（**根节点常驻内存**），渐进复杂度为O(h)=O(logdN)O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。

​     综上所述，用B-Tree作为索引结构效率是非常高的。



# **MySQL索引实现**

在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的，下面主要讨论MyISAM和InnoDB两个存储引擎的索引实现方式。

## **MyISAM索引实现**

MyISAM引擎使用B+Tree作为索引结构，**叶节点的data域存放的是数据记录的地址**。下图是MyISAM索引的原理图：

{%asset_img 07.png%}

这里设表一共有三列，假设我们以Col1为主键，则上图是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。**在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。**如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：

{%asset_img 08.png%}



## **InnoDB索引实现**

​     虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。

​     第一个重大区别是**InnoDB的数据文件本身就是索引文件。**从上文知道，**MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。**而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的**叶节点data域保存了完整的数据记录**。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。

{%asset_img 09.png%}

​	上图是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。

​      **第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。**例如，下图为定义在Col3上的一个辅助索引：

{%asset_img 10.png%}

这里以英文字符的ASCII码作为比较准则。**<u>聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</u>**

​     了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么**不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。**再例如，用**非单调的字段**作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在**插入新记录时数据文件**为了维持B+Tree的特性而**频繁的分裂调整**，十分低效，而**<u>使用自增字段作为主键则是一个很好的选择。</u>**

**<u>对于InnoDB而言，因为节点下有数据文件，因此节点的分裂将会比较慢。对于InnoDB的主键，尽量用整型，而且是递增的整型。如果是无规律的数据，将会产生页的分裂，影响速度。</u>**



## **InnoDB索引**和**MyISAM索引**的区别：

**一是主索引的区别，InnoDB的数据文件本身就是索引文件。而MyISAM的索引和数据是分开的。**

**二是辅助索引的区别：InnoDB的辅助索引data域存储相应记录主键的值而不是地址。而MyISAM的辅助索引和主索引没有多大区别。**

**InnoDB的主索引文件上，直接存放该行数据，称为聚簇索引。次索引指向对主键的引用。**

**Myisam中，主索引和次索引都指向物理行。**



补充：**索引覆盖**

索引覆盖是指如果查询的列恰好是索引的一部分，那么查询只需要在索引文件上进行，不需要回行到磁盘再找数据（**即不需要回表查找**）。这种查询速度非常快，称为“索引覆盖”。



## **聚簇索引与非聚簇索引**

### **1、聚簇索引**

​    所谓聚簇索引，就是指**<u>主索引</u>文件和数据文件为同一份文件，聚簇索引主要用在Innodb存储引擎中。**在该索引实现方式中B+Tree的叶子节点上的data就是数据本身，key为主键，如果是一般索引的话，data便会指向对应的主索引(**然后再进行一次索引**)，如下图所示：

{%asset_img 05.png%}

  在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。**做这个优化的目的是为了提高区间访问的性能**，例如上图中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。

### **2、非聚簇索引**

​    非聚簇索引就是**指B+Tree的叶子节点上的data，并不是数据本身，而是数据存放的地址。**主索引和辅助索引没啥区别，只是主索引中的key一定得是唯一的。主要用在MyISAM存储引擎中，如下图：

{%asset_img 06.png%}

**非聚簇索引比聚簇索引多了一次读取数据的IO操作，所以查找性能上会差。**

## 联合索引

### 联合索引的B+树结构

我们用（name，age）这个联合索引来分析

{%asset_img 11.jpg%}

可以看到，索引项是按照索引定义里面出现的字段顺序排序的。

当你的逻辑需求是查到所有名字是“张三”的人时，可以快速定位到 ID4，然后向后遍历得到所有需要的结果。

只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。

基于上面对最左前缀索引的说明，我们来讨论一个问题：在建立联合索引的时候，如何安排索引内的字段顺序。

使用越频繁的字段通常可以放在最左侧。

### 多个单列索引和联合索引的区别

多个单列索引：

多个单列索引在多条件查询时只会生效第一个索引！所以多条件联合查询时最好建联合索引！

| where语句查询情况 | 实际用的索引          |
| ----------------- | --------------------- |
| a and b and c     | a                     |
| a or b or c       | a,b,c(查询结果有去重) |



联合索引本质：

当创建(a,b,c)联合索引时，**相当于创建了(a)单列索引，(a,b)联合索引以及(a,b,c)联合索引**想要索引生效的话,只能使用 a和a,b和a,b,c三种组合；当然，我们上面测试过，a,c组合也可以，但实际上只用到了a的索引，c并没有用到！生效情况如下表：

| where语句查询情况 | 索引     | 实际用的索引 |
| ----------------- | -------- | ------------ |
| a                 | 联合索引 | a            |
| b                 | NULL     | ×            |
| c                 | NULL     | ×            |
| a and b           | 联合索引 | (a,b)        |
| a and c           | 联合索引 | a            |
| b and c           | NULL     | ×            |
| a and b and c     | 联合索引 | (a,b,c)      |

**总结：**索引的最左原则（左前缀原则），如（c1,c2,c3,c4....cN）的联合索引，where 条件按照索引建立的字段顺序来使用（**不代表and条件必须按照顺序来写**），**如果中间某列没有条件，或使用like会导致后面的列不能使用索引。**

（如面试题：现在有a b 作为联合索引，有一条sql语句 where b > 0 and a = 7 和 where a>0 and b = 7分别会用到索引吗？  会）



**最左前缀：**顾名思义，就是最左优先，上例中我们创建了lname_fname_age多列索引,相当于创建了(lname)单列索引，(lname,fname)组合索引以及(lname,fname,age)组合索引。

[参考博客:多个单列索引和联合索引的区别](https://blog.csdn.net/mrxiky/article/details/81775194)



## 索引优化

### 1. 独立的列

在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。

例如下面的查询不能使用 actor_id 列的索引：

```sql
SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;
```

### 2. 多列索引

在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。

```sql
SELECT film_id, actor_ id FROM sakila.film_actor
WHERE actor_id = 1 AND film_id = 1;
```

### 3. 索引列的顺序

让选择性最强的索引列放在前面。

索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。

例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。

```sql
SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,
COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,
COUNT(*)
FROM payment;
```

```html
   staff_id_selectivity: 0.0001
customer_id_selectivity: 0.0373
               COUNT(*): 16049
```

### 4. 前缀索引

对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。

前缀长度的选取需要根据索引选择性来确定。

### 5. 覆盖索引

索引包含所有需要查询的字段的值。

具有以下优点：

- 索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。
- 一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。
- 对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。

## 索引的优点

- 大大减少了服务器需要扫描的数据行数。
- 帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。
- 将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。



## 索引的使用条件

- 对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；
- 对于中到大型的表，索引就非常有效；
- 但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。

