<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yue</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yuemingyang7010.github.io/"/>
  <updated>2019-10-31T02:35:51.488Z</updated>
  <id>http://yuemingyang7010.github.io/</id>
  
  <author>
    <name>Mingyang Yue</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分类器</title>
    <link href="http://yuemingyang7010.github.io/2019/10/28/%E5%88%86%E7%B1%BB%E5%99%A8/"/>
    <id>http://yuemingyang7010.github.io/2019/10/28/分类器/</id>
    <published>2019-10-28T09:01:45.000Z</published>
    <updated>2019-10-31T02:35:51.488Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线性分类器"><a href="#线性分类器" class="headerlink" title="线性分类器"></a>线性分类器</h2><p>神经网络方法包含两部分组成：<strong>评分函数（score function）和损失函数（loss function）</strong></p><h3 id="线性分类器评分函数"><a href="#线性分类器评分函数" class="headerlink" title="线性分类器评分函数"></a>线性分类器评分函数</h3><p>评分函数是原始图像数据到类别分值的映射，损失函数是用来量化预测分类标签的得分与真实标签之间一致性的。</p><script type="math/tex; mode=display">f\left(x_{i}, W, b\right)=W x_{i}+b</script><p>矩阵<strong>W</strong>被称为<strong>权重（weights）</strong>。<strong>b</strong>被称为<strong>偏差向量（bias vector）</strong></p><p><strong>线性分类器的理解：</strong></p><img src="/2019/10/28/分类器/001.jpg"><p><strong>将图像看做高维度的点</strong>：</p><p>可以把图像看做这个高维度空间中的一个点（即每张图像是3072维空间中的一个点）。整个数据集就是一个点的集合，每个点都带有1个分类标签。</p><p>既然定义每个分类类别的分值是权重和图像的矩阵乘，那么<strong>每个分类类别的分数就是这个空间中的一个线性函数的函数值。</strong>我们没办法可视化3072维空间中的线性函数，但假设<strong>把这些维度挤压到二维</strong>，那么就可以看看这些分类器在做什么</p><img src="/2019/10/28/分类器/002.jpg"><p>从上面可以看到，<strong>W</strong>的每一行都是一个分类类别的分类器。对于这些数字的几何解释是：如果改变其中一行的数字，会看见分类器在空间中对应的直线开始向着不同方向旋转。而偏差<strong>b</strong>，则允许分类器对应的直线平移。</p><p><strong>偏差和权重的合并技巧：</strong></p><script type="math/tex; mode=display">f\left(x_{i}, W\right)=W x_{i}</script><p>以CIFAR-10为例，那么[公式]的大小就变成[3073x1]，而不是[3072x1]了，多出了包含常量1的1个维度）。W大小就是[10x3073]了。[公式]中多出来的这一列对应的就是偏差值[公式]，具体见下图：</p><img src="/2019/10/28/分类器/003.jpg"><h3 id="线性分类器损失函数："><a href="#线性分类器损失函数：" class="headerlink" title="线性分类器损失函数："></a>线性分类器损失函数：</h3><p>当评分函数输出结果与真实结果之间差异越大，损失函数输出越大，反之越小。</p><p><strong>(1)多类支持向量机损失 Multiclass Support Vector Machine Loss：</strong></p><script type="math/tex; mode=display">L_{i}=\sum_{j \neq y_{i}} \max \left(0, s_{j}-s_{y_{i}}+\Delta\right)</script><p>SVM的损失函数想要正确分类类别$y_i$的分数比不正确类别分数高，而且至少要高$\Delta$。如果不满足这点，就开始计算损失值。</p><p><strong>举例</strong>：用一个例子演示公式是如何计算的。假设有3个分类，并且得到了分值S=[13,-7,11]。其中第一个类别是正确类别，即$y_i=0$。同时假设$\Delta$是10（后面会详细介绍该超参数）。上面的公式是将所有不正确分类（$j\neq y_i$)）加起来，所以我们得到两个部分（认为正确分类的分值最高）：</p><script type="math/tex; mode=display">L i=\max (0,-7-13+10)+\max (0,11-13+10)</script><p>对于线性评分函数，可以将损失函数的公式稍微改写一下：</p><script type="math/tex; mode=display">L_{i}=\sum_{j \neq y_{i}} \max \left(0, w_{j}^{T} x_{i}-w_{y_{i}}^{T} x_{i}+\Delta\right)</script><p>关于0的阀值：$max(0,-)$函数，它常被称为<strong>折叶损失（hinge loss）</strong>。有时候会听到人们使用<strong>平方折叶损失</strong>SVM（即L2-SVM），它使用的是$max(0,-)^2$，将更强烈（平方地而不是线性地）地惩罚过界的边界值。不使用平方是更标准的版本，但是在某些数据集中，平方折叶损失会工作得更好。<strong>可以通过交叉验证来决定使用哪个。</strong></p><p><strong>(2)正则化(Regularization):</strong></p><p>上面损失函数有一个问题。假设有一个数据集和一个权重集<strong>W</strong>能够正确地分类每个数据（即所有的边界都满足，对于所有的i都有$L_i=0$）。问题在于这个<strong>W</strong>并不唯一：可能有很多相似的W都能正确地分类所有的数据。</p><p>我们希望能向某些特定的权重<strong>W</strong>添加一些偏好，对其他权重则不添加，以此来消除模糊性。这一点是能够实现的，方法是向损失函数增加一个正则化惩罚（regularization penalty）$R(W)$部分。最常用的正则化惩罚是L2范式，L2范式通过对所有参数进行逐元素的平方惩罚来抑制大数值的权重：</p><script type="math/tex; mode=display">R(W)=\sum_{k} \sum_{l} W_{k, l}^{2}</script><p>上面的表达式中，将<strong>W</strong>中所有元素平方后求和。注意<strong>正则化函数不是数据的函数，仅基于权重</strong>。包含正则化惩罚后，就能够给出完整的多类SVM损失函数了，它由两个部分组成：<strong>数据损失</strong>（data loss），即所有样例的的平均损失$L_i$，以及<strong>正则化损失</strong>（regularization loss）。完整公式如下所示：</p><script type="math/tex; mode=display">L=\frac{1}{N} \sum_{i} \sum_{j \neq y_{i}}\left[\max \left(0, f\left(x_{i} ; W\right)_{j}-f\left(x_{i} ; W\right)_{y_{i}}+\Delta\right)\right]+\lambda \sum_{k} \sum_{l} W_{k, l}^{2}</script><p>其中，N是训练集的数据量。现在正则化惩罚添加到了损失函数里面，并用超参数$\lambda$来计算其权重。该超参数无法简单确定，需要通过交叉验证来获取。</p><p><strong>注意:</strong>和权重不同，偏差没有这样的效果，因为它们并不控制输入维度上的影响强度。因此通常只对权重[公式]正则化，而不正则化偏差[公式]。在实际操作中，可发现这一操作的影响可忽略不计。最后，因为正则化惩罚的存在，不可能在所有的例子中得到0的损失值，这是因为只有当[公式]的特殊情况下，才能得到损失值为0。</p><p><strong>正则化惩罚好的性质：</strong></p><p>对大数值权重进行惩罚，可以提升其泛化能力，因为这就意味着没有哪个维度能够独自对于整体分值有过大的影响。</p><p><strong>实际考虑设置Delta：</strong> <strong>在绝大多数情况下设为$ \Delta = 1.0$都是安全的</strong>。超参数$ \Delta$和$ \lambda$看起来是两个不同的超参数，但实际上他们一起控制同一个权衡：即损失函数中的数据损失和正则化损失之间的权衡。理解这一点的关键是要知道，权重<strong>W</strong>的大小对于分类分值有直接影响（当然对他们的差异也有直接影响）：当我们将<strong>W</strong>中值缩小，分类分值之间的差异也变小，反之亦然。因此，不同分类分值之间的边界的具体值（比如[公式]或[公式]）从某些角度来看是没意义的，<strong>因为权重自己就可以控制差异变大和缩小。也就是说，真正的权衡是我们允许权重能够变大到何种程度（通过正则化强度$ \lambda$来控制）。</strong></p><h2 id="Softmax分类器"><a href="#Softmax分类器" class="headerlink" title="Softmax分类器"></a>Softmax分类器</h2><p>SVM是最常用的两个分类器之一，而另一个就是Softmax分类器。Softmax分类器就可以理解为逻辑回归分类器面对多个分类的一般化归纳。SVM将输出$f(x_i,W)$作为每个分类的评分（因为无定标，所以难以直接解释）。与SVM不同，Softmax的输出（归一化的分类概率）更加直观，并且从概率上可以解释。在Softmax分类器中，函数映射$f(x_i,W)=Wx_i$保持不变，但将这些评分值视为每个分类的未归一化的对数概率，并且将折叶损失（hinge loss）替换为<strong>交叉熵损失</strong>（cross-entropy loss）。公式如下：</p><script type="math/tex; mode=display">L i=-\log \left(\frac{e^{f_{y_{i}}}}{\sum_{j} e^{f_{j}}}\right)</script><p>$f_{j}(z)=\frac{e^{z_{j}}}{\sum_{k} e^{z_{k}}}$被称作softmax 函数.</p><p>概率论解释：</p><script type="math/tex; mode=display">P\left(y_{i} | x_{i}, W\right)=\frac{e^{f_{y_{i}}}}{\sum_{j} e^{f_{j}}}</script><p>可以解释为是给定图像数据$x_i$，以$W$为参数，分配给正确分类标签$ y_i$的归一化概率。</p><p><strong>实操事项：注意数值稳定。</strong></p><p>编程实现softmax函数计算的时候，中间项$ e^{f_{y_{i}}}$和$ \sum_{j} e^{f_{j}}$因为存在指数函数，所以数值可能非常大。除以大数值可能导致数值计算的不稳定，所以学会使用归一化技巧非常重要。如果在分式的分子和分母都乘以一个常数$ C$，并把它变换到求和之中，就能得到一个从数学上等价的公式：</p><script type="math/tex; mode=display">\frac{e^{f_{y_{i}}}}{\sum_{j} e^{f_{j}}}=\frac{C e^{f_{y_{i}}}}{C \sum_{j} e^{f_{j}}}=\frac{e^{f_{y_{i}}+\log C}}{\sum_{j} e^{f_{j}+\log C}}</script><p>$ C$的值可自由选择，不会影响计算结果，通过使用这个技巧可以提高计算中的数值稳定性。通常将$ C$设为$ logC = -max f_j$。该技巧简单地说，就是应该将向量$f$中的数值进行平移，使得最大值为0。代码实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f = np.array([<span class="number">123</span>, <span class="number">456</span>, <span class="number">789</span>]) <span class="comment"># 例子中有3个分类，每个评分的数值都很大</span></span><br><span class="line">p = np.exp(f) / np.sum(np.exp(f)) <span class="comment"># 不妙：数值问题，可能导致数值爆炸</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 那么将f中的值平移到最大值为0：</span></span><br><span class="line">f -= np.max(f) <span class="comment"># f becomes [-666, -333, 0]</span></span><br><span class="line">p = np.exp(f) / np.sum(np.exp(f)) <span class="comment"># 现在OK了，将给出正确结果</span></span><br></pre></td></tr></table></figure><h2 id="SVM和Softmax的比较"><a href="#SVM和Softmax的比较" class="headerlink" title="SVM和Softmax的比较"></a>SVM和Softmax的比较</h2><p><strong>命名规则：</strong>精确地说，SVM分类器使用的是折叶损失（hinge loss），有时候又被称为最大边界损失（max-margin loss）。Softmax分类器使用的是交叉熵损失（corss-entropy loss）。</p><img src="/2019/10/28/分类器/004.png"><p>Softmax分类器为每个分类提供了“可能性”,即给出了每种分类的归一化概率。</p><p>​        在实际使用中，SVM和Softmax经常是相似的：通常说来，两种分类器的表现差别很小，不同的人对于哪个分类器更好有不同的看法。相对于Softmax分类器，SVM更加“局部目标化（local objective）”，这既可以看做是一个特性，也可以看做是一个劣势。考虑一个评分是[10, -2, 3]的数据，其中第一个分类是正确的。那么一个SVM（$\Delta = 1$）会看到正确分类相较于不正确分类，已经得到了比边界值还要高的分数，它就会认为损失值是0。SVM对于数字个体的细节是不关心的：如果分数是[10, -100, -100]或者[10, 9, 9]，对于SVM来说没设么不同，只要满足超过边界值等于1，那么损失值就等于0。</p><p>​        对于softmax分类器，情况则不同。对于[10, 9, 9]来说，计算出的损失值就远远高于[10, -100, -100]的。换句话来说，softmax分类器对于分数是永远不会满意的：正确分类总能得到更高的可能性，错误分类总能得到更低的可能性，损失值总是能够更小。但是，SVM只要边界值被满足了就满意了，不会超过限制去细微地操作具体分数。这可以被看做是SVM的一种特性。举例说来，一个汽车的分类器应该把他的大量精力放在如何分辨小轿车和大卡车上，而不应该纠结于如何与青蛙进行区分，因为区分青蛙得到的评分已经足够低了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;线性分类器&quot;&gt;&lt;a href=&quot;#线性分类器&quot; class=&quot;headerlink&quot; title=&quot;线性分类器&quot;&gt;&lt;/a&gt;线性分类器&lt;/h2&gt;&lt;p&gt;神经网络方法包含两部分组成：&lt;strong&gt;评分函数（score function）和损失函数（loss funct
      
    
    </summary>
    
    
      <category term="深度学习" scheme="http://yuemingyang7010.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="CS231N笔记" scheme="http://yuemingyang7010.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/CS231N%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="DeepLearning" scheme="http://yuemingyang7010.github.io/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>多线程编程</title>
    <link href="http://yuemingyang7010.github.io/2019/08/29/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    <id>http://yuemingyang7010.github.io/2019/08/29/多线程编程/</id>
    <published>2019-08-29T05:52:09.000Z</published>
    <updated>2019-08-30T01:32:49.284Z</updated>
    
    <content type="html"><![CDATA[<p>从C++11新标准开始，C++语言本身增加了对多线程的支持，意味着使用C++可实现多线程程序的可移植，跨平台。一个书写良好的程序，必须等所有的子线程执行完毕之后，主线程才能结束。</p><p><a href="https://www.bilibili.com/video/av48611530/?p=10" target="_blank" rel="noopener">C++并发与多线程视频教程</a></p><p><a href="https://www.jianshu.com/p/5d273e4e3cbb" target="_blank" rel="noopener">[c++11]多线程编程(一)——初识</a></p><p><a href="https://www.jianshu.com/p/109df8a7e627" target="_blank" rel="noopener">[c++11]多线程编程(二)——理解线程类的构造函数</a></p><p><a href="https://www.jianshu.com/p/4a2578dd9b5d" target="_blank" rel="noopener">[c++11]多线程编程(三)——竞争条件与互斥锁</a></p><p><a href="https://www.jianshu.com/p/c01e992a3d9d" target="_blank" rel="noopener">[c++11]多线程编程(四)——死锁(Dead Lock)</a></p><p><a href="https://www.jianshu.com/p/34d219380d90" target="_blank" rel="noopener">[c++11]多线程编程(五)——unique_lock</a></p><p><a href="https://www.jianshu.com/p/c1dfa1d40f53" target="_blank" rel="noopener">[c++11]多线程编程(六)——条件变量(Condition Variable)</a></p><p><a href="https://www.cnblogs.com/moodlxs/p/10111601.html" target="_blank" rel="noopener">C++11 使用异步编程std::async和std::future</a></p><h2 id="C-11创建线程基本方法"><a href="#C-11创建线程基本方法" class="headerlink" title="C++11创建线程基本方法"></a>C++11创建线程基本方法</h2><h3 id="1-1-使用函数创建线程"><a href="#1-1-使用函数创建线程" class="headerlink" title="1.1 使用函数创建线程"></a>1.1 使用函数创建线程</h3><h4 id="1-添加头文件"><a href="#1-添加头文件" class="headerlink" title="1 添加头文件"></a>1 添加头文件</h4><p>添加头文件以使用多线程：#include <thread></thread></p><h4 id="2-创建初始函数"><a href="#2-创建初始函数" class="headerlink" title="2  创建初始函数"></a>2  创建初始函数</h4><p>定义一个函数，这个函数将会作为我们创建的线程的初始函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"start executing my thread..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 在程序中添加线程，以及基本的线程函数</p><p>新建一个线程使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread 线程名称（初始函数）</span><br></pre></td></tr></table></figure><p><strong>join()函数</strong></p><p>用法：线程名称.join()</p><p>说明：使用该函数后，<strong>主线程阻塞到这里，当子线程执行完毕，这个join()函数就执行完毕，主线程也就可以继续运行了。</strong></p><p><strong>detach()函数</strong></p><p>传统多线程程序，主线程要等待子线程执行完毕，然后自己再退出。</p><p>deteach的意思是分离，<strong>也就是主线程不必和子线程汇合了，主线程与子线程各自执行。</strong>引入detach()是为了避免让主线程逐个等待子线程结,但是以后就不能被主线程控制或者回收了，不太推荐用，除非子线程与主线程业务无关。</p><p><strong>joinable()函数</strong></p><p><strong>判断是否可以成功使用join()或者detach()，返回true则可以，返回false则不可以。</strong></p><p>最后的完整程序如下，您可以通过依次运行mythread.join()，mythread.detach()函数查看程序运行结果以加深对这几个函数的理解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"子线程运行"</span> &lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">mythread</span><span class="params">(thread_function)</span></span>;        <span class="comment">// 传递初始函数作为线程的参数</span></span><br><span class="line">    <span class="keyword">if</span>(mythread.joinable())</span><br><span class="line">        mythread.join();                     <span class="comment">// 使用join()函数阻塞主线程直至子线程执行完毕</span></span><br><span class="line">    <span class="keyword">if</span>(mythread.joinable())</span><br><span class="line">        mythread.detach();                   <span class="comment">// 使用detach()函数让子线程和主线程并行运行，主线程也不再等待子线程。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"主线程运行"</span> &lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-运行结果分析"><a href="#4-运行结果分析" class="headerlink" title="4 运行结果分析"></a>4 运行结果分析</h4><p>如果只使用join()函数，注释detach()函数，运行结果如下，为顺序执行： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">子线程运行<span class="number">1</span></span><br><span class="line">子线程运行<span class="number">2</span></span><br><span class="line">子线程运行<span class="number">3</span></span><br><span class="line">子线程运行<span class="number">4</span></span><br><span class="line">子线程运行<span class="number">5</span></span><br><span class="line">主线程运行<span class="number">1</span></span><br><span class="line">主线程运行<span class="number">2</span></span><br><span class="line">主线程运行<span class="number">3</span></span><br><span class="line">主线程运行<span class="number">4</span></span><br><span class="line">主线程运行<span class="number">5</span></span><br></pre></td></tr></table></figure><p>​    如果只使用detach()函数，运行结果如下，每次执行的结果均不相同：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">子线程运行主线程运行<span class="number">11</span></span><br><span class="line"></span><br><span class="line">主线程运行<span class="number">2</span></span><br><span class="line">子线程运行<span class="number">2</span></span><br><span class="line">子线程运行<span class="number">3</span></span><br><span class="line">子线程运行<span class="number">4</span></span><br><span class="line">子线程运行<span class="number">5</span></span><br><span class="line">主线程运行<span class="number">3</span></span><br><span class="line">主线程运行<span class="number">4</span></span><br><span class="line">主线程运行<span class="number">5</span></span><br></pre></td></tr></table></figure><p>带参数的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myprint</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span>&#123;   <span class="comment">//最好不用引用，不安全，如果是引用，线程外的n改变会影响线程工作</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; n &lt;&lt; str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">thread <span class="title">threrad1</span><span class="params">(myprint,<span class="number">5</span>,<span class="string">"yue"</span>)</span></span>;</span><br><span class="line">threrad1.join();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5yue</span><br></pre></td></tr></table></figure><h3 id="1-2-使用类对象创建线程"><a href="#1-2-使用类对象创建线程" class="headerlink" title="1.2 使用类对象创建线程"></a>1.2 使用类对象创建线程</h3><p>创建thread的时候参数不仅可以是一个函数，也可以是一个类的对象。这个类中需要重载运算符()，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 运算符重载 </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span>  <span class="comment">//不能带参数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"子线程运行"</span> &lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Thread t;</span><br><span class="line">    <span class="function">thread <span class="title">mythread</span><span class="params">(t)</span></span>;        <span class="comment">// ！！！将对象复制到线程中去，所以复制后t销毁了也没关系。！！！</span></span><br><span class="line">    <span class="keyword">if</span>(mythread.joinable())</span><br><span class="line">        mythread.join();       <span class="comment">// 使用join()函数阻塞主线程直至子线程执行完毕</span></span><br><span class="line">    <span class="keyword">if</span>(mythread.joinable())</span><br><span class="line">        mythread.detach();     <span class="comment">// 使用detach()函数让子线程和主线程并行运行，主线程也不再等待子线程。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"主线程运行"</span> &lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>detach()之后子线程就分离了，运行完了由C++运行时库回收，并且detach()之后就不能join了。</strong></p><h3 id="1-3-detach-的坑"><a href="#1-3-detach-的坑" class="headerlink" title="1.3 detach()的坑"></a>1.3 detach()的坑</h3><p>坑的原因：子线程还没运行完，主线程就运行完了。</p><p>（比如传进一个主线程中字符串数组的指针，但是用了detach(),如果主线程先退出了，此时对该数组的操作可能出问题。）</p><p>子线程参数通过构造临时对象的方式来进行传递，构造临时对象主要有两种情况<br>（1）传递int这种简单类型参数<strong>，建议使用值传递，不要使用引用</strong>，防止节外生枝。<br>（2）如果传递类对象，一律在创建线程的地方就通过隐式转换构建临时对象，然后在函数形参处使用引用（节约资源）。</p><h2 id="多线程数据共享问题分析"><a href="#多线程数据共享问题分析" class="headerlink" title="多线程数据共享问题分析"></a>多线程数据共享问题分析</h2><p>问题：（1）只读数据：是安全稳定的，不需要特别的处理手段，只是不做其他处理，线程读取的顺序不能控制；</p><p>（2）有写的情况：例如，2个线程写，8个线程读，没有特殊处理，程序会崩溃，最简单的就是读的时候不能写，写的时候不能读。（3）多线程按顺序执行问题。</p><h3 id="1-互斥量mutex"><a href="#1-互斥量mutex" class="headerlink" title="1.互斥量mutex"></a>1.互斥量mutex</h3><p>一般情况下，最简单的协调不同线程之间的调度关系，都<strong>可以使用mutex来做，本质是信号量。</strong></p><p>std::mutex 的成员函数有四个：</p><p><strong>构造函数</strong>，std::mutex不允许拷贝构造，也不允许 move 拷贝，最初产生的 mutex 对象是处于 unlocked 状态的。<br><strong>lock()</strong>，调用线程将锁住该互斥量。线程调用该函数会发生下面 3 种情况：<br>(1). 如果该互斥量当前没有被锁住，则调用线程将该互斥量锁住，<strong>直到调用 unlock之前，该线程一直拥有该锁</strong>。<br>(2). 如果当前互斥量被其他线程锁住，则当前的调用线程<strong>被阻塞住</strong>。<br>(3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。<br><strong>unlock()</strong>， 解锁，释放对互斥量的所有权。<br><strong>try_lock()</strong>，尝试锁住互斥量，如果互斥量被其他线程占有，则当前线程也不会被阻塞。线程调用该函数也会出现下面 3 种情况，<br>(1). 如果当前互斥量没有被其他线程占有，则该线程锁住互斥量，<strong>直到该线程调用 unlock 释放互斥量</strong>。<br>(2). 如果当前互斥量被其他线程锁住，则当前调用线程返回 false，而并<strong>不会被阻塞掉</strong>。<br>(3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。</p><h3 id="2-lock-guard类模板"><a href="#2-lock-guard类模板" class="headerlink" title="2.lock_guard类模板"></a>2.lock_guard类模板</h3><p><strong>功能：取代mutex的lock()和unlock()</strong></p><p>如果mu.lock()和mu.unlock()之间的语句发生了异常，会发生什么？<strong>unlock()语句没有机会执行</strong>！导致导致mu一直处于锁着的状态（死锁）。</p><p><code>为解决这一问题，c++</code>库已经提供了<code>std::lock_guard</code>类模板，将lock()放在构造函数中，unlock()放在析构函数中，使用方法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shared_print</span><span class="params">(<span class="built_in">string</span> msg, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="comment">//构造的时候帮忙上锁，析构的时候释放锁</span></span><br><span class="line"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; guard(mu);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; msg &lt;&lt; id &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当在cout之后还有比较多的代码需要执行，而又不想锁住，可添加{}，提前结束lock_guard的生命周期，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shared_print</span><span class="params">(<span class="built_in">string</span> msg, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="comment">//构造的时候帮忙上锁，析构的时候释放锁</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; guard(mu);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; msg &lt;&lt; id &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">do something</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-std-lock-mu1-mu2-…-函数模板"><a href="#3-std-lock-mu1-mu2-…-函数模板" class="headerlink" title="3.std::lock(mu1,mu2,…)函数模板"></a>3.std::lock(mu1,mu2,…)函数模板</h3><p><strong>功能：解决上锁顺序导致的死锁</strong></p><p>死锁需要两个及其以上的互斥量才会发生，举一个死锁的例子：</p><p>例如有两个互斥量，叫做锁1和锁2，有两个线程，线程1，线程2，线程1所要执行的代码中都有，对锁1加锁，然后对锁2加锁，线程2所要执行的代码中，先对锁2加锁，再对锁1加锁。  可能出现，线程1锁了锁1，准备锁2时，由于上下切换，线程2去锁了锁2，于是线程1始终无法锁锁2，线程2始终无法锁住锁1，各自拥有的锁也不释放，从而造成僵持状态。</p><p>解决方法：<strong>只要保证上锁顺序一致就不会出现死锁。</strong></p><p>std:：lock()函数模板：一次锁住两个或者两个以上的互斥量（至少两个，多了不限，1个不行）；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::lock(_mu, _mu2);</span><br></pre></td></tr></table></figure><p>//它<strong>不存在这种因为再多个线程中因为锁的顺序问题导致死锁的风险问题</strong>；<br>//std:：lock()；如果互斥量中有一个没锁柱，它就在那里等着，<strong>等所有互斥量都锁住，它才能往下走（返回）</strong>；</p><p>该方法要谨慎使用。</p><p>问题：对多个互斥量上锁后，需要unlock()，这个时候可以采用<strong>lock()和lock_guard</strong>相结合的方式，先用lock()对多个互斥量上锁，再使用<code>std::adopt_lock</code>表示无需上锁，但会在超出作用于释放锁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; guard(_mu2, <span class="built_in">std</span>::adopt_lock);</span><br><span class="line"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; guard2(_mu, <span class="built_in">std</span>::adopt_lock);</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogFile</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::mutex _mu;</span><br><span class="line">    <span class="built_in">std</span>::mutex _mu2;</span><br><span class="line">    ofstream f;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LogFile() &#123;</span><br><span class="line">        f.open(<span class="string">"log.txt"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~LogFile() &#123;</span><br><span class="line">        f.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shared_print</span><span class="params">(<span class="built_in">string</span> msg, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::lock(_mu, _mu2);</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; guard(_mu, <span class="built_in">std</span>::adopt_lock);</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; guard2(_mu2, <span class="built_in">std</span>::adopt_lock);</span><br><span class="line">        f &lt;&lt; msg &lt;&lt; id &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; msg &lt;&lt; id &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shared_print2</span><span class="params">(<span class="built_in">string</span> msg, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::lock(_mu, _mu2);</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; guard(_mu2, <span class="built_in">std</span>::adopt_lock);</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; guard2(_mu, <span class="built_in">std</span>::adopt_lock);</span><br><span class="line">        f &lt;&lt; msg &lt;&lt; id &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; msg &lt;&lt; id &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function_1</span><span class="params">(LogFile&amp; <span class="built_in">log</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&gt;<span class="number">-100</span>; i--)</span><br><span class="line">        <span class="built_in">log</span>.shared_print2(<span class="built_in">string</span>(<span class="string">"From t1: "</span>), i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LogFile <span class="built_in">log</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span><span class="params">(function_1, <span class="built_in">std</span>::ref(<span class="built_in">log</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)</span><br><span class="line">        <span class="built_in">log</span>.shared_print(<span class="built_in">string</span>(<span class="string">"From main: "</span>), i);</span><br><span class="line"></span><br><span class="line">    t1.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-unique-lock类模板"><a href="#4-unique-lock类模板" class="headerlink" title="4.unique_lock类模板"></a>4.unique_lock类模板</h3><p>功能：unique_lock取代lock_guard<br>（1）unique_lock是个类模板，工作中，一般lock_guard（绝大多数情况都能满足，推荐使用）//unique_lock比lock_guard灵活很多；效率上差一点，内存占用多一点。</p><p>（2）unique_lock的第二个参数：</p><p><strong>(a)std:：adopt_lock</strong>和lock_guard相同，就是不再让unique_lock的构造函数中lock()这个mutex;</p><p><strong>(b)std:：try_to_lock</strong><br>尝试用mutex的lock()去锁定这个mutex，但如果没有锁定成功，我也会立即返回，并不会阻塞在那里；用这个try_to_lock的前提是不能先去lock()。<br><strong>(c))std:：defer_lock</strong><br>用这个defer_lock的前提是不能自己先lock，否则会报异常。<br>defer_lock的意思就是并没有给mutext加锁：初始化了一个没有加锁的mutex。</p><p>5.条件变量condition_variable</p><p>（3）unique_lock的重更成员函数（一般在std:：defer_lock参数下） </p><p>功能：常见用法可以更加灵活地<strong>提供细粒度的锁</strong>，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogFile</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::mutex _mu;</span><br><span class="line">    ofstream f;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LogFile() &#123;</span><br><span class="line">        f.open(<span class="string">"log.txt"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~LogFile() &#123;</span><br><span class="line">        f.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shared_print</span><span class="params">(<span class="built_in">string</span> msg, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; guard(_mu);</span><br><span class="line">        <span class="comment">//do something 1</span></span><br><span class="line">        guard.unlock(); <span class="comment">//临时解锁</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//do something 2</span></span><br><span class="line"></span><br><span class="line">        guard.lock(); <span class="comment">//继续上锁</span></span><br><span class="line">        <span class="comment">// do something 3</span></span><br><span class="line">        f &lt;&lt; msg &lt;&lt; id &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; msg &lt;&lt; id &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 结束时析构guard会临时解锁</span></span><br><span class="line">        <span class="comment">// 这句话可要可不要，不写，析构的时候也会自动执行</span></span><br><span class="line">        <span class="comment">// guard.ulock();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>(a) lock()，加锁<br>(b) unlock()，(临时)解锁；<br>(c) try_lock()，尝试给互斥量加锁，如果拿不到锁，则返回false，如果拿到了锁，返回true，这个数不阳塞的；<br>(d) release()，返回它所管理的mutex对象指针，并释放所有权；也就是说，这个unique_lock和mutex不再有关系。<br>注意严格区分unlock 0和release）的区，不要混淆。用release()的话，如果已经加锁，进行该操作，有责任需要自己unlock().</p><p>（4）unique_lock所有权转移</p><p>不可复制，可移动</p><p>unique_lock和lock_guard都不能复制，lock_guard不能移动，但是unique_lock可以！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unique_lock 可以移动，不能复制</span></span><br><span class="line"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; guard1(_mu);</span><br><span class="line"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; guard2 = guard1;  <span class="comment">// error</span></span><br><span class="line"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; guard2 = <span class="built_in">std</span>::move(guard1); <span class="comment">// ok ,guard2接管guard1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// lock_guard 不能移动，不能复制</span></span><br><span class="line"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; guard1(_mu);</span><br><span class="line"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; guard2 = guard1;  <span class="comment">// error</span></span><br><span class="line"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; guard2 = <span class="built_in">std</span>::move(guard1); <span class="comment">// error</span></span><br></pre></td></tr></table></figure><h3 id="5-条件变量condition-vriable类模板"><a href="#5-条件变量condition-vriable类模板" class="headerlink" title="5.条件变量condition_vriable类模板"></a>5.条件变量condition_vriable类模板</h3><p>需要包含：#include <condition_variable></condition_variable></p><p>condition_vriable这个类需要和互斥量配合使用，用的时候我们要生成这个类的对象。</p><p>主要有以下几个函数：</p><p>wait(),notify_one(),notify_all().</p><p>wait()函数有两个参数：<br>（1）如果第二个参数lambda表达式返回值是true，那wait()直接返回；<br>（2）如果第二个参数lambda表达式返回值是false，那么wait()将解锁互斥量，并阻塞到本行，<br>            那堵塞到什么时候为止呢？堵塞到其他某个线程调用notify_one()或者notify_all()成员函数为止；<br>(3)如果wait()没有第二个参数就跟第二个参数lambda表达式返回false效果一样。</p><p>不用第二个参数的形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; locker(mu);</span><br><span class="line">q.push_front(count);</span><br><span class="line">locker.unlock();</span><br><span class="line">cond.notify_one();  <span class="comment">// Notify one waiting thread, if there is one.</span></span><br><span class="line"><span class="comment">//std::this_thread::sleep_for(std::chrono::seconds(1));</span></span><br><span class="line">count--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (data != <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; locker(mu);</span><br><span class="line"><span class="keyword">while</span> (q.empty())</span><br><span class="line">cond.wait(locker); <span class="comment">// Unlock mu and wait to be notified</span></span><br><span class="line">data = q.back();</span><br><span class="line">q.pop_back();</span><br><span class="line">locker.unlock();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"t2 got a value from t1: "</span> &lt;&lt; data &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="built_in">std</span>::mutex mu;</span><br><span class="line"><span class="built_in">std</span>::condition_variable cond;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">A a;</span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span><span class="params">(&amp;A::function_1,&amp;a)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t2</span><span class="params">(&amp;A::function_2,&amp;a)</span></span>;</span><br><span class="line">t1.join();</span><br><span class="line">t2.join();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要用第二个参数，可以不用notify_one(),直接用lambda表达式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; locker(mu);</span><br><span class="line">q.push_front(count);</span><br><span class="line">locker.unlock();</span><br><span class="line"><span class="comment">//cond.notify_one();  // Notify one waiting thread, if there is one.</span></span><br><span class="line"><span class="comment">//std::this_thread::sleep_for(std::chrono::seconds(1));</span></span><br><span class="line">count--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (data != <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; locker(mu);</span><br><span class="line"><span class="comment">//while (q.empty())</span></span><br><span class="line"><span class="comment">//cond.wait(locker); // Unlock mu and wait to be notified</span></span><br><span class="line">cond.wait(locker, [<span class="keyword">this</span>]()&#123;  <span class="comment">//一个lambda就是一个可调用的对象(函数)</span></span><br><span class="line"><span class="keyword">if</span> (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;);</span><br><span class="line">data = q.back();</span><br><span class="line">q.pop_back();</span><br><span class="line">locker.unlock();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"t2 got a value from t1: "</span> &lt;&lt; data &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="built_in">std</span>::mutex mu;</span><br><span class="line"><span class="built_in">std</span>::condition_variable cond;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">A a;</span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span><span class="params">(&amp;A::function_1,&amp;a)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t2</span><span class="params">(&amp;A::function_2,&amp;a)</span></span>;</span><br><span class="line">t1.join();</span><br><span class="line">t2.join();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>存在的坑：</strong></p><p>（1）例如上例中，如果notify_one()唤醒wait()后，wait()后面还有很多代码需要执行，在执行过程中可能下一次循环又调用了notify_one()，而这个时候function_2()并不是阻塞在wait()处，这样将会使wait()无效果。</p><p>(2)根据(1)可知，不一定两个function都是交替执行，可能function_1()执行完notify_one()之后，马上又抢到锁，即连续朝队列中插入了两个(或多个)数据。</p><h3 id="6-使用异步编程std-async和std-future"><a href="#6-使用异步编程std-async和std-future" class="headerlink" title="6.使用异步编程std::async和std::future"></a>6.使用异步编程std::async和std::future</h3><p>需要包含 #include <future></future></p><p>std::future可以从异步任务中获取结果，一般与std::async配合使用，<strong>std::async</strong>用于创建异步任务，实际上就是<strong>创建一个线程执行相应任务。</strong></p><p>std::async就是异步编程的高级封装，封装了std::future的操作，基本上可以代替std::thread 的所有事情。</p><p>future对象是std::async、std::promise、std::packaged_task的底层对象，用来<strong>传递其他线程中操作的数据结果。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mythread</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"mythread start"</span> &lt;&lt; <span class="string">" threadID:"</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">chrono::<span class="function">milliseconds <span class="title">sleep1</span><span class="params">(<span class="number">1000</span>)</span></span>;</span><br><span class="line">this_thread::sleep_for(sleep1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"mythread end"</span> &lt;&lt; <span class="string">" threadID:"</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"main"</span> &lt;&lt; <span class="string">"threadID:"</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">future&lt;<span class="keyword">int</span>&gt; result = async(mythread);   <span class="comment">//async()创建一个异步任务（线程），将运行结果返回给futrue.</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"子线程返回值:"</span> &lt;&lt; result.get() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//阻塞在get()这里，等待mythread()执行完毕，拿到结果</span></span><br><span class="line">    <span class="comment">//result.wait();  // 等待线程返回，本省并不返回结果。</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mainthreadID:9964</span><br><span class="line">mythread start threadID:9964</span><br><span class="line">mythread end threadID:9964</span><br><span class="line">子线程返回值:5</span><br></pre></td></tr></table></figure><p>代码说明：</p><p>std::async会首先创建线程执行， 任务创建之后，std::async立即返回一个std::future对象。主线程既可使用<strong>std::future::get获取结果，如果调用过程中，任务尚未完成，则主线程阻塞至任务完成。</strong>　主线程也可使用std::future::wait_for等待结果返回，wait_for可设置超时时间，如果在超时时间之内任务完成，则返回std::future_status::ready状态；如果在超时时间之内任务尚未完成，则返回std::future_status::timeout状态。</p><p>注意：futrue的get()只能对一个任务执行一次，比如上例中不能get()两次。</p><p>如果传入的是一个带参数的类的成员函数，写法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;condition_variable&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;deque&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;mutex&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mythread</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"mythread start"</span> &lt;&lt; <span class="string">" threadID:"</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">chrono::<span class="function">milliseconds <span class="title">sleep1</span><span class="params">(<span class="number">1000</span>)</span></span>;</span><br><span class="line">this_thread::sleep_for(sleep1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"mythread end"</span> &lt;&lt; <span class="string">" threadID:"</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">A a;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"main"</span> &lt;&lt; <span class="string">"threadID:"</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">future&lt;<span class="keyword">int</span>&gt; result = async(&amp;A::mythread,&amp;a,<span class="number">10</span>);   <span class="comment">//async()创建一个异步任务（线程），将运行结果返回给futrue.</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"子线程返回值:"</span> &lt;&lt; result.get() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//阻塞在get()这里，等待mythread()执行完毕，拿到结果</span></span><br><span class="line">    <span class="comment">//result.wait();  // 等待线程返回，本省并不返回结果。</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mainthreadID:10208</span><br><span class="line">mythread start threadID:10208</span><br><span class="line">mythread end threadID:10208</span><br><span class="line">子线程返回值:10</span><br></pre></td></tr></table></figure><h3 id="7-std-：promise类模板"><a href="#7-std-：promise类模板" class="headerlink" title="7.std:：promise类模板"></a>7.std:：promise类模板</h3><p>需要包含 #include <future></future></p><p>std::promise是C++11并发编程中常用的一个类，常配合std::future使用。其作用是<strong>在一个线程t1中保存一个类型typename T的值，可供相绑定的std::future对象在另一线程t2中获取。</strong></p><p>关键点：（1）std::promise与std::future相绑定；（2）std::promise的对象set_value()，std::future的对象get()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Thread_Fun1</span><span class="params">(<span class="built_in">std</span>::promise&lt;<span class="keyword">int</span>&gt; &amp;p,<span class="keyword">int</span> temp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//为了突出效果，可以使线程休眠5s</span></span><br><span class="line"><span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">500</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> iVal = temp;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"传入数据(int)："</span> &lt;&lt; iVal &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入数据iVal</span></span><br><span class="line">p.set_value(iVal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Thread_Fun2</span><span class="params">(<span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt; &amp;f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//阻塞函数，直到收到相关联的std::promise对象传入的数据</span></span><br><span class="line"><span class="keyword">auto</span> iVal = f.get();<span class="comment">//iVal = 233</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"收到数据(int)："</span> &lt;&lt; iVal &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//声明一个std::promise对象pr1，其保存的值类型为int</span></span><br><span class="line"><span class="built_in">std</span>::promise&lt;<span class="keyword">int</span>&gt; pr1;</span><br><span class="line"><span class="comment">//声明一个std::future对象fu1，并通过std::promise的get_future()函数与pr1绑定</span></span><br><span class="line"><span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt; fu1 = pr1.get_future();</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">233</span>;</span><br><span class="line"><span class="comment">//创建一个线程t1，将函数Thread_Fun1及对象pr1放在线程里面执行</span></span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span><span class="params">(Thread_Fun1, <span class="built_in">std</span>::ref(pr1),<span class="number">233</span>)</span></span>;</span><br><span class="line"><span class="comment">//创建一个线程t2，将函数Thread_Fun2及对象fu1放在线程里面执行</span></span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t2</span><span class="params">(Thread_Fun2, <span class="built_in">std</span>::ref(fu1))</span></span>;</span><br><span class="line"></span><br><span class="line">t1.join();</span><br><span class="line">t2.join();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：上例其实使将主线程中的参数，传递给Thread_Fun1，然后再传递给Thread_Fun2，如果Thread_Fun1不含参数，直接set_value(233)，也会得到相同结果。</p><h3 id="8-原子操作atomic"><a href="#8-原子操作atomic" class="headerlink" title="8.原子操作atomic"></a>8.原子操作atomic</h3><p>互序量的加锁一般是针对一个代码段（几行代码），而<strong>原子操作针对的一般都是一个变量</strong>，而不是一个代码段；</p><p>通常非常适合用来控制代码块运行的<strong>全局标志位bool flag,还有计数值count等。</strong></p><p>原子操作，它表示在多个线程访问同一个全局资源的时候，能够确保所有其他线程都不在同一时间访问该资源。也就是确保了在同一时刻只有一个线程对这个资源进行访问。这有点<strong>类似互斥对象对共享资源的访问的保护，但是原子操作更加接近底层，因而效率更高。</strong></p><p>例如三个线程同时执行如下代码，由于num++编译后可能变成3条汇编，多个线程同时执行会使计算结果不正确。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程函数,内部对num自增1000万次</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000000</span>;i++) </span><br><span class="line">    &#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别不加锁，加锁，用原子操作进行实验：</p><p>实验结论（多线程操作全局变量，三个线程，每个线程对整型自增1000万次）</p><ol><li><p>非原子操作，不加锁，效率很高，但<strong>无法得到正确的结果；</strong></p></li><li><p>非原子操作，加锁，<strong>效率很低</strong>，大约和无锁的相差20倍，但结果正确；</p></li><li><p>原子操作，<strong>效率很高</strong>，大约是有锁实现的5倍，且结果正确。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">atomic&lt;<span class="keyword">int</span>&gt; num(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数,内部对num自增1000万次</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">clock_t</span> startClock = clock();   <span class="comment">// 记下开始时间</span></span><br><span class="line"><span class="comment">// 3个线程,创建即运行</span></span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(Add)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">(Add)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">t3</span><span class="params">(Add)</span></span>;</span><br><span class="line"><span class="comment">// 等待3个线程结束</span></span><br><span class="line">t1.join();</span><br><span class="line">t2.join();</span><br><span class="line">t3.join();</span><br><span class="line"><span class="keyword">clock_t</span> endClock = clock();     <span class="comment">// 记下结束时间</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"耗时:"</span> &lt;&lt; endClock - startClock &lt;&lt; <span class="string">",单位:"</span> &lt;&lt; CLOCKS_PER_SEC &lt;&lt; <span class="string">",result:"</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">耗时:1767,单位:1000,result:30000000</span><br></pre></td></tr></table></figure><h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><h2 id="C-11处理常见的多线程问题"><a href="#C-11处理常见的多线程问题" class="headerlink" title="C++11处理常见的多线程问题"></a>C++11处理常见的多线程问题</h2><h3 id="leetcode1114-按顺序打印"><a href="#leetcode1114-按顺序打印" class="headerlink" title="leetcode1114 按顺序打印"></a>leetcode1114 按顺序打印</h3><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/95889253" target="_blank" rel="noopener">参考</a></p><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>我们提供了一个类：</p><p>public class Foo {<br>  public void one() { print(“one”); }<br>  public void two() { print(“two”); }<br>  public void three() { print(“three”); }<br>}<br>三个不同的线程将会共用一个 Foo 实例。</p><p>线程 A 将会调用 one() 方法<br>线程 B 将会调用 two() 方法<br>线程 C 将会调用 three() 方法<br>请设计修改程序，以确保 two() 方法在 one() 方法之后被执行，three() 方法在 two() 方法之后被执行。</p><p>示例 1:</p><p>输入: [1,2,3]<br>输出: “onetwothree”<br>解释:<br>有三个线程会被异步启动。<br>输入 [1,2,3] 表示线程 A 将会调用 one() 方法，线程 B 将会调用 two() 方法，线程 C 将会调用 three() 方法。<br>正确的输出是 “onetwothree”。<br>示例 2:</p><p>输入: [1,3,2]<br>输出: “onetwothree”<br>解释:<br>输入 [1,3,2] 表示线程 A 将会调用 one() 方法，线程 B 将会调用 three() 方法，线程 C 将会调用 two() 方法。<br>正确的输出是 “onetwothree”。</p><p>注意:</p><p>尽管输入中的数字似乎暗示了顺序，但是我们并不保证线程在操作系统中的调度顺序。</p><p>你看到的输入格式主要是为了确保测试的全面性。</p><h4 id="方法0：用一个mutex与标志位结合-耗时长"><a href="#方法0：用一个mutex与标志位结合-耗时长" class="headerlink" title="方法0：用一个mutex与标志位结合(耗时长)"></a>方法0：用一个mutex与标志位结合(耗时长)</h4><p>执行用时 :<strong>4192 ms</strong>, 在所有 C++ 提交中击败了<strong>5.10%</strong>的用户</p><p>内存消耗 :9.3 MB, 在所有 C++ 提交中击败了100.00%的用户</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo() &#123;</span><br><span class="line">        flag=<span class="number">1</span>;</span><br><span class="line">        count=<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">first</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printFirst)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag==<span class="number">1</span>)&#123;</span><br><span class="line">                mu.lock();</span><br><span class="line">                <span class="comment">// printFirst() outputs "first". Do not change or remove this line.</span></span><br><span class="line">                printFirst();  </span><br><span class="line">                count--;</span><br><span class="line">                mu.unlock();</span><br><span class="line">                flag=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">second</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printSecond)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag==<span class="number">2</span>)&#123;</span><br><span class="line">                mu.lock();</span><br><span class="line">                <span class="comment">// printSecond() outputs "second". Do not change or remove this line.</span></span><br><span class="line">                printSecond();  </span><br><span class="line">                count--;</span><br><span class="line">                mu.unlock();</span><br><span class="line">                flag=<span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">third</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printThird)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag==<span class="number">3</span>)&#123;</span><br><span class="line">                mu.lock();</span><br><span class="line">                <span class="comment">// printThird() outputs "third". Do not change or remove this line.</span></span><br><span class="line">                printThird();  </span><br><span class="line">                count--;</span><br><span class="line">                mu.unlock();</span><br><span class="line">                flag=<span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printFirst</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"one"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printSecond</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"two"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printThird</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"three"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    mutex mu;</span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="方法1：用两个mutex锁"><a href="#方法1：用两个mutex锁" class="headerlink" title="方法1：用两个mutex锁"></a>方法1：用两个mutex锁</h4><p><strong>一个锁能控制两个线程的执行顺序。这个题中我们需要保持三个函数是按顺序执行的，则需要两个锁m1和m2。</strong></p><p>在开始的时候，两个锁都锁起来。first()可以直接执行，second()等待m1释放之后执行，third()等待m2释放之后执行。first()结束之后释放m1，second()结束之后释放m2.因此三个的顺序都协调一致了。</p><p>C++代码如下：</p><p>执行用时 :<strong>8 ms</strong>, 在所有 C++ 提交中击败了<strong>93.41%</strong>的用户</p><p>内存消耗 :9.1 MB, 在所有 C++ 提交中击败了100.00%的用户</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    mutex m1, m2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo() &#123;</span><br><span class="line">        m1.lock();</span><br><span class="line">        m2.lock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">first</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printFirst)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// printFirst() outputs "first". Do not change or remove this line.</span></span><br><span class="line">        printFirst();</span><br><span class="line">        m1.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">second</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printSecond)</span> </span>&#123;</span><br><span class="line">        m1.lock();</span><br><span class="line">        <span class="comment">// printSecond() outputs "second". Do not change or remove this line.</span></span><br><span class="line">        printSecond();</span><br><span class="line">        m1.unlock();</span><br><span class="line">        m2.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">third</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printThird)</span> </span>&#123;</span><br><span class="line">        m2.lock();</span><br><span class="line">        <span class="comment">// printThird() outputs "third". Do not change or remove this line.</span></span><br><span class="line">        printThird();</span><br><span class="line">        m2.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"first"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSecond</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"second"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printThird</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"third"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法2：promise-future"><a href="#方法2：promise-future" class="headerlink" title="方法2：promise/future"></a>方法2：promise/future</h4><p>这也是C++11中的新特性，可以把promise和future当做是在不同线程之间传递值的方式。在某个线程中对promise中生产一个数据，可以在另外一个线程中从future中获取这个数据。</p><p><strong>promise和future是绑定在一起的，可以调用promise::get_future()获取与其绑定的future。</strong><br><strong>future.wait()方法对当前的线程进行阻塞，等待与其绑定的promise调用set_value()方法。</strong><br><strong>future.get()方法对当前的线程进行阻塞，等待与其绑定的promise调用set_value()方法的返回值。</strong><br>因此实现线程的同步的方法会很方便。C++代码如下：</p><p>执行用时 :<strong>16 ms</strong>, 在所有 C++ 提交中击败了69.55%的用户</p><p>内存消耗 :9.4 MB, 在所有 C++ 提交中击败了100.00%的用户</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::promise&lt;<span class="keyword">void</span>&gt; p1;</span><br><span class="line">    <span class="built_in">std</span>::promise&lt;<span class="keyword">void</span>&gt; p2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">first</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printFirst)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// printFirst() outputs "first". Do not change or remove this line.</span></span><br><span class="line">        printFirst();</span><br><span class="line">        p1.set_value();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">second</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printSecond)</span> </span>&#123;</span><br><span class="line">        p1.get_future().wait();</span><br><span class="line">        <span class="comment">// printSecond() outputs "second". Do not change or remove this line.</span></span><br><span class="line">        printSecond();</span><br><span class="line">        p2.set_value();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">third</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printThird)</span> </span>&#123;</span><br><span class="line">        p2.get_future().wait();</span><br><span class="line">        <span class="comment">// printThird() outputs "third". Do not change or remove this line.</span></span><br><span class="line">        printThird();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"first"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSecond</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"second"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printThird</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"third"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="leetcode1115-交替打印FooBar"><a href="#leetcode1115-交替打印FooBar" class="headerlink" title="leetcode1115 交替打印FooBar"></a>leetcode1115 交替打印FooBar</h3><h4 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h4><p>我们提供一个类：</p><p>class FooBar {<br>  public void foo() {<br>    for (int i = 0; i &lt; n; i++) {<br>      print(“foo”);<br>    }<br>  }</p><p>  public void bar() {<br>    for (int i = 0; i &lt; n; i++) {<br>      print(“bar”);<br>    }<br>  }<br>}<br>两个不同的线程将会共用一个 FooBar 实例。其中一个线程将会调用 foo() 方法，另一个线程将会调用 bar() 方法。</p><p>请设计修改程序，以确保 “foobar” 被输出 n 次。</p><p>示例 1:</p><p>输入: n = 1<br>输出: “foobar”<br>解释: 这里有两个线程被异步启动。其中一个调用 foo() 方法, 另一个调用 bar() 方法，”foobar” 将被输出一次。<br>示例 2:</p><p>输入: n = 2<br>输出: “foobarfoobar”<br>解释: “foobar” 将被输出两次。</p><h4 id="方法：mutex交替加锁"><a href="#方法：mutex交替加锁" class="headerlink" title="方法：mutex交替加锁"></a>方法：mutex交替加锁</h4><p>执行用时 :<strong>28 ms</strong>, 在所有 C++ 提交中击败了44.50%的用户</p><p>内存消耗 :10.6 MB, 在所有 C++ 提交中击败了100.00%的用户</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    mutex m1,m2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    FooBar(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        m2.lock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printFoo)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            m1.lock();</span><br><span class="line">        <span class="comment">// printFoo() outputs "foo". Do not change or remove this line.</span></span><br><span class="line">        printFoo();</span><br><span class="line">            m2.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printBar)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            m2.lock();</span><br><span class="line">        <span class="comment">// printBar() outputs "bar". Do not change or remove this line.</span></span><br><span class="line">        printBar();</span><br><span class="line">            m1.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printFoo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Foo"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printBar</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Bar"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3个线程按照123的顺序循环打印一个字符串的每一个字符。"><a href="#3个线程按照123的顺序循环打印一个字符串的每一个字符。" class="headerlink" title="3个线程按照123的顺序循环打印一个字符串的每一个字符。"></a>3个线程按照123的顺序循环打印一个字符串的每一个字符。</h3><p><strong>本人笔记本测试用了33ms</strong></p><p>结合标志位和一个全局的mutex</p><h4 id="方法0：比较菜的方法"><a href="#方法0：比较菜的方法" class="headerlink" title="方法0：比较菜的方法"></a>方法0：比较菜的方法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> m_data = <span class="string">"abcdefghijklmnopqrstuvwxyz"</span>;  <span class="comment">//临界资源1</span></span><br><span class="line"><span class="keyword">int</span> len = m_data.size();</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;    <span class="comment">//临界资源2</span></span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>; <span class="comment">//临界资源3</span></span><br><span class="line">mutex mu;     <span class="comment">//不同线程共用一把锁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (i &lt; len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">mu.lock();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; m_data[i++] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">mu.unlock();</span><br><span class="line">flag = <span class="number">1</span>;   <span class="comment">//由于每个线程lock之外用的了flag,</span></span><br><span class="line"><span class="comment">//所以flag不能在unlock前改变，否则thread2线程可能马上进入if条件内，并抢用没有释放的锁</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (i &lt; len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">mu.lock();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; m_data[i++] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">mu.unlock();</span><br><span class="line">flag = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread3</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (i &lt; len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">2</span>) &#123;</span><br><span class="line">mu.lock();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; m_data[i++] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">mu.unlock();</span><br><span class="line">flag = <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">thread <span class="title">tesk01</span><span class="params">(thread1)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">tesk02</span><span class="params">(thread2)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">tesk03</span><span class="params">(thread3)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (tesk02.joinable())</span><br><span class="line">tesk02.join();</span><br><span class="line"><span class="keyword">if</span> (tesk01.joinable())</span><br><span class="line">tesk01.join();</span><br><span class="line"><span class="keyword">if</span> (tesk03.joinable())</span><br><span class="line">tesk03.join();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从C++11新标准开始，C++语言本身增加了对多线程的支持，意味着使用C++可实现多线程程序的可移植，跨平台。一个书写良好的程序，必须等所有的子线程执行完毕之后，主线程才能结束。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/
      
    
    </summary>
    
    
      <category term="C++基础" scheme="http://yuemingyang7010.github.io/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://yuemingyang7010.github.io/categories/C-%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="C++基础" scheme="http://yuemingyang7010.github.io/tags/C-%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://yuemingyang7010.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务</title>
    <link href="http://yuemingyang7010.github.io/2019/08/20/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    <id>http://yuemingyang7010.github.io/2019/08/20/分布式/</id>
    <published>2019-08-20T01:27:53.000Z</published>
    <updated>2019-08-22T04:30:38.681Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本地事务与分布式事务"><a href="#本地事务与分布式事务" class="headerlink" title="本地事务与分布式事务"></a>本地事务与分布式事务</h2><img src="/2019/08/20/分布式/01.png"><h2 id="两阶段提交协议-2PC"><a href="#两阶段提交协议-2PC" class="headerlink" title="两阶段提交协议(2PC)"></a>两阶段提交协议(2PC)</h2><p>两种常见方案：</p><img src="/2019/08/20/分布式/03.png"><h3 id="基于XA协议的两阶段提交方案"><a href="#基于XA协议的两阶段提交方案" class="headerlink" title="基于XA协议的两阶段提交方案"></a>基于XA协议的两阶段提交方案</h3><p>交易中间件与数据库通过 XA 接口规范，使用两阶段提交来完成一个全局事务， XA 规范的基础是两阶段提交协议。<br>第一阶段是表决阶段，所有参与者都将本事务能否成功的信息反馈发给协调者；第二阶段是执行阶段，协调者根据所有参与者的反馈，通知所有参与者，步调一致地在所有分支上提交或者回滚。</p><img src="/2019/08/20/分布式/02.png"><p>两阶段提交方案应用非常广泛，几乎所有商业OLTP数据库都支持XA协议。但是<strong>两阶段提交方案锁定资源时间长，对性能影响很大</strong>，基本不适合解决微服务事务问题。</p><h3 id="TCC（Try-Confirm-Cancel）两阶段补偿型方案"><a href="#TCC（Try-Confirm-Cancel）两阶段补偿型方案" class="headerlink" title="TCC（Try-Confirm-Cancel）两阶段补偿型方案"></a>TCC（Try-Confirm-Cancel）两阶段补偿型方案</h3><p><a href="https://wenku.baidu.com/view/be946bec0975f46527d3e104.html" target="_blank" rel="noopener">TCC方案</a>在电商、金融领域落地较多。TCC方案其实是两阶段提交的一种改进。其将整个业务逻辑的每个分支显式的分成了Try、Confirm、Cancel三个操作。Try部分完成业务的准备工作，confirm部分完成业务的提交，cancel部分完成事务的回滚。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;本地事务与分布式事务&quot;&gt;&lt;a href=&quot;#本地事务与分布式事务&quot; class=&quot;headerlink&quot; title=&quot;本地事务与分布式事务&quot;&gt;&lt;/a&gt;本地事务与分布式事务&lt;/h2&gt;&lt;img src=&quot;/2019/08/20/分布式/01.png&quot;&gt;
&lt;h2 id
      
    
    </summary>
    
    
      <category term="分布式" scheme="http://yuemingyang7010.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="http://yuemingyang7010.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题</title>
    <link href="http://yuemingyang7010.github.io/2019/07/30/LeetCode%E5%88%B7%E9%A2%98/"/>
    <id>http://yuemingyang7010.github.io/2019/07/30/LeetCode刷题/</id>
    <published>2019-07-30T15:21:56.000Z</published>
    <updated>2019-08-03T07:08:30.655Z</updated>
    
    <content type="html"><![CDATA[<h3 id><a href="#" class="headerlink" title=" "></a> </h3><h3 id="两数之和-1-易"><a href="#两数之和-1-易" class="headerlink" title="两数之和(1.易)"></a>两数之和(1.易)</h3><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><p>示例:</p><p>给定 nums = [2, 7, 11, 15], target = 9</p><p>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p><p>两遍遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            m[nums[i]] = i; <span class="comment">//先遍历一遍数组，建立HashMap映射</span></span><br><span class="line">        &#125;</span><br><span class="line">           <span class="comment">//然后再遍历一遍，开始查找，找到则记录index</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (m.count(t) &amp;&amp; m[t] != i) &#123;<span class="comment">//if里面的条件用于判断查找到的数字不是第一个数字</span></span><br><span class="line">                res.push_back(i);</span><br><span class="line">                res.push_back(m[t]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一次遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m.count(target - nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;i, m[target - nums[i]]&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            m[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="最小因式分解-625-中"><a href="#最小因式分解-625-中" class="headerlink" title="最小因式分解(625. 中)"></a>最小因式分解(625. 中)</h3><p>给定一个正整数 a，找出最小的正整数 b 使得 b 的所有数位相乘恰好等于 a。如果不存在这样的结果或者结果不是 32 位有符号整数，返回 0。</p><p>样例 1</p><p>输入：48<br>输出：68</p><p>样例 2</p><p>输入：15<br>输出：35</p><p>思路：</p><p>当该数小于10，直接返回该数，其他数分解出的因数一定是个位数字，即范围是[2, 9]。那我们就可以从大到小开始找因数，首先查找9是否是因数，是要能整除a，就是其因数，如果是的话，就加入到结果res的末尾，a自除以9，我们用while循环查找9，直到取出所有的9，然后取8，7，6…以此类推，如果a能成功的被分解的话，最后a的值应该为1，如果a值大于1，说明无法被分解，返回0。最后还要看我们结果res字符转为整型是否越界，越界的话还是返回0，参见代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">smallestFactorization</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a &lt; <span class="number">10</span>) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>, cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">9</span>; i &gt;= <span class="number">2</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (a % i == <span class="number">0</span>) &#123;</span><br><span class="line">                res += cnt * i;</span><br><span class="line">                <span class="keyword">if</span> (res &gt; INT_MAX) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                a /= i;</span><br><span class="line">                cnt *= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (a == <span class="number">1</span>) ? res : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="无重复字符的最长子串-3-中"><a href="#无重复字符的最长子串-3-中" class="headerlink" title="无重复字符的最长子串(3.中)"></a>无重复字符的最长子串(3.中)</h3><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:</p><p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:</p><p>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:</p><p>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p><p>思路：滑动窗口+HashMap</p><p>​        例如”abcabcbb”，让你手动找无重复字符的子串，比如子串a，b，c，然后又出现了一个a，那么此时就应该去掉第一次出现的a，然后继续往后，又出现了一个b，则应该去掉一次出现的b，以此类推，最终发现最长的长度为3。</p><p>​        用HashMap来建立字符和其出现位置之间的映射。进一步考虑，由于字符会重复出现，到底是保存所有出现的位置呢，还是只记录一个位置？我们之前手动推导的方法实际上是维护了一个<strong>滑动窗口</strong>，<strong>窗口内的都是没有重复的字符</strong>，我们需要尽可能的扩大窗口的大小。由于窗口在不停向右滑动，所以<strong>我们只关心每个字符最后出现的位置，并建立映射。窗口的右边界就是当前遍历到的字符的位置</strong>，为了求出窗口的大小，我们需要一个<strong>变量left来指向滑动窗口的左边界</strong>，这样，如果当前遍历到的字符从未出现过，那么直接扩大右边界，<strong>如果之前出现过</strong>，那么就<strong>分两种情况，在或不在滑动窗口内</strong>，如果不在滑动窗口内，那么就没事，当前字符可以加进来，如果在的话，就需要先在滑动窗口内去掉这个已经出现过的字符了，去掉的方法并不需要将左边界left一位一位向右遍历查找，由于我们的HashMap已经保存了该重复字符最后出现的位置，所以<strong>直接移动left指针就可以</strong>了。我们维护一个结果res，每次用出现过的窗口大小来更新结果res，就可以得到最终结果啦。</p><p>​        这里解释下程序中那个if条件语句中的两个条件m.count(s[i]) &amp;&amp; m[s[i]] &gt; left，因为一旦当前字符s[i]在HashMap已经存在映射，说明当前的字符已经出现过了，而若m[s[i]] &gt; left 成立，说明之前出现过的字符在我们的窗口内，那么如果要加上当前这个重复的字符，就要移除之前的那个，所以我们<strong>让left赋值为m[s[i]]</strong>，由于left是窗口左边界的前一个位置（这也是left初始化为-1的原因，因为窗口左边界是从0开始遍历的），所以相当于已经移除出滑动窗口了。举一个最简单的例子”aa”，当i=0时，我们建立了a-&gt;0的映射，并且此时结果res更新为1，那么当i=1的时候，我们发现a在HashMap中，并且映射值0大于left的-1，所以此时left更新为0，映射对更新为a-&gt;1，那么此时i-left还为1，不用更新结果res，那么最终结果res还为1，正确，代码如下：</p><p>解法一：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>,left=<span class="number">-1</span>,len=s.length(); <span class="comment">//left代表滑窗左边界元素的前一个元素位置</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;  <span class="comment">//key为字符串的每一个字符，value为该字符从左到右遍历过程中最后出现的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m.count(s[i]) &amp;&amp; m[s[i]]&gt;left)  <span class="comment">//如果满足字符在m中，并且还在滑动窗口中</span></span><br><span class="line">                left = m[s[i]];      <span class="comment">//更新左边界的前一个元素位置</span></span><br><span class="line">            m[s[i]] = i;   <span class="comment">//更新s[i]对应的位置，及s[i]最后出现的位置</span></span><br><span class="line">            res = max(res,i-left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>解法二：（本质和解法一完全一样）</p><p>解法二是解法一的精简模式，这里我们可以建立一个256位大小的整型数组来代替HashMap，然后我们全部初始化为-1，这样的好处是我们就不用像之前的HashMap一样要查找当前字符是否存在映射对了，对于每一个遍历到的字符，我们直接用其在数组中的值来更新left，因为默认是-1，而left初始化也是-1，所以并不会产生错误，这样就省了if判断的步骤，其余思路都一样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m[<span class="number">256</span>]=&#123;<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, left = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            left = max(left, m[s[i]]);  <span class="comment">//因为数组m初始值为-1，因此只有</span></span><br><span class="line"><span class="comment">//满足其值不为-1（即该字符出现过），并且m[s[i]]大于left的时候才会left = m[s[i]]; </span></span><br><span class="line">            m[s[i]] = i;</span><br><span class="line">            res = max(res, i - left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="两数相加-2-中"><a href="#两数相加-2-中" class="headerlink" title="两数相加(2.中)"></a>两数相加(2.中)</h3><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>示例：</p><p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p><p>思路：</p><p>new一个头结点，方便以后的操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* preHead = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);    <span class="comment">//头结点,方便后续的操作</span></span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        ListNode *cur = preHead;</span><br><span class="line">        <span class="keyword">while</span>(l1||l2)&#123;</span><br><span class="line">            <span class="keyword">int</span> ai = l1 == <span class="literal">nullptr</span> ? <span class="number">0</span> : l1-&gt;val;  <span class="comment">//l1对应位置的值，如果不存在，则补0</span></span><br><span class="line">            <span class="keyword">int</span> bi = l2 == <span class="literal">nullptr</span> ? <span class="number">0</span> : l2-&gt;val;  <span class="comment">//同上</span></span><br><span class="line">            <span class="keyword">int</span> value = (ai + bi + carry) % <span class="number">10</span>;    <span class="comment">//求相应加法运算后值</span></span><br><span class="line">            carry = (ai + bi + carry) / <span class="number">10</span>;        <span class="comment">//求相应加法运算后进位值</span></span><br><span class="line">            cur-&gt;next = <span class="keyword">new</span> ListNode(value);      <span class="comment">//尾插法   </span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//更新</span></span><br><span class="line">            l1 = l1 == <span class="literal">nullptr</span> ? <span class="literal">nullptr</span> : l1-&gt;next;  </span><br><span class="line">            l2 = l2 == <span class="literal">nullptr</span> ? <span class="literal">nullptr</span> : l2-&gt;next;</span><br><span class="line">            cur = cur-&gt;next;         </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry &gt; <span class="number">0</span>)     <span class="comment">//判断最后是否有进位，如果有，多开一个节点</span></span><br><span class="line">            cur-&gt;next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">        <span class="keyword">return</span> preHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="最长回文子串-5-中"><a href="#最长回文子串-5-中" class="headerlink" title="最长回文子串(5.中)"></a>最长回文子串(5.中)</h3><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p><p>示例 1：</p><p>输入: “babad”<br>输出: “bab”<br>注意: “aba” 也是一个有效答案。<br>示例 2：</p><p>输入: “cbbd”<br>输出: “bb”</p><p>思路：<a href="https://mp.weixin.qq.com/s?__biz=MzIwNTc4NTEwOQ==&amp;mid=2247484049&amp;idx=1&amp;sn=b3ee1a909d0c75cb9ef57df69ca36f5c&amp;chksm=972ad3eba05d5afd63dcb87c78a3b99cd6312e86c26d3727a7c7e01f0ed9a5f4f81edbee06f9&amp;mpshare=1&amp;scene=1&amp;srcid=0719xSkvzvmyhSB5d0cGY6Au&amp;key=034516426b2066d0e0aa6ab7340f5165b69a49c8183a1b4a232fae513c14ca25e69fa8220126e8ae5c517f68513d650b40ea657e95aed7b3002b7281a4c0fec8b6e601f0a455962f47f12cab9c546f51&amp;ascene=1&amp;uin=MjUzODM5ODQwNA%3D%3D&amp;devicetype=Windows+10&amp;version=62060833&amp;lang=zh_CN&amp;pass_ticket=x3FegFPx%2Bvw0qa34JSQ8rVDFtlaR46UnZVCzg53idyupd1SCO5oQv401BqivS7%2Fn" target="_blank" rel="noopener">参考</a></p><p><strong>方法一：Manacher 算法求最长回文子串:  时间复杂度O(N)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="string">""</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"><span class="built_in">string</span> str = <span class="string">"@"</span>;</span><br><span class="line"><span class="built_in">string</span> result;</span><br><span class="line"><span class="keyword">int</span> len = s.length();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">str = str + <span class="string">"#"</span> + s[i];</span><br><span class="line">str += <span class="string">"#$"</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p(str.length(), <span class="number">1</span>);</span><br><span class="line">manacher(str, p);</span><br><span class="line"><span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> imax;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.size(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (p[i] &gt; max) &#123;</span><br><span class="line">max = p[i];</span><br><span class="line">imax = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = imax - (max - <span class="number">1</span>); j &lt;= imax + (max - <span class="number">1</span>); j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (str[j] != <span class="string">'#'</span>)</span><br><span class="line">result += str[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manacher</span><span class="params">(<span class="built_in">string</span>&amp; str, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = str.length();</span><br><span class="line"><span class="keyword">int</span> id = <span class="number">0</span>;  <span class="comment">// id 为已知的 &#123;右边界最大&#125; 的回文子串的中心</span></span><br><span class="line"><span class="keyword">int</span> mx = <span class="number">1</span>;  <span class="comment">//mx则为id+P[id]，也就是这个子串的右边界</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len - <span class="number">2</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (mx &gt; i)</span><br><span class="line">p[i] = min(p[<span class="number">2</span> * id - i], mx - i);  <span class="comment">//如果mx&gt;i，则分两种情况</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">p[i] = <span class="number">1</span>;                   <span class="comment">//如果mx&lt;i，则无法用之前的p来计算，先置1</span></span><br><span class="line"><span class="keyword">for</span> (; str[i + p[i]] == str[i - p[i]]; p[i]++);  <span class="comment">//统计i对应的p[i]</span></span><br><span class="line"><span class="keyword">if</span> (mx &lt; i + p[i]) &#123;</span><br><span class="line">mx = i + p[i]; <span class="comment">//更新右边界</span></span><br><span class="line">id = i;      <span class="comment">//更新id</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方法2：暴力法 n*(n/2)(n2)  时间复杂度O(N^3)</p><p>方法3: 动态规划 O(N^2)</p><h3 id="反转链表-206-易"><a href="#反转链表-206-易" class="headerlink" title="反转链表(206. 易)"></a>反转链表(206. 易)</h3><p>反转一个单链表。</p><p>示例:</p><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL<br>进阶:<br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p><p>思路：</p><img src="/2019/07/30/LeetCode刷题/01.png"><p>迭代法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *newHead = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            ListNode *t = head-&gt;next;</span><br><span class="line">            head-&gt;next = newHead;</span><br><span class="line">            newHead = head;</span><br><span class="line">            head = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>递归法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* p = reverseList(head-&gt;next); <span class="comment">//把head节点之后的所有节点都反转了</span></span><br><span class="line">        head-&gt;next-&gt;next = head; <span class="comment">//head-&gt;next为原先head节点后面部分的首节点，反转后变成尾节点，所以他的下一个节点接上head节点，至此整个链表反转完成</span></span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;   <span class="comment">//此时head为新链表尾节点，其下一个节点需要置为NULL</span></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="最大子数组和-53-易"><a href="#最大子数组和-53-易" class="headerlink" title="最大子数组和(53. 易)"></a>最大子数组和(53. 易)</h3><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例:</p><p>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: <strong>连续子数组</strong> [4,-1,2,1] 的和最大，为 6。<br>进阶:</p><p>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p><p>思路：</p><p>动态规划：</p><p>dp[i] = max(dp[i-1]+nums[i],nums[i]);  //dp[i]代表以位置i元素为结尾的子数组的最大和</p><p>然后求出最大的dp[i]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> maxAns;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n,<span class="number">0</span>);   <span class="comment">//dp[i]代表以位置i元素为结尾的子数组的最大和</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        maxAns = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i] = max(dp[i<span class="number">-1</span>]+nums[i],nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(dp[i] &gt; maxAns)&#123;</span><br><span class="line">                maxAns = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxAns;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="三数之和（15-中）"><a href="#三数之和（15-中）" class="headerlink" title="三数之和（15.中）"></a>三数之和（15.中）</h3><p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p>例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p><p>满足要求的三元组集合为：<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p><p>思路：</p><p>​        我们对原数组进行<strong>排序</strong>，然后开始遍历排序后的数组，这里注意不是遍历到最后一个停止，而是到倒数第三个就可以了。这里我们可以先做个剪枝优化，就是<strong>当遍历到正数的时候就break</strong>，为啥呢，因为我们的数组现在是有序的了，如果第一个要fix的数就是正数了，那么后面的数字就都是正数，就永远不会出现和为0的情况了。然后我们还要加上<strong>重复就跳过的处理</strong>，处理方法是从第二个数开始，如果和前面的数字相等，就跳过，因为我们不想把相同的数字fix两次。</p><p>​        对于遍历到的数，用0减去这个fix的数得到一个target，然后只需要再之后找到两个数之和等于target即可。我们用两个指针分别指向fix数字之后开始的数组首尾两个数，如果两个数和正好为target，则将这两个数和fix的数一起存入结果中。然后就是跳过重复数字的步骤了，两个指针都需要检测重复数字。如果两数之和小于target，则我们将左边那个指针i右移一位，使得指向的数字增大一些。同理，如果两数之和大于target，则我们将右边那个指针j左移一位，使得指向的数字减小一些，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">        sort(nums.begin(),nums.end());  <span class="comment">//先排序</span></span><br><span class="line">        <span class="keyword">if</span>(nums.empty()||nums.back()&lt;<span class="number">0</span>||nums.front()&gt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;  <span class="comment">//数组为空、全为正数或者全为负数，结果都返回空</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;nums.size();++k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[k]&gt;<span class="number">0</span>)    <span class="comment">//当用来计算target的元素大于0的时候，证明后面的两正数之和小于0，不可能的情况</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(k&gt;<span class="number">0</span> &amp;&amp; nums[k]==nums[k<span class="number">-1</span>])  <span class="comment">//遇到用来计算target的元素相等的情况，去掉重复</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> target = <span class="number">0</span>-nums[k];</span><br><span class="line"><span class="comment">//下面一部分其实成了用左右双指针求和为target的两个数。</span></span><br><span class="line">            <span class="keyword">int</span> i=k+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> j=nums.size()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]==target)&#123;</span><br><span class="line">                    res.push_back(&#123;nums[k],nums[i],nums[j]&#125;);</span><br><span class="line">                    <span class="keyword">while</span>(i&lt;j&amp;&amp;nums[i]==nums[i+<span class="number">1</span>])  <span class="comment">//去处重复情况</span></span><br><span class="line">                        i++;</span><br><span class="line">                    <span class="keyword">while</span>(i&lt;j&amp;&amp;nums[j]==nums[j<span class="number">-1</span>])  <span class="comment">//去处重复情况</span></span><br><span class="line">                        j--;</span><br><span class="line">                    i++;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] + nums[j] &lt; target)</span><br><span class="line">                    i++;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    --j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="有效的括号-20-易"><a href="#有效的括号-20-易" class="headerlink" title="有效的括号(20. 易)"></a>有效的括号(20. 易)</h3><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p><p>示例 1:</p><p>输入: “()”<br>输出: true<br>示例 2:</p><p>输入: “()[]{}”<br>输出: true<br>示例 3:</p><p>输入: “(]”<br>输出: false<br>示例 4:</p><p>输入: “([)]”<br>输出: false<br>示例 5:</p><p>输入: “{[]}”<br>输出: true</p><p>思路：</p><p>这道题让我们验证输入的字符串是否为括号字符串，包括大括号，中括号和小括号。这里我们需要<strong>用一个栈</strong>，我们开始遍历输入字符串，如果<strong>当前字符为左半边括号时，则将其压入栈中</strong>，如果<strong>遇到右半边括号时，若此时栈为空，则直接返回false，如不为空，则取出栈顶元素</strong>，若为对应的左半边括号，则继续循环，反之返回false，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; mstack;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'('</span>||s[i] == <span class="string">'['</span>||s[i] == <span class="string">'&#123;'</span>)</span><br><span class="line">                mstack.push(s[i]);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(mstack.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">')'</span>&amp;&amp;(mstack.top() != <span class="string">'('</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">']'</span>&amp;&amp;(mstack.top() != <span class="string">'['</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">'&#125;'</span>&amp;&amp;(mstack.top() != <span class="string">'&#123;'</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                mstack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mstack.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot; &quot;&gt;&lt;/a&gt; &lt;/h3&gt;&lt;h3 id=&quot;两数之和-1-易&quot;&gt;&lt;a href=&quot;#两数之和-1-易&quot; class=&quot;headerlink&quot; title=&quot;两数之和(1.易)&quot;&gt;&lt;/a&gt;两数之
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yuemingyang7010.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法刷题" scheme="http://yuemingyang7010.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="LeetCode刷题" scheme="http://yuemingyang7010.github.io/tags/LeetCode%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>STL总结</title>
    <link href="http://yuemingyang7010.github.io/2019/07/30/STL%E6%80%BB%E7%BB%93/"/>
    <id>http://yuemingyang7010.github.io/2019/07/30/STL总结/</id>
    <published>2019-07-30T12:26:49.000Z</published>
    <updated>2019-07-30T13:44:13.338Z</updated>
    
    <content type="html"><![CDATA[<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>字符串类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1：string对象的定义和初始化以及读写</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s1;        <span class="comment">//默认构造函数，s1为空串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(s1)</span></span>;    <span class="comment">//将s2初始化为s1的一个副本</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(<span class="string">"valuee"</span>)</span></span>;   <span class="comment">//将s3初始化一个字符串面值副本</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(n,<span class="string">'c'</span>)</span></span>;      <span class="comment">//将s4 初始化为字符'c'的n个副本</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s5;               <span class="comment">//读取有效字符到遇到空格</span></span><br><span class="line">getline(<span class="built_in">cin</span>,s6);      <span class="comment">//读取字符到遇到换行，空格可读入，知道‘\n’结束（练习在下一个代码中），</span></span><br><span class="line">getline(<span class="built_in">cin</span>,s7,<span class="string">'a'</span>); <span class="comment">//一个直到‘a’结束，其中任何字符包括'\n'都能够读入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2：string对象中一些函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*------插入函数------包括迭代器操作和下标操作，下标操作更灵活*/</span></span><br><span class="line">s.insert( it , p );  <span class="comment">//把字符串p插入到it的位置</span></span><br><span class="line">s.insert(p,n,t)；   <span class="comment">//迭代器p元素之前插入n个t的副本</span></span><br><span class="line">s.insert(p,b,e);     <span class="comment">//迭代器p元素之前插入迭代器b到e之间的所有元素</span></span><br><span class="line">s.insert(p,s2,poe2,len); <span class="comment">//在下标p之前插入s2下标从poe2开始长度为len的元素</span></span><br><span class="line">s.insert(pos,cp,len);  <span class="comment">//下标pos之前插入cp数组的前len个元素。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*----------替换函数-------------------*/</span></span><br><span class="line">s.substr(i,j)   截取s串中从i到j的子串  <span class="comment">//string::npos  判断字符串是否结束</span></span><br><span class="line">s.replace ( <span class="number">3</span> , <span class="number">3</span> , <span class="string">" good "</span> ) ;   <span class="comment">//从第三个起连续三个替换为good</span></span><br><span class="line">s.assign(b,e);  <span class="comment">//用迭代器b到e范围内的元素替换s</span></span><br><span class="line">s.assign(n,t)；  <span class="comment">//用n个t的副本替换s</span></span><br><span class="line">a.assign(s1,pos2,len);   <span class="comment">//从s1的下标pos2开始连续替换len个。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------删除函数-----------------------------*/</span></span><br><span class="line">s.erase( <span class="number">3</span> )||s.erase ( <span class="number">0</span> , <span class="number">4</span> ) ;  <span class="comment">//删除第四个元素或第一到第五个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*----------------------其他函数-----------------------------*/</span></span><br><span class="line">s.find ( <span class="string">" cat "</span> ) ;  <span class="comment">//超找第一个出现的字符串”cat“，返回其下标值，查不到返回 4294967295，也可查找字符；</span></span><br><span class="line">s.append(args); <span class="comment">//将args接到s的后面</span></span><br><span class="line">s.compare ( <span class="string">" good "</span> ) ;  <span class="comment">//s与”good“比较相等返回0，比"good"大返回1，小则返回-1；</span></span><br><span class="line">reverse ( s.begin(), s.end () );  <span class="comment">//反向排序函数，即字符串反转函数</span></span><br></pre></td></tr></table></figure><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p>功能：动态数组,<strong>可随机存取</strong></p><p>底层实现 ：<br>首先开辟一定大小的数组 随着元素的增加，如果空间不够之后，以原空间大小的2倍重新开辟一块空间， 将就空间的元素挪到新空间上 在继续添加元素，一直遵循每次扩容大小是原空间大小的2倍。</p><p>相关用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//【1】初始化</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;        <span class="comment">//声明一个int型向量</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(<span class="number">10</span>);    <span class="comment">//声明一个初始大小为10的int向量</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(<span class="number">10</span>, <span class="number">1</span>); <span class="comment">//声明一个初始大小为10且值都是1的向量</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec1(vec);  <span class="comment">//调用拷贝构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp(vec.begin(), vec.begin() + <span class="number">3</span>);  <span class="comment">//用向量vec的第0个到第2个值初始化tmp</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;   </span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(<span class="built_in">array</span>, <span class="built_in">array</span> + <span class="number">5</span>);      <span class="comment">//将arr数组的元素用于初始化vec向量</span></span><br><span class="line"><span class="comment">//！！！！易错！！！！末尾指针都是指结束元素的下一个元素和vec.end()指针统一</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(&amp;arr[<span class="number">1</span>], &amp;arr[<span class="number">4</span>]); <span class="comment">//将arr[1]~arr[4]范围内的元素作为vec的初始值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//【2】大小操作</span></span><br><span class="line">vec.empty()    <span class="comment">//判断是否为空</span></span><br><span class="line">vec.size()     <span class="comment">//输出实际大小</span></span><br><span class="line">vec.max_size()  <span class="comment">//输出最大容量</span></span><br><span class="line">vec.resize()    <span class="comment">//重新定义大小,保留适当的容量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//【3】插入元素</span></span><br><span class="line">vec.push_back();            <span class="comment">//末尾添加元素</span></span><br><span class="line">vec.insert(vec.begin()+i,a); <span class="comment">//任意位置插入元素 在第i+1个元素前面插入a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//【4】删除元素</span></span><br><span class="line">vec.pop_back();     <span class="comment">//末尾删除元素 </span></span><br><span class="line">vec.clear();     <span class="comment">//清空向量元素</span></span><br><span class="line">vec.erase (vec.begin()+<span class="number">5</span>);                 <span class="comment">// erase the 6th element</span></span><br><span class="line">vec.erase (vec.begin(),vec.begin()+<span class="number">3</span>); <span class="comment">// erase the first 3 elements:</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">//【7】迭代器</span></span><br><span class="line">vec.begin();<span class="comment">//起始指针：</span></span><br><span class="line">vec.end(); <span class="comment">//指向最后一个元素的下一个位置</span></span><br><span class="line"></span><br><span class="line">vec.cbegin(); <span class="comment">//不能通过这个指针来修改所指的内容，但可以通过其他方式修改的。</span></span><br><span class="line">vec.cend();<span class="comment">//指向常量的末尾指针</span></span><br><span class="line">vec.rbegin()<span class="comment">//反向迭代器头</span></span><br><span class="line">vec.rend()<span class="comment">//反向迭代器尾</span></span><br><span class="line">vec.crbegin()</span><br><span class="line">vec.crend()</span><br><span class="line"></span><br><span class="line"><span class="comment">//【8】元素访问</span></span><br><span class="line">vec[<span class="number">1</span>]; <span class="comment">//下标访问，并不会检查是否越界</span></span><br><span class="line">vec.at(<span class="number">1</span>); <span class="comment">//at会检查是否越界，会抛出out of range异常</span></span><br><span class="line">vec.front();        <span class="comment">//访问第一个元素 </span></span><br><span class="line">vec.back();         <span class="comment">//访问最后一个元素</span></span><br><span class="line"></span><br><span class="line">vec.swap(vec2);  <span class="comment">//交换两个向量的元素</span></span><br><span class="line">swap(vec,vec2);</span><br></pre></td></tr></table></figure><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>实际上,list容器就是一个双向链表,可以高效地进行插入删除元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; first;                                <span class="comment">// empty list of ints</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; second (<span class="number">4</span>,<span class="number">100</span>);                       <span class="comment">// four ints with value 100</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; third (second.begin(),second.end());  <span class="comment">// iterating through second</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; fourth (third);                       <span class="comment">// a copy of third</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入元素</span></span><br><span class="line">a.insert(a.begin(),<span class="number">100</span>);  <span class="comment">//在a的开始位置（即头部）插入100</span></span><br><span class="line">a.insert(a.begin(),<span class="number">2</span>, <span class="number">100</span>);   <span class="comment">//在a的开始位置插入2个100</span></span><br><span class="line">a.insert(a.begin(),b.begin(), b.end());<span class="comment">//在a的开始位置插入b从开始到结束的所有位置的元素</span></span><br><span class="line"><span class="built_in">list</span>.push_back(x)  <span class="comment">//在链表尾插入元素</span></span><br><span class="line"><span class="built_in">list</span>.push_front(x) <span class="comment">//在链表头插入元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器</span></span><br><span class="line"><span class="built_in">list</span>.begin()    <span class="comment">//获得指向链表尾的指针</span></span><br><span class="line"><span class="built_in">list</span>.end()      <span class="comment">//获得指向链表尾（尾的下一个元素）的指针</span></span><br><span class="line"><span class="built_in">list</span>.rbegin()<span class="comment">//获得反向链表的头指针</span></span><br><span class="line"><span class="built_in">list</span>.rend()<span class="comment">//获得反向链表的尾（尾的下一个元素）指针</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//大小判断</span></span><br><span class="line"><span class="built_in">list</span>.empty()      <span class="comment">//判断是否为空，为空，返回true</span></span><br><span class="line"><span class="built_in">list</span>.size()  <span class="comment">//返回list的实际大小</span></span><br><span class="line"><span class="built_in">list</span>.max_size()   <span class="comment">//返回list的最大容量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获得元素</span></span><br><span class="line"><span class="built_in">list</span>.front()      <span class="comment">//获得头元素</span></span><br><span class="line"><span class="built_in">list</span>.back()       <span class="comment">//获得尾元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除操作</span></span><br><span class="line">a.erase(a.begin());  <span class="comment">//将a的第一个元素删除</span></span><br><span class="line">a.erase(a.begin(),a.end());  <span class="comment">//将a的从begin()到end()之间的元素删除。</span></span><br><span class="line"><span class="comment">//必须保证不为空</span></span><br><span class="line"><span class="built_in">list</span>.pop_back()   <span class="comment">//删除尾元素</span></span><br><span class="line"><span class="built_in">list</span>.pop_front()  <span class="comment">//删除头元素</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; a &#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">10</span>&#125;; a.remove(<span class="number">7</span>);   <span class="comment">//删除指定元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//其他操作</span></span><br><span class="line"><span class="built_in">list</span>.assign(n,value)  <span class="comment">//list将被改为n个值为value的元素</span></span><br><span class="line"><span class="built_in">list</span>.resize(x)   <span class="comment">//将链表改为长为x   超出的部分将被删除</span></span><br><span class="line">swap(a,b)   <span class="comment">//交换a,b链表的值</span></span><br><span class="line"><span class="built_in">list</span>.reverse()   <span class="comment">//将链表倒置</span></span><br><span class="line">a.merge(b)   <span class="comment">//将链表b添加到链表a的后面</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//补充以下迭代器的使用</span></span><br><span class="line"><span class="comment">//以下是四种迭代器的遍历操作（如果使用C11标准，可以直接使用auto）</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator cur1=li.begin();</span><br><span class="line">    <span class="keyword">for</span>(;cur1!=li.end();cur1++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;*cur1&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::const_iterator cur2=li.cbegin();</span><br><span class="line">    <span class="keyword">for</span>(;cur2!=li.cend();cur2++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;*cur2&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C11标准</span></span><br><span class="line">    <span class="keyword">auto</span> cur=li.begin();</span><br><span class="line">    <span class="keyword">for</span>(;cur!=li.end();cur++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;*cur&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><p>栈 （后进先出）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; sta;</span><br><span class="line"><span class="comment">//大小操作</span></span><br><span class="line">sta.empty()</span><br><span class="line">sta.size()</span><br><span class="line"></span><br><span class="line">sta.push(x)  <span class="comment">//将x加入到栈顶</span></span><br><span class="line">sta.pop() <span class="comment">//将栈顶元素弹出</span></span><br><span class="line">sta.top() <span class="comment">//返回栈顶元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//C11</span></span><br><span class="line">sta.swap(sta1) <span class="comment">//交换栈sta和sta1中的元素</span></span><br><span class="line">sta.emplace(x) <span class="comment">//将x放入到栈顶</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//栈的清空</span></span><br><span class="line"><span class="keyword">while</span>(!sta.empty()) sta.pop();</span><br></pre></td></tr></table></figure><h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><p>队列 （先进先出）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">que.size()   <span class="comment">//返回队列中元素的个数</span></span><br><span class="line">que.empty()  <span class="comment">//如果为空，返回true</span></span><br><span class="line"></span><br><span class="line">que.front()  <span class="comment">//返回第一个元素（即队首元素）</span></span><br><span class="line">que.back()   <span class="comment">//返回队尾元素</span></span><br><span class="line"></span><br><span class="line">que.pop()    <span class="comment">//删除第一个元素</span></span><br><span class="line">que.push(x)  <span class="comment">//在队尾加入一个元素</span></span><br><span class="line"></span><br><span class="line">que.swap(que1) <span class="comment">//交换que和que1的元素</span></span><br><span class="line">que.emplace(x)  <span class="comment">//向队首加入元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//queue不提供清空操作，一般手动实现</span></span><br><span class="line"><span class="keyword">while</span>(!que.empty()) que.pop();</span><br></pre></td></tr></table></figure><h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><p>优先队列 (STL中的堆)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  模板原型：</span></span><br><span class="line"><span class="comment">*  priority_queue&lt;Type,Container,Functional&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; que;     <span class="comment">//默认是降序的</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; que1;  <span class="comment">//升序队列</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt;&gt; que2;     <span class="comment">//降序队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于结构体的比较</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">int</span> score;</span><br><span class="line">student(<span class="built_in">string</span> na, <span class="keyword">int</span> sc):name(na), score(sc) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> student&amp; a, <span class="keyword">const</span> student&amp; b )</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.score &gt; b.score;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;student, <span class="built_in">vector</span>&lt;student&gt; , cmp&gt; que;   <span class="comment">//根据成绩从大到小排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//具体操作</span></span><br><span class="line">que.empty();</span><br><span class="line">que.size();</span><br><span class="line"></span><br><span class="line">que.push(x);<span class="comment">//加入元素到队尾</span></span><br><span class="line">que.pop();<span class="comment">//从队首删除元素</span></span><br><span class="line"></span><br><span class="line">que.top();     <span class="comment">//返回队首元素</span></span><br><span class="line"></span><br><span class="line">que.emplace(x)</span><br><span class="line">que.swap(que1)</span><br></pre></td></tr></table></figure><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map对于key是随机存取的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;  //使用pair与make_pair要包含头文件#include &lt;utility&gt;</span></span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; ma;</span><br><span class="line"><span class="comment">//必会操作</span></span><br><span class="line">ma.begin();         <span class="comment">//返回指向头部的迭代器</span></span><br><span class="line">ma.end();           <span class="comment">//返回指向末尾的迭代器</span></span><br><span class="line">ma[i] = A;      <span class="comment">//插入 A</span></span><br><span class="line">mp.insert(make_pair(i,A));  <span class="comment">//插入 A</span></span><br><span class="line">ma.erase(i);    <span class="comment">//删除 i</span></span><br><span class="line">ma.clear();     <span class="comment">//删除所有元素</span></span><br><span class="line">ma.find(i);     <span class="comment">//查找 i (若未找到返回 end())</span></span><br><span class="line">ma.empty();     <span class="comment">//如果map为空则返回true</span></span><br><span class="line">ma.size();      <span class="comment">//返回map中元素的个数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ma.swap();    <span class="comment">//交换两个map</span></span><br><span class="line">ma.lower_bound();   <span class="comment">//返回 &gt;=给定元素的第一个位置</span></span><br><span class="line">ma.upper_bound();   <span class="comment">//返回 &gt;给定元素的第一个位置</span></span><br><span class="line">ma.max_size();      <span class="comment">//返回可以容纳的最大元素个数</span></span><br></pre></td></tr></table></figure><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>和map操作几乎一样，只是插入的为key即为value</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; se;</span><br><span class="line"><span class="comment">//必会操作</span></span><br><span class="line">se.begin();         <span class="comment">//返回指向头部的迭代器</span></span><br><span class="line">se.end();           <span class="comment">//返回指向末尾的迭代器</span></span><br><span class="line">se.insert(A);      <span class="comment">//插入 A</span></span><br><span class="line">se.erase(A);    <span class="comment">//删除 A</span></span><br><span class="line">se.clear();     <span class="comment">//删除所有元素</span></span><br><span class="line">se.find(i);     <span class="comment">//查找 i (若未找到返回 end())</span></span><br><span class="line">se.empty();</span><br><span class="line">se.size();</span><br><span class="line">    </span><br><span class="line">se.swap();    <span class="comment">//交换两个map</span></span><br><span class="line">se.lower_bound();   <span class="comment">//返回 &gt;=给定元素的第一个位置</span></span><br><span class="line">se.upper_bound();   <span class="comment">//返回 &gt;给定元素的第一个位置</span></span><br><span class="line">se.max_size();      <span class="comment">//返回可以容纳的最大元素个数</span></span><br></pre></td></tr></table></figure><p>还有 hash_table 没有写，hash_table 是兼顾各项，在元素不 “冲突” 的情况下，上面四个可以，而且速度很快。</p><p>unordered_set、unordered_multiset、unordered_map、unordered_multimap 都是以 hash_table 作为底层实现的。所以效率要比 RB_tree 作为底层实现的 set、map、multiset、multimap 高，但是 hash_table 的缺点是没有进行排序。</p><p>stack、queue 都是以 deque（双端队列）作为底层实现的，效率问题直接看deque就行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;string&quot;&gt;&lt;a href=&quot;#string&quot; class=&quot;headerlink&quot; title=&quot;string&quot;&gt;&lt;/a&gt;string&lt;/h2&gt;&lt;p&gt;字符串类&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td 
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yuemingyang7010.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="STL总结" scheme="http://yuemingyang7010.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/STL%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="STL" scheme="http://yuemingyang7010.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL中的索引</title>
    <link href="http://yuemingyang7010.github.io/2019/07/24/MySQL%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95/"/>
    <id>http://yuemingyang7010.github.io/2019/07/24/MySQL中的索引/</id>
    <published>2019-07-24T08:28:27.000Z</published>
    <updated>2019-09-01T11:37:06.844Z</updated>
    
    <content type="html"><![CDATA[<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h2><p>排好序的快速查询的数据结构，常常类比为字典目录。</p><p>优点：<strong>大大加快数据的检索速度</strong>；</p><p>缺点：<strong>创建索引和维护索引要花费一定的时间</strong>。</p><h2 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h2><p>主键索引（PRIMAY KEY）</p><p>普通索引（INDEX）</p><p>唯一索引（UNIQUE）</p><p>联合索引</p><p>InnoDB和MyISAM会自动为<strong>主键</strong>或者声明为<strong>UNIQUE</strong>的列去自动建立B+树索引。</p><h3 id="主键索引（最常用，最好用自增ID）"><a href="#主键索引（最常用，最好用自增ID）" class="headerlink" title="主键索引（最常用，最好用自增ID）"></a>主键索引（最常用，最好用自增ID）</h3><p>为表设置了主键，数据库将自动创建主键索引</p><p>（一个表只能有一个主键，主键的值不可重复，也不可为空（NULL）。）</p><h3 id="普通索引（一表可建多个，尽量避免NULL）"><a href="#普通索引（一表可建多个，尽量避免NULL）" class="headerlink" title="普通索引（一表可建多个，尽量避免NULL）"></a>普通索引（一表可建多个，尽量避免NULL）</h3><p>注意：可以有NULL，但是<strong>尽量避免NULL</strong>：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化。因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值。</p><h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>与普通索引类似，不同的是，Mysql的索引列值必须唯一，但普通索引值可重复。</p><h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>联合索引即联合若干列组成索引，这种情况下和普通索引类似，可不唯一，可以有NULL，如果加上unique，可以使其为联合唯一索引，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t_aa <span class="keyword">add</span> <span class="keyword">unique</span> <span class="keyword">index</span>(aa,bb);</span><br></pre></td></tr></table></figure><h2 id="MySQL中创建和删除索引的语句"><a href="#MySQL中创建和删除索引的语句" class="headerlink" title="MySQL中创建和删除索引的语句"></a>MySQL中创建和删除索引的语句</h2><p>我们可以在创建表的时候指定需要建立索引的单个列或者建立联合索引的多个列：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> TALBE 表名 (</span><br><span class="line">    各种列的信息 ··· , </span><br><span class="line">    [<span class="keyword">KEY</span>|<span class="keyword">INDEX</span>] 索引名 (需要被索引的单个列或多个列)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>其中的KEY和INDEX是同义词，任意选用一个就可以。我们也可以在修改表结构的时候添加索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> [<span class="keyword">INDEX</span>|<span class="keyword">KEY</span>] 索引名 (需要被索引的单个列或多个列);</span><br></pre></td></tr></table></figure><p>也可以在修改表结构的时候删除索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> [<span class="keyword">INDEX</span>|<span class="keyword">KEY</span>] 索引名;</span><br></pre></td></tr></table></figure><p>比方说我们想在创建index_demo表的时候就为c2和c3列添加一个联合索引，可以这么写建表语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> index_demo(</span><br><span class="line">    c1 <span class="built_in">INT</span>,</span><br><span class="line">    c2 <span class="built_in">INT</span>,</span><br><span class="line">    c3 <span class="built_in">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(c1),</span><br><span class="line">    <span class="keyword">INDEX</span> idx_c2_c3 (c2, c3)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>在这个建表语句中我们创建的索引名是idx_c2_c3，这个名称可以随便起，不过我们还是建议以idx_为前缀，后边跟着需要建立索引的列名，多个列名之间用下划线_分隔开。</p><p>如果我们想删除这个索引，可以这么写：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> index_demo <span class="keyword">DROP</span> <span class="keyword">INDEX</span> idx_c2_c3;</span><br></pre></td></tr></table></figure><p>注意：主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。</p><h2 id="各种索引的区别与联系"><a href="#各种索引的区别与联系" class="headerlink" title="各种索引的区别与联系"></a>各种索引的区别与联系</h2><div class="table-container"><table><thead><tr><th>索引类型</th><th>是否要求值唯一</th><th>是否要求值不能有NULL</th></tr></thead><tbody><tr><td>主键索引</td><td>是</td><td>是</td></tr><tr><td>唯一索引</td><td>是</td><td>否</td></tr><tr><td>普通索引</td><td>否</td><td>否</td></tr></tbody></table></div><h3 id="主键索引与普通索引的区别"><a href="#主键索引与普通索引的区别" class="headerlink" title="主键索引与普通索引的区别"></a>主键索引与普通索引的区别</h3><p>如果语句是 select <em> from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；<br>如果语句是 select </em> from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。<br>也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。</p><p>总结：（1）主键索引查询一次B+树，普通索引有回表操作；（2）主键索引要求列值唯一，且无NULL，普通索引没这两个限制。</p><h3 id="主键索引与唯一索引的区别"><a href="#主键索引与唯一索引的区别" class="headerlink" title="主键索引与唯一索引的区别"></a>主键索引与唯一索引的区别</h3><p>（1）主键索引查询一次B+树，唯一索引有回表操作；（2）主键索引要求列值唯一，且无NULL，唯一索引列值唯一，但是<strong>可以有NULL</strong>。</p><h1 id="索引底层数据结构"><a href="#索引底层数据结构" class="headerlink" title="索引底层数据结构"></a>索引底层数据结构</h1><p><a href="https://www.cnblogs.com/xiaoxi/p/6894610.html?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener">本文主要参考博客</a></p><p><a href="https://blog.csdn.net/q503267755/article/details/50791794" target="_blank" rel="noopener">对于磁道、扇区和磁盘块的理解1</a></p><p><a href="https://www.cnblogs.com/yi-mu-xi/p/10939612.html" target="_blank" rel="noopener">对于磁道、扇区和磁盘块的理解2</a></p><h2 id="磁盘I-O原理"><a href="#磁盘I-O原理" class="headerlink" title="磁盘I/O原理"></a>磁盘I/O原理</h2><h3 id="扇区与磁盘块-block-的区别"><a href="#扇区与磁盘块-block-的区别" class="headerlink" title="扇区与磁盘块(block)的区别"></a>扇区与磁盘块(block)的区别</h3><p><strong>磁盘在物理层面上分为磁道，扇区</strong>（通常大小为512K），磁盘驱动器操作磁盘数据，硬盘的最小存储单位是扇区，硬盘本身没有block的概念。</p><p><strong>文件系统：</strong></p><p>文件系统若按照一个扇区一个扇区读数据速度太慢，所以有了<strong>block（磁盘块）</strong>的概念，是一个块一个块读取的，block才是文件存取的最小单位。通常一个block是4KB，该文件系统中1个块是由连续的8个扇区组成。一个块大小=一个扇区大小*2的n次方。N是可以修改的。</p><p><strong>总结：扇区是对硬盘而言，块是对文件系统而言。</strong></p><p>索引是帮助MySQL高效获取数据的排好序的数据结构</p><h2 id="B树（平衡多路查找树）"><a href="#B树（平衡多路查找树）" class="headerlink" title="B树（平衡多路查找树）"></a><strong>B树（平衡多路查找树）</strong></h2><p>B-Tree是为磁盘等外存储设备设计的一种平衡查找树。因此在讲B-Tree之前先了解下磁盘的相关知识。</p><p>系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。</p><p><strong>InnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB存储引擎中默认每个页的大小为16KB，可通过参数innodb_page_size将页的大小设置为4K、8K、16K，在MySQL中可通过如下命令查看页的大小（可以将其设置为4K）：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_page_size&apos;;</span><br></pre></td></tr></table></figure><p>而系统一个磁盘块的存储空间往往没有这么大，因此InnoDB每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小16KB。InnoDB在把磁盘数据读入到内存时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。</p><p>B-Tree结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述B-Tree，首先定义一条记录为一个二元组[key, data] ，key为记录的键值，对应表中的主键值，data为一行记录中除主键外的数据。对于不同的记录，key值互不相同。</p><p><strong>一棵m阶的B-Tree有如下特性：</strong> </p><ol><li>每个节点最多有m个孩子。 </li><li>除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子。 </li><li>若根节点不是叶子节点，则至少有2个孩子。</li><li>所有叶子节点都在同一层，且不包含其它关键字信息。 </li><li>每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn） </li><li>关键字的个数n满足：ceil(m/2)-1 &lt;= n &lt;= m-1 </li><li>ki(i=1,…n)为关键字，且关键字升序排序。 </li><li>Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)。</li></ol><p>B-Tree中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个3阶的B-Tree：</p><img src="/2019/07/24/MySQL中的索引/01.png"><p>两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。</p><p>模拟查找关键字29的过程：</p><p>根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】<br>比较关键字29在区间（17,35），找到磁盘块1的指针P2。<br>根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】<br>比较关键字29在区间（26,30），找到磁盘块3的指针P2。<br>根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】<br>在磁盘块8中的关键字列表中找到关键字29。</p><p>分析上面过程，发现需要<strong>3次磁盘I/O操作，和3次内存查找操作。</strong>由于内存中的关键字是一个有序表结构，<strong>可以利用二分法查找提高效率</strong>。而<strong><u>3次磁盘I/O操作是影响整个B-Tree查找效率的决定因素</u></strong>。B-Tree相对于AVLTree缩减了节点个数，使每次磁盘I/O取到内存的数据都发挥了作用，从而提高了查询效率。</p><h2 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+Tree**"></a>B+Tree**</h2><p>B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。</p><p>从上一节中的B-Tree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。<strong>在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息</strong>，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。</p><p><strong>B+Tree相对于B-Tree有几点不同：</strong></p><ol><li>非叶子节点只存储键值信息。</li><li>所有叶子节点之间都有一个链指针。</li><li>数据记录都存放在叶子节点中。</li></ol><p>将上一节中的B-Tree优化，由于B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示：</p><img src="/2019/07/24/MySQL中的索引/02.png"><p>通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对B+Tree进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。</p><h2 id="为什么使用B-Tree（B-Tree）"><a href="#为什么使用B-Tree（B-Tree）" class="headerlink" title="为什么使用B-Tree（B+Tree）"></a>为什么使用B-Tree（B+Tree）</h2><p>一般来说，索引本身也很大，<strong>不可能全部存储在内存中</strong>，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是要<strong>尽量减少查找过程中磁盘I/O的存取次数</strong>。</p><p><strong>与红黑树的比较：</strong></p><p>红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因：</p><p>（一）更少的查找次数</p><p>平衡树查找操作的时间复杂度和树高 h 相关，O(h)=O(log<sub>d</sub>N)，其中 d 为每个节点的出度。</p><p>红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。</p><p>（二）利用磁盘预读特性</p><p>为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。</p><p>操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。</p><h2 id="B-树索引和hash索引的区别"><a href="#B-树索引和hash索引的区别" class="headerlink" title="B+树索引和hash索引的区别"></a><strong>B+树索引和hash索引的区别</strong></h2><p>hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的<strong>查询效率要远高于 B-Tree 索引。</strong></p><p>既然 Hash 索引的效率要比 B-Tree 高很多，为什么大家不都用 Hash 索引而还要使用 B-Tree 索引呢？ Hash 索引本身由于其特殊性也带来了很多限制和弊端，主要有以下这些。</p><p><strong>（1）Hash 索引仅仅能满足”=”,”IN”和”&lt;=&gt;”查询，不能使用范围查询。</strong></p><p>由于 Hash 索引比较的是进行 Hash 运算之后的 Hash 值，所以它<strong>只能用于等值的过滤，不能用于基于范围的过滤</strong>，因为经过相应的 Hash 算法处理之后的 Hash 值的大小关系，并不能保证和Hash运算前完全一样。</p><p>（2）Hash 索引<strong>无法被用来避免数据的排序操作。</strong></p><p>由于 Hash 索引中存放的是经过 Hash 计算之后的 Hash 值，而且Hash值的大小关系并不一定和 Hash 运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算；</p><p>（3）Hash 索引不能利用部分索引键查询。</p><p>对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。</p><p><strong>（4）Hash 索引在任何时候都不能避免表扫描。</strong></p><p>前面已经知道，<strong>Hash 索引是将索引键通过 Hash 运算之后</strong>，将 Hash运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中，<strong>由于不同索引键存在相同 Hash 值**</strong>，所以即使取满足某个 Hash 键值的数据的记录条数，也无法从 Hash 索引中直接完成查询<strong>，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。</strong>当Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。</p><h2 id="磁盘存取原理"><a href="#磁盘存取原理" class="headerlink" title="磁盘存取原理"></a><strong>磁盘存取原理</strong></h2><p>​      上面说过，索引一般以文件形式存储在磁盘上，索引检索需要磁盘I/O操作。与主存不同，磁盘I/O存在机械运动耗费，因此磁盘I/O的时间消耗是巨大的。</p><p>​      下图是磁盘的整体结构示意图。</p><img src="/2019/07/24/MySQL中的索引/03.png"><p>一个磁盘由大小相同且同轴的圆形盘片组成，磁盘可以转动（各个磁盘必须同步转动）。在磁盘的一侧有磁头支架，磁头支架固定了一组磁头，每个磁头负责存取一个磁盘的内容。磁头不能转动，但是可以沿磁盘半径方向运动（实际是斜切向运动），每个磁头同一时刻也必须是同轴的，即从正上方向下看，所有磁头任何时候都是重叠的（不过目前已经有多磁头独立技术，可不受此限制）。</p><p>​      下图是磁盘结构的示意图。</p><img src="/2019/07/24/MySQL中的索引/04.png"><p>盘片被划分成一系列同心环，圆心是盘片中心，每个同心环叫做一个磁道，所有半径相同的磁道组成一个柱面。磁道被沿半径线划分成一个个小的段，每个段叫做一个扇区，每个扇区是磁盘的最小存储单元。为了简单起见，我们下面假设磁盘只有一个盘片和一个磁头。</p><p>​      当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间。</p><h2 id="局部性原理与磁盘预读"><a href="#局部性原理与磁盘预读" class="headerlink" title="局部性原理与磁盘预读"></a><strong>局部性原理与磁盘预读</strong></h2><p> 由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：</p><p>​      当一个数据被用到时，其附近的数据也通常会马上被使用。</p><h2 id="B-Tree索引的性能分析"><a href="#B-Tree索引的性能分析" class="headerlink" title="B-/+Tree索引的性能分析"></a><strong>B-/+Tree索引的性能分析</strong></h2><p>​      到这里终于可以分析B-/+Tree索引的性能了。</p><p>​    数据库系统的设计者巧<strong>妙利用了磁盘预读原理</strong>，<strong>将一个节点的大小设为等于一个页</strong>，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：</p><p>​     每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p><p>​     B-Tree中一次检索最多需要h-1次I/O（<strong>根节点常驻内存</strong>），渐进复杂度为O(h)=O(logdN)O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。</p><p>​     综上所述，用B-Tree作为索引结构效率是非常高的。</p><h1 id="MySQL索引实现"><a href="#MySQL索引实现" class="headerlink" title="MySQL索引实现"></a><strong>MySQL索引实现</strong></h1><p>在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的，下面主要讨论MyISAM和InnoDB两个存储引擎的索引实现方式。</p><h2 id="MyISAM索引实现"><a href="#MyISAM索引实现" class="headerlink" title="MyISAM索引实现"></a><strong>MyISAM索引实现</strong></h2><p>MyISAM引擎使用B+Tree作为索引结构，<strong>叶节点的data域存放的是数据记录的地址</strong>。下图是MyISAM索引的原理图：</p><img src="/2019/07/24/MySQL中的索引/07.png"><p>这里设表一共有三列，假设我们以Col1为主键，则上图是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。<strong>在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。</strong>如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：</p><img src="/2019/07/24/MySQL中的索引/08.png"><h2 id="InnoDB索引实现"><a href="#InnoDB索引实现" class="headerlink" title="InnoDB索引实现"></a><strong>InnoDB索引实现</strong></h2><p>​     虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。</p><p>​     第一个重大区别是<strong>InnoDB的数据文件本身就是索引文件。</strong>从上文知道，<strong>MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。</strong>而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的<strong>叶节点data域保存了完整的数据记录</strong>。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p><img src="/2019/07/24/MySQL中的索引/09.png"><p>​    上图是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p><p>​      <strong>第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。</strong>例如，下图为定义在Col3上的一个辅助索引：</p><img src="/2019/07/24/MySQL中的索引/10.png"><p>这里以英文字符的ASCII码作为比较准则。<strong><u>聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</u></strong></p><p>​     了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么<strong>不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。</strong>再例如，用<strong>非单调的字段</strong>作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在<strong>插入新记录时数据文件</strong>为了维持B+Tree的特性而<strong>频繁的分裂调整</strong>，十分低效，而<strong><u>使用自增字段作为主键则是一个很好的选择。</u></strong></p><p><strong><u>对于InnoDB而言，因为节点下有数据文件，因此节点的分裂将会比较慢。对于InnoDB的主键，尽量用整型，而且是递增的整型。如果是无规律的数据，将会产生页的分裂，影响速度。</u></strong></p><h2 id="InnoDB索引和MyISAM索引的区别："><a href="#InnoDB索引和MyISAM索引的区别：" class="headerlink" title="InnoDB索引和MyISAM索引的区别："></a><strong>InnoDB索引</strong>和<strong>MyISAM索引</strong>的区别：</h2><p><strong>一是主索引的区别，InnoDB的数据文件本身就是索引文件。而MyISAM的索引和数据是分开的。</strong></p><p><strong>二是辅助索引的区别：InnoDB的辅助索引data域存储相应记录主键的值而不是地址。而MyISAM的辅助索引和主索引没有多大区别。</strong></p><p><strong>InnoDB的主索引文件上，直接存放该行数据，称为聚簇索引。次索引指向对主键的引用。</strong></p><p><strong>Myisam中，主索引和次索引都指向物理行。</strong></p><p>补充：<strong>索引覆盖</strong></p><p>索引覆盖是指如果查询的列恰好是索引的一部分，那么查询只需要在索引文件上进行，不需要回行到磁盘再找数据（<strong>即不需要回表查找</strong>）。这种查询速度非常快，称为“索引覆盖”。</p><h2 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a><strong>聚簇索引与非聚簇索引</strong></h2><h3 id="1、聚簇索引"><a href="#1、聚簇索引" class="headerlink" title="1、聚簇索引"></a><strong>1、聚簇索引</strong></h3><p>​    所谓聚簇索引，就是指<strong><u>主索引</u>文件和数据文件为同一份文件，聚簇索引主要用在Innodb存储引擎中。</strong>在该索引实现方式中B+Tree的叶子节点上的data就是数据本身，key为主键，如果是一般索引的话，data便会指向对应的主索引(<strong>然后再进行一次索引</strong>)，如下图所示：</p><img src="/2019/07/24/MySQL中的索引/05.png"><p>  在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。<strong>做这个优化的目的是为了提高区间访问的性能</strong>，例如上图中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。</p><h3 id="2、非聚簇索引"><a href="#2、非聚簇索引" class="headerlink" title="2、非聚簇索引"></a><strong>2、非聚簇索引</strong></h3><p>​    非聚簇索引就是<strong>指B+Tree的叶子节点上的data，并不是数据本身，而是数据存放的地址。</strong>主索引和辅助索引没啥区别，只是主索引中的key一定得是唯一的。主要用在MyISAM存储引擎中，如下图：</p><img src="/2019/07/24/MySQL中的索引/06.png"><p><strong>非聚簇索引比聚簇索引多了一次读取数据的IO操作，所以查找性能上会差。</strong></p><h2 id="联合索引-1"><a href="#联合索引-1" class="headerlink" title="联合索引"></a>联合索引</h2><h3 id="联合索引的B-树结构"><a href="#联合索引的B-树结构" class="headerlink" title="联合索引的B+树结构"></a>联合索引的B+树结构</h3><p>我们用（name，age）这个联合索引来分析</p><img src="/2019/07/24/MySQL中的索引/11.jpg"><p>可以看到，索引项是按照索引定义里面出现的字段顺序排序的。</p><p>当你的逻辑需求是查到所有名字是“张三”的人时，可以快速定位到 ID4，然后向后遍历得到所有需要的结果。</p><p>只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。</p><p>基于上面对最左前缀索引的说明，我们来讨论一个问题：在建立联合索引的时候，如何安排索引内的字段顺序。</p><p>使用越频繁的字段通常可以放在最左侧。</p><h3 id="多个单列索引和联合索引的区别"><a href="#多个单列索引和联合索引的区别" class="headerlink" title="多个单列索引和联合索引的区别"></a>多个单列索引和联合索引的区别</h3><p>多个单列索引：</p><p>多个单列索引在多条件查询时只会生效第一个索引！所以多条件联合查询时最好建联合索引！</p><div class="table-container"><table><thead><tr><th>where语句查询情况</th><th>实际用的索引</th></tr></thead><tbody><tr><td>a and b and c</td><td>a</td></tr><tr><td>a or b or c</td><td>a,b,c(查询结果有去重)</td></tr></tbody></table></div><p>联合索引本质：</p><p>当创建(a,b,c)联合索引时，<strong>相当于创建了(a)单列索引，(a,b)联合索引以及(a,b,c)联合索引</strong>想要索引生效的话,只能使用 a和a,b和a,b,c三种组合；当然，我们上面测试过，a,c组合也可以，但实际上只用到了a的索引，c并没有用到！生效情况如下表：</p><div class="table-container"><table><thead><tr><th>where语句查询情况</th><th>索引</th><th>实际用的索引</th></tr></thead><tbody><tr><td>a</td><td>联合索引</td><td>a</td></tr><tr><td>b</td><td>NULL</td><td>×</td></tr><tr><td>c</td><td>NULL</td><td>×</td></tr><tr><td>a and b</td><td>联合索引</td><td>(a,b)</td></tr><tr><td>a and c</td><td>联合索引</td><td>a</td></tr><tr><td>b and c</td><td>NULL</td><td>×</td></tr><tr><td>a and b and c</td><td>联合索引</td><td>(a,b,c)</td></tr></tbody></table></div><p><strong>总结：</strong>索引的最左原则（左前缀原则），如（c1,c2,c3,c4….cN）的联合索引，where 条件按照索引建立的字段顺序来使用（<strong>不代表and条件必须按照顺序来写</strong>），<strong>如果中间某列没有条件，或使用like会导致后面的列不能使用索引。</strong></p><p>（如面试题：现在有a b 作为联合索引，有一条sql语句 where b &gt; 0 and a = 7 和 where a&gt;0 and b = 7分别会用到索引吗？  会）</p><p><strong>最左前缀：</strong>顾名思义，就是最左优先，上例中我们创建了lname_fname_age多列索引,相当于创建了(lname)单列索引，(lname,fname)组合索引以及(lname,fname,age)组合索引。</p><p><a href="https://blog.csdn.net/mrxiky/article/details/81775194" target="_blank" rel="noopener">参考博客:多个单列索引和联合索引的区别</a></p><h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><h3 id="1-独立的列"><a href="#1-独立的列" class="headerlink" title="1. 独立的列"></a>1. 独立的列</h3><p>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。</p><p>例如下面的查询不能使用 actor_id 列的索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> sakila.actor <span class="keyword">WHERE</span> actor_id + <span class="number">1</span> = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h3 id="2-多列索引"><a href="#2-多列索引" class="headerlink" title="2. 多列索引"></a>2. 多列索引</h3><p>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> film_id, actor_ <span class="keyword">id</span> <span class="keyword">FROM</span> sakila.film_actor</span><br><span class="line"><span class="keyword">WHERE</span> actor_id = <span class="number">1</span> <span class="keyword">AND</span> film_id = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="3-索引列的顺序"><a href="#3-索引列的顺序" class="headerlink" title="3. 索引列的顺序"></a>3. 索引列的顺序</h3><p>让选择性最强的索引列放在前面。</p><p>索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。</p><p>例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> staff_id)/<span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> staff_id_selectivity,</span><br><span class="line"><span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> customer_id)/<span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> customer_id_selectivity,</span><br><span class="line"><span class="keyword">COUNT</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> payment;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   staff_id_selectivity: 0.0001</span><br><span class="line">customer_id_selectivity: 0.0373</span><br><span class="line">               COUNT(*): 16049</span><br></pre></td></tr></table></figure><h3 id="4-前缀索引"><a href="#4-前缀索引" class="headerlink" title="4. 前缀索引"></a>4. 前缀索引</h3><p>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。</p><p>前缀长度的选取需要根据索引选择性来确定。</p><h3 id="5-覆盖索引"><a href="#5-覆盖索引" class="headerlink" title="5. 覆盖索引"></a>5. 覆盖索引</h3><p>索引包含所有需要查询的字段的值。</p><p>具有以下优点：</p><ul><li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li><li>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</li><li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</li></ul><h2 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h2><ul><li>大大减少了服务器需要扫描的数据行数。</li><li>帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。</li><li>将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。</li></ul><h2 id="索引的使用条件"><a href="#索引的使用条件" class="headerlink" title="索引的使用条件"></a>索引的使用条件</h2><ul><li>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；</li><li>对于中到大型的表，索引就非常有效；</li><li>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;索引&quot;&gt;&lt;a href=&quot;#索引&quot; class=&quot;headerlink&quot; title=&quot;索引&quot;&gt;&lt;/a&gt;索引&lt;/h1&gt;&lt;h2 id=&quot;什么是索引？&quot;&gt;&lt;a href=&quot;#什么是索引？&quot; class=&quot;headerlink&quot; title=&quot;什么是索引？&quot;&gt;&lt;/a&gt;什
      
    
    </summary>
    
    
      <category term="数据库" scheme="http://yuemingyang7010.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="http://yuemingyang7010.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
    
    
      <category term="数据库" scheme="http://yuemingyang7010.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Linux IO模式及select、poll、epoll</title>
    <link href="http://yuemingyang7010.github.io/2019/07/21/Linux-IO%E6%A8%A1%E5%BC%8F%E5%8F%8Aselect%E3%80%81poll%E3%80%81epoll/"/>
    <id>http://yuemingyang7010.github.io/2019/07/21/Linux-IO模式及select、poll、epoll/</id>
    <published>2019-07-21T12:33:33.000Z</published>
    <updated>2019-08-05T15:42:06.884Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="noopener">转载出处</a></p><p>同步IO和异步IO，阻塞IO和非阻塞IO分别是什么，到底有什么区别？不同的人在不同的上下文下给出的答案是不同的。所以先限定一下本文的上下文。</p><p><strong>本文讨论的背景是Linux环境下的network IO。</strong></p><h1 id="一-概念说明"><a href="#一-概念说明" class="headerlink" title="一 概念说明"></a>一 概念说明</h1><p>在进行解释之前，首先要说明几个概念：</p><ul><li>用户空间和内核空间</li><li>进程切换</li><li>进程的阻塞</li><li>文件描述符</li><li>缓存 I/O</li></ul><h2 id="用户空间与内核空间"><a href="#用户空间与内核空间" class="headerlink" title="用户空间与内核空间"></a>用户空间与内核空间</h2><p>现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。<strong>操作系统的核心是内核，独立于普通的应用程序</strong>，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。</p><h2 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h2><p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。</p><p>从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：</p><ol><li>保存处理机上下文，包括程序计数器和其他寄存器。</li><li>更新PCB信息。</li><li>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。</li><li>选择另一个进程执行，并更新其PCB。</li><li>更新内存管理的数据结构。</li><li>恢复处理机上下文。</li></ol><p>注：总而言之就是很耗资源，具体的可以参考这篇文章：进程切换</p><h2 id="进程的阻塞"><a href="#进程的阻塞" class="headerlink" title="进程的阻塞"></a>进程的阻塞</h2><p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。<code>当进程进入阻塞状态，是不占用CPU资源的</code>。</p><h2 id="文件描述符fd"><a href="#文件描述符fd" class="headerlink" title="文件描述符fd"></a>文件描述符fd</h2><p>文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。</p><p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。<strong>当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。</strong>在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p><h2 id="缓存-I-O"><a href="#缓存-I-O" class="headerlink" title="缓存 I/O"></a>缓存 I/O</h2><p>缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p><p><strong>缓存 I/O 的缺点：</strong><br>数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</p><h1 id="二-IO模式"><a href="#二-IO模式" class="headerlink" title="二 IO模式"></a>二 IO模式</h1><p>刚才说了，对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段：</p><ol><li><strong><u>等待数据准备 (Waiting for the data to be ready)</u></strong></li><li><strong><u>将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</u></strong></li></ol><p>正式因为这两个阶段，linux系统产生了下面五种网络模式的方案。</p><ul><li>阻塞 I/O（blocking IO）</li><li>非阻塞 I/O（nonblocking IO）</li><li>I/O 多路复用（ IO multiplexing）</li><li>信号驱动 I/O（ signal driven IO）</li><li>异步 I/O（asynchronous IO）</li></ul><p>注：由于signal driven IO在实际中并不常用，所以我这只提及剩下的四种IO Model。</p><h2 id="阻塞-I-O（blocking-IO）"><a href="#阻塞-I-O（blocking-IO）" class="headerlink" title="阻塞 I/O（blocking IO）"></a>阻塞 I/O（blocking IO）</h2><p>在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：</p><img src="/2019/07/21/Linux-IO模式及select、poll、epoll/01.png"><p>当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 所以，blocking IO的特点就是在IO执行的两个阶段都被block了。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="非阻塞-I-O（nonblocking-IO）"><a href="#非阻塞-I-O（nonblocking-IO）" class="headerlink" title="非阻塞 I/O（nonblocking IO）"></a>非阻塞 I/O（nonblocking IO）</h2><p>linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：</p><img src="/2019/07/21/Linux-IO模式及select、poll、epoll/02.png"><p>当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 所以，nonblocking IO的特点是用户进程需要**不断的主动询问**kernel数据好了没有。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="I-O-多路复用（-IO-multiplexing）"><a href="#I-O-多路复用（-IO-multiplexing）" class="headerlink" title="I/O 多路复用（ IO multiplexing）"></a>I/O 多路复用（ IO multiplexing）</h2><p>IO multiplexing就是我们说的select，poll，epoll，有些地方也称这种IO方式为event driven IO。select/epoll的好处就在于<strong>单个process就可以同时处理多个网络连接的IO</strong>。它的基本原理就是select，poll，epoll这个function会<strong>不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。</strong></p><img src="/2019/07/21/Linux-IO模式及select、poll、epoll/03.png"><p><code>当用户进程调用了select，那么整个进程会被block</code>，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，<strong>select就会返回</strong>。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; 所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待</span><br><span class="line">&gt; 多个文件描述符，而这些文件描述符（套接字描述符）其中的任意</span><br><span class="line">&gt; 一个进入读就绪状态，select()函数就可以返回。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，<strong>用select的优势在于它可以同时处理多个connection。</strong></p><p>所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。<strong>select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。</strong>）</p><p>在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</p><h2 id="异步-I-O（asynchronous-IO）"><a href="#异步-I-O（asynchronous-IO）" class="headerlink" title="异步 I/O（asynchronous IO）"></a>异步 I/O（asynchronous IO）</h2><p>linux下的asynchronous IO其实用得很少。先看一下它的流程：</p><img src="/2019/07/21/Linux-IO模式及select、poll、epoll/04.png"><p>用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="blocking和non-blocking的区别"><a href="#blocking和non-blocking的区别" class="headerlink" title="blocking和non-blocking的区别"></a>blocking和non-blocking的区别</h3><p>调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。</p><h3 id="synchronous-IO和asynchronous-IO的区别"><a href="#synchronous-IO和asynchronous-IO的区别" class="headerlink" title="synchronous IO和asynchronous IO的区别"></a>synchronous IO和asynchronous IO的区别</h3><p>在说明synchronous IO和asynchronous IO的区别之前，需要先给出两者的定义。POSIX的定义是这样子的：<br>- A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;<br>- An asynchronous I/O operation does not cause the requesting process to be blocked;</p><p>两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。</p><p>有人会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。</p><p>而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。</p><p><strong>各个IO Model的比较如图所示：</strong></p><img src="/2019/07/21/Linux-IO模式及select、poll、epoll/05.png"><p>通过上面的图片，可以发现non-blocking IO和asynchronous IO的区别还是很明显的。在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。</p><h1 id="三-I-O-多路复用之select、poll、epoll详解"><a href="#三-I-O-多路复用之select、poll、epoll详解" class="headerlink" title="三 I/O 多路复用之select、poll、epoll详解"></a>三 I/O 多路复用之select、poll、epoll详解</h1><p>select，poll，epoll都是IO多路复用的机制。I/O多路复用就是通过一种机制，<strong>一个进程可以监视多个描述符，一旦某个描述符就绪</strong>（一般是读就绪或者写就绪），<strong>能够通知程序进行相应的读写操作。</strong>但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。（这里啰嗦下）</p><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span> <span class="params">(<span class="keyword">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述副就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以 通过遍历fdset，来找到就绪的描述符。</p><p><strong>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select的一 个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024</strong>，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但 是这样也会造成效率的降低。</p><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span> <span class="params">(struct pollfd *fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>不同与select使用三个位图来表示三个fdset的方式，poll使用一个 pollfd的指针实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="keyword">short</span> events; <span class="comment">/* requested events to watch */</span></span><br><span class="line">    <span class="keyword">short</span> revents; <span class="comment">/* returned events witnessed */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>pollfd结构包含了要监视的event和发生的event，不再使用select“参数-值”传递的方式。同时，pollfd并没有最大数量限制（但是数量过大后性能也是会下降）。 和select函数一样，poll返回后，需要轮询pollfd来获取就绪的描述符。</p><blockquote><p>从上面看，<strong>select和poll都需要在返回后，`通过遍历文件描述符来获取已经就绪的socket</strong>`。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。</p></blockquote><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>epoll是在2.6内核中提出的，是之前的select和poll的增强版本。<strong>相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</strong></p><h3 id="一-epoll操作过程"><a href="#一-epoll操作过程" class="headerlink" title="一 epoll操作过程"></a>一 epoll操作过程</h3><p>epoll操作过程需要三个接口，分别如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int epoll_create(int size)；//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>1. int epoll_create(int size);</strong><br>创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大，这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值，<code>参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议</code>。<br>当创建好epoll句柄后，它就会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</p><ol><li>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；<br>函数是对指定描述符fd执行op操作。</li></ol><ul><li>epfd：是epoll_create()的返回值。</li><li>op：表示op操作，用三个宏来表示：添加EPOLL_CTL_ADD，删除EPOLL_CTL_DEL，修改EPOLL_CTL_MOD。分别添加、删除和修改对fd的监听事件。</li><li>fd：是需要监听的fd（文件描述符）</li><li>epoll_event：是告诉内核需要监听什么事，struct epoll_event结构如下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">  <span class="keyword">__uint32_t</span> events;  <span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data;  <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//events可以是以下几个宏的集合：</span></span><br><span class="line">EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</span><br><span class="line">EPOLLOUT：表示对应的文件描述符可以写；</span><br><span class="line">EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</span><br><span class="line">EPOLLERR：表示对应的文件描述符发生错误；</span><br><span class="line">EPOLLHUP：表示对应的文件描述符被挂断；</span><br><span class="line">EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。</span><br><span class="line">EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</span><br></pre></td></tr></table></figure><p><strong>3. int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</strong><br>等待epfd上的io事件，最多返回maxevents个事件。<br>参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</p><h3 id="二-工作模式"><a href="#二-工作模式" class="headerlink" title="二 工作模式"></a>二 工作模式</h3><p>　epoll对文件描述符的操作有两种模式：<strong>LT（level trigger）</strong>和<strong>ET（edge trigger）</strong>。LT模式是默认模式，LT模式与ET模式的区别如下：<br>　　<strong>LT模式</strong>：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<code>应用程序可以不立即处理该事件</code>。下次调用epoll_wait时，会再次响应应用程序并通知此事件。<br>　　<strong>ET模式</strong>：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<code>应用程序必须立即处理该事件</code>。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p><h4 id="1-LT模式"><a href="#1-LT模式" class="headerlink" title="1. LT模式"></a>1. LT模式</h4><p>LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。</p><h4 id="2-ET模式"><a href="#2-ET模式" class="headerlink" title="2. ET模式"></a>2. ET模式</h4><p>ET(edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)</p><p>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p><h4 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h4><p>假如有这样一个例子：</p><ol><li>我们已经把一个用来从管道中读取数据的文件句柄(RFD)添加到epoll描述符</li><li>这个时候从管道的另一端被写入了2KB的数据</li><li>调用epoll_wait(2)，并且它会返回RFD，说明它已经准备好读取操作</li><li>然后我们读取了1KB的数据</li><li>调用epoll_wait(2)……</li></ol><p><strong>LT模式：</strong><br>如果是LT模式，那么在第5步调用epoll_wait(2)之后，仍然能受到通知。</p><p><strong>ET模式：</strong><br>如果我们在第1步将RFD添加到epoll描述符的时候使用了EPOLLET标志，那么在第5步调用epoll_wait(2)之后将有可能会挂起，因为剩余的数据还存在于文件的输入缓冲区内，而且数据发出端还在等待一个针对已经发出数据的反馈信息。只有在监视的文件句柄上发生了某个事件的时候 ET 工作模式才会汇报事件。因此在第5步的时候，调用者可能会放弃等待仍在存在于文件输入缓冲区内的剩余数据。</p><p>当使用epoll的ET模型来工作时，当产生了一个EPOLLIN事件后，<br>读数据的时候需要考虑的是当recv()返回的大小如果等于请求的大小，那么很有可能是缓冲区还有数据未读完，也意味着该次事件还没有处理完，所以还需要再次读取：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(rs)&#123;</span><br><span class="line">  buflen = recv(activeevents[i].data.fd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(buflen &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 由于是非阻塞的模式,所以当errno为EAGAIN时,表示当前缓冲区已无数据可读</span></span><br><span class="line">    <span class="comment">// 在这里就当作是该次事件已处理处.</span></span><br><span class="line">    <span class="keyword">if</span>(errno == EAGAIN)&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(buflen == <span class="number">0</span>)&#123;</span><br><span class="line">     <span class="comment">// 这里表示对端的socket已正常关闭.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(buflen == <span class="keyword">sizeof</span>(buf)&#123;</span><br><span class="line">      rs = <span class="number">1</span>;   <span class="comment">// 需要再次读取</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span>&#123;</span><br><span class="line">      rs = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Linux中的EAGAIN含义</strong></p></blockquote><p>Linux环境下开发经常会碰到很多错误(设置errno)，其中EAGAIN是其中比较常见的一个错误(比如用在非阻塞操作中)。<br>从字面上来看，是提示再试一次。这个错误经常出现在当应用程序进行一些非阻塞(non-blocking)操作(对文件或socket)的时候。</p><p>例如，以 O_NONBLOCK的标志打开文件/socket/FIFO，如果你连续做read操作而没有数据可读。此时程序不会阻塞起来等待数据准备就绪返回，read函数会返回一个错误EAGAIN，提示你的应用程序现在没有数据可读请稍后再试。<br>又例如，当一个系统调用(比如fork)因为没有足够的资源(比如虚拟内存)而执行失败，返回EAGAIN提示其再调用一次(也许下次就能成功)。</p><h3 id="三-代码演示"><a href="#三-代码演示" class="headerlink" title="三 代码演示"></a>三 代码演示</h3><p>下面是一段不完整的代码且格式不对，意在表述上面的过程，去掉了一些模板代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPADDRESS   <span class="meta-string">"127.0.0.1"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT        8787</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE     1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTENQ     5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FDSIZE      1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPOLLEVENTS 100</span></span><br><span class="line"></span><br><span class="line">listenfd = socket_bind(IPADDRESS,PORT);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">EPOLLEVENTS</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个描述符</span></span><br><span class="line">epollfd = epoll_create(FDSIZE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加监听描述符事件</span></span><br><span class="line">add_event(epollfd,listenfd,EPOLLIN);</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环等待</span></span><br><span class="line"><span class="keyword">for</span> ( ; ; )&#123;</span><br><span class="line">    <span class="comment">//该函数返回已经准备好的描述符事件数目</span></span><br><span class="line">    ret = epoll_wait(epollfd,events,EPOLLEVENTS,<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">//处理接收到的连接</span></span><br><span class="line">    handle_events(epollfd,events,ret,listenfd,buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//事件处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_events</span><span class="params">(<span class="keyword">int</span> epollfd,struct epoll_event *events,<span class="keyword">int</span> num,<span class="keyword">int</span> listenfd,<span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i;</span><br><span class="line">     <span class="keyword">int</span> fd;</span><br><span class="line">     <span class="comment">//进行遍历;这里只要遍历已经准备好的io事件。num并不是当初epoll_create时的FDSIZE。</span></span><br><span class="line">     <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; num;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         fd = events[i].data.fd;</span><br><span class="line">        <span class="comment">//根据描述符的类型和事件类型进行处理</span></span><br><span class="line">         <span class="keyword">if</span> ((fd == listenfd) &amp;&amp;(events[i].events &amp; EPOLLIN))</span><br><span class="line">            handle_accpet(epollfd,listenfd);</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN)</span><br><span class="line">            do_read(epollfd,fd,buf);</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLOUT)</span><br><span class="line">            do_write(epollfd,fd,buf);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加事件</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add_event</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">int</span> state)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.events = state;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    epoll_ctl(epollfd,EPOLL_CTL_ADD,fd,&amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理接收到的连接</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_accpet</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> listenfd)</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> clifd;     </span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span>     </span><br><span class="line">     <span class="keyword">socklen_t</span>  cliaddrlen;     </span><br><span class="line">     clifd = accept(listenfd,(struct sockaddr*)&amp;cliaddr,&amp;cliaddrlen);     </span><br><span class="line">     <span class="keyword">if</span> (clifd == <span class="number">-1</span>)         </span><br><span class="line">     perror(<span class="string">"accpet error:"</span>);     </span><br><span class="line">     <span class="keyword">else</span> &#123;         </span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"accept a new client: %s:%d\n"</span>,inet_ntoa(cliaddr.sin_addr),cliaddr.sin_port);                       <span class="comment">//添加一个客户描述符和事件         </span></span><br><span class="line">         add_event(epollfd,clifd,EPOLLIN);     </span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读处理</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_read</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">char</span> *buf)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nread;</span><br><span class="line">    nread = read(fd,buf,MAXSIZE);</span><br><span class="line">    <span class="keyword">if</span> (nread == <span class="number">-1</span>)     &#123;         </span><br><span class="line">        perror(<span class="string">"read error:"</span>);         </span><br><span class="line">        close(fd); <span class="comment">//记住close fd        </span></span><br><span class="line">        delete_event(epollfd,fd,EPOLLIN); <span class="comment">//删除监听 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>)     &#123;         </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"client close.\n"</span>);</span><br><span class="line">        close(fd); <span class="comment">//记住close fd       </span></span><br><span class="line">        delete_event(epollfd,fd,EPOLLIN); <span class="comment">//删除监听 </span></span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="keyword">else</span> &#123;         </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"read message is : %s"</span>,buf);        </span><br><span class="line">        <span class="comment">//修改描述符对应的事件，由读改为写         </span></span><br><span class="line">        modify_event(epollfd,fd,EPOLLOUT);     </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写处理</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_write</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">char</span> *buf)</span> </span>&#123;     </span><br><span class="line">    <span class="keyword">int</span> nwrite;     </span><br><span class="line">    nwrite = write(fd,buf,<span class="built_in">strlen</span>(buf));     </span><br><span class="line">    <span class="keyword">if</span> (nwrite == <span class="number">-1</span>)&#123;         </span><br><span class="line">        perror(<span class="string">"write error:"</span>);        </span><br><span class="line">        close(fd);   <span class="comment">//记住close fd       </span></span><br><span class="line">        delete_event(epollfd,fd,EPOLLOUT);  <span class="comment">//删除监听    </span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        modify_event(epollfd,fd,EPOLLIN); </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="number">0</span>,MAXSIZE); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除事件</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete_event</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.events = state;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    epoll_ctl(epollfd,EPOLL_CTL_DEL,fd,&amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改事件</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">modify_event</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">int</span> state)</span></span>&#123;     </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.events = state;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    epoll_ctl(epollfd,EPOLL_CTL_MOD,fd,&amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注：另外一端我就省了</span></span><br></pre></td></tr></table></figure><h3 id="四-epoll总结"><a href="#四-epoll总结" class="headerlink" title="四 epoll总结"></a>四 epoll总结</h3><p>在 select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而<strong>epoll事先通过epoll_ctl()来注册一 个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait() 时便得到通知</strong>。(<code>此处去掉了遍历文件描述符，而是通过监听回调的的机制</code>。这正是epoll的魅力所在。)</p><p><strong>epoll的优点主要是一下几个方面：</strong></p><ol><li><strong>监视的描述符数量不受限制</strong>，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左 右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。select的最大缺点就是进程打开的fd是有数量限制的。这对 于连接数量比较大的服务器来说根本不能满足。虽然也可以选择多进程的解决方案( Apache就是这样实现的)，不过虽然linux上面创建进程的代价比较小，但仍旧是不可忽视的，加上进程间数据同步远比不上线程间同步的高效，所以也不是一种完美的方案。</li><li><strong>IO的效率不会随着监视fd的数量的增长而下降。</strong>epoll不同于select和poll轮询的方式，而是<strong>通过每个fd定义的回调函数来实现的。只有就绪的fd才会执行回调函数。</strong></li></ol><blockquote><p>如果没有大量的idle -connection或者dead-connection，epoll的效率并不会比select/poll高很多，但是当遇到大量的idle- connection，就会发现epoll的效率大大高于select/poll。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000003063859&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;转载出处&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;同步IO和异步IO，阻塞IO和非阻塞IO分别是什么，到底有什么区别？不同
      
    
    </summary>
    
    
      <category term="操作系统" scheme="http://yuemingyang7010.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux" scheme="http://yuemingyang7010.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"/>
    
    
      <category term="操作系统" scheme="http://yuemingyang7010.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux" scheme="http://yuemingyang7010.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="http://yuemingyang7010.github.io/2019/06/29/LeetCode-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://yuemingyang7010.github.io/2019/06/29/LeetCode-动态规划/</id>
    <published>2019-06-29T05:52:09.000Z</published>
    <updated>2019-07-19T07:05:24.529Z</updated>
    
    <content type="html"><![CDATA[<h3 id="最长公共子序列问题-LCS问题"><a href="#最长公共子序列问题-LCS问题" class="headerlink" title="最长公共子序列问题(LCS问题)"></a>最长公共子序列问题(LCS问题)</h3><p>给定两个字符串A和B，长度分别为m和n，要求找出它们最长的公共子序列，并<strong>返回子序列</strong>。例如：</p><p>　　A = “Hel<strong>lo</strong>W<strong>o</strong>rld”</p><p>　   B = “<strong>loo</strong>p”</p><p>当我们要求<strong>dp [i] [j]</strong>，我们要先判断<strong>A的第i个元素B的第j个元素</strong>是否相同即判断<strong>A[i - 1]</strong>和 <strong>B[j -1]</strong>是否相同，如果相同它就是<strong>dp [i-1] [j-1]+ 1</strong>，相当于在两个字符串都去掉一个字符时的<strong>最长公共子序列</strong>再加 <strong>1</strong>；否则<strong>最长公共子序列</strong>取<strong>dp[i] [j - 1]</strong> 和<strong>dp[i - 1] [j]</strong>中大者。所以整个问题的初始状态为：                                                            </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] [0]=0,dp[0] [j]=0</span><br></pre></td></tr></table></figure><p>相应的状态转移方程为：</p><img src="/2019/06/29/LeetCode-动态规划/01.png"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LCS</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str1,<span class="keyword">const</span> <span class="keyword">char</span>* str2,<span class="built_in">string</span>&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m = (<span class="keyword">int</span>)<span class="built_in">strlen</span>(str1);</span><br><span class="line"><span class="keyword">int</span> n = (<span class="keyword">int</span>)<span class="built_in">strlen</span>(str2);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &gt; dp(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;(n+<span class="number">1</span>)); </span><br><span class="line"><span class="comment">//第一步：填二维表格</span></span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= m; i++)<span class="comment">//初始状态</span></span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (str1[i - <span class="number">1</span>] == str2[j - <span class="number">1</span>])<span class="comment">//判断A的第i个字符和B的第j个字符是否相同</span></span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j] &gt; dp[i][j - <span class="number">1</span>]? dp[i - <span class="number">1</span>][j]: dp[i][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二步：从左下角找到朝左上部分遍历，不一定最终到达左上角，只要i或者j等于0则终止</span></span><br><span class="line">i = m;</span><br><span class="line">j = n;    </span><br><span class="line"><span class="keyword">while</span> ((i != <span class="number">0</span>)&amp;&amp;(j != <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (str1[i<span class="number">-1</span>] == str2[j<span class="number">-1</span>])</span><br><span class="line">&#123;</span><br><span class="line">str.push_back(str1[i]);</span><br><span class="line">i--;</span><br><span class="line">j--;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (dp[i][j - <span class="number">1</span>] &gt; dp[i - <span class="number">1</span>][j])</span><br><span class="line">j--;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">i--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">reverse(str.begin(),str.end());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* str1=<span class="string">"HelloWorld"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* str2 = <span class="string">"loop"</span>;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line">LCS(str1,str2,str);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str.c_str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历的过程：</p><p>str1[i-1] == str2[j-1] 成立时，向左上角遍历</p><p>不成立时，dp[i] [j - 1] &gt; dp[i - 1] [j] 成立则朝左遍历，否则朝上遍历</p><img src="/2019/06/29/LeetCode-动态规划/03.png"><h3 id="最长公共子串问题"><a href="#最长公共子串问题" class="headerlink" title="最长公共子串问题"></a>最长公共子串问题</h3><p>给定两个字符串A和B，长度分别为m和n，要求找出它们最长的公共子串，并返回其长度。例如：</p><p>A = “Hel<strong>lo</strong>World”</p><p>B = “<strong>lo</strong>op”</p><p>子序列和子串的区别：<strong>子序列和子串都是字符集合的子集，但是子序列不一定连续，但是子串一定是连续的</strong>。同样地，这里只给出动态规划的解法：定义<strong>dp[i] [j]</strong>表示以A中第i个字符结尾的子串和B中第j个字符结尾的子串的的最大公共子串(<strong>其中A中第i个字符和B中第J个字符指</strong>)的长度。</p><p>当我们要求<strong>dp[i] [j]</strong>，我们要先判断<strong>A的第i个元素B的第j个元素</strong>是否相同即判断<strong>A[i - 1]</strong>和 <strong>B[j -1]</strong>是否相同，如果相同它就是<strong>dp[i - 1] [j- 1] + 1</strong>，相当于在两个字符串都去掉一个字符时的<strong>最长公共子串</strong>再加 <strong>1</strong>；否则<strong>最长公共子串</strong>取0。所以整个问题的初始状态为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] [0]=0,dp[0] [j]=0</span><br></pre></td></tr></table></figure><p>相应的状态转移方程为：</p><img src="/2019/06/29/LeetCode-动态规划/02.png"><p>代码的实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">findLongest</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str1,<span class="keyword">const</span> <span class="keyword">char</span>* str2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m = (<span class="keyword">int</span>)<span class="built_in">strlen</span>(str1);</span><br><span class="line"><span class="keyword">int</span> n = (<span class="keyword">int</span>)<span class="built_in">strlen</span>(str2);</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> imax = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> jmax = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &gt; dp(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;(n+<span class="number">1</span>)); </span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= m; i++)<span class="comment">//初始状态</span></span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (str1[i - <span class="number">1</span>] == str2[j - <span class="number">1</span>]) &#123;<span class="comment">//判断A的第i个字符和B的第j个字符是否相同</span></span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (dp[i][j] &gt; result)<span class="comment">//当前dp[i][j]大于result，则更新公共子串最大长度，及其对应坐标</span></span><br><span class="line">&#123;</span><br><span class="line">result = dp[i][j];</span><br><span class="line">imax = i;</span><br><span class="line">jmax = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">dp[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (result != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">str.push_back(str1[imax<span class="number">-1</span>]);</span><br><span class="line">imax--;</span><br><span class="line">jmax--;</span><br><span class="line">result--;</span><br><span class="line">&#125;</span><br><span class="line">reverse(str.begin(), str.end());</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* str1=<span class="string">"HelloWorld"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* str2 = <span class="string">"loop"</span>;</span><br><span class="line"><span class="built_in">string</span> resultStr = findLongest(str1,str2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; resultStr.c_str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历的过程：</p><p>从dp最大的位置沿着左上角遍历result个字符</p><img src="/2019/06/29/LeetCode-动态规划/04.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;最长公共子序列问题-LCS问题&quot;&gt;&lt;a href=&quot;#最长公共子序列问题-LCS问题&quot; class=&quot;headerlink&quot; title=&quot;最长公共子序列问题(LCS问题)&quot;&gt;&lt;/a&gt;最长公共子序列问题(LCS问题)&lt;/h3&gt;&lt;p&gt;给定两个字符串A和B，长度分别为
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yuemingyang7010.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法刷题" scheme="http://yuemingyang7010.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划刷题" scheme="http://yuemingyang7010.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>字符串</title>
    <link href="http://yuemingyang7010.github.io/2019/06/29/LeetCode-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://yuemingyang7010.github.io/2019/06/29/LeetCode-字符串/</id>
    <published>2019-06-29T05:52:09.000Z</published>
    <updated>2019-07-19T15:15:57.246Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://baijiahao.baidu.com/s?id=1605574559806098900&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">C语言字符串函数参考1</a></p><p><a href="https://www.cnblogs.com/xionghj/p/4443891.html" target="_blank" rel="noopener">C语言字符串函数参考2</a></p><p><a href="http://c.biancheng.net/cpp/biancheng/view/3284.html" target="_blank" rel="noopener">C++语言字符串函数参考</a></p><h1 id="字符串刷题方法"><a href="#字符串刷题方法" class="headerlink" title="字符串刷题方法"></a>字符串刷题方法</h1><p>字符串循环移位<br>LCS最长递增子序到   <strong>去动态规划看</strong><br>字符串全排到<br>Manacher算法<br>KMP模式串匹配<br>    附：BM算法<br>三字母字符串组合</p><h2 id="字符串循环左移"><a href="#字符串循环左移" class="headerlink" title="字符串循环左移"></a>字符串循环左移</h2><p>题目：给定一个字符串S[0..N-1]，要求把S的前k个字符移动到S的尾部，如把字符串“abcdef”前面的2个字符‘a’、b’移动到字符串的尾部，得到新字符串“cdefab”：即字符串循环左移k。<br>多说一句：循环左移n+k位和k位的效果相同，循环左移k位等价于循环右移n-k位。<br>算法要求：<br><strong>时间复杂度为O（n），空间复杂度为O（1）。</strong></p><p>分析：</p><p><strong>暴力移位法</strong><br>每次循环左移1位，调用k次即可<br>时间复杂度O（kN），空间复杂度O（1）</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> temp = S[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">S[i<span class="number">-1</span>] = S[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>三次拷贝</strong><br>S[0…k]→T[0…k]<br>S[k+1..N-1]→S[0..N-k-1]<br>T[0…k]→S[N-k…N-1]<br>时间复杂度O（N），空间复杂度O（k）</p><p><strong>优雅一点的算法</strong><br>(1)（X‘Y’)‘=YX</p><p>​        如：abcdef </p><p>​        X=ab         X’=ba </p><p>​        Y=cdef      Y’=fedc</p><p>​     （X‘Y’)‘=（bafedc）’ = cdefab</p><p>(2)时间复杂度O（N），空间复杂度O（1）</p><p>​        该问题会在“完美洗牌”算法中再次遇到。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串翻转</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReverseString</span><span class="params">(<span class="keyword">char</span>* s,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line"> <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">char</span> tem = s[left];</span><br><span class="line">        s[left++] = s[right];</span><br><span class="line">        s[right--] = t;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//n为字符串长度，m为左移多少位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LeftRotateString</span><span class="params">(<span class="keyword">char</span>* s,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    m %= n;</span><br><span class="line">    ReverseString(s,<span class="number">0</span>,m<span class="number">-1</span>);</span><br><span class="line">    ReverseString(s,m,n<span class="number">-1</span>);</span><br><span class="line">    ReverseString(s,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>该方法特别适合，反转 “I love china”为“china love I”</strong></p><h2 id="最长回文子串-leetcode-5"><a href="#最长回文子串-leetcode-5" class="headerlink" title="最长回文子串(leetcode 5)"></a>最长回文子串(leetcode 5)</h2><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p><p>示例 1：</p><p>输入: “babad”<br>输出: “bab”<br>注意: “aba” 也是一个有效答案。<br>示例 2：</p><p>输入: “cbbd”<br>输出: “bb”</p><p>思路：<a href="https://mp.weixin.qq.com/s?__biz=MzIwNTc4NTEwOQ==&amp;mid=2247484049&amp;idx=1&amp;sn=b3ee1a909d0c75cb9ef57df69ca36f5c&amp;chksm=972ad3eba05d5afd63dcb87c78a3b99cd6312e86c26d3727a7c7e01f0ed9a5f4f81edbee06f9&amp;mpshare=1&amp;scene=1&amp;srcid=0719xSkvzvmyhSB5d0cGY6Au&amp;key=034516426b2066d0e0aa6ab7340f5165b69a49c8183a1b4a232fae513c14ca25e69fa8220126e8ae5c517f68513d650b40ea657e95aed7b3002b7281a4c0fec8b6e601f0a455962f47f12cab9c546f51&amp;ascene=1&amp;uin=MjUzODM5ODQwNA%3D%3D&amp;devicetype=Windows+10&amp;version=62060833&amp;lang=zh_CN&amp;pass_ticket=x3FegFPx%2Bvw0qa34JSQ8rVDFtlaR46UnZVCzg53idyupd1SCO5oQv401BqivS7%2Fn" target="_blank" rel="noopener">参考</a></p><p><strong>方法一：Manacher 算法求最长回文子串:  时间复杂度O(N)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="string">""</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"><span class="built_in">string</span> str = <span class="string">"@"</span>;</span><br><span class="line"><span class="built_in">string</span> result;</span><br><span class="line"><span class="keyword">int</span> len = s.length();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">str = str + <span class="string">"#"</span> + s[i];</span><br><span class="line">str += <span class="string">"#$"</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p(str.length(), <span class="number">1</span>);</span><br><span class="line">manacher(str, p);</span><br><span class="line"><span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> imax;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.size(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (p[i] &gt; max) &#123;</span><br><span class="line">max = p[i];</span><br><span class="line">imax = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = imax - (max - <span class="number">1</span>); j &lt;= imax + (max - <span class="number">1</span>); j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (str[j] != <span class="string">'#'</span>)</span><br><span class="line">result += str[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manacher</span><span class="params">(<span class="built_in">string</span>&amp; str, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = str.length();</span><br><span class="line"><span class="keyword">int</span> id = <span class="number">0</span>;  <span class="comment">// id 为已知的 &#123;右边界最大&#125; 的回文子串的中心</span></span><br><span class="line"><span class="keyword">int</span> mx = <span class="number">1</span>;  <span class="comment">//mx则为id+P[id]，也就是这个子串的右边界</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len - <span class="number">2</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (mx &gt; i)</span><br><span class="line">p[i] = min(p[<span class="number">2</span> * id - i], mx - i);  <span class="comment">//如果mx&gt;i，则分两种情况</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">p[i] = <span class="number">1</span>;                   <span class="comment">//如果mx&lt;i，则无法用之前的p来计算，先置1</span></span><br><span class="line"><span class="keyword">for</span> (; str[i + p[i]] == str[i - p[i]]; p[i]++);  <span class="comment">//统计i对应的p[i]</span></span><br><span class="line"><span class="keyword">if</span> (mx &lt; i + p[i]) &#123;</span><br><span class="line">mx = i + p[i]; <span class="comment">//更新右边界</span></span><br><span class="line">id = i;      <span class="comment">//更新id</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方法2：暴力法 n*(n/2)(n2)  时间复杂度O(N^3)</p><p>方法3: 动态规划 O(N^2)</p><h2 id="KMP算法-实现-strStr-函数（leetcode-28）"><a href="#KMP算法-实现-strStr-函数（leetcode-28）" class="headerlink" title="KMP算法-实现 strStr() 函数（leetcode-28）"></a>KMP算法-实现 strStr() 函数（leetcode-28）</h2><p>KMP算法重点是求next数组：</p><p><a href="https://blog.csdn.net/v_JULY_v/article/details/7041827" target="_blank" rel="noopener">KMP经典参考文章</a></p><p>时间复杂度O(M+N)O(M+N)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getnext(<span class="built_in">string</span> str)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> len=str.size();</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next;</span><br><span class="line">            next.push_back(<span class="number">-1</span>);<span class="comment">//next数组初值为-1</span></span><br><span class="line">            <span class="keyword">int</span> j=<span class="number">0</span>,k=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;len<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(k==<span class="number">-1</span>||str[j]==str[k])<span class="comment">//str[j]后缀 str[k]前缀</span></span><br><span class="line">                &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                    k++;</span><br><span class="line">                    next.push_back(k);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    k=next[k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(needle.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;<span class="comment">//源串</span></span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;<span class="comment">//子串</span></span><br><span class="line">        <span class="keyword">int</span> len1=haystack.size();</span><br><span class="line">        <span class="keyword">int</span> len2=needle.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next;</span><br><span class="line">        next=getnext(needle);</span><br><span class="line">        <span class="keyword">while</span>((i&lt;len1)&amp;&amp;(j&lt;len2))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((j==<span class="number">-1</span>)||(haystack[i]==needle[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                j=next[j];<span class="comment">//获取下一次匹配的位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j==len2)</span><br><span class="line">            <span class="keyword">return</span> i-j;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>库函数解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(needle.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pos=haystack.find(needle);</span><br><span class="line">        <span class="keyword">return</span> pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="剑指offer目录"><a href="#剑指offer目录" class="headerlink" title="剑指offer目录"></a>剑指offer目录</h1><div class="table-container"><table><thead><tr><th>题目</th><th>难度</th><th></th></tr></thead><tbody><tr><td><a href="note://2FE9426DFA26451590280DDE2FF5D995" target="_blank" rel="noopener">15.二进制中1的个数.note</a></td><td>☆</td><td>要考虑到负数这种情况，右移数还是左移相与的数？</td></tr><tr><td><a href="note://0F2C9A08084941ACABE64F2321602B23" target="_blank" rel="noopener">38.字符串的排列.note</a></td><td>☆☆</td><td>采用递归回溯的方式实现，要考虑字符的重复，输出结果是否为字典序。</td></tr><tr><td><a href="note://6433D1219FFA437180403A8BBF8FB764" target="_blank" rel="noopener">43.1~n整数中1出现的次数.note</a></td><td>☆☆☆</td><td>设定整数点（如1、10、100等等）作为位置点i，<strong>求每个位置点为1时的数有多少个，再算出所有情况</strong>    //<strong>根据设定的整数位置，对n进行分割，分为两部分，高位n/i，低位n%i</strong></td></tr><tr><td><a href="note://00DEAC2A377142BDAAECF1A29FDD4F7D" target="_blank" rel="noopener">把数组排成最小的数.note</a></td><td>☆☆</td><td>要会用数字转字符串函数 to_string(number1),会写sort()的cmp函数。</td></tr><tr><td><a href="note://0E29AFB8ABE446BB98834AFFFF1CDCE1" target="_blank" rel="noopener">49.丑数.note</a></td><td>☆☆☆</td><td>一个丑数的因子只有2,3,5，那么丑数p = 2 ^ x <em> 3 ^ y </em> 5 ^ z</td></tr><tr><td><a href="note://7B71AF3F8E6341F6A7B00CEF6B8B1C82" target="_blank" rel="noopener">50.第一次只出现一次的字符.note</a></td><td>☆☆</td><td>采用hash思想，用int map[256]统计字符串中字符的个数，然后从头遍历字符串，到map[256]中寻找对应值，如果为1，则返回。</td></tr><tr><td><a href="note://495347488DBB4A7D8BBF97F7F6219833" target="_blank" rel="noopener">50(2).字符流中第一个只出现一次的字符.note</a></td><td>☆☆</td><td>和上题类似，只是字符串S和map[256]作为类的成员变量，每次调用insert()函数时，从字符流中添加一个字符到S的结尾，同时，更新map[256]中对应位，findFirst()仍然按照字符串顺序，遍历map数组。</td></tr><tr><td><a href="note://1BAB43C17FA84EF69194DDD5CDDECAE3" target="_blank" rel="noopener">求1+2+…+n.note</a></td><td>☆☆</td><td>采用递归代替循环，用&amp;&amp;代替if条件语句。</td></tr><tr><td><a href="note://CDEFFF8B180046AA8FD27260647AF6E8" target="_blank" rel="noopener">把字符串转换成整数.note</a></td><td>☆☆</td><td>(1)字符串指针是否为空，字符串长度是否为0；(2)考虑字符串的正负，正数要考虑带不带正号；(3)确保除了符号位以外所有的字符必须都是0~9之间的几个字符，否则返回0.</td></tr><tr><td><a href="note://3C01B41508FE4CCEA3220DA0E931715D" target="_blank" rel="noopener">19.正则表达式匹配.note</a></td><td>☆☆☆</td><td>分多种情况考虑，具体分析见链接</td></tr><tr><td><a href="note://660AC5B81F104AB5B54A6CF4A7701F09" target="_blank" rel="noopener">58(2).左旋转字符串.note</a></td><td>☆</td><td>主要熟悉下string类的一些函数的操作<a href="note://81AE2E6AD935400C912AE83D10A7DBAF" target="_blank" rel="noopener">2.16 C++ string类详解.note</a></td></tr><tr><td><a href="note://73104616EC1B4EEE947B96B4CD1EC0FF" target="_blank" rel="noopener">5.替换空格.note</a></td><td>☆☆</td><td>在同一个字符数组中，通过两个指针进行空格和%20的替换。</td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table></div><h2 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h2><p><strong>题目描述</strong></p><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><p><strong>知识补充：</strong></p><p>左移运算符m&lt;&lt;n，在左移n位时候，最左边n位丢弃，同时在最右边补上n个0；</p><p>m&gt;&gt;n时分两种情况：(1)无符号数，用0填补最左边n位；</p><p>（2）有符号数，则右移之后数字的符号位填补最左侧的n位。</p><p>如：00001010&gt;&gt;2 = 00000010            10001010&gt;&gt;3 = 11110001</p><p>思路分析：</p><p>(1)拿到题目可能第一想法，直接右移(注意：右移比除以2效率高很多)，如果输入的是负数，右移后，最左侧补上的是’1’,从而造成死循环；</p><p>(2)为了避免死循环，我们不右移输入的数字，而是将其与1,2,4,8…相与，实际采用标志位左移的方式，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">int</span>  <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">             <span class="keyword">if</span>(n&amp;flag)</span><br><span class="line">                 count++;</span><br><span class="line">             flag = flag&lt;&lt;<span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> count;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h2><p><strong>题目描述</strong></p><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p><p><strong>输入描述:</strong></p><p>输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。</p><p>思路：实际上本题需要排除重复情况，结果需要字典排序</p><p><strong>思路：</strong></p><p><strong>(1)将第一个元素与包括自身在内的所有元素交换。</strong></p><p><strong>(2)那么第一个元素是固定的，转到下一个元素。</strong></p><p><strong>(3)直到最后一个元素固定。输出。</strong></p><img src="/2019/06/29/LeetCode-字符串/01.png"><p>可以参考LeetCode刷题笔记：<a href="note://38033A07A3AD427AA3CA0E8ABE6D757F" target="_blank" rel="noopener">2.Permutations(中)全排列.note</a></p><p>也可以<a href="https://www.cnblogs.com/AndyJee/p/4655485.html" target="_blank" rel="noopener">参考博客:</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; Permutation(<span class="built_in">string</span> str) &#123;</span><br><span class="line">        <span class="keyword">if</span>(str.length() &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        permu(str,<span class="number">0</span>);</span><br><span class="line">        sort(result.begin(),result.end());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">permu</span><span class="params">(<span class="built_in">string</span> str,<span class="keyword">int</span> begin)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(begin == str.length()<span class="number">-1</span>)  <span class="comment">//最后一个字符的自身交换可以不考虑，如果考虑就不减1</span></span><br><span class="line">            result.push_back(str);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = begin;i&lt;str.length();i++)&#123;      </span><br><span class="line">                <span class="keyword">if</span>(begin == i || str[begin] != str[i])&#123;  <span class="comment">//排除重复的影响</span></span><br><span class="line">                    swap(str[begin],str[i]);</span><br><span class="line">                    permu(str,begin+<span class="number">1</span>);</span><br><span class="line">                    swap(str[begin],str[i]);  <span class="comment">//采用回溯的方法</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>&amp; a,<span class="keyword">char</span>&amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> temp = a;</span><br><span class="line">        a=b;</span><br><span class="line">        b=temp;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1-n整数中1出现的次数"><a href="#1-n整数中1出现的次数" class="headerlink" title="1~n整数中1出现的次数"></a>1~n整数中1出现的次数</h2><p><strong>题目描述</strong></p><p>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。</p><p><strong>思路：</strong></p><p>设定整数点（如1、10、100等等）作为位置点i（对应n的各位、十位、百位等等），分别对每个数位上有多少包含1的点进行分析，<strong>即求每个位置点为1时的数有多少个，再算出所有情况</strong></p><p>​    //<strong>根据设定的整数位置，对n进行分割，分为两部分，高位n/i，低位n%i</strong></p><p>​    //当i表示百位，且百位对应的数&gt;=2,如n=31456,i=100，则a=314,b=56，此时百位为1的次数有a/10+1=32（最高两位0~31），每一次都包含100个连续的点，即共有(a/10+1)*100个点的百位为1</p><p>​    //当i表示百位，且百位对应的数为1，如n=31156,i=100，则a=311,b=56，此时百位对应的就是1，则共有(a/10)*100+(b+1)个数</p><p>​    //当i表示百位，且百位对应的数为0,如n=31056,i=100，则a=310,b=56，此时百位为1的次数有(a/10)*100个</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> i=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i*=<span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> a=n/i;</span><br><span class="line">            <span class="keyword">int</span> b=n%i;</span><br><span class="line">            <span class="keyword">if</span>(a%<span class="number">10</span> == <span class="number">0</span>)</span><br><span class="line">                count = count+(a/<span class="number">10</span>)*i;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a%<span class="number">10</span> &gt;= <span class="number">2</span>)</span><br><span class="line">                count = count+(a/<span class="number">10</span> + <span class="number">1</span>)*i;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                count = count+(a/<span class="number">10</span>)*i+b+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a>把数组排成最小的数</h2><p><strong>题目描述</strong></p><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p><p><strong>解题思路</strong></p><p>可以看成是一个排序问题，在比较两个字符串S1和S2的大小时，应该比较的是S1+S2和S2+S1的大小，如果S1+S2&lt;S2+S1,那么应该把S1排在前面，否则应该把S2排在前面。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">PrintMinNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = numbers.size();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(numbers.begin(),numbers.end(),cmp);<span class="comment">//核心就一个sort()</span></span><br><span class="line">        <span class="built_in">string</span> result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            result += to_string(numbers[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果在类里面定义cmp要设置为静态的，直接放在类外不用这样，可能和sort()的实现有关</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> A = to_string(a)+to_string(b);</span><br><span class="line">        <span class="built_in">string</span> B = to_string(b)+to_string(a);</span><br><span class="line">        <span class="keyword">return</span> A &lt; B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h2><p><strong>题目描述</strong></p><p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p><p><strong>思路：</strong></p><p>首先从丑数的定义我们知道，一个丑数的因子只有2,3,5，那么丑数p = 2 ^ x <em> 3 ^ y </em> 5 ^ z，换句话说<strong>一个丑数一定由另一个丑数乘以2或者乘以3或者乘以5得到</strong>，那么我们从1开始乘以2,3,5，就得到2,3,5三个丑数，在从这三个丑数出发乘以2,3,5就得到4，6,10,6，9,15,10,15,25九个丑数，我们发现这种方法会得到重复的丑数，而且我们题目要求第N个丑数，这样的方法得到的丑数也是无序的。那么我们可以维护三个队列：</p><p>（1）丑数数组： 1</p><p>乘以2的队列：2</p><p>乘以3的队列：3</p><p>乘以5的队列：5</p><p>选择三个队列头最小的数2加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列；</p><p>（2）丑数数组：1,2</p><p>乘以2的队列：4</p><p>乘以3的队列：3，6</p><p>乘以5的队列：5，10</p><p>选择三个队列头最小的数3加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列；</p><p>（3）丑数数组：1,2,3</p><p>乘以2的队列：4,6</p><p>乘以3的队列：6,9</p><p>乘以5的队列：5,10,15</p><p>选择三个队列头里最小的数4加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列；</p><p>（4）丑数数组：1,2,3,4</p><p>乘以2的队列：6，8</p><p>乘以3的队列：6,9,12</p><p>乘以5的队列：5,10,15,20</p><p>选择三个队列头里最小的数5加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列；</p><p>（5）丑数数组：1,2,3,4,5</p><p>乘以2的队列：6,8,10，</p><p>乘以3的队列：6,9,12,15</p><p>乘以5的队列：10,15,20,25</p><p>选择三个队列头里最小的数6加入丑数数组，但我们发现，有两个队列头都为6，所以我们弹出两个队列头，同时将12,18,30放入三个队列；</p><p>……………………</p><p>疑问：</p><p>1.为什么分三个队列？</p><p>丑数数组里的数一定是有序的，因为我们是从丑数数组里的数乘以2,3,5选出的最小数，一定比以前未乘以2,3,5大，同时对于三个队列内部，按先后顺序乘以2,3,5分别放入，所以同一个队列内部也是有序的；</p><p>2.为什么比较三个队列头部最小的数放入丑数数组？</p><p>因为三个队列是有序的，所以取出三个头中最小的，等同于找到了三个队列所有数中最小的。</p><p>实现思路：</p><p>我们没有必要维护三个队列，只需要记录三个指针显示到达哪一步；“|”表示指针,arr表示丑数数组；</p><p>（1）1</p><p>|2</p><p>|3</p><p>|5</p><p>目前指针指向0,0,0，队列头arr[0] <em> 2 = 2,  arr[0] </em> 3 = 3,  arr[0] * 5 = 5</p><p>（2）1 2</p><p>2 |4</p><p>|3 6</p><p>|5 10</p><p>目前指针指向1,0,0，队列头arr[1] <em> 2 = 4,  arr[0] </em> 3 = 3, arr[0] * 5 = 5</p><p>（3）1 2 3</p><p>2| 4 6</p><p>3 |6 9</p><p>|5 10 15</p><p>目前指针指向1,1,0，队列头arr[1] <em> 2 = 4,  arr[1] </em> 3 = 6, arr[0] * 5 = 5</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">7</span>)</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(index);</span><br><span class="line">        res[<span class="number">0</span>] =<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> p2=<span class="number">0</span>,p3=<span class="number">0</span>,p5=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;index;i++)&#123;</span><br><span class="line">            res[i]=min_num(res[p2]*<span class="number">2</span>,res[p3]*<span class="number">3</span>,res[p5]*<span class="number">5</span>);</span><br><span class="line">            <span class="keyword">if</span>(res[i] == res[p2]*<span class="number">2</span>)</span><br><span class="line">                p2++;</span><br><span class="line">            <span class="keyword">if</span>(res[i] == res[p3]*<span class="number">3</span>)</span><br><span class="line">                p3++;</span><br><span class="line">            <span class="keyword">if</span>(res[i] == res[p5]*<span class="number">5</span>)</span><br><span class="line">                p5++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[index <span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min_num</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        a = a &lt; b?a:b;</span><br><span class="line">        a = a &lt; c?a:c;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>我所遇到过的错误分析：</strong></p><p><strong>在下面代码中，如果用if-else if-else，则会产生重复问题，比如产生两个6,6的重复。   所以一定要用if()….if()…..if()…..</strong>       </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index &lt; <span class="number">7</span>)</span><br><span class="line"><span class="keyword">return</span> index;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result(index);</span><br><span class="line">result[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> p2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> p3 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> p5 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; index; i++) &#123;</span><br><span class="line">result[i] = find_min(result[p2] * <span class="number">2</span>, result[p3] * <span class="number">3</span>, result[p5] * <span class="number">5</span>);</span><br><span class="line"><span class="keyword">if</span> (result[i] == result[p2] * <span class="number">2</span>)</span><br><span class="line">p2++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (result[i] == result[p3] * <span class="number">3</span>)</span><br><span class="line">p3++;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">p5++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result[index - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">a = a &lt; b ? a : b;</span><br><span class="line">a = a &lt; c ? a : c;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="第一次只出现一次的字符"><a href="#第一次只出现一次的字符" class="headerlink" title="第一次只出现一次的字符"></a>第一次只出现一次的字符</h2><p><strong>题目描述</strong></p><p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.</p><p><strong>思路：</strong></p><p>用STL中的map或者直接构件一个哈希表，由于本题只需要一个简单的哈希表，因此考虑实现一个简单的哈希表。</p><p><strong>每个字母根据其ASCII码值作为数组的下标对应数组的一个数字，而数组中存储的是每个字符出现的次数。这样我们就创建了一个大小为256、以字符ASCII码为键值的哈希表。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">map</span>[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : str)</span><br><span class="line">            <span class="built_in">map</span>[c]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[str[i]] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="字符流中第一个只出现一次的字符"><a href="#字符流中第一个只出现一次的字符" class="headerlink" title="字符流中第一个只出现一次的字符"></a>字符流中第一个只出现一次的字符</h2><p><strong>题目描述</strong></p><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。</p><p><strong>输出描述:</strong></p><p>如果当前字符流没有存在出现一次的字符，返回#字符。</p><p><strong>思路：</strong></p><p>类似于上一题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">         s+=ch;</span><br><span class="line">        hash[ch]++;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash[s[i]] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">char</span> hash[<span class="number">256</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="求1-2-…-n"><a href="#求1-2-…-n" class="headerlink" title="求1+2+…+n"></a>求1+2+…+n</h2><p><strong>题目：</strong></p><p>求1+2+…+n，要求不能使用乘除法、for、while、ifelse、switch、case等关键字及条件判断语句（A？B:C）。</p><p><strong>思路：</strong>采用递归，用&amp;&amp;代替if判断</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = n;</span><br><span class="line">        ans&amp;&amp;(ans += Sum_Solution(n<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="把字符串转换成整数"><a href="#把字符串转换成整数" class="headerlink" title="把字符串转换成整数"></a>把字符串转换成整数</h2><p>题目描述：</p><p>将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。</p><p>思路：本题主要考察思维严密性，注意以下几点：</p><p><strong>(1)字符串指针是否为空，字符串长度是否为0；</strong></p><p><strong>(2)考虑字符串的正负，特别是正数要考虑带不带正号；</strong></p><p><strong>(3)确保除了符号位以外所有的字符必须都是0~9之间的几个字符，否则返回0.</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> s = (str[<span class="number">0</span>] == <span class="string">'-'</span> ? <span class="number">-1</span>:<span class="number">1</span>); <span class="comment">//记录符号正负</span></span><br><span class="line">        <span class="keyword">int</span> i = ((str[<span class="number">0</span>] == <span class="string">'-'</span>)||(str[<span class="number">0</span>] == <span class="string">'+'</span>)?<span class="number">1</span>:<span class="number">0</span>); <span class="comment">//看字符串前有符号没有</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i]&gt;=<span class="string">'0'</span> &amp;&amp; str[i]&lt;=<span class="string">'9'</span>)  <span class="comment">//只有每一个单个字符都在0~9之间才合理，否则返回0</span></span><br><span class="line">                result = result*<span class="number">10</span> + str[i]-<span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result*s;  <span class="comment">//乘以符号位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h2><p><strong>题目描述</strong></p><p>请实现一个函数用来匹配包括’.’和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配</p><p><strong>思路：</strong></p><p>解这题需要把题意仔细研究清楚其多种情况。</p><p>首先通过模式串是否到结尾作为分类标准，分为两类</p><p>【1】模式串到结尾了</p><p>这种情况根据字符串是否到结尾了又分为两类：</p><p>(1)如果字符串和模式串都到了结尾，则返回true</p><p>(2)如果模式串到尾了，字符串还没到尾，肯定匹配失败,返回false</p><p>【2】模式串未到结尾</p><p>根据模式串当前字符的下一个字符是否为‘*’分为2类：</p><p>(1)若不为*，该种情况比较简单，比较字符串和模式串，分为当前字符匹配成功与失败2种；</p><p>(2)若为*，该种情况相对复杂，也是比较字符串和模式串，分为当前字符匹配成功与失败2种；</p><p>a.若匹配成功，则再分为字符串指针向后移动一位和不考虑模式串此次的成功匹配(考虑模式串出现多次连续与字符串当前位匹配成功的情况)字符串指针不向后移动两种情况，其中字符串指针向后移动一位的情况，又分为模式串指针保持在原位置和向后移动两位。具体如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> matchCore(str+<span class="number">1</span>,pattern+<span class="number">2</span>)||matchCore(str+<span class="number">1</span>,pattern)||matchCore(str,pattern+<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>b.若匹配不成功，则，字符串指针保持原位，模式串指针向后移动两位。</p><p>   为了更加直观说明，各种分类情况如下脑图：</p><img src="/2019/06/29/LeetCode-字符串/02.png"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">char</span>* pattern)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="literal">NULL</span> || pattern == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> matchCore(str,pattern);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">matchCore</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">char</span>* pattern)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果字符串和模式串都到了结尾，则返回true</span></span><br><span class="line">        <span class="keyword">if</span>(*str == <span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//如果模式串到尾了，字符串还没到尾，肯定匹配失败</span></span><br><span class="line">        <span class="keyword">if</span>(*str != <span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">///!!!!!!!!!上方为模式串到结尾了，下方是模式串未到结尾的所有情况！！！/////</span></span><br><span class="line">        <span class="keyword">if</span>(*(pattern+<span class="number">1</span>) == <span class="string">'*'</span>)&#123;  <span class="comment">//剩下情况以模式串下一个字符是否为*作为分类标准，分两类</span></span><br><span class="line">            <span class="comment">//如果当前字符串与模式串匹配上了则分为两种情况：【1】字符串和模式串相等，【2】模式串是‘.’，</span></span><br><span class="line">            <span class="comment">//且字符串没有到结尾，则继续匹配，字符串指针向后移1位，模式串指针保持原位或者向后2位</span></span><br><span class="line">            <span class="comment">//此外还要额外考虑一种情况，如字符串abc  模式串 a*a*bc,即模式串可以匹配成功，但是模式串</span></span><br><span class="line">            <span class="comment">//放弃前两位a*，用后面的字符与字符串去匹配，这种情况极易忽略，重点！！！</span></span><br><span class="line">            <span class="keyword">if</span>(*str == *pattern || (*str != <span class="string">'\0'</span>&amp;&amp;*pattern == <span class="string">'.'</span>))</span><br><span class="line">                <span class="keyword">return</span> matchCore(str+<span class="number">1</span>,pattern+<span class="number">2</span>)||matchCore(str+<span class="number">1</span>,pattern)||matchCore(str,pattern+<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">else</span>  <span class="comment">//如果字符串和模式串没配上，继续配，只能认为模式串*字符前一位字符出现0个</span></span><br><span class="line">                <span class="keyword">return</span> matchCore(str,pattern+<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(*str == *pattern || (*str != <span class="string">'\0'</span>&amp;&amp;*pattern == <span class="string">'.'</span>))</span><br><span class="line">                <span class="keyword">return</span> matchCore(str+<span class="number">1</span>,pattern+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h2><p>本题重点了解字符串string的用法：<a href="note://81AE2E6AD935400C912AE83D10A7DBAF" target="_blank" rel="noopener">2.16 C++ string类详解.note</a></p><p>对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">LeftRotateString</span><span class="params">(<span class="built_in">string</span> str, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        <span class="keyword">if</span>(len &lt; n)</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        <span class="built_in">string</span> temp = str.substr(n);</span><br><span class="line">        <span class="built_in">string</span> result = str.substr(<span class="number">0</span>,n);</span><br><span class="line">        result = temp + result;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h2><p><strong>题目描述</strong></p><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为4We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><p><strong>思路：</strong></p><img src="/2019/06/29/LeetCode-字符串/03.png"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replaceSpace</span><span class="params">(<span class="keyword">char</span> *str,<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先判断是否为空字符数组</span></span><br><span class="line">        <span class="keyword">if</span>(str == <span class="literal">NULL</span> || length &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//计算字符数组的实际长度(带\0)/////begin////</span></span><br><span class="line">        <span class="keyword">int</span> trueLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>* pTemp = str;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;str[i] != <span class="string">'\0'</span>;i++)&#123;</span><br><span class="line">            trueLength++;</span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">' '</span>)</span><br><span class="line">                count++;</span><br><span class="line">        &#125;</span><br><span class="line">        trueLength++;</span><br><span class="line">        <span class="keyword">int</span> newlength = count*<span class="number">2</span>+trueLength;</span><br><span class="line">    <span class="comment">//计算字符数组的实际长度(带\0)/////end/////</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(newlength &gt; length)<span class="comment">//如果替换空格后所需的字符数组长度小于length,则返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//进行替换////begin/////</span></span><br><span class="line">        <span class="keyword">int</span> indexOriginal = trueLength<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> indexNew = newlength<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(indexOriginal &gt;= <span class="number">0</span> &amp;&amp; indexNew &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[indexOriginal] == <span class="string">' '</span>)&#123;</span><br><span class="line">                str[indexNew--] = <span class="string">'0'</span>;</span><br><span class="line">                str[indexNew--] = <span class="string">'2'</span>;</span><br><span class="line">                str[indexNew--] = <span class="string">'%'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                str[indexNew--] = str[indexOriginal];</span><br><span class="line">            &#125;</span><br><span class="line">            indexOriginal--;</span><br><span class="line">        &#125;</span><br><span class="line">          <span class="comment">//进行替换////end/////</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://baijiahao.baidu.com/s?id=1605574559806098900&amp;amp;wfr=spider&amp;amp;for=pc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;C语言字符串函数参考1&lt;/a&gt;&lt;/p
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yuemingyang7010.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法刷题" scheme="http://yuemingyang7010.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="字符串刷题" scheme="http://yuemingyang7010.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>贪心</title>
    <link href="http://yuemingyang7010.github.io/2019/06/24/LeetCode-%E8%B4%AA%E5%BF%83/"/>
    <id>http://yuemingyang7010.github.io/2019/06/24/LeetCode-贪心/</id>
    <published>2019-06-24T05:52:09.000Z</published>
    <updated>2019-07-13T14:29:11.511Z</updated>
    
    <content type="html"><![CDATA[<h2 id="总结目录"><a href="#总结目录" class="headerlink" title="总结目录"></a>总结目录</h2><div class="table-container"><table><thead><tr><th>题目</th><th>难度</th><th>收获与总结</th></tr></thead><tbody><tr><td>1.分饼干</td><td>易</td><td>首先<strong>对需求数组g[]和饼干大小数组s[]排序</strong>，然后循环遍历，知道其中某一个数组遍历完，循环结束。两个数组都从首元素开始遍历过程中，<strong>每次cookie加1，若能够满足其中一个孩子则child加1</strong>，遍历完成后，返回child值。</td></tr><tr><td>2.摇摆数列</td><td>中</td><td>画<strong>数字升降规律图</strong>和用<strong>状态机</strong>的方法，眼前一亮，方法值得学习借鉴。</td></tr><tr><td>3.移除K位数字</td><td>中</td><td>思路：从最高位向最低位遍历，<strong>当对应的数字比下一位数字大，并且在没有剔除完K位数时，则应该剔除该位数</strong>，这样才能保证最后的数最小，编程时可以借用<strong>栈</strong>来实现。此外还要考虑数的开头不能为0的情况，以及遍历完字符串后，仍然没有删除完K位数的情况。</td></tr><tr><td>4.用最少的弓箭击爆气球</td><td>中</td><td>将<strong>所有气球区间的左端点从小到大排序</strong>，首先以第一个气球所在区间作为射击区间，遍历第二个气球的时候<strong>更新该区间</strong>，依次不断更新，当遍历到第i个气球时，气球区间左端点大于射击区间右端点，此时设定第二个射击区间，以此类推。</td></tr></tbody></table></div><h2 id="Assign-Cookies-易"><a href="#Assign-Cookies-易" class="headerlink" title="Assign Cookies(易)"></a>Assign Cookies(易)</h2><ol><li>Assign Cookies</li></ol><p><strong>分发饼干</strong></p><img src="/2019/06/24/LeetCode-贪心/01.png"><p>Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj &gt;= gi, we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.</p><p><strong>Note:</strong></p><p>You may assume the greed factor is always positive. </p><p>You cannot assign more than one cookie to one child.</p><p><strong>Example 1:</strong></p><p><strong>Input:</strong> [1,2,3], [1,1]  </p><p><strong>Output:</strong> 1  </p><p><strong>Explanation:</strong> You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3.  And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content. You need to output 1. </p><p><strong>Example 2:</strong></p><p><strong>Input:</strong> [1,2], [1,2,3]  </p><p><strong>Output:</strong> 2  </p><p><strong>Explanation:</strong> You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2.  You have 3 cookies and their sizes are big enough to gratify all of the children,  You need to output 2.</p><img src="/2019/06/24/LeetCode-贪心/02.png"><img src="/2019/06/24/LeetCode-贪心/03.png"><img src="/2019/06/24/LeetCode-贪心/04.png"><img src="/2019/06/24/LeetCode-贪心/05.png"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; g, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::sort(g.begin(),g.end());</span><br><span class="line">        <span class="built_in">std</span>::sort(s.begin(),s.end());</span><br><span class="line">        <span class="keyword">int</span> child = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cookie = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(child &lt; g.size() &amp;&amp; cookie &lt; s.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(g[child]&lt;=s[cookie])&#123;</span><br><span class="line">                child++;</span><br><span class="line">            &#125;</span><br><span class="line">            cookie++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> child;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Wiggle-Subsequence-中"><a href="#Wiggle-Subsequence-中" class="headerlink" title="Wiggle Subsequence(中)"></a>Wiggle Subsequence(中)</h2><p>摇摆序列</p><ol><li>Wiggle Subsequence</li></ol><img src="/2019/06/24/LeetCode-贪心/06.png"><p>A sequence of numbers is called a <strong>wiggle sequence</strong> if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence.</p><p>For example, <strong>[1,7,4,9,2,5]</strong> is a wiggle sequence because the differences (6,-3,5,-7,3) are alternately positive and negative. In contrast, [1,4,7,2,5] and [1,7,4,5,5] are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero.</p><p>Given a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order.</p><p><strong>Example 1:</strong></p><p><strong>Input:</strong> [1,7,4,9,2,5] </p><p><strong>Output:</strong> 6</p><p> <strong>Explanation:</strong> The entire sequence is a wiggle sequence.</p><p><strong>Example 2:</strong></p><p><strong>Input:</strong> [1,17,5,10,13,15,10,5,16,8] </p><p><strong>Output:</strong> 7 </p><p><strong>Explanation:</strong> There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].</p><p><strong>Example 3:</strong></p><p><strong>Input:</strong> [1,2,3,4,5,6,7,8,9] </p><p><strong>Output:</strong> 2</p><p><strong>Follow up:</strong></p><p>Can you do it in O(<em>n</em>) time?</p><img src="/2019/06/24/LeetCode-贪心/07.png"><img src="/2019/06/24/LeetCode-贪心/08.png"><img src="/2019/06/24/LeetCode-贪心/09.png"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums.size();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> BEGIN = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> UP = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> DOWN = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> STATE = BEGIN;</span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">switch</span>(STATE)&#123;</span><br><span class="line">                <span class="keyword">case</span> BEGIN:</span><br><span class="line">                    <span class="keyword">if</span>(nums[i]&gt;nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                        STATE = UP;</span><br><span class="line">                        maxLength++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(nums[i]&lt;nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                        STATE = DOWN;</span><br><span class="line">                        maxLength++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> UP:</span><br><span class="line">                    <span class="keyword">if</span>(nums[i]&lt;nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                        STATE = DOWN;</span><br><span class="line">                        maxLength++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> DOWN:</span><br><span class="line">                    <span class="keyword">if</span>(nums[i]&gt;nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                        STATE = UP;</span><br><span class="line">                        maxLength++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Remove-K-Digits-中"><a href="#Remove-K-Digits-中" class="headerlink" title="Remove K Digits(中)"></a>Remove K Digits(中)</h2><p>移掉K位数字</p><ol><li>Remove K Digits</li></ol><img src="/2019/06/24/LeetCode-贪心/10.png"><p>Given a non-negative integer <em>num</em> represented as a string, remove <em>k</em> digits from the number so that the new number is the smallest possible.</p><p><strong>Note:</strong></p><ul><li>The length of <em>num</em> is less than 10002 and will be ≥ <em>k</em>.</li><li>The given <em>num</em> does not contain any leading zero.</li></ul><p><strong>Example 1:</strong></p><p>Input: num = “1432219”, k = 3 </p><p>Output: “1219” </p><p>Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest. </p><p><strong>Example 2:</strong></p><p>Input: num = “10200”, k = 1 </p><p>Output: “200” </p><p>Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes. </p><p><strong>Example 3:</strong></p><p>Input: num = “10”, k = 2 </p><p>Output: “0” </p><p>Explanation: Remove all the digits from the number and it is left with nothing which is 0.</p><img src="/2019/06/24/LeetCode-贪心/11.png"><img src="/2019/06/24/LeetCode-贪心/12.png"><img src="/2019/06/24/LeetCode-贪心/13.png"><img src="/2019/06/24/LeetCode-贪心/14.png"><img src="/2019/06/24/LeetCode-贪心/15.png"><img src="/2019/06/24/LeetCode-贪心/16.png"><p>自己实现的代码比上述截图稍微简洁点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeKdigits</span><span class="params">(<span class="built_in">string</span> num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; mStack;</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num.length();i++)&#123;    </span><br><span class="line">            <span class="comment">//当栈不空，且要压入的数字比栈顶数字小，且仍然可以删除数字的时候，while循环继续</span></span><br><span class="line">            <span class="keyword">while</span>((!mStack.empty()) &amp;&amp; num[i] &lt; mStack.top() &amp;&amp;  k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                mStack.pop();</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num[i] != <span class="string">'0'</span> || (!mStack.empty()))&#123; <span class="comment">//防止出现数字字符串以0开头</span></span><br><span class="line">               mStack.push(num[i]); </span><br><span class="line">            &#125;                     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//解决当字符串从头遍历到尾，k仍然大于0，如nums= "12345" k=3时，此时弹出末尾比较大的数</span></span><br><span class="line">        <span class="keyword">while</span>((!mStack.empty()) &amp;&amp; k&gt;<span class="number">0</span>)&#123; <span class="comment">//如果栈不空，且仍然可以删除数字</span></span><br><span class="line">            mStack.pop();</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!mStack.empty())&#123;   <span class="comment">//将栈中的每一个char型字符连接为字符串</span></span><br><span class="line">            ans = mStack.top() + ans;</span><br><span class="line">            mStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans == <span class="string">""</span>)&#123;   <span class="comment">//根据题目要求，当ans为空字符串时候，返回“0”</span></span><br><span class="line">            ans = <span class="string">"0"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">LeetCode优秀解答，没有用到额外的数据结构，但是纯用数组比较绕！！！</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeKdigits</span><span class="params">(<span class="built_in">string</span> num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num.size()&lt;=k)<span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">int</span> top=<span class="number">0</span>,count=<span class="number">0</span>,n=num.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span> (top&gt;<span class="number">0</span>&amp;&amp;count&lt;k&amp;&amp;num[top<span class="number">-1</span>]&gt;num[i])&#123;</span><br><span class="line">                top--;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            num[top++]=num[i];</span><br><span class="line">        &#125;</span><br><span class="line">        top=min(top,n-k);</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;i&lt;top;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (num[i]!=<span class="string">'0'</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i==top)<span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        <span class="built_in">string</span> res=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (;i&lt;top;i++)</span><br><span class="line">            res+=num[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Minimum-Number"><a href="#Minimum-Number" class="headerlink" title="Minimum Number"></a>Minimum Number</h2><ol><li>Minimum Number of Arrows to Burst Balloons</li></ol><img src="/2019/06/24/LeetCode-贪心/17.png"><p>There are a number of spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it’s horizontal, y-coordinates don’t matter and hence the x-coordinates of start and end of the diameter suffice. Start is always smaller than end. There will be at most 104 balloons.</p><p>An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with xstart and xend bursts by an arrow shot at x if xstart ≤ x ≤ xend. There is no limit to the number of arrows that can be shot. An arrow once shot keeps travelling up infinitely. The problem is to find the minimum number of arrows that must be shot to burst all balloons.</p><p><strong>Example:</strong></p><p><strong>Input:</strong> [[10,16], [2,8], [1,6], [7,12]]  </p><p><strong>Output:</strong> 2  </p><p><strong>Explanation:</strong> One way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x = 11 (bursting the other two balloons). </p><img src="/2019/06/24/LeetCode-贪心/18.png"><img src="/2019/06/24/LeetCode-贪心/19.png"><img src="/2019/06/24/LeetCode-贪心/20.png"><img src="/2019/06/24/LeetCode-贪心/21.png"><img src="/2019/06/24/LeetCode-贪心/22.png"><img src="/2019/06/24/LeetCode-贪心/23.png"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; a,<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(points.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::sort(points.begin(),points.end(),comp);</span><br><span class="line">        <span class="keyword">int</span> arrowNum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> begin = points[<span class="number">0</span>].first;</span><br><span class="line">        <span class="keyword">int</span> end = points[<span class="number">0</span>].second;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;points.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(points[i].first &lt;= end)&#123;</span><br><span class="line">                begin = points[i].first;</span><br><span class="line">                <span class="keyword">if</span>(points[i].second &lt; end)&#123;</span><br><span class="line">                    end = points[i].second;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                arrowNum++;</span><br><span class="line">                begin = points[i].first;</span><br><span class="line">                end = points[i].second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arrowNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;总结目录&quot;&gt;&lt;a href=&quot;#总结目录&quot; class=&quot;headerlink&quot; title=&quot;总结目录&quot;&gt;&lt;/a&gt;总结目录&lt;/h2&gt;&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;题目&lt;/th&gt;
&lt;t
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yuemingyang7010.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法刷题" scheme="http://yuemingyang7010.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="贪心刷题" scheme="http://yuemingyang7010.github.io/tags/%E8%B4%AA%E5%BF%83%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>栈与队列</title>
    <link href="http://yuemingyang7010.github.io/2019/06/23/LeetCode-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    <id>http://yuemingyang7010.github.io/2019/06/23/LeetCode-栈与队列/</id>
    <published>2019-06-23T05:52:09.000Z</published>
    <updated>2019-07-13T14:27:13.060Z</updated>
    
    <content type="html"><![CDATA[<h2 id="总结目录"><a href="#总结目录" class="headerlink" title="总结目录"></a>总结目录</h2><div class="table-container"><table><thead><tr><th>题目</th><th>难度</th><th>收获与总结</th></tr></thead><tbody><tr><td>1.用队列实现栈</td><td>易</td><td>只是push()函数需要修改，每次添加一个数的时候，把队列中原有的数按顺序出队列再进队列。</td></tr><tr><td>2.用栈实现队列</td><td>易</td><td>只有push()函数需要改，<strong>用一个临时栈</strong>，每次添加一个数的时候，将数据栈中数按照顺序放临时栈中，将要push()的数加入数据栈中后，再将临时栈中的数据按照顺序放回数据栈。</td></tr><tr><td>3.实现含有getMin()函数的栈</td><td>易</td><td>需要改push()和pop()函数，使用两个栈，一个正常放数据，一个记录每个push()和pop()操作对应栈中最小的数。</td></tr><tr><td>4.找出数组中第K大的数</td><td>易</td><td>利用STL中priority_queue(PriorityQueue队列,是基于最小堆原理实现),也可以用STL中的sort()函数先排序。</td></tr></tbody></table></div><h2 id="Implement-实现-Stack-using-Queues-易"><a href="#Implement-实现-Stack-using-Queues-易" class="headerlink" title="Implement(实现) Stack using Queues(易)"></a>Implement(实现) Stack using Queues(易)</h2><ol><li>Implement Stack using Queues</li></ol><p>Implement the following operations of a stack using queues.</p><ul><li>push(x) — Push element x onto stack.</li><li>pop() — Removes the element on top of the stack.</li><li>top() — Get the top element.</li><li>empty() — Return whether the stack is empty.</li></ul><p><strong>Example:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyStack <span class="built_in">stack</span> = <span class="keyword">new</span> MyStack();</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>.push(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">stack</span>.push(<span class="number">2</span>);  </span><br><span class="line"><span class="built_in">stack</span>.top();   <span class="comment">// returns 2</span></span><br><span class="line"><span class="built_in">stack</span>.pop();   <span class="comment">// returns 2</span></span><br><span class="line"><span class="built_in">stack</span>.empty(); <span class="comment">// returns false</span></span><br></pre></td></tr></table></figure><p><strong>Notes:</strong></p><ul><li>You must use <em>only</em> standard operations of a queue — which means only push to back, peek/pop from front, size, and is empty operations are valid.</li><li>Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.</li><li>You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyStack() &#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        mQueue.push(x);</span><br><span class="line">        <span class="keyword">if</span>(mQueue.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;mQueue.size() <span class="number">-1</span> ;i++)&#123;</span><br><span class="line">                mQueue.push(mQueue.front());</span><br><span class="line">                mQueue.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = mQueue.front();</span><br><span class="line">        mQueue.pop();</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mQueue.front();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mQueue.empty();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; mQueue;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="Implement-Queue-using-Stacks-易"><a href="#Implement-Queue-using-Stacks-易" class="headerlink" title="Implement Queue using Stacks(易)"></a>Implement Queue using Stacks(易)</h2><p>\232. Implement Queue using Stacks</p><p>Implement the following operations of a queue using stacks.</p><ul><li>push(x) — Push element x to the back of queue.</li><li>pop() — Removes the element from in front of queue.</li><li>peek() — Get the front element.</li><li>empty() — Return whether the queue is empty.</li></ul><p><strong>Example:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyQueue <span class="built_in">queue</span> = <span class="keyword">new</span> MyQueue();</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>.push(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">queue</span>.push(<span class="number">2</span>);  </span><br><span class="line"><span class="built_in">queue</span>.peek();  <span class="comment">// returns 1</span></span><br><span class="line"><span class="built_in">queue</span>.pop();   <span class="comment">// returns 1</span></span><br><span class="line"><span class="built_in">queue</span>.empty(); <span class="comment">// returns false</span></span><br></pre></td></tr></table></figure><p><strong>Notes:</strong></p><ul><li>You must use <em>only</em> standard operations of a stack — which means only push to top, peek/pop from top, size, and is emptyoperations are valid.</li><li>Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.</li><li>You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).</li></ul><p>class MyQueue {<br>public:<br>    /<em>* Initialize your data structure here. </em>/<br>    MyQueue() {</p><pre><code>}/** Push element x to the back of queue. */void push(int x) {    std::stacktempStack;    while(!mStack.empty()){        tempStack.push(mStack.top());        mStack.pop();    }    mStack.push(x);    while(!tempStack.empty()){        mStack.push(tempStack.top());        tempStack.pop();    }}/** Removes the element from in front of queue and returns that element. */int pop() {    int a = mStack.top();    mStack.pop();    return a;}/** Get the front element. */int peek() {    return mStack.top();}/** Returns whether the queue is empty. */bool empty() {    return mStack.empty();}</code></pre><p>private:<br>    stackmStack;<br>    stacktempStack;<br>};</p><p>/**</p><ul><li>Your MyQueue object will be instantiated and called as such:</li><li>MyQueue obj = new MyQueue();</li><li>obj.push(x);</li><li>int param_2 = obj.pop();</li><li>int param_3 = obj.peek();</li><li>bool param_4 = obj.empty();<br>*/</li></ul><img src="/2019/06/23/LeetCode-栈与队列/01.png"><img src="/2019/06/23/LeetCode-栈与队列/02.png"><img src="/2019/06/23/LeetCode-栈与队列/03.png"><img src="/2019/06/23/LeetCode-栈与队列/04.png"><h2 id="Min-Stack-易"><a href="#Min-Stack-易" class="headerlink" title="Min Stack(易)"></a>Min Stack(易)</h2><img src="/2019/06/23/LeetCode-栈与队列/05.png"><p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p><ul><li>push(x) — Push element x onto stack.</li><li>pop() — Removes the element on top of the stack.</li><li>top() — Get the top element.</li><li>getMin() — Retrieve the minimum element in the stack.</li></ul><p><strong>Example:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MinStack minStack = <span class="keyword">new</span> MinStack();</span><br><span class="line">minStack.push(<span class="number">-2</span>);</span><br><span class="line">minStack.push(<span class="number">0</span>);</span><br><span class="line">minStack.push(<span class="number">-3</span>);</span><br><span class="line">minStack.getMin();   --&gt; Returns <span class="number">-3.</span></span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; Returns <span class="number">0.</span></span><br><span class="line">minStack.getMin();   --&gt; Returns <span class="number">-2.</span></span><br></pre></td></tr></table></figure><p><strong>题目思路：用两个栈，一个正常地存储数据，另一个存储每一步的最小值。</strong></p><img src="/2019/06/23/LeetCode-栈与队列/06.png"><img src="/2019/06/23/LeetCode-栈与队列/07.png"><img src="/2019/06/23/LeetCode-栈与队列/08.png"><img src="/2019/06/23/LeetCode-栈与队列/09.png"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MinStack() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        mStack.push(x);</span><br><span class="line">        <span class="keyword">if</span>(minStack.empty())&#123;</span><br><span class="line">            minStack.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(x &lt; minStack.top())&#123;</span><br><span class="line">                minStack.push(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                minStack.push(minStack.top());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mStack.pop();</span><br><span class="line">        minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mStack.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.top();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; mStack;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; minStack;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="Kth-Largest-Element-in-an-Array（易）"><a href="#Kth-Largest-Element-in-an-Array（易）" class="headerlink" title="Kth Largest Element in an Array（易）"></a>Kth Largest Element in an Array（易）</h2><p>Find the <strong>k</strong>th largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p><p><strong>Example 1:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>] <span class="keyword">and</span> k = <span class="number">2</span></span><br><span class="line">Output: <span class="number">5</span></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>] <span class="keyword">and</span> k = <span class="number">4</span></span><br><span class="line">Output: <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>Note:</strong> </p><p>You may assume k is always valid, 1 ≤ k ≤ array’s length.</p><p><strong>思路：直接用STL中的priority_queue（</strong>PriorityQueue队列,是基于最小堆原理实现<strong>）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>&gt;pQueue;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.size();i++)&#123;</span><br><span class="line">            pQueue.push(nums.at(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k - <span class="number">1</span>;i++)&#123;</span><br><span class="line">            pQueue.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pQueue.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;总结目录&quot;&gt;&lt;a href=&quot;#总结目录&quot; class=&quot;headerlink&quot; title=&quot;总结目录&quot;&gt;&lt;/a&gt;总结目录&lt;/h2&gt;&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;题目&lt;/th&gt;
&lt;t
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yuemingyang7010.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法刷题" scheme="http://yuemingyang7010.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="栈与队列刷题" scheme="http://yuemingyang7010.github.io/tags/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="http://yuemingyang7010.github.io/2019/06/22/LeetCode-%E9%93%BE%E8%A1%A8/"/>
    <id>http://yuemingyang7010.github.io/2019/06/22/LeetCode-链表/</id>
    <published>2019-06-22T05:52:09.000Z</published>
    <updated>2019-07-20T06:38:04.024Z</updated>
    
    <content type="html"><![CDATA[<h2 id="总结目录"><a href="#总结目录" class="headerlink" title="总结目录"></a>总结目录</h2><div class="table-container"><table><thead><tr><th>题目</th><th>难度</th><th>收获与分析</th></tr></thead><tbody><tr><td>1.两数相加(链表表示的)</td><td>中</td><td></td></tr><tr><td>2.链表逆序</td><td>易</td><td>采用头插法，通常申请一个ListNode*新的头指针。</td></tr><tr><td>3.链表逆序II</td><td>中</td><td>类似2，只是需要头尾的连接，保存好需要逆序的序列前驱元素指针和后面元素的首节点指针。</td></tr><tr><td>4.相交链表</td><td>易</td><td>方法1：用set,简单，但是需要开辟额外的空间，空间复杂度O(n);方法2：先统计两个链表的长度，然后再遍历。</td></tr><tr><td>5.判断链表是否存在环</td><td>易</td><td>方法1：用set,很好，但是用了额外空间；方法2：用快慢指针法。</td></tr><tr><td>6.返回链表环的起始节点</td><td>中</td><td>类似5，也有两种方法，重点记住，相遇节点和头结点同样速度朝前遍历，相遇的地方，即为环的起始节点。</td></tr><tr><td>7.划分链表</td><td>中</td><td>采用尾插法，额外申请两个ListNode<em>的节点，以及用于遍历的ListNode</em>指针，将节点val小于X的放在一个链表中，另一部分放…</td></tr><tr><td>8.合并两个有序链表</td><td>易</td><td>同7，采用尾插法，额外申请1个ListNode<em>的节点，以及用于遍历的ListNode</em>指针…</td></tr></tbody></table></div><h2 id="Add-Two-Numbers-中"><a href="#Add-Two-Numbers-中" class="headerlink" title="Add Two Numbers(中)"></a>Add Two Numbers(中)</h2><p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits（数字） are stored（存储） in <strong>reverse order</strong> （逆序）and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p><strong>Example:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: (<span class="number">2</span> -&gt; <span class="number">4</span> -&gt; <span class="number">3</span>) + (<span class="number">5</span> -&gt; <span class="number">6</span> -&gt; <span class="number">4</span>)</span><br><span class="line">Output: <span class="number">7</span> -&gt; <span class="number">0</span> -&gt; <span class="number">8</span></span><br><span class="line">Explanation: <span class="number">342</span> + <span class="number">465</span> = <span class="number">807.</span></span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">-1</span>)</span></span>;   <span class="comment">//头结点，（自己代码缺少头结点，导致后面不好操作）</span></span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        ListNode *prev = &amp;dummy;</span><br><span class="line">        <span class="keyword">for</span> (ListNode *pa = l1, *pb = l2;pa != <span class="literal">nullptr</span> || pb != <span class="literal">nullptr</span>;</span><br><span class="line">        pa = pa == <span class="literal">nullptr</span> ? <span class="literal">nullptr</span> : pa-&gt;next,</span><br><span class="line">        pb = pb == <span class="literal">nullptr</span> ? <span class="literal">nullptr</span> : pb-&gt;next,</span><br><span class="line">        prev = prev-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> ai = pa == <span class="literal">nullptr</span> ? <span class="number">0</span> : pa-&gt;val;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> bi = pb == <span class="literal">nullptr</span> ? <span class="number">0</span> : pb-&gt;val;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> value = (ai + bi + carry) % <span class="number">10</span>;</span><br><span class="line">            carry = (ai + bi + carry) / <span class="number">10</span>;</span><br><span class="line">            prev-&gt;next = <span class="keyword">new</span> ListNode(value);    <span class="comment">//尾插法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry &gt; <span class="number">0</span>)     <span class="comment">//判断最后是否有进位，如果有，多开一个节点</span></span><br><span class="line">            prev-&gt;next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O</em>(max(<em>m</em>,<em>n</em>))，假设 <em>m</em> 和 <em>n</em> 分别表示 <em>l</em>1 和 <em>l</em>2 的长度，上面的算法最多重复 max(<em>m</em>,<em>n</em>)次。</li><li>空间复杂度：<em>O</em>(max(<em>m</em>,<em>n</em>))， 新列表的长度最多为 max(<em>m</em>,<em>n</em>)+1。</li></ul><h2 id="Reverse-Linked-List（易）"><a href="#Reverse-Linked-List（易）" class="headerlink" title="Reverse Linked List（易）"></a>Reverse Linked List（易）</h2><p>反转一个单链表。</p><p>示例:</p><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL<br>进阶:<br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p><p>思路分析：</p><img src="/2019/06/22/LeetCode-链表/01.png"><img src="/2019/06/22/LeetCode-链表/02.png"><img src="/2019/06/22/LeetCode-链表/03.png"><img src="/2019/06/22/LeetCode-链表/04.png"><p><strong>迭代版本：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* pre = <span class="literal">NULL</span>; <span class="comment">//反转后的链表头，相对于旧的链表头为pre  </span></span><br><span class="line">        ListNode* cur = head; <span class="comment">//旧的链表头，为当前节点</span></span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            ListNode* tempNext = cur-&gt;next; <span class="comment">//临时存储旧链表头的下一个节点</span></span><br><span class="line">            cur-&gt;next = pre; <span class="comment">//旧链表头指向新链表头</span></span><br><span class="line">            pre = cur;  <span class="comment">//新链表头指针pre朝前移动一位</span></span><br><span class="line">            cur = tempNext; <span class="comment">//旧链表头更新为旧链表头的下一位                 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>递归版本：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* p = reverseList(head-&gt;next); <span class="comment">//从第二个节点开始反转</span></span><br><span class="line">        head-&gt;next-&gt;next = head;      <span class="comment">//上一步第二个节点反转完了应该处在链表尾，这个时候他的下一个节点接上head节点</span></span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;   <span class="comment">//head-&gt;next信息清掉</span></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2.在剑指offer上给出的是在不改变链表的结构情况下，逆序打印链表，分用栈和递归两种方式实现</p><p>(1)用栈来实现链表的逆序打印</p><p>(2)用递归实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 面试题6：从尾到头打印链表</span></span><br><span class="line"><span class="comment">// 题目：输入一个链表的头结点，从尾到头反过来打印出每个结点的值。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"..\Utilities\List.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintListReversingly_Iteratively</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;ListNode*&gt; nodes;</span><br><span class="line"></span><br><span class="line">    ListNode* pNode = pHead;</span><br><span class="line">    <span class="keyword">while</span>(pNode != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nodes.push(pNode);</span><br><span class="line">        pNode = pNode-&gt;m_pNext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!nodes.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        pNode = nodes.top();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, pNode-&gt;m_nValue);</span><br><span class="line">        nodes.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintListReversingly_Recursively</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pHead != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead-&gt;m_pNext != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            PrintListReversingly_Recursively(pHead-&gt;m_pNext);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, pHead-&gt;m_nValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Reverse-Linked-List-II（中）"><a href="#Reverse-Linked-List-II（中）" class="headerlink" title="Reverse Linked List II（中）"></a>Reverse Linked List II（中）</h2><p><strong>链表逆序II</strong></p><p>\92. Reverse Linked List II</p><p>Reverse a linked list from position <em>m</em> to <em>n</em>. Do it in one-pass.</p><p><strong>Note:</strong> 1 ≤ <em>m</em> ≤ <em>n</em> ≤ length of list.</p><p><strong>Example:</strong></p><p><strong>Input:</strong> 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, <em>m</em> = 2, <em>n</em> = 4 </p><p><strong>Output:</strong> 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</p><img src="/2019/06/22/LeetCode-链表/05.png"><img src="/2019/06/22/LeetCode-链表/06.png"><img src="/2019/06/22/LeetCode-链表/07.png"><img src="/2019/06/22/LeetCode-链表/08.png"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> reverseLength = n - m + <span class="number">1</span>;</span><br><span class="line">        ListNode* pre_head = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* modify_list_tail = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* new_head = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* ans_head = head;       </span><br><span class="line">        <span class="keyword">while</span>(head &amp;&amp; --m)&#123;</span><br><span class="line">            pre_head = head;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        modify_list_tail = head;</span><br><span class="line">        <span class="keyword">while</span>(head &amp;&amp; reverseLength--)&#123;</span><br><span class="line">            ListNode* next = head-&gt;next;</span><br><span class="line">            head-&gt;next = new_head;</span><br><span class="line">            new_head = head;</span><br><span class="line">            head = next;            </span><br><span class="line">        &#125;</span><br><span class="line">        modify_list_tail-&gt;next = head;</span><br><span class="line">        <span class="keyword">if</span>(pre_head)&#123;    <span class="comment">//pre_head为真代表m&gt;1</span></span><br><span class="line">            pre_head-&gt;next = new_head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ans_head = new_head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans_head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Intersection-交点-of-Two-Linked"><a href="#Intersection-交点-of-Two-Linked" class="headerlink" title="Intersection(交点) of Two Linked"></a>Intersection(交点) of Two Linked</h2><p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener"><strong>相交链表</strong></a></p><ol><li>Intersection(交点) of Two Linked Lists</li></ol><img src="/2019/06/22/LeetCode-链表/16.png"><p>Write a program to find the node at which the intersection of two singly linked lists begins.</p><p>For example, the following two linked lists:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A:          a1 → a2</span><br><span class="line">                   ↘</span><br><span class="line">                     c1 → c2 → c3</span><br><span class="line">                   ↗            </span><br><span class="line">B:     b1 → b2 → b3</span><br></pre></td></tr></table></figure><p>begin to intersect at node c1.</p><p><strong>Notes:</strong></p><ul><li>If the two linked lists have no intersection at all, return null.</li><li>The linked lists must retain(保持) their original structure after the function returns.</li><li>You may assume（假定） there are no cycles anywhere in the entire linked structure.</li><li>Your code should preferably run in O(n) time and use only O(1) memory.</li></ul><img src="/2019/06/22/LeetCode-链表/09.png"><img src="/2019/06/22/LeetCode-链表/10.png"><img src="/2019/06/22/LeetCode-链表/11.png"><img src="/2019/06/22/LeetCode-链表/12.png"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//用来计算链表的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listLength</span><span class="params">(ListNode *head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(head)&#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用来返回两个已知长度的链表的相交点的指针</span></span><br><span class="line"><span class="function">ListNode *<span class="title">findIntersection</span><span class="params">(ListNode *headL, ListNode *headS,<span class="keyword">int</span> lengthL,<span class="keyword">int</span> lengthS)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lengthDelt = <span class="number">0</span>;</span><br><span class="line">    lengthDelt = lengthL-lengthS;</span><br><span class="line">    <span class="keyword">while</span>(headL &amp;&amp; lengthDelt--)&#123;</span><br><span class="line">        headL = headL-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(headS)&#123;</span><br><span class="line">        <span class="keyword">if</span>(headL == headS)&#123;</span><br><span class="line">            <span class="keyword">return</span> headL;</span><br><span class="line">        &#125;</span><br><span class="line">        headL = headL-&gt;next;</span><br><span class="line">        headS = headS-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lengthA,lengthB;</span><br><span class="line">        lengthA = listLength(headA);</span><br><span class="line">        lengthB = listLength(headB);</span><br><span class="line">        ListNode *ans;</span><br><span class="line">        <span class="keyword">if</span>(lengthA &gt; lengthB)&#123;</span><br><span class="line">            ans = findIntersection(headA, headB,lengthA,lengthB);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ans = findIntersection(headB, headA,lengthB,lengthA);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2019/06/22/LeetCode-链表/13.png"><img src="/2019/06/22/LeetCode-链表/14.png"><img src="/2019/06/22/LeetCode-链表/15.png"><h2 id="Linked-List-Cycle-易"><a href="#Linked-List-Cycle-易" class="headerlink" title="Linked List Cycle(易)"></a>Linked List Cycle(易)</h2><p>\141. Linked List Cycle</p><p>Given a linked list, determine if it has a cycle in it.</p><p>Follow up:</p><p><strong>Can you solve it without using extra space?</strong></p><p><strong>自己做法，用STL中的set,用了额外的空间。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">set</span>&lt;ListNode*&gt;node_set;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            num++;</span><br><span class="line">            node_set.insert(head);</span><br><span class="line">            <span class="keyword">if</span>(node_set.size() != num)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head-&gt;next;          </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>快慢指针的实现方法如下（思想讲解可参考6中）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  Node *slow = head, *fast = head;</span><br><span class="line">  <span class="keyword">while</span> (slow &amp;&amp; fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">    slow = slow-&gt;next;</span><br><span class="line">    fast = fast-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (slow == fast)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Linked-List-Cycle-II（中）"><a href="#Linked-List-Cycle-II（中）" class="headerlink" title="Linked List Cycle II（中）"></a>Linked List Cycle II（中）</h2><img src="/2019/06/22/LeetCode-链表/17.png"><p>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</p><p><strong>Note:</strong> Do not modify the linked list.</p><p><strong>Follow up</strong>:</p><p><strong>Can you solve it without using extra space?</strong></p><p><strong>自己做法，用STL中的set,用了额外的空间，和5几乎一样。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">set</span>&lt;ListNode*&gt;node_set;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            num++;</span><br><span class="line">            node_set.insert(head);</span><br><span class="line">            <span class="keyword">if</span>(node_set.size() != num)&#123;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head-&gt;next;          </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>经典方法：快慢指针法</strong></p><img src="/2019/06/22/LeetCode-链表/18.png"><img src="/2019/06/22/LeetCode-链表/19.png"><img src="/2019/06/22/LeetCode-链表/20.png"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* low = head;</span><br><span class="line">        ListNode* meet = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//先求出相遇点的位置</span></span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; low &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            low = low-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast == low)&#123;</span><br><span class="line">                meet = fast;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再求出环的交点的位置</span></span><br><span class="line">        <span class="keyword">while</span>(head &amp;&amp; meet)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head == meet)&#123;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            meet = meet-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Partition-（划分）List-中"><a href="#Partition-（划分）List-中" class="headerlink" title="Partition （划分）List(中)"></a>Partition （划分）List(中)</h2><img src="/2019/06/22/LeetCode-链表/21.png"><p>Given a linked list and a value <em>x</em>, partition it such that all nodes less than <em>x</em> come before nodes greater than or equal to <em>x</em>.</p><p>You should preserve the original relative order of the nodes in each of the two partitions.</p><p><strong>Example:</strong></p><p><strong>Input:</strong> head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, <em>x</em> = 3 </p><p><strong>Output:</strong> 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode  <span class="title">lessHead</span><span class="params">(<span class="number">0</span>)</span></span>;       <span class="comment">//设置两个临时节点</span></span><br><span class="line">        <span class="function">ListNode  <span class="title">moreHead</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        ListNode* pLess = &amp;lessHead; <span class="comment">//设置两个指针用于对两个链表的尾插</span></span><br><span class="line">        ListNode* pMore = &amp;moreHead;</span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;val &lt; x)&#123;</span><br><span class="line">                pLess-&gt;next = head;</span><br><span class="line">                pLess = pLess-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                pMore-&gt;next = head;</span><br><span class="line">                pMore = pMore-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pLess-&gt;next = moreHead.next;</span><br><span class="line">        pMore-&gt;next = <span class="literal">NULL</span>;         <span class="comment">//此句要加，不然跑不过，纳闷中...</span></span><br><span class="line">        <span class="keyword">return</span> lessHead.next; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2019/06/22/LeetCode-链表/22.png"><img src="/2019/06/22/LeetCode-链表/23.png"><img src="/2019/06/22/LeetCode-链表/24.png"><img src="/2019/06/22/LeetCode-链表/25.png"><h2 id="Merge-合并-Two-Sorted-Lists-易"><a href="#Merge-合并-Two-Sorted-Lists-易" class="headerlink" title="Merge(合并) Two Sorted Lists(易)"></a>Merge(合并) Two Sorted Lists(易)</h2><img src="/2019/06/22/LeetCode-链表/26.png"><img src="/2019/06/22/LeetCode-链表/27.png"><img src="/2019/06/22/LeetCode-链表/28.png"><ol><li>Merge Two Sorted Lists</li></ol><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p><p>Example:</p><p>Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4</p><p>Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* newHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* pTemp  = newHead;</span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">                pTemp-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                pTemp-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pTemp = pTemp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将比较后某一个原始链表剩余部分直接插到新的链表后方</span></span><br><span class="line">        <span class="keyword">if</span>(l1)&#123;   <span class="comment">//如果l1有剩余</span></span><br><span class="line">            pTemp-&gt;next  = l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l2)&#123;</span><br><span class="line">            pTemp-&gt;next  = l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;总结目录&quot;&gt;&lt;a href=&quot;#总结目录&quot; class=&quot;headerlink&quot; title=&quot;总结目录&quot;&gt;&lt;/a&gt;总结目录&lt;/h2&gt;&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;题目&lt;/th&gt;
&lt;t
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yuemingyang7010.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法刷题" scheme="http://yuemingyang7010.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="链表刷题" scheme="http://yuemingyang7010.github.io/tags/%E9%93%BE%E8%A1%A8%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-其他</title>
    <link href="http://yuemingyang7010.github.io/2019/06/21/%E5%89%91%E6%8C%87offer-%E5%85%B6%E4%BB%96/"/>
    <id>http://yuemingyang7010.github.io/2019/06/21/剑指offer-其他/</id>
    <published>2019-06-21T05:52:09.000Z</published>
    <updated>2019-06-28T06:38:31.735Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>位运算：</p><div class="table-container"><table><thead><tr><th>题目</th><th>难度</th><th></th></tr></thead><tbody><tr><td><a href="note://016376B881D24D5DA4E1252EBAAD3CBB" target="_blank" rel="noopener">不用加减乘除做加法.note</a></td><td>☆☆</td><td>a^b代表不进位的二进制加法，(a&amp;b)&lt;&lt;1为二进制加法所有的进位信息，然后通过循环或者递归，直到进位为0。   扩展题：不使用新的变量，交换两个变量的值</td></tr></tbody></table></div><p>动态规划：</p><div class="table-container"><table><thead><tr><th>题目</th><th>难度</th><th></th></tr></thead><tbody><tr><td><a href="note://E574D3AC0C7D4F1994EE0A3196695E28" target="_blank" rel="noopener">9.变态跳台阶.note</a></td><td>☆</td><td>和动态规划中的跳台阶类似</td></tr><tr><td><a href="note://EE2B5194B93E47D7856EB6CCFA736BF9" target="_blank" rel="noopener">10.矩形覆盖.note</a></td><td>☆</td><td>从简单例子开始推导，得到状态转移方程和斐波那契数列一致。</td></tr></tbody></table></div><p>思维严密性：</p><div class="table-container"><table><thead><tr><th>题目</th><th>难度</th><th></th></tr></thead><tbody><tr><td><a href="note://C7ED1D57EA364E5C9299E2F20BD87951" target="_blank" rel="noopener">16.数值的整数次方.note</a></td><td>☆</td><td>考虑base正负零，exponent正负零。</td></tr></tbody></table></div><h2 id="不用加减乘除做加法"><a href="#不用加减乘除做加法" class="headerlink" title="不用加减乘除做加法"></a>不用加减乘除做加法</h2><p><strong>题目：</strong></p><p>不用加减乘除做加法</p><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p><p><strong>解析：</strong></p><p>　　首先看十进制是如何做的： 5+7=12，三步走</p><p>第一步：相加各位的值，不算进位，得到2。</p><p>第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。</p><p>第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。</p><p>　　</p><p>同样我们可以用三步走的方式计算二进制值相加： 5-101，7-111</p><p>第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。</p><p>第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&amp;111)&lt;&lt;1。</p><p>第三步重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&amp;1010)&lt;&lt;1。 继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(num2 != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = num1^num2; <span class="comment">//二进制不带进位的加法</span></span><br><span class="line">            num2 = (num1 &amp; num2)&lt;&lt;<span class="number">1</span>; <span class="comment">//二进制加法的每一位进位情况</span></span><br><span class="line">            num1 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num1;  <span class="comment">//直到进位为0，返回num1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>扩展题目：</strong></p><p>不使用新的变量，交换两个变量的值</p><p>①基于加减法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a + b; </span><br><span class="line">b = a - b; </span><br><span class="line">a = a - b;</span><br></pre></td></tr></table></figure><p>②基于异或运算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a ^ b; </span><br><span class="line">b = a ^ b; </span><br><span class="line">a = a ^ b;</span><br></pre></td></tr></table></figure><h2 id="变态跳台阶"><a href="#变态跳台阶" class="headerlink" title="变态跳台阶"></a>变态跳台阶</h2><p><strong>题目描述</strong></p><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><p><strong>思路：动态规划</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(number+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(number==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(number == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(number == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=number;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">                dp[i] += dp[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[number];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="矩形覆盖"><a href="#矩形覆盖" class="headerlink" title="矩形覆盖"></a>矩形覆盖</h2><p><strong>题目描述</strong></p><p>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p><p>思路：</p><p>依旧是斐波那契数列</p><p>2<em>n的大矩形，和n个2</em>1的小矩形</p><p>其中target*2为大矩阵的大小</p><p>有以下几种情形：</p><p>1⃣️      target &lt;= 0 大矩形为&lt;= 2*0,直接return 1；</p><p>2⃣️      target = 1大矩形为2*1，只有一种摆放方法，return1；</p><p>3⃣️      target = 2 大矩形为2*2，有两种摆放方法，return2；</p><p>4⃣️      target = n 分为两步考虑：</p><p>​        第一次摆放一块 2*1 的小矩阵，则摆放方法总共为f(target - 1)</p><img src="/2019/06/21/剑指offer-其他/01.png"><p>第一次摆放一块1*2的小矩阵，则摆放方法总共为f(target-2)</p><p>因为，摆放了一块1<em>2的小矩阵（用√√表示），对应下方的1</em>2（用××表示）摆放方法就确定了，所以为f(targte-2)</p><img src="/2019/06/21/剑指offer-其他/02.png"><p>实际是一个动态规划，也是一个斐波那契数列，此处按照斐波那契数列求解;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rectCover</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> prepre = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> cur;</span><br><span class="line">        <span class="keyword">if</span>(number ==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(number == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(number == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=number;i++)&#123;</span><br><span class="line">                cur = prepre + pre;</span><br><span class="line">                prepre = pre;</span><br><span class="line">                pre = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h2><p><strong>题目描述</strong></p><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p><p>思路：重点考察思维的严密性，对于double int 这种数据类型，不能上来就默认为正，分别考虑正、负和零的情况，从而发现以下几种特殊情况：</p><p>（1）底数为0.0，指数为负数，会导致分母为零的异常；</p><p>（2）底数为0.0，指数为0，无意义；</p><p>（3）注意指数分正负两种情况时，数学表达式不同。</p><p>优化：常规思路，在循环中，一直底数*底数，但是当指数不太大时可以考虑采用递归的方式实现如下算式，时间复杂度会大大降低。</p><img src="/2019/06/21/剑指offer-其他/03.png"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(base==<span class="number">0.0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(exponent == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(exponent &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">pow</span>(base,exponent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>/<span class="built_in">pow</span>(base,-exponent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;p&gt;位运算：&lt;/p&gt;
&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;题目&lt;/th
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yuemingyang7010.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="剑指offer" scheme="http://yuemingyang7010.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="http://yuemingyang7010.github.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-链表、队列与栈</title>
    <link href="http://yuemingyang7010.github.io/2019/06/20/%E5%89%91%E6%8C%87offer-%E9%93%BE%E8%A1%A8%E3%80%81%E9%98%9F%E5%88%97%E4%B8%8E%E6%A0%88/"/>
    <id>http://yuemingyang7010.github.io/2019/06/20/剑指offer-链表、队列与栈/</id>
    <published>2019-06-20T05:52:09.000Z</published>
    <updated>2019-06-28T06:30:40.056Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><div class="table-container"><table><thead><tr><th>题目</th><th>难度</th><th></th></tr></thead><tbody><tr><td><a href="note://267A264815194320AE99C6456F7F9067" target="_blank" rel="noopener">6.从尾到头打印链表.note</a></td><td>☆</td><td>即链表逆序，如果不能改变原始链表结构，可用栈</td></tr><tr><td><a href="note://188647273FFD47D28D4BC73B9689F456" target="_blank" rel="noopener">22.链表中倒数第K个节点.note</a></td><td>☆</td><td>快慢指针法</td></tr><tr><td><a href="note://1EB18F62FA924217AF3E9890E393B48F" target="_blank" rel="noopener">25.合并两个排序的链表.note</a></td><td>☆</td><td>先获取新链表头(两链表最小的头)，然后按照递增方式连接，最后将某一个剩余一段的链表直接接上。</td></tr><tr><td><a href="note://A4047F5CE1E345E2917C4B71250C1BFB" target="_blank" rel="noopener">35.复杂链表的复制.note</a></td><td>☆☆☆</td><td>细心！！分三步：1，复制每个节点，插在其后；2，复制每个旧节点的random到新节点；3.拆分节点。</td></tr><tr><td><a href="note://2B3B33D6AFDE4BD98362D2EC0146B083" target="_blank" rel="noopener">圆圈中最后剩下的数.note</a></td><td>☆☆☆</td><td>约瑟夫环问题，采用STL中的list构成环形链表。</td></tr><tr><td></td><td></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>题目</th><th>难度</th><th></th></tr></thead><tbody><tr><td><a href="note://E97F872F78694F578300934A2651FFB5" target="_blank" rel="noopener">9.用两个栈实现队列(易).note</a></td><td>☆</td><td>模拟队列先进先出，一个栈存数据，另一个栈临时放数据。</td></tr><tr><td><a href="note://EFF3BEAF7B584C859F553D330A86E4E2" target="_blank" rel="noopener">30.包含min函数的栈.note</a></td><td>☆</td><td>设置两个栈，一个存放数据，一个存放每一步数据栈中最小的数。</td></tr><tr><td><a href="note://E815AA4D2EF94E8CA776D8A770604A4F" target="_blank" rel="noopener">31.栈的压入、弹出序列.note</a></td><td>☆☆☆</td><td>用一个栈来模拟压入弹出操作。</td></tr><tr><td></td><td></td></tr></tbody></table></div><h2 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h2><p><strong>题目描述</strong></p><p>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</p><p><strong>思路分析：</strong></p><p>其实本题和链表逆序很类似，链表逆序要求改变链表，采用头插法。此题逆序打印链表，一般理解为不改变链表结构，因此采用栈的结构。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  struct ListNode &#123;</span></span><br><span class="line"><span class="comment">*        int val;</span></span><br><span class="line"><span class="comment">*        struct ListNode *next;</span></span><br><span class="line"><span class="comment">*        ListNode(int x) :</span></span><br><span class="line"><span class="comment">*              val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">*        &#125;</span></span><br><span class="line"><span class="comment">*  &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;ListNode*&gt; nodes;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mVector;</span><br><span class="line">        ListNode* pNodes = head;</span><br><span class="line">        <span class="keyword">while</span>(pNodes != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            nodes.push(pNodes);</span><br><span class="line">            pNodes = pNodes-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!nodes.empty())&#123;</span><br><span class="line">            pNodes = nodes.top();</span><br><span class="line">            mVector.push_back(pNodes-&gt;val);</span><br><span class="line">            nodes.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mVector;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="链表中倒数第K个节点"><a href="#链表中倒数第K个节点" class="headerlink" title="链表中倒数第K个节点"></a>链表中倒数第K个节点</h2><p>输入一个链表，输出该链表中倒数第k个结点。</p><p>思路：快慢指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">int val;</span></span><br><span class="line"><span class="comment">struct ListNode *next;</span></span><br><span class="line"><span class="comment">ListNode(int x) :</span></span><br><span class="line"><span class="comment">val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">FindKthToTail</span><span class="params">(ListNode* pListHead, <span class="keyword">unsigned</span> <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = pListHead;</span><br><span class="line">        ListNode* low = pListHead;</span><br><span class="line">        <span class="keyword">while</span>(k &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;   <span class="comment">//防止越界错误！！！要加</span></span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            low = low-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h2><p><strong>题目描述</strong></p><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p><img src="/2019/06/20/剑指offer-链表、队列与栈/01.png"><p>非递归代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">int val;</span></span><br><span class="line"><span class="comment">struct ListNode *next;</span></span><br><span class="line"><span class="comment">ListNode(int x) :</span></span><br><span class="line"><span class="comment">val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">Merge</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead1 ==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> pHead2;</span><br><span class="line">        <span class="keyword">if</span>(pHead2 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> pHead1;</span><br><span class="line">        ListNode* pre_head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* pTemp = pre_head;</span><br><span class="line">        <span class="keyword">while</span>(pHead1 !=<span class="literal">NULL</span> &amp;&amp; pHead2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pHead1-&gt;val &lt; pHead2-&gt;val)&#123;</span><br><span class="line">                pTemp-&gt;next = pHead1;</span><br><span class="line">                pHead1 = pHead1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                pTemp-&gt;next = pHead2;</span><br><span class="line">                pHead2 = pHead2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pTemp = pTemp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将比较后某一个原始链表剩余部分直接插到新的链表后方</span></span><br><span class="line">        <span class="keyword">if</span>(pHead1)</span><br><span class="line">            pTemp-&gt;next = pHead1;</span><br><span class="line">        <span class="keyword">if</span>(pHead2)</span><br><span class="line">            pTemp-&gt;next = pHead2;</span><br><span class="line">        ListNode* ans = pre_head-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> pre_head;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h2><p><strong>题目描述</strong></p><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p><p>思路：(在不借助辅助空间的情况下，实现O(n)的时间效率)</p><p>分为三步走：</p><img src="/2019/06/20/剑指offer-链表、队列与栈/02.png"><img src="/2019/06/20/剑指offer-链表、队列与栈/03.png"><img src="/2019/06/20/剑指offer-链表、队列与栈/04.png"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct RandomListNode &#123;</span></span><br><span class="line"><span class="comment">    int label;</span></span><br><span class="line"><span class="comment">    struct RandomListNode *next, *random;</span></span><br><span class="line"><span class="comment">    RandomListNode(int x) :</span></span><br><span class="line"><span class="comment">            label(x), next(NULL), random(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">RandomListNode* <span class="title">Clone</span><span class="params">(RandomListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//第一步：遍历链表，复制每个结点，如复制结点A得到A1，将结点A1插到结点A后面；</span></span><br><span class="line">        RandomListNode* curNode = pHead;</span><br><span class="line">        <span class="keyword">while</span>(curNode != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            RandomListNode* pCloned = <span class="keyword">new</span> RandomListNode(<span class="number">0</span>);</span><br><span class="line">            pCloned-&gt;label = curNode-&gt;label;</span><br><span class="line">            pCloned-&gt;next = curNode-&gt;next;</span><br><span class="line">            pCloned-&gt;random = <span class="literal">NULL</span>;</span><br><span class="line">            curNode-&gt;next = pCloned;</span><br><span class="line">            curNode = pCloned-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第二步：重新遍历链表，复制老结点的随机指针给新结点，如A1.random = A.random.next;</span></span><br><span class="line">        curNode = pHead;</span><br><span class="line">        <span class="keyword">while</span>(curNode != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            RandomListNode* pCloned = curNode-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(curNode-&gt;random != <span class="literal">NULL</span>)&#123;  <span class="comment">//！！！！很关键的一个判断，不然就出现野指针</span></span><br><span class="line">                pCloned-&gt;random = curNode-&gt;random-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            curNode = pCloned-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第三步：拆分链表，将链表拆分为原链表和复制后的链表</span></span><br><span class="line">        curNode = pHead;</span><br><span class="line">        RandomListNode* pCloneHead = pHead-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(curNode != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            RandomListNode* pCloneNode = curNode-&gt;next;  <span class="comment">//临时存放当前节点的下一个指针</span></span><br><span class="line">            curNode-&gt;next = curNode-&gt;next-&gt;next;  <span class="comment">//原始链表，隔一个节点连接一个</span></span><br><span class="line">            <span class="comment">//复制后链表，隔一个节点连接一个，但是要考虑该节点是最后一个的情况</span></span><br><span class="line">            pCloneNode-&gt;next = pCloneNode-&gt;next == <span class="literal">NULL</span>?<span class="literal">NULL</span>:pCloneNode-&gt;next-&gt;next;</span><br><span class="line">            curNode = curNode-&gt;next;  <span class="comment">//移到下一个原始节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pCloneHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="圆圈中最后剩下的数"><a href="#圆圈中最后剩下的数" class="headerlink" title="圆圈中最后剩下的数"></a>圆圈中最后剩下的数</h2><p>圆圈中最后剩下的数</p><p>题目：0，1，n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p><p><strong>思路：用约瑟夫环的思想</strong></p><p>例如，0、1、2、3、4这5个数字组成一个圆圈（如图6.3所示），从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p><img src="/2019/06/20/剑指offer-链表、队列与栈/05.png"><p>可以用模板库中的std:list来模拟一个环形链表。由于std:：list本身并不是一个环形结构，因此每当迭代器（Iterator）扫描到链表末尾的时候，我们要记得把迭代器移到链表的头部。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">1</span> || m &lt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; mlist;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">mlist.push_back(i);</span><br><span class="line"><span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> it = mlist.begin();</span><br><span class="line"><span class="keyword">int</span> k = m - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (mlist.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (k--) &#123;</span><br><span class="line">it++;</span><br><span class="line"><span class="keyword">if</span> (it == mlist.end())</span><br><span class="line">it = mlist.begin();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">it = mlist.erase(it);</span><br><span class="line"><span class="keyword">if</span> (it == mlist.end())</span><br><span class="line">it = mlist.begin();</span><br><span class="line">k = m - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mlist.front();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="用两个栈实现队列-易"><a href="#用两个栈实现队列-易" class="headerlink" title="用两个栈实现队列(易)"></a>用两个栈实现队列(易)</h2><p><strong>题目描述</strong></p><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!stack1.empty())&#123;</span><br><span class="line">            stack2.push(stack1.top());</span><br><span class="line">            stack1.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">        <span class="keyword">while</span>(!stack2.empty())&#123;</span><br><span class="line">            stack1.push(stack2.top());</span><br><span class="line">            stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> top = stack1.top();</span><br><span class="line">        stack1.pop();</span><br><span class="line">        <span class="keyword">return</span> top;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h2><p><strong>题目描述</strong></p><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</p><img src="/2019/06/20/剑指offer-链表、队列与栈/06.png"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        dataStack.push(value);</span><br><span class="line">        <span class="keyword">if</span>(minStack.empty())&#123;</span><br><span class="line">            minStack.push(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(value &lt; minStack.top())</span><br><span class="line">                minStack.push(value);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                minStack.push(minStack.top());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dataStack.pop();</span><br><span class="line">        minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dataStack.top();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.top();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; dataStack;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; minStack;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h2><p><strong>题目描述</strong></p><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p><p><strong>思路:用一个栈来模拟压入弹出操作。</strong></p><p>如果下一个弹出的数字刚好是栈顶数字, 那么直接弹出;如果下一个弹出的数字不在栈顶, 则把<strong>压栈序列</strong>中还没有入栈的数字压入辅助栈,直到把下一个需要弹出的数字压入栈顶为止;如果所有数字都压入栈后仍然没有找到下一个弹出的数字, 那么该序列不可能是一个弹出序列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsPopOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pushV,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; popV)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pushV.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;pushV.size();i++)&#123;</span><br><span class="line">            dataStack.push(pushV[i]);</span><br><span class="line">            <span class="keyword">while</span>(j&lt;popV.size()&amp;&amp;dataStack.top() == popV[j])&#123;</span><br><span class="line">                dataStack.pop();</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dataStack.empty();  <span class="comment">//若压栈完了，没能全部弹出，说明不是弹出序列，反之是</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; dataStack;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;题目&lt;/th&gt;
&lt;th&gt;难度&lt;/th
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yuemingyang7010.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="剑指offer" scheme="http://yuemingyang7010.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="http://yuemingyang7010.github.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-树</title>
    <link href="http://yuemingyang7010.github.io/2019/06/19/%E5%89%91%E6%8C%87offer-%E6%A0%91/"/>
    <id>http://yuemingyang7010.github.io/2019/06/19/剑指offer-树/</id>
    <published>2019-06-19T05:52:09.000Z</published>
    <updated>2019-06-28T06:28:12.544Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><div class="table-container"><table><thead><tr><th>题目</th><th>难度</th><th></th></tr></thead><tbody><tr><td><a href="note://8DDF3522701B494690B73B66DAD632FD" target="_blank" rel="noopener">7.重建二叉树.note</a></td><td>☆☆☆</td><td>采用递归的方式不断找出根节点和左右子树</td></tr><tr><td><a href="note://053AB99ED0AE4E2BB8B2998BD0231A5C" target="_blank" rel="noopener">树的子结构.note</a></td><td>☆☆☆☆</td><td>第一步在树A中找到和B的根结点的值一样的结点R,第二步再判断树A中以R为根节点的子树是不是包含和树B一样的结构。</td></tr><tr><td><a href="note://BB74C82F4C8142CC98BD69937C0185AD" target="_blank" rel="noopener">二叉树的镜像.note</a></td><td>☆☆</td><td>先交换根节点的左右子节点，再将子节点作为根节点进行递归镜像操作。</td></tr><tr><td><a href="note://604E14887ACB4A54B2DB840DF409A161" target="_blank" rel="noopener">从上往下打印二叉树.note</a></td><td>☆</td><td>根节点入队列，然后出队列，出队时将其左右孩子入队，循环操作进行队列出队，每次出队将其左右孩子入队。当队列为空时，整棵树层序遍历完毕。</td></tr><tr><td><a href="note://3FE09CB0553C4995AD5C56B1C18156BD" target="_blank" rel="noopener">二叉搜索树的后序遍历序列.note</a></td><td>☆☆</td><td><strong>BST的后序序列的合法序列</strong>是，对于一个序列S，最后一个元素是x （也就是根），如果去掉最后一个元素的序列为T，那么T满足：T可以分成两段，前一段（左子树）小于x，后一段（右子树）大于x，且这两段（子树）都是合法的后序序列。完美的递归定义。</td></tr><tr><td><a href="note://D0DBBA55ED06432BA749C0EAAF85AFBA" target="_blank" rel="noopener">36.二叉搜索树与双向链表.note</a></td><td>☆☆</td><td>改造中序遍历，设置一个pre和cur，将中序遍历打印的过程替换为前后连接pre和cur</td></tr><tr><td><a href="note://1A9A17C46DAF4E429528B2BA288CEBC1" target="_blank" rel="noopener">二叉树深度.note</a></td><td>☆</td><td>采用尾递归的方式</td></tr><tr><td><a href="note://5138177E05AC400A82052CE734DB2196" target="_blank" rel="noopener">55.判断树是否为平衡二叉树.note</a></td><td>☆☆</td><td>性质：是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。  <strong>因此递归函数每次要计算出子树的高度。</strong></td></tr><tr><td></td><td></td></tr></tbody></table></div><h2 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h2><p><strong>题目描述</strong></p><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><p><strong>解题思路：采用递归方法</strong></p><img src="/2019/06/19/剑指offer-树/01.png"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">reConstructBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> reConstruct(pre,<span class="number">0</span>,pre.size()<span class="number">-1</span>,vin,<span class="number">0</span>,vin.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">reConstruct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre,<span class="keyword">int</span> startPre,<span class="keyword">int</span> endPre,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vin,<span class="keyword">int</span> startIn,<span class="keyword">int</span> endIn)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(startPre &gt; endPre||startIn &gt; endIn)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(pre[startPre]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=startIn;i&lt;=endIn;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vin[i] == pre[startPre])&#123;</span><br><span class="line">                root-&gt;left = reConstruct(pre,startPre + <span class="number">1</span>,startPre+i-startIn,vin,startIn,i<span class="number">-1</span>);</span><br><span class="line">                root-&gt;right = reConstruct(pre,startPre+i-startIn+<span class="number">1</span>,endPre,vin,i+<span class="number">1</span>,endIn);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h2><p><strong>题目描述</strong></p><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p><p><strong>解题思路</strong></p><p>要查找树A中是否存在和树B结构一样的子枘我们可以分为两步：第一步在树A中找到和B的根结点的值一样的结点R,第二步再判断树A中以R为根节点的子树是不是包含和树B一样的结构。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">int val;</span></span><br><span class="line"><span class="comment">struct TreeNode *left;</span></span><br><span class="line"><span class="comment">struct TreeNode *right;</span></span><br><span class="line"><span class="comment">TreeNode(int x) :</span></span><br><span class="line"><span class="comment">val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">HasSubtree</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span>  <span class="comment">//二叉树的前序遍历</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot1 != <span class="literal">NULL</span> &amp;&amp; pRoot2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pRoot1-&gt;val == pRoot2-&gt;val)</span><br><span class="line">                result = DoseTreeHaveTree2(pRoot1,pRoot2);</span><br><span class="line">            <span class="keyword">if</span>(!result)</span><br><span class="line">                result = HasSubtree(pRoot1-&gt;left,pRoot2);</span><br><span class="line">            <span class="keyword">if</span>(!result)</span><br><span class="line">                result = HasSubtree(pRoot1-&gt;right,pRoot2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断以pRoot1为根节点的树中是否有以pRoot2为根节点的树</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">DoseTreeHaveTree2</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot2 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot1 == <span class="literal">NULL</span> || pRoot1-&gt;val != pRoot2-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> DoseTreeHaveTree2(pRoot1-&gt;left,pRoot2-&gt;left)&amp;&amp;DoseTreeHaveTree2(pRoot1-&gt;right,pRoot2-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h2><p><strong>题目描述</strong></p><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p><p><strong>输入描述:</strong></p><p>二叉树的镜像定义：</p><p>源二叉树             </p><p>​         8            </p><p>​       /             </p><p>​    6   10          </p><p>   /    /           </p><p> 5  7 9  11         </p><p>镜像二叉树             </p><p>​         8           </p><p>​        /             </p><p>​     10   6          </p><p>​     /    /           </p><p>  11  9  7   5</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">int val;</span></span><br><span class="line"><span class="comment">struct TreeNode *left;</span></span><br><span class="line"><span class="comment">struct TreeNode *right;</span></span><br><span class="line"><span class="comment">TreeNode(int x) :</span></span><br><span class="line"><span class="comment">val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode *pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            TreeNode *temp = pRoot-&gt;left;</span><br><span class="line">            pRoot-&gt;left = pRoot-&gt;right;</span><br><span class="line">            pRoot-&gt;right = temp;</span><br><span class="line">            <span class="keyword">if</span>(pRoot-&gt;left)&#123;</span><br><span class="line">                Mirror(pRoot-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pRoot-&gt;right)&#123;</span><br><span class="line">                Mirror(pRoot-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="从上往下打印二叉树"><a href="#从上往下打印二叉树" class="headerlink" title="从上往下打印二叉树"></a>从上往下打印二叉树</h2><p><strong>题目描述</strong></p><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p><p>思路：参考<a href="note://wcp153494909997195" target="_blank" rel="noopener">二叉树的递归与非递归遍历（前序、中序、后序、层序）</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">int val;</span></span><br><span class="line"><span class="comment">struct TreeNode *left;</span></span><br><span class="line"><span class="comment">struct TreeNode *right;</span></span><br><span class="line"><span class="comment">TreeNode(int x) :</span></span><br><span class="line"><span class="comment">val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; PrintFromTopToBottom(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        mQueue.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!mQueue.empty())&#123;</span><br><span class="line">            TreeNode* temp = mQueue.front();</span><br><span class="line">            result.push_back(temp-&gt;val);</span><br><span class="line">            mQueue.pop();</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;left)</span><br><span class="line">                mQueue.push(temp-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;right)</span><br><span class="line">                mQueue.push(temp-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; mQueue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="二叉搜索树的后序遍历序列"><a href="#二叉搜索树的后序遍历序列" class="headerlink" title="二叉搜索树的后序遍历序列"></a>二叉搜索树的后序遍历序列</h2><p><strong>题目描述</strong></p><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p><p><strong>思路：</strong></p><p>BST的后序序列的合法序列是，对于一个序列S，最后一个元素是x （也就是根），如果去掉最后一个元素的序列为T，那么T满足：T可以分成两段，前一段（左子树）小于x，后一段（右子树）大于x，且这两段（子树）都是合法的后序序列。完美的递归定义 : ) 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> juge(sequence,<span class="number">0</span>,sequence.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">juge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sequence,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//从右向左寻找右子树所对应的序列</span></span><br><span class="line">        <span class="keyword">int</span> i=right<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i&gt;=left &amp;&amp; sequence[i]&gt;sequence[right];i--);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;=left;j--)&#123;  <span class="comment">//寻找左子树对应的序列</span></span><br><span class="line">            <span class="keyword">if</span>(sequence[j]&gt;sequence[right])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归判断左子树和右子树是不是都符合条件，注意最后一个参数为right-1 ！！！</span></span><br><span class="line">        <span class="keyword">return</span> juge(sequence,left,i)&amp;&amp;juge(sequence,i+<span class="number">1</span>,right<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h2><p><strong>题目描述</strong></p><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p><p><strong>解题思路：</strong></p><p>该结构特点可以类比到双向链表中： </p><p>在双向链表中，每个结点也有两个指针，它们分别指向前一个结点和后一个结点。</p><p>所以这两种数据结构的结点是一致，二叉搜索树之所以为二叉搜索树，双向链表之所以为双向链表，只是因为两个指针的指向不同而已，通过改变其指针的指向来实现是完全可能的。</p><img src="/2019/06/19/剑指offer-树/02.png"><p><strong>具体实现步骤：</strong> </p><p>原先指向左子结点的指针调整为链表中指向前一个结点的指针，原先指向右子结点的指针调整为链表中指向下一个结点的指针。 </p><p>具体转换过程：按照中序遍历的方法遍历二叉搜索树，可以将该二叉树分为三个部分：根节点、左子树和右子树，当遍历结点值为4的节点时，将它分为以2为节点的左子树和以6为节点的右子树，并将4的左指针指向值为3的结点，值为3的节点的右指针指向值为4的结点，因为采用的是中序遍历，所以当遍历到根节点的时候，它的左子树已经遍历结束了，所以要对所有的子树采用递归的执行上述操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">int val;</span></span><br><span class="line"><span class="comment">struct TreeNode *left;</span></span><br><span class="line"><span class="comment">struct TreeNode *right;</span></span><br><span class="line"><span class="comment">TreeNode(int x) :</span></span><br><span class="line"><span class="comment">val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Convert</span><span class="params">(TreeNode* pRootOfTree)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TreeNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">        Tree2list(pRootOfTree,&amp;pre);  <span class="comment">//运行完之后pre对应最后一个节点</span></span><br><span class="line">        TreeNode* pHead = pre;</span><br><span class="line">        <span class="keyword">while</span>(pHead != <span class="literal">NULL</span> &amp;&amp; pHead-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">            pHead = pHead-&gt;left;</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Tree2list</span><span class="params">(TreeNode* root,TreeNode** pre)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">            Tree2list(cur-&gt;left,pre);</span><br><span class="line">        </span><br><span class="line">        cur-&gt;left = *pre;   <span class="comment">//当前节点连接前一个节点</span></span><br><span class="line">        <span class="keyword">if</span>(*pre != <span class="literal">NULL</span>)    <span class="comment">//前一个节点连接当前节点</span></span><br><span class="line">            (*pre)-&gt;right = cur;</span><br><span class="line">        *pre = cur;        <span class="comment">//更新当前节点为前一个节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">            Tree2list(cur-&gt;right,pre);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="二叉树深度"><a href="#二叉树深度" class="headerlink" title="二叉树深度"></a>二叉树深度</h2><p><strong>题目描述</strong></p><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p><p><strong>思路：采用递归的方式</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">int val;</span></span><br><span class="line"><span class="comment">struct TreeNode *left;</span></span><br><span class="line"><span class="comment">struct TreeNode *right;</span></span><br><span class="line"><span class="comment">TreeNode(int x) :</span></span><br><span class="line"><span class="comment">val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode* pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lDepth = TreeDepth(pRoot-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> rDepth = TreeDepth(pRoot-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> lDepth&gt;rDepth?(lDepth+<span class="number">1</span>):(rDepth+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="判断树是否为平衡二叉树"><a href="#判断树是否为平衡二叉树" class="headerlink" title="判断树是否为平衡二叉树"></a>判断树是否为平衡二叉树</h2><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p><p>平衡二叉树性质：是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p><p>思路：</p><p>方法一（不合适，需要重复遍历节点多次，耗时长O(n^2)））</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* pRoot)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(pRoot == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">int</span> left = maxDepth(pRoot-&gt;left);</span><br><span class="line"><span class="keyword">int</span> right = maxDepth(pRoot-&gt;right);</span><br><span class="line"><span class="keyword">int</span> diff = left-right;</span><br><span class="line"><span class="keyword">if</span>(diff &lt;<span class="number">-1</span> || diff &gt;<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> isBalanced(pRoot-&gt;left)&amp;&amp;isBalanced(pRoot-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二：</strong></p><p>用后序遍历的方式遍历整棵二叉树。在遍历某节点的左、右子节点之后，我们可以根据它的左、右子节点的深度判断它是不是平衡的，并得到当前节点的深度。当最后遍历到树的根节点的时候，也就判断了整棵二叉树是不是平衡二叉树。</p><p> //<strong>后续遍历</strong>时，遍历到一个节点，其左右子树已经遍历  依次自底向上判断，每个节点只需要遍历一次</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> isBalanced(pRoot,depth);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* pRoot,<span class="keyword">int</span> &amp;depth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(isBalanced(pRoot-&gt;left,left) &amp;&amp; isBalanced(pRoot-&gt;right,right))&#123;</span><br><span class="line">            <span class="keyword">int</span> dif = left-right;</span><br><span class="line">            <span class="keyword">if</span>(dif &lt; <span class="number">-1</span> || dif &gt; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            depth = left &gt; right?(left+<span class="number">1</span>):(right+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;题目&lt;/th&gt;
&lt;th&gt;难度&lt;/th
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yuemingyang7010.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="剑指offer" scheme="http://yuemingyang7010.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="http://yuemingyang7010.github.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-数组</title>
    <link href="http://yuemingyang7010.github.io/2019/06/18/%E5%89%91%E6%8C%87offer-%E6%95%B0%E7%BB%84/"/>
    <id>http://yuemingyang7010.github.io/2019/06/18/剑指offer-数组/</id>
    <published>2019-06-18T05:52:09.000Z</published>
    <updated>2019-07-26T08:47:02.753Z</updated>
    
    <content type="html"><![CDATA[<h3 id="天平与假币"><a href="#天平与假币" class="headerlink" title="天平与假币"></a>天平与假币</h3><p>有12枚硬币，其中有且只有1枚是假币，其重量与真币不同，但不知是重还是轻。现给定一祭没有砝码的天平，问至少需要多少次称量才能确保找到这枚假币？</p><p><strong>解释：</strong></p><p>随机将12枚硬币等分成3份，每份4枚；标记为A、B、C三份。<br>将A放于左侧，B放于右侧，用天平称量A和B，分三种情况：<br>1.天平平衡<br>2.A（左）比B（右）重</p><p>3.A（左）比B（右）轻口与2对称，只分析2即可</p><p><strong>核心讲解：</strong></p><img src="/2019/06/18/剑指offer-数组/08.png"><img src="/2019/06/18/剑指offer-数组/07.png"><p><strong>理论下界</strong><br>一次天平称量能得到左倾、右倾、平衡3种情况，则把一次称量当成一位编码，该编码是3进制的。问题转换为：需要多少位编码，能够表示12呢？<br>(1)由于12的轻重未知，有两种可能，因此，需要用3进制表示24。<br>    答：假定需要n位，则：3^n &gt;= 24<br>(2)取对数后计算得到n = 2.89，这表示至少3次才能找到该假币。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><div class="table-container"><table><thead><tr><th>题目</th><th>难度</th><th></th></tr></thead><tbody><tr><td><a href="note://93AEF8BA6AA7487889D90A38FEFB6EFB" target="_blank" rel="noopener">1.二维数组中的查找(..).note</a></td><td>☆</td><td>从右上角到左下角进行查找</td></tr><tr><td><a href="note://9934046F6A364AF2AB3F9E2001172611" target="_blank" rel="noopener">11.旋转数组的最小数字.note</a></td><td>☆☆☆</td><td>采用分治的思想，递归地将数组进行二分区，然后找到最小的数（时间复杂度logn   顺序查找O(n)）</td></tr><tr><td><a href="note://1D28A716E2644F2896A9783B4422806D" target="_blank" rel="noopener">10.斐波那契数列.note</a></td><td>☆</td><td>很简单，考虑节省空间复杂度，用循环代替递归。</td></tr><tr><td><a href="note://74A9846762214F99B65C28886B2F5886" target="_blank" rel="noopener">21.调整数组顺序使奇数位于偶数前面.note</a></td><td>☆</td><td>用两个指针，一个遍历数组，一个指向存放奇数的位置，都从0开始，偶数暂时放在另一个vector中，先将奇数存放在奇数指针指向的位置，最后再存偶数。</td></tr><tr><td><a href="note://04273EDFA38342CF8F045D9929092182" target="_blank" rel="noopener">顺时针打印矩阵.note</a></td><td>☆☆</td><td>考虑全面：m×n,m×1,1×n,1×1几种情况都要考虑；流程控制采用top、down、left、right四个变量来控制。</td></tr><tr><td><a href="note://54E9B5A378AF4CAA89BAAA4B51CC98F6" target="_blank" rel="noopener">39.数组中出现次数超过一半的数字.note</a></td><td>☆☆</td><td>在遍历数组时保存两个值：一是数组中一个数字，一是次数。遍历下一个数字时，若它与之前保存的数字相同，则次数加1，否则次数减1；若次数为0，则保存下一个数字，并将次数置为1。遍历结束后，所保存的数字即为所求。</td></tr><tr><td><a href="note://40706EC19933414FAD962C18B084C1EA" target="_blank" rel="noopener">40.最小的K个数.note</a></td><td>☆</td><td>TOPk问题</td></tr><tr><td><a href="note://AB0F15EF819F450B8CE63334ADC3170F" target="_blank" rel="noopener">52.在排序数组中查找数字.note</a></td><td>☆☆</td><td>考虑查找效率，总体思路是找到第一个K位置和最后一个K的位置，作差加一求出个数。可以采取递归方式二分查找，也可直接通过循环二分查找，不过大神的<strong>通过查找K-0.5和K+0.5更加简洁高效。</strong></td></tr><tr><td><a href="note://533C7FFFB40C4CB49945680548E9F990" target="_blank" rel="noopener">56.数组中只出现一次的两个数字.note</a></td><td>☆☆</td><td>先将所有数依次异或，结果和两个单一数异或相同，从右开始找到结果中第一个为1的位，以此为标准将数分成两类，再将两类分别异或，得到的就是两个单数。<strong>注意大坑！！！ a &amp; flag != 0;和(a &amp; flag) !=0;结果不同。</strong></td></tr><tr><td><a href="note://3D914AA5A5E54B25B59FD5140A85343E" target="_blank" rel="noopener">57(2).和为S的连续正数序列.note</a></td><td>☆☆</td><td>用两个数small和big分别表示序列的最小值和最大值。首先把small初始化为1，big初始化为2。如果从small到big的序列的和大于s，则可以从序列中去掉较小的值，也就是增大small的值。如果从small到big的序列的和小于s，则可以增大big，让这个序列包含更多的数字。因为这个序列至少要有两个数字，我们一直增加small到（1+s）/2为止。</td></tr><tr><td><a href="note://2266DA7FAFA247DC85E399041FA1EEDB" target="_blank" rel="noopener">57(1).和为S的两个数字.note</a></td><td>☆☆</td><td>类似与<a href="note://3D914AA5A5E54B25B59FD5140A85343E" target="_blank" rel="noopener">57(2).和为S的连续正数序列.note</a>做法，只不过，只不过本题左指针开始指向数组最左端，右指针指向最右端。</td></tr><tr><td></td><td></td><td></td></tr><tr><td><a href="note://1222CD0B205943C898C7F5CE8FD72F1B" target="_blank" rel="noopener">扑克牌顺子.note</a></td><td>☆☆</td><td>第一步：排序；第二步：统计0的个数，统计间隙的个数；第三步:间隙数大于0个数返回false，间隙数小于0的个数，更新0的个数，继续统计后面的数字是否有间隙。同时在此过程中也要统计前后两个数是否有重复情况，重复返回false。</td></tr><tr><td><a href="note://8912A6F7345E4239A3BACA1DBBB3E926" target="_blank" rel="noopener">2.数组中重复的数字.note</a></td><td>☆☆</td><td>从头到尾依次扫描数组元素，当扫描到第i个元素m时，当m等于i时，继续遍历下一元素，当不等于i时，则拿他与第m个数n比较，如果m=n，则找到重复元素，返回true,否则交换两元素…</td></tr><tr><td><a href="note://637AF30B91D443ADB65E4DE36FD82A10" target="_blank" rel="noopener">3.构建乘积数组.note</a></td><td>☆☆</td><td>求B[i]的时候分为两步，先求左侧所有的A相乘，再求右侧的所有的A相乘，最终将两者相乘即得相应的B。具体通过两次循环，累乘得到不同的B[i]</td></tr><tr><td></td><td></td></tr></tbody></table></div><h2 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h2><p><strong>题目描述</strong></p><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong>解题思路：</strong></p><p>首先选取数组中<strong>右上角的数字</strong>，</p><p>【1】如果该数字等于要查的数字，则查找结束；</p><p>【2】如果该数字大于要查找的数字，则剔除该数字所在的列,如(a)；</p><p>【3】如果该数字小于要查找的数字，则剔除该数字所在的行，如(c)</p><img src="/2019/06/18/剑指offer-数组/01.png"><p>代码实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="built_in">array</span>.size();</span><br><span class="line">        <span class="keyword">int</span> col = <span class="built_in">array</span>[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = col<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; row &amp;&amp; j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target &lt; <span class="built_in">array</span>[i][j])&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; <span class="built_in">array</span>[i][j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h2><p><strong>题目描述</strong></p><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><p><strong>思路：</strong></p><p>正常情况：</p><img src="/2019/06/18/剑指offer-数组/02.png"><p>特殊情况：</p><p>（1）数组为排序好的数组，发现arry[left] &lt; arry[right]则认为是排序好的数组，去首元素返回；</p><p>（2）arry[left] = arry[right] = arry[mid]时，用顺序遍历查找，如下</p><img src="/2019/06/18/剑指offer-数组/03.png"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = rotateArray.size();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> rotateArray[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>; <span class="comment">//用于特殊情况1：将排序好的数组前面0个元素旋转到后面</span></span><br><span class="line">        <span class="keyword">while</span>(rotateArray[left] &gt;= rotateArray[right])&#123;</span><br><span class="line">            <span class="keyword">if</span>(right - left ==<span class="number">1</span>)&#123;</span><br><span class="line">                mid = right;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//特殊情况2：首尾中三个元素大小相等，只能采用顺序查找，如｛1，0，1，1，1｝ 和 ｛1，1， 1，0，1｝</span></span><br><span class="line">            <span class="keyword">if</span>(rotateArray[left] == rotateArray[right] &amp;&amp; rotateArray[left] == rotateArray[mid])</span><br><span class="line">                <span class="keyword">return</span> minInorder(rotateArray,left,right);</span><br><span class="line">            <span class="keyword">if</span>(rotateArray[mid] &gt;= rotateArray[left])</span><br><span class="line">                left = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(rotateArray[mid] &lt;= rotateArray[right])</span><br><span class="line">                right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rotateArray[mid];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minInorder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rotateArray,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = rotateArray[left];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=left + <span class="number">1</span>;i&lt;=right;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(result &gt; rotateArray[i])</span><br><span class="line">                result = rotateArray[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p><strong>题目描述</strong></p><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39</p><p><strong>思路：</strong></p><p>用非递归的方式解题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> last2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> last1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cur;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">2</span>;i--)&#123;</span><br><span class="line">                cur = last1 + last2;</span><br><span class="line">                last2 = last1;</span><br><span class="line">                last1 = cur;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="调整数组顺序使奇数位于偶数前面"><a href="#调整数组顺序使奇数位于偶数前面" class="headerlink" title="调整数组顺序使奇数位于偶数前面"></a>调整数组顺序使奇数位于偶数前面</h2><p><strong>题目描述</strong></p><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的<strong>相对位置不变。（书上的方法是顺序可变）</strong></p><p><strong>思路：</strong></p><p>顺序遍历vector,将偶数放在一个queue里面，遇到奇数按顺序覆盖之前的vector，待vector遍历完了，将queue中的数再放到vector的后面。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; evenQueue;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">array</span>.size();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>||n==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> oddIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isEven(<span class="built_in">array</span>[i]))&#123;</span><br><span class="line">                evenQueue.push(<span class="built_in">array</span>[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">array</span>[oddIndex++] = <span class="built_in">array</span>[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(oddIndex &lt; n)&#123;</span><br><span class="line">            <span class="built_in">array</span>[oddIndex++] = evenQueue.front();</span><br><span class="line">            evenQueue.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEven</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (number &amp; <span class="number">1</span>) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h2><p><strong>题目描述</strong></p><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p><img src="/2019/06/18/剑指offer-数组/04.png"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; matrix) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.size();</span><br><span class="line">        <span class="keyword">if</span>(row == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> down = row<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = col<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(top &lt;= down &amp;&amp; left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;=right;i++)</span><br><span class="line">                result.push_back(matrix[top][i]);</span><br><span class="line">            top++;</span><br><span class="line">            <span class="keyword">if</span>(top &gt; down || left &gt; right) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=top;i&lt;=down;i++)</span><br><span class="line">                result.push_back(matrix[i][right]);</span><br><span class="line">            right--;</span><br><span class="line">            <span class="keyword">if</span>(top &gt; down || left &gt; right) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=right;i&gt;=left;i--)</span><br><span class="line">                result.push_back(matrix[down][i]);</span><br><span class="line">            down--;</span><br><span class="line">            <span class="keyword">if</span>(top &gt; down || left &gt; right) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=down;i&gt;=top;i--)</span><br><span class="line">                result.push_back(matrix[i][left]);</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span>(top &gt; down || left &gt; right) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a>数组中出现次数超过一半的数字</h2><p><strong>题目描述</strong></p><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p><p>分析：</p><p>如果将这个数组排序，那么中位数一定是要求得这数；</p><p><strong>思路：</strong></p><p>方法一：用sort先排序，然后中间数即为所求；时间复杂度O(nlogn)</p><p>方法二：采用用户“分形叶”思路（注意到目标数 超过数组长度的一半，对数组同时去掉两个不同的数字，到最后剩下的一个数就是该数字。如果剩下两个，那么这两个也是一样的，就是结果），在其基础上把最后剩下的一个数字或者两个回到原来数组中，将数组遍历一遍统计一下数字出现次数进行最终判断。</p><p>方法三：借鉴快排思想，用时间复杂度为O(n)的partition()函数实现，但是总体的复杂度可能最差时候达到O(n^2) （剑指offer的方法）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (numbers.size() &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> midIndex = numbers.size() &gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> end = numbers.size() - <span class="number">1</span>;</span><br><span class="line">index = partition(numbers, start, end);</span><br><span class="line"><span class="keyword">while</span> (index != midIndex)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (index &lt; midIndex)</span><br><span class="line">&#123;</span><br><span class="line">start = index + <span class="number">1</span>;</span><br><span class="line">index = partition(numbers,start,end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">end = end - <span class="number">1</span>;</span><br><span class="line">index = partition(numbers, start, end);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> result = numbers[midIndex];</span><br><span class="line"><span class="keyword">if</span> (!isMoreThanHalf(numbers, result))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//快排中用于找分界点的函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pivot = numbers[left];</span><br><span class="line"><span class="keyword">int</span> start = left;</span><br><span class="line"><span class="keyword">int</span> end = right;</span><br><span class="line"><span class="keyword">while</span> (start != end)&#123;</span><br><span class="line"><span class="keyword">while</span> (start &lt; end &amp;&amp; numbers[end] &gt; pivot)</span><br><span class="line">end--;</span><br><span class="line"><span class="keyword">while</span> (start &lt; end &amp;&amp; numbers[start] &lt;= pivot)</span><br><span class="line">start++;</span><br><span class="line"><span class="keyword">if</span> (start &lt; end)</span><br><span class="line">swap(numbers[start], numbers[end]);</span><br><span class="line">&#125;</span><br><span class="line">swap(numbers[left], numbers[start]);</span><br><span class="line"><span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//检测数组中数是否满足题目中交代的"数组中有一个数字出现的次数超过数组长度的一半"条件</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMoreThanHalf</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers, <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> times = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> isMoreThanHalf = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.size(); i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (numbers[i] == num)</span><br><span class="line">times++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (times * <span class="number">2</span> &lt;= numbers.size())&#123;</span><br><span class="line">isMoreThanHalf = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> isMoreThanHalf;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方法四：如果有符合条件的数字，则它出现的次数比其他所有数字出现的次数和还要多。<strong>在遍历数组时保存两个值：一是数组中一个数字，一是次数。遍历下一个数字时，若它与之前保存的数字相同，则次数加1，否则次数减1；若次数为0，则保存下一个数字，并将次数置为1。遍历结束后，所保存的数字即为所求。</strong>然后再判断它是否符合条件即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers.empty()) <span class="keyword">return</span> <span class="number">0</span>;         </span><br><span class="line">        <span class="comment">// 遍历每个元素，并记录次数；若与前一个元素相同，则次数加1，否则次数减1</span></span><br><span class="line">        <span class="keyword">int</span> result = numbers[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> times = <span class="number">1</span>; <span class="comment">// 次数</span></span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;numbers.size();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(times == <span class="number">0</span>)  <span class="comment">//每次加减times之前都要判断下是否在遍历上一个元素的时候置为0</span></span><br><span class="line">            &#123;  </span><br><span class="line">                result = numbers[i];</span><br><span class="line">                times = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i] == result)</span><br><span class="line">                ++times; <span class="comment">// 相同则加1</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                --times; <span class="comment">// 不同则减1               </span></span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="comment">// 检测所给的数组是否存在这样一个数</span></span><br><span class="line">        times = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numbers.size();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i] == result) ++times;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> (times &gt; numbers.size()/<span class="number">2</span>) ? result : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="最小的K个数"><a href="#最小的K个数" class="headerlink" title="最小的K个数"></a>最小的K个数</h2><p><strong>题目描述</strong></p><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。</p><p><strong>思路：</strong></p><p>可以采用快速排序，也可以采用堆排序(尤其适合动态的排序和海量数据排序)</p><p>下面提供堆排序代码，采用STL中的堆排序，可参考：<a href="note://1CC6153444B54CF39D58B77F8667A677" target="_blank" rel="noopener">10.堆heap.note</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; GetLeastNumbers_Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = input.size();</span><br><span class="line">        <span class="keyword">if</span>(len &lt;=<span class="number">0</span> || k&gt;len)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(k+<span class="number">1</span>);  </span><br><span class="line"><span class="comment">/*将input中元素全部拷贝到res开始的位置中,注意拷贝的区间为input.begin() ~ input.end()的左闭右开的区间*/</span></span><br><span class="line">        res.assign(input.begin(),input.begin()+k);</span><br><span class="line">        <span class="comment">//实际编程需要包含头文件&lt;algorithm&gt;建堆,默认创建的是最大堆，堆顶为首元素，若要创建最小堆，第三个参数为greater&lt;int&gt;()</span></span><br><span class="line">        make_heap(res.begin(),res.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(input[i]&lt;res[<span class="number">0</span>])&#123;</span><br><span class="line">                res.push_back(input[i]);</span><br><span class="line">                push_heap(res.begin(),res.end());</span><br><span class="line">                </span><br><span class="line">                pop_heap(res.begin(),res.end());</span><br><span class="line">                res.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>或者直接采用priority_queue</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; GetLeastNumbers_Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = input.size();</span><br><span class="line">        <span class="keyword">if</span>(len &lt;=<span class="number">0</span> ||k&lt;=<span class="number">0</span> || k &gt; len)  <span class="comment">//注意K的范围，之前一直编译不过，就是因为漏掉了k&lt;=0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>&gt; heap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">            heap.push(input[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(input[i] &lt; heap.top())&#123;</span><br><span class="line">                heap.pop();</span><br><span class="line">                heap.push(input[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result(k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            result[i] = heap.top();</span><br><span class="line">            heap.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="在排序数组中查找数字"><a href="#在排序数组中查找数字" class="headerlink" title="在排序数组中查找数字"></a>在排序数组中查找数字</h2><p><strong>题目描述</strong></p><p>统计一个数字在排序数组中出现的次数。</p><p>思路1：<strong>直接用二分法找出要找的数字K</strong>，然后通过两个while()循环，分别朝前和后扫描，得到K的个数；  <strong>但是当K的个数较多时，前后扫描相当于顺序查找，时间复杂度仍然很高。</strong></p><p>思路二：用二分法，采用递归的方式，分别找到第一个K的下标和，最后一个K的下标，然后根据两个下标的差得出K的个数，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data ,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(data.size() &lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> first = getFirstK(data,k,<span class="number">0</span>,data.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> last = getLastK(data,k,<span class="number">0</span>,data.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(first==<span class="number">-1</span> || last==<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> last-first+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getFirstK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data,<span class="keyword">int</span> k,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;     <span class="comment">//数组中不包含数字，返回-1</span></span><br><span class="line">        <span class="keyword">int</span> mid = (start+end)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(data[mid]==k)&#123;</span><br><span class="line">            <span class="keyword">if</span>((mid&gt;<span class="number">0</span> &amp;&amp; data[mid<span class="number">-1</span>] != k)||mid==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(data[mid]&gt;k)</span><br><span class="line">            end = mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            start = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> getFirstK(data,k,start,end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLastK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data,<span class="keyword">int</span> k,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;    <span class="comment">//数组中不包含数字，返回-1</span></span><br><span class="line">        <span class="keyword">int</span> mid = (start+end)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(data[mid]==k)&#123;</span><br><span class="line">            <span class="keyword">if</span>((mid &lt; data.size()<span class="number">-1</span> &amp;&amp; data[mid+<span class="number">1</span>] != k)||mid==data.size()<span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(data[mid]&gt;k)</span><br><span class="line">            end = mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            start = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> getLastK(data,k,start,end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>思路三：和思路二类似，不采用递归的方式，直接用二分法，注意易错点！！！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data ,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = firstk(data,k);</span><br><span class="line">        <span class="keyword">int</span> right = lastk(data,k);</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">-1</span> || right == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> right-left+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstk</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = data.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(data[mid] == k)&#123;</span><br><span class="line">                <span class="keyword">if</span>((mid<span class="number">-1</span>&gt;=left &amp;&amp; data[mid<span class="number">-1</span>]!= k) || mid==left)</span><br><span class="line">                    <span class="keyword">return</span> mid;</span><br><span class="line"><span class="comment">//！！！！犯错处，当mid位和mid-1位均等于k，取right=mid-1,不然可能出现死循环。</span></span><br><span class="line">                right = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(data[mid] &lt;k)</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid<span class="number">-1</span>;</span><br><span class="line">            mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastk</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = data.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(data[mid] == k)&#123;</span><br><span class="line">                <span class="keyword">if</span>((mid+<span class="number">1</span>&lt;=right &amp;&amp; data[mid+<span class="number">1</span>]!=k) || mid==right)</span><br><span class="line">                    <span class="keyword">return</span> mid;</span><br><span class="line"><span class="comment">//！！！！犯错处，当mid位和mid+1位均等于k，取left=mid+1,不然可能出现死循环。</span></span><br><span class="line">                left = mid+<span class="number">1</span>;  </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(data[mid] &lt;k)</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid<span class="number">-1</span>;</span><br><span class="line">            mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>思路四：(大神思路)</p><p>由于data中都是整数，所以可以稍微变一下，不是搜索k的两个位置，而是搜索<strong>k-0.5</strong>和<strong>k+0.5</strong></p><p>//这两个数应该插入的位置，然后相减即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data ,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> biSearch(data, k+<span class="number">0.5</span>) - biSearch(data, k<span class="number">-0.5</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">biSearch</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; data, <span class="keyword">double</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, e = data.size()<span class="number">-1</span>;     </span><br><span class="line">        <span class="keyword">while</span>(s &lt;= e)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (e - s)/<span class="number">2</span> + s;</span><br><span class="line">            <span class="keyword">if</span>(data[mid] &lt; num)</span><br><span class="line">                s = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(data[mid] &gt; num)</span><br><span class="line">                e = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="数组中只出现一次的两个数字"><a href="#数组中只出现一次的两个数字" class="headerlink" title="数组中只出现一次的两个数字"></a>数组中只出现一次的两个数字</h2><p><strong>题目描述</strong></p><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p><p><strong>知识补充：</strong></p><p><a href="https://www.cnblogs.com/suoloveyou/archive/2012/04/25/2470292.html" target="_blank" rel="noopener">异或的性质及运用</a></p><p> 异或是一种基于二进制的位运算，用符号XOR或者 ^ 表示，其运算法则是对运算符两侧数的每一个二进制位，同值取0，异值取1。它与布尔运算的区别在于，当运算符两侧均为1时，布尔运算的结果为1，异或运算的结果为0。</p><p>简单理解就是不进位加法，如1+1=0，,0+0=0,1+0=1。</p><p>性质</p><p><strong>1、交换律</strong></p><p><strong>2、**</strong>结合律（即(a^b)^c == a^(b^c)）  重点！！！**</p><p><strong>3、对于任何数x，都有x^x=0，x^0=x</strong></p><p><strong>4、**</strong>自反性 A XOR B XOR B = A xor  0 = A**</p><p><strong>思路：</strong></p><p>要求时间复杂度是O(n)，空间复杂度是O(1)。</p><p>大家首先想到的是顺序扫描法，但是这种方法的时间复杂度是O（n^2）。接着大家又会考虑用哈希表的方法，但是空间复杂度不是O（1）。</p><p>我们知道异或的一个性质是：<strong>任何一个数字异或它自己都等于0</strong>。也就是说，如果我们从头到尾依次异或数组中的每一个数字，那么最终的结果刚好是那个只出现一次的数字。比如数组{4,5,5}，我们先用数组中的第一个元素4（二进制形式：0100）和数组中的第二个元素5（二进制形式：0101）进行异或操作，0100和0101异或得到0001，用这个得到的元素与数组中的三个元素5（二进制形式：0101）进行异或操作，0001和0101异或得到0100，正好是结果数字4。这是因为数组中相同的元素异或是为0的，<strong>因此就只剩下那个不成对的孤苦伶仃元素。</strong></p><p>现在好了，我们已经知道了如何找到一个数组中找到一个只出现一次的数字，那么我们如何在一个数组中找到两个只出现一次的数字呢？如果，我们可以将原始数组分成两个子数组，使得每个子数组包含一个只出现一次的数字，而其他数字都成对出现。这样，我们就可以用上述方法找到那个<strong>孤苦伶仃的元素。</strong></p><p>我们还是从头到尾一次异或数组中的每一个数字，那么最终得到的结果就是两个只出现一次的数组的异或结果。<strong>因为其他数字都出现了两次，在异或中全部抵消了。</strong>由于两个数字肯定不一样，那么异或的结果肯定不为0，也就是说这个结果数组的二进制表示至少有一个位为1。我们在结果数组中找到第一个为1的位的位置，记为第n位。现在我们以第n位是不是1为标准把元数组中的数字分成两个子数组，第一个子数组中每个数字的第n位都是1，而第二个子数组中每个数字的第n位都是0。</p><p>举例：{2,4,3,6,3,2,5,5}</p><p>我们依次对数组中的每个数字做异或运行之后，得到的结果用二进制表示是0010。异或得到结果中的倒数第二位是1，于是我们根据数字的倒数第二位是不是1分为两个子数组。第一个子数组{2,3,6,3,2}中所有数字的倒数第二位都是1，而第二个子数组{4,5,5}中所有数字的倒数第二位都是0。接下来只要分别两个子数组求异或，就能找到第一个子数组中只出现一次的数字是6，而第二个子数组中只出现一次的数字是4。</p><p><strong>思路总结：</strong></p><p>本文思路有两大亮点：【1】一个整数数组中如果除了其中一个数以外，其他数都出现了两次，将这些数相异或得到的是这个单一的数。【2】如何将两个单一的数字分到两批数中，将所有数异或，得到的结果其实就是两个单一数字的异或结果，根据其中某一位是否为1将两个数字分开，其他数字也根据这个标准分成了两批。   最终分成的两批数字中，每一批数字中，只有一个单一数字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data,<span class="keyword">int</span>* num1,<span class="keyword">int</span> *num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = data.size();</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//对原始数组每个元素依次求异或(异或为位运算)</span></span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">            temp ^= data[i];</span><br><span class="line">        <span class="keyword">int</span> indexOf1 = rfindFirst1(temp);</span><br><span class="line">        *num1 =<span class="number">0</span>;</span><br><span class="line">        *num2 =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isBit1(data[i],indexOf1))</span><br><span class="line">                *num1 ^=data[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                *num2 ^=data[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//从右找到某个数二进制形式下第一次出现1的下标</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rfindFirst1</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> bit1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((num &amp; bit1)== <span class="number">0</span> &amp;&amp; (index &lt; <span class="number">8</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>)))&#123;</span><br><span class="line">            bit1 = bit1&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断某个数index位是否为1</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBit1</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        num = num&gt;&gt;index;</span><br><span class="line">        <span class="keyword">return</span> (num &amp; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>二刷的时候，最终对每个数移位的时候不是通过对该数移动、位之后再判断其是否为1，而是直接通过位与，直接判断相应位是否为1，<strong>但是遇见了个大坑！！！</strong></p><p><strong>直接写 a &amp; flag != 0;会判断错误</strong></p><p><strong>经验教训！！！，该多加个括号的时候不要吝啬！！！！</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data, <span class="keyword">int</span>* num1, <span class="keyword">int</span> *num2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = data.size();</span><br><span class="line"><span class="keyword">if</span> (len &lt; <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">temp ^= data[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> ((temp &amp; flag) == <span class="number">0</span>) &#123;</span><br><span class="line">flag = flag &lt;&lt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">*num1 = <span class="number">0</span>;</span><br><span class="line">*num2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="comment">//bool aa = isfalag1(data[i], flag);</span></span><br><span class="line"><span class="keyword">if</span> (isfalag1(data[i], flag)) &#123;</span><br><span class="line">*num1 ^= data[i];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"第1组"</span> &lt;&lt; data[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">*num2 ^= data[i];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"第2组"</span> &lt;&lt; data[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//通过与flag相位与，判断每个数相对于temp中从右到左的第一个为1的位是否为1</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isfalag1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> flag)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> ((a &amp; flag) != <span class="number">0</span>) <span class="comment">//大坑！！！直接写 a &amp; flag != 0;会判断错误</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="和为S的连续正数序列"><a href="#和为S的连续正数序列" class="headerlink" title="和为S的连续正数序列"></a>和为S的连续正数序列</h2><p><strong>题目描述</strong></p><p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!</p><p><strong>输出描述:</strong></p><p>输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序</p><p>有了解决前面问题的经验，我们也考虑用两个数small和big分别表示序列的最小值和最大值。首先把small初始化为1，big初始化为2。如果从small到big的序列的和大于s，则可以从序列中去掉较小的值，也就是增大small的值。如果从small到big的序列的和小于s，则可以增大big，让这个序列包含更多的数字。因为这个序列至少要有两个数字，我们一直增加small到（1+s）/2为止。</p><p>{asset_img 05.png}</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; FindContinuousSequence(<span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; result;</span><br><span class="line">        <span class="keyword">if</span>(sum &lt;<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (<span class="number">1</span>+sum)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; mid)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum == calculate(left,right))&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;=right;i++)</span><br><span class="line">                    temp.push_back(i);</span><br><span class="line">                result.push_back(temp);</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; calculate(left,right))</span><br><span class="line">                right++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=a;i&lt;=b;i++)</span><br><span class="line">            sum += i;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="和为S的两个数字"><a href="#和为S的两个数字" class="headerlink" title="和为S的两个数字"></a>和为S的两个数字</h2><p><strong>题目描述</strong></p><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p><p><strong>输出描述:</strong></p><p>对应每个测试案例，输出两个数，小的先输出。</p><p>思路：</p><p>方法1：(耗时长)这个问题，很多人都能立即想到O（n2）的方法，也就是先在数组中固定一个数字，再依次判断数组中其余的n-1个数字与它的和是不是等于s。</p><p>方法2：我们以数组{1，2，4，7，11，15}及期待的和15为例详细分析一下这个过程。首先定义两个指针，第一个指针指向数组的第一个（最小的）数字1，第二个指针指向数组的最后一个（最大的）数字15。这两个数字的和16大于15，因此我们把第二个指针向前移动一个数字，让它指向11。这时候两个数字1与11的和是12，小于15。接下来我们把第一个指针向后移动一个数字指向2，此时两个数字2与11的和是13，还是小于15。我们再次向后移动第一个指针，让它指向数字4。数字4与11的和是15，正是我们期待的结果。表6.1总结了在数组{1，2，4，7，11，15}中查找和为15的数对的过程。</p><p>{asset_img 06.png}</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; FindNumbersWithSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>,<span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">array</span>.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(len &lt;<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = len<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">long</span> minMulti = <span class="built_in">array</span>[right]*<span class="built_in">array</span>[right];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[left]+<span class="built_in">array</span>[right]==sum)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">array</span>[left] * <span class="built_in">array</span>[right] &lt; minMulti)&#123;</span><br><span class="line">                    minMulti = <span class="built_in">array</span>[left] * <span class="built_in">array</span>[right];</span><br><span class="line">                    <span class="keyword">if</span>(result.size() == <span class="number">0</span>)&#123;</span><br><span class="line">                        result.push_back(<span class="built_in">array</span>[left]);</span><br><span class="line">                        result.push_back(<span class="built_in">array</span>[right]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        result.pop_back();</span><br><span class="line">                        result.pop_back();</span><br><span class="line">                        result.push_back(<span class="built_in">array</span>[left]);</span><br><span class="line">                        result.push_back(<span class="built_in">array</span>[right]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">array</span>[left]+<span class="built_in">array</span>[right] &lt; sum)</span><br><span class="line">                left++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">array</span>[left]+<span class="built_in">array</span>[right] &gt; sum)</span><br><span class="line">                right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="扑克牌顺子"><a href="#扑克牌顺子" class="headerlink" title="扑克牌顺子"></a>扑克牌顺子</h2><p><strong>题目：</strong></p><p>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2~10为数字本身，A为1，J为11，Q为12，K为13，而大、小王可以看成任意数字。在本题中看作0。</p><p><strong>思路：</strong></p><p>判断5个数字是不是连续的。</p><p>第一步：排序；</p><p>第二步：统计0的个数，统计间隙的个数，<strong>注意：</strong>统计间隙的时候不能和0作运算，非0数字不能重复；</p><p>第三步:间隙数大于0个数返回false，间隙数小于等于0的个数返回true。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsContinuous</span><span class="params">( <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = numbers.size();</span><br><span class="line">        <span class="keyword">if</span>(len != <span class="number">5</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        sort(numbers.begin(),numbers.end());</span><br><span class="line">        <span class="keyword">int</span> zeronum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;  <span class="comment">//统计0的个数</span></span><br><span class="line">            <span class="keyword">if</span>(numbers[i]==<span class="number">0</span>)</span><br><span class="line">                zeronum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pre=numbers[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> diffCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> cur = numbers[i];</span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="number">0</span>&amp;&amp; pre !=<span class="number">0</span>)&#123;  <span class="comment">//要考虑，计算间隙的时候，不能和0作运算，如[3,0,2,6,4]</span></span><br><span class="line">                <span class="keyword">if</span>(cur == pre)   <span class="comment">//要考虑数相等的情况，如[1,0,0,1,0]</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                diffCount += (cur-pre<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            pre = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> zeronum&gt;=diffCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h2><p>题目描述(数组)</p><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p><p><strong>一、可以改变数组</strong></p><p>【方法1】先把输入的数组排序(sort())，然后遍历数组，找出重复元素，时间复杂度为O(nlogn);</p><p>【方法2】<strong>时间复杂度为O(n),空间复杂度为O(1)</strong>  </p><p>思路：从头到尾依次扫描数组元素，当扫描到第i个元素m时，当m等于i时，继续遍历下一元素，当不等于i时，则拿他与第m个数n比较，如果m=n，则找到重复元素，返回true,否则交换两元素…</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果数组为空，或者输入的长度小于等于0</span></span><br><span class="line">        <span class="keyword">if</span>(numbers == <span class="literal">nullptr</span>||length &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//确保数组中每个数在0~length-1之间</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i]&lt;<span class="number">0</span> || numbers[i] &gt; length<span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i != numbers[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(numbers[i] == numbers[numbers[i]])</span><br><span class="line">                &#123;</span><br><span class="line">                    *duplication = numbers[i];</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//交换第i和第numbers[i]个数</span></span><br><span class="line">                <span class="keyword">int</span> temp = numbers[i];</span><br><span class="line">                numbers[i] = numbers[temp];</span><br><span class="line">                numbers[temp] = temp;<span class="comment">//注意该句千万不要写成numbers[numbers[i]] = temp;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>二、不能改变数组</strong></p><p>【方法1】创建一个长度为length的辅助数组，然后逐一把原数组的每一个数字复制到辅助数组，这样很容易找到重复数字，时间复杂度O(N),空间复杂度O(N)。</p><p>【方法2】用STL中的set,将数组中的数，插入set,当set的大小不变的时候，所插入的数字即为重复数字。</p><h2 id="构建乘积数组"><a href="#构建乘积数组" class="headerlink" title="构建乘积数组"></a>构建乘积数组</h2><p><strong>题目描述</strong></p><p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]</em>A[i+1]<em>…</em>A[n-1]。不能使用除法。</p><p><strong>思路：</strong></p><p>求B[i]的时候分为两步，先求左侧所有的A相乘，再求右侧的所有的A相乘，最终将两者相乘即得相应的B。具体通过两次循环，累乘得到不同的B[i]，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; multiply(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = A.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; B(len);</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> B;</span><br><span class="line"><span class="comment">//总结：第0位和第n-1位为特殊情况，其对应左侧和右侧乘积均当做1，for循环都从第二位和倒数第二位起</span></span><br><span class="line">        B[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//此处的B[0]代表第0位前A[i]的乘积，初始化为1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;  <span class="comment">//累乘求第1位到第n-1位前面所有A[i]的乘积</span></span><br><span class="line">            B[i] = B[i<span class="number">-1</span>]*A[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">1</span>; <span class="comment">//此处的temp代表最后1位后面A[i]的乘积，对应的是最后一位，所以初始化为1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;<span class="comment">//累乘求第n-2位到第0位前面所有A[i]的乘积</span></span><br><span class="line">            temp *=A[i+<span class="number">1</span>];</span><br><span class="line">            B[i] *= temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;天平与假币&quot;&gt;&lt;a href=&quot;#天平与假币&quot; class=&quot;headerlink&quot; title=&quot;天平与假币&quot;&gt;&lt;/a&gt;天平与假币&lt;/h3&gt;&lt;p&gt;有12枚硬币，其中有且只有1枚是假币，其重量与真币不同，但不知是重还是轻。现给定一祭没有砝码的天平，问至少需要多少次
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yuemingyang7010.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="剑指offer" scheme="http://yuemingyang7010.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="http://yuemingyang7010.github.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>socket编程(Windows下实现)</title>
    <link href="http://yuemingyang7010.github.io/2019/05/18/socket%E7%BC%96%E7%A8%8B-Windows%E4%B8%8B%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yuemingyang7010.github.io/2019/05/18/socket编程-Windows下实现/</id>
    <published>2019-05-18T06:52:09.000Z</published>
    <updated>2019-06-27T12:11:51.340Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/18/socket编程-Windows下实现/001.png"><p>服务器端代码 server.cpp：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment (lib, <span class="meta-string">"ws2_32.lib"</span>)  <span class="comment">//加载 ws2_32.dll</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化 DLL</span></span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    WSAStartup( MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    SOCKET servSock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定套接字</span></span><br><span class="line">    sockaddr_in sockAddr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;sockAddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(sockAddr));  <span class="comment">//每个字节都用0填充</span></span><br><span class="line">    sockAddr.sin_family = PF_INET;  <span class="comment">//使用IPv4地址</span></span><br><span class="line">    sockAddr.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>);  <span class="comment">//具体的IP地址</span></span><br><span class="line">    sockAddr.sin_port = htons(<span class="number">1234</span>);  <span class="comment">//端口</span></span><br><span class="line">    bind(servSock, (SOCKADDR*)&amp;sockAddr, <span class="keyword">sizeof</span>(SOCKADDR));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进入监听状态</span></span><br><span class="line">    listen(servSock, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收客户端请求</span></span><br><span class="line">    SOCKADDR clntAddr;</span><br><span class="line">    <span class="keyword">int</span> nSize = <span class="keyword">sizeof</span>(SOCKADDR);</span><br><span class="line">    SOCKET clntSock = accept(servSock, (SOCKADDR*)&amp;clntAddr, &amp;nSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向客户端发送数据</span></span><br><span class="line">    <span class="keyword">char</span> *str = <span class="string">"Hello World!"</span>;</span><br><span class="line">    send(clntSock, str, <span class="built_in">strlen</span>(str)+<span class="keyword">sizeof</span>(<span class="keyword">char</span>), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭套接字</span></span><br><span class="line">    closesocket(clntSock);</span><br><span class="line">    closesocket(servSock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//终止 DLL 的使用</span></span><br><span class="line">    WSACleanup();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码 client.cpp：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">"ws2_32.lib"</span>)  <span class="comment">//加载 ws2_32.dll</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化DLL</span></span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    SOCKET sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向服务器发起请求</span></span><br><span class="line">    sockaddr_in sockAddr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;sockAddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(sockAddr));  <span class="comment">//每个字节都用0填充</span></span><br><span class="line">    sockAddr.sin_family = PF_INET;</span><br><span class="line">    sockAddr.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>);</span><br><span class="line">    sockAddr.sin_port = htons(<span class="number">1234</span>);</span><br><span class="line">    connect(sock, (SOCKADDR*)&amp;sockAddr, <span class="keyword">sizeof</span>(SOCKADDR));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收服务器传回的数据</span></span><br><span class="line">    <span class="keyword">char</span> szBuffer[MAXBYTE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    recv(sock, szBuffer, MAXBYTE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出接收到的数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Message form server: %s\n"</span>, szBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭套接字</span></span><br><span class="line">    closesocket(sock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//终止使用 DLL</span></span><br><span class="line">    WSACleanup();</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  Windows 下的 socket 程序和 Linux 思路相同，但细节有所差别：<br>1) Windows 下的 socket 程序依赖 Winsock.dll 或 ws2_32.dll，必须提前加载。DLL 有两种加载方式，请查看：<a href="http://c.biancheng.net/cpp/html/2754.html" target="_blank" rel="noopener">动态链接库DLL的加载</a></p><p>2) Linux 使用“文件描述符”的概念，而 Windows 使用“文件句柄”的概念；Linux 不区分 socket 文件和普通文件，而 Windows 区分；Linux 下 socket() 函数的返回值为 int 类型，而 Windows 下为 SOCKET 类型，也就是句柄。</p><p><strong>3) Linux 下使用 read() / write() 函数读写，而 Windows 下使用 recv() / send() 函数发送和接收。</strong></p><p><strong>4) 关闭 socket 时，Linux 使用 close() 函数，而 Windows 使用 closesocket() 函数。</strong>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/18/socket编程-Windows下实现/001.png&quot;&gt;
&lt;p&gt;服务器端代码 server.cpp：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;p
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yuemingyang7010.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="socket编程" scheme="http://yuemingyang7010.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/socket%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="计算机网络" scheme="http://yuemingyang7010.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="socket编程" scheme="http://yuemingyang7010.github.io/tags/socket%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>socket编程(Linux下实现)</title>
    <link href="http://yuemingyang7010.github.io/2019/05/17/socket%E7%BC%96%E7%A8%8B-Linux%E4%B8%8B%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yuemingyang7010.github.io/2019/05/17/socket编程-Linux下实现/</id>
    <published>2019-05-17T06:52:09.000Z</published>
    <updated>2019-06-27T09:14:18.881Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/05/17/socket编程-Linux下实现/002.png"><p> Linux 下的代码，server.cpp 是服务器端代码，client.cpp 是客户端代码，要实现的<strong>功能是：客户端从服务器读取一个字符串并打印出来。</strong></p><p>服务器端代码 server.cpp：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    <span class="keyword">int</span> serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将套接字和IP、端口绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_addr));  <span class="comment">//每个字节都用0填充</span></span><br><span class="line">    serv_addr.sin_family = AF_INET;  <span class="comment">//使用IPv4地址</span></span><br><span class="line">    serv_addr.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>);  <span class="comment">//具体的IP地址</span></span><br><span class="line">    serv_addr.sin_port = htons(<span class="number">1234</span>);  <span class="comment">//端口</span></span><br><span class="line">    bind(serv_sock, (struct sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进入监听状态，等待用户发起请求</span></span><br><span class="line">    listen(serv_sock, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收客户端请求</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clnt_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clnt_addr_size = <span class="keyword">sizeof</span>(clnt_addr);</span><br><span class="line">    <span class="keyword">int</span> clnt_sock = accept(serv_sock, (struct sockaddr*)&amp;clnt_addr, &amp;clnt_addr_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向客户端发送数据</span></span><br><span class="line">    <span class="keyword">char</span> str[] = <span class="string">"Hello World!"</span>;</span><br><span class="line">    write(clnt_sock, str, <span class="keyword">sizeof</span>(str));</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//关闭套接字</span></span><br><span class="line">    close(clnt_sock);</span><br><span class="line">    close(serv_sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码 client.cpp：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    <span class="keyword">int</span> sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向服务器（特定的IP和端口）发起请求</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_addr));  <span class="comment">//每个字节都用0填充</span></span><br><span class="line">    serv_addr.sin_family = AF_INET;  <span class="comment">//使用IPv4地址</span></span><br><span class="line">    serv_addr.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>);  <span class="comment">//具体的IP地址</span></span><br><span class="line">    serv_addr.sin_port = htons(<span class="number">1234</span>);  <span class="comment">//端口</span></span><br><span class="line">    connect(sock, (struct sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//读取服务器传回的数据</span></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">40</span>];</span><br><span class="line">    read(sock, buffer, <span class="keyword">sizeof</span>(buffer)<span class="number">-1</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Message form server: %s\n"</span>, buffer);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//关闭套接字</span></span><br><span class="line">    close(sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先编译 server.cpp 并运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[admin@localhost ~]$ g++ server.cpp -o server</span><br><span class="line">[admin@localhost ~]$ ./server</span><br></pre></td></tr></table></figure><p>正常情况下，程序运行到 accept() 函数就会被阻塞，等待客户端发起请求。</p><p>////////////////////////////////////////////////////////////////////////</p><p>接下来编译 client.cpp 并运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[admin@localhost ~]$ g++ client.cpp -o client</span><br><span class="line">[admin@localhost ~]$ ./client</span><br><span class="line">Message form server: Hello World!</span><br></pre></td></tr></table></figure><p>client 运行后，通过 connect() 函数向 server 发起请求，处于监听状态的 server 被激活，执行 accept() 函数，接受客户端的请求，然后执行 write() 函数向 client 传回数据。client 接收到传回的数据后，connect() 就运行结束了，然后使用 read() 将数据读取出来。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/05/17/socket编程-Linux下实现/002.png&quot;&gt;
&lt;p&gt; Linux 下的代码，server.cpp 是服务器端代码，client.cpp 是客户端代码，要实现的&lt;strong&gt;功能是：客户端从服务器读取一个字符串并打印出来。&lt;/
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yuemingyang7010.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="socket编程" scheme="http://yuemingyang7010.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/socket%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="计算机网络" scheme="http://yuemingyang7010.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="socket编程" scheme="http://yuemingyang7010.github.io/tags/socket%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++面试题(1)</title>
    <link href="http://yuemingyang7010.github.io/2019/04/03/C-%E9%9D%A2%E8%AF%95%E9%A2%981/"/>
    <id>http://yuemingyang7010.github.io/2019/04/03/C-面试题1/</id>
    <published>2019-04-03T05:52:09.000Z</published>
    <updated>2019-09-06T09:32:55.114Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么标准头文件都有类似以下的结构？"><a href="#为什么标准头文件都有类似以下的结构？" class="headerlink" title="为什么标准头文件都有类似以下的结构？"></a>为什么标准头文件都有类似以下的结构？</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __INCvxWorksh</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __INCvxWorksh </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br><span class="line"><span class="comment">/*...*/</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __INCvxWorksh */</span></span></span><br></pre></td></tr></table></figure><p>头文件中的编译宏 </p><h1 id="ifndef-INCvxWorksh"><a href="#ifndef-INCvxWorksh" class="headerlink" title="ifndef　INCvxWorksh"></a>ifndef　INCvxWorksh</h1><h1 id="define-INCvxWorksh"><a href="#define-INCvxWorksh" class="headerlink" title="define　__INCvxWorksh"></a>define　__INCvxWorksh</h1><h1 id="endif"><a href="#endif" class="headerlink" title="endif"></a>endif</h1><p>的作用是防止被重复引用。 </p><p>后的str仍然为NULL；<br>1：传入形参并不能真正改变形参的值，执行完之后为空；<br>2：在函数GetMemory中和Test中没有malloc对应的free，造成内存泄露</p><h3 id="Linux内存分区-常见两种分法"><a href="#Linux内存分区-常见两种分法" class="headerlink" title="Linux内存分区(常见两种分法)"></a>Linux内存分区(常见两种分法)</h3><h3 id="判断是大端存储还是小端存储"><a href="#判断是大端存储还是小端存储" class="headerlink" title="判断是大端存储还是小端存储"></a>判断是大端存储还是小端存储</h3><p>【解答】 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkCPU</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">union</span> w&#123; </span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">char</span> b;</span><br><span class="line">&#125; c;</span><br><span class="line">c.a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> (c.b == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【剖析】<br>嵌入式系统开发者应该对Little-endian和Big-endian模式非常了解。采用Little-endian模式的CPU对操作数的存放方式是从低字节到高字节，而Big-endian模式对操作数的存放方式是从高字节到低字节。</p><p>32bit宽的数0x12345678在Little-endian模式CPU内存中的存放方式（假设从地址0x4000开始存放）为： </p><div class="table-container"><table><thead><tr><th>内存地址</th><th>存放内容</th></tr></thead><tbody><tr><td>0x4000</td><td>0x78</td></tr><tr><td>0x4001</td><td>0x56</td></tr><tr><td>0x4002</td><td>0x34</td></tr><tr><td>0x4003</td><td>0x12</td></tr></tbody></table></div><p>结构体和共用体的区别在于：结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。</p><p>结构体占用的内存大于等于所有成员占用的内存的总和（成员之间可能会存在缝隙），共用体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。</p><p><strong>分析：</strong>共用体的各个成员是共用一段内存的。1 是数据的低位，如果 1 被存储在 data 的低字节，就是小端模式，这个时候 data.ch 的值也是 1。如果 1 被存储在 data 的高字节，就是大端模式，这个时候 data.ch 的值就是 0。</p><h3 id="说一下C-和C的区别"><a href="#说一下C-和C的区别" class="headerlink" title="说一下C++和C的区别"></a>说一下C++和C的区别</h3><p>参考回答:</p><p>设计思想上：<br>C++是面向对象的语言，而C是面向过程的结构化编程语言</p><p>语法上：</p><p>C++具有封装、继承和多态三种特性</p><p>C++相比C，增加多许多类型安全的功能，比如强制类型转换、</p><p>C++支持范式编程，比如模板类、函数模板等</p><h3 id="说一说c-中四种cast转换"><a href="#说一说c-中四种cast转换" class="headerlink" title="说一说c++中四种cast转换"></a>说一说c++中四种cast转换</h3><p><a href="https://blog.csdn.net/xiaonan153/article/details/81381381" target="_blank" rel="noopener">参考1</a></p><p><a href="https://www.cnblogs.com/cauchy007/p/4968707.html" target="_blank" rel="noopener">参考2</a></p><p><strong>static_cast转换</strong></p><p>　　1.基本用法：static_cast<type-id> expression</type-id></p><p>　　2.使用场景：</p><p>　　<strong>a、</strong>用于类层次结构中<strong>基类和派生类之间</strong>指针或引用的转换(<strong>不一定构成多态</strong>)</p><p>　　上行转换（派生类——&gt;基类）是安全的；</p><p>　　下行转换（基类——&gt;派生类）由于没有动态类型检查，所以是不安全的。</p><p>　　b、用于<strong>基本数据类型之间</strong>的转换，如把int转换为char，这种带来安全性问题由程序员来保证</p><p>　　c、把空指针转换成目标类型的空指针</p><p>　　d、把任何类型的表达式转为void类型</p><p>　　3.使用特点</p><p>　　a、主要执行非多态的转换操作，用于代替C中通常的转换操作</p><p>　　b、隐式转换都建议使用static_cast进行标明和替换</p><p><strong>dynamic_cast转换</strong></p><p>基本用法：dynamic_cast<type-id> expression<br>（1）其他三种都是编译时完成的，dynamic_cast是运行时处理的，<strong>运行时要进行类型检查。</strong><br>（2）不能用于内置的基本数据类型的强制转换。<br>（3）dynamic_cast转换如果成功的话返回的是指向类的指针或引用，转换失败的话则会返回NULL。<br>（4）<strong>使用dynamic_cast进行转换的，基类中一定要有虚函数，否则编译不通过。</strong><br>        需要检测有虚函数的原因：类中存在虚函数，就说明它有想要让基类指针或引用指向派生类对象的情况，此时转换才有意义。<br>        这是由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表（关于虚函数表的概念，详细可见<inside c++ object model>）中，<br>        只有定义了虚函数的类才有虚函数表。<br>（5） <strong>在类的转换时，在类层次间进行上行转换</strong>时，dynamic_cast和static_cast的效果是一样的。在进行下行转换 时，dynamic_cast具有类型检查的功能，比static_cast更安全。向上转换即为指向子类对象的向下转换，即将父类指针转化子类指针。向下转换的成功与否还与将要转换的类型有关，即要转换的指针指向的对象的实际类型与转换以后的对象类型一定要相同，否则转换失败。</inside></type-id></p><p><strong>const_cast转换</strong></p><p>　　1.基本用法：const_cast<type-id>expression</type-id></p><p>　　2.使用场景：<strong>const转非const</strong></p><p>　　a、常量指针转换为非常量指针，并且仍然指向原来的对象</p><p>　　b、常量引用被转换为非常量引用，并且仍然指向原来的对象</p><p>　　3.使用特点：</p><p>　　a、cosnt_cast是四种类型转换符中唯一可以对常量进行操作的转换符</p><p>　　b、去除常量性是一个危险的动作，尽量避免使用。一个特定的场景是：类通过const提供重载时，一般都是非常量函数调用const_cast<const t>将参数转换为常量，然后调用常量函数，然后得到结果再调用const_cast <t>去除常量性。</t></const></p><p><strong>reinterpret_cast转换</strong></p><p>　　1.基本用法:reinterpret_cast<type-id>expression</type-id></p><p>　　2.使用场景：<strong>不到万不得已，不用使用这个转换符，高危操作</strong></p><p>　　3.使用特点：　　</p><p>　　a、reinterpret_cast是从底层对数据进行重新解释，依赖具体的平台，可移植性差</p><p>　　b、reinterpret_cast可以将整型转换为指针，也可以把指针转换为数组</p><p>　　c、reinterpret_cast可以在指针和引用里进行肆无忌惮的转换</p><p><strong>为什么不使用C的强制转换？</strong></p><p>C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。</p><h3 id="指针和引用的区别？"><a href="#指针和引用的区别？" class="headerlink" title="指针和引用的区别？"></a>指针和引用的区别？</h3><p>参考回答:</p><p>1)   <strong>指针是一个实体，需要分配内存空间</strong>。引用只是变量的别名，不需要分配内存空间。</p><p>2)   引用在定义的时候<strong>必须进行初始化</strong>，并且不能够改变。指针在定义的时候不一定要初始化，并且指向的空间可变。（注：不能有引用的值不能为NULL）</p><p>3)   <strong>有多级指针，但是没有多级引用</strong>，只能有一级引用。</p><p>4)   指针和引用的<strong>自增运算</strong>结果不一样。（指针是指向下一个空间，引用时引用的变量值加1）</p><p>5)   <strong>sizeof</strong> 引用得到的是所指向的变量（对象）的大小，而sizeof 指针得到的是指针本身的大小。</p><p>6)   <strong>引用访问一个变量是直接访问，而指针访问一个变量是间接访问</strong>。</p><p>7)   使用指针前最好做类型检查，防止野指针的出现；</p><p>8)   引用底层是通过指针实现的；</p><p>9）如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。</p><p>10)   作为参数时也不同，传指针的实质是传值，传递的值是指针的地址；传引用的实质是传地址，传递的是变量的地址。</p><h3 id="指针参数传递和引用参数传递"><a href="#指针参数传递和引用参数传递" class="headerlink" title="指针参数传递和引用参数传递"></a>指针参数传递和引用参数传递</h3><p>1) <strong>指针参数传递本质上是值传递，它所传递的是一个地址值。</strong>值传递过程中，被调函数的形式参数作为被调函数的<strong>局部变量处理</strong>，会在栈中开辟内存空间以存放由主调函数传递进来的实参值，从而形成了实参的一个副本（替身）。值传递的特点是，被调函数对形式参数的任何操作都是作为局部变量进行的，不会影响主调函数的实参变量的值（<strong>形参指针变了，实参指针不会变</strong>）。</p><p>2) 引用参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。<strong>被调函数对形参（本体）的任何操作都被处理成间接寻址</strong>，即通过栈中存放的地址访问主调函数中的实参变量（根据别名找到主调函数中的本体）。因此，<strong>被调函数对形参的任何操作都会影响主调函数中的实参变量。</strong></p><p>3) 引用传递和指针传递是不同的，虽然他们都是在被调函数栈空间上的一个局部变量，但是<strong>任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量</strong>。而对于指针传递的参数，如果改变被调函数中的指针地址，它将应用不到主调函数的相关变量。<strong>如果想通过指针参数传递来改变主调函数中的相关变量（地址），那就得使用指向指针的指针或者指针引用。</strong></p><p>4)从编译的角度来讲，<strong>程序在编译时分别将指针和引用添加到符号表上，符号表中记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值（与实参名字不同，地址相同）</strong>。符号表生成之后就不会再改，因此指针可以改变其指向的对象（<strong>指针变量中的值可以改</strong>），而引用对象则不能修改。</p><h3 id="函数参数传递种类"><a href="#函数参数传递种类" class="headerlink" title="函数参数传递种类"></a>函数参数传递种类</h3><p> 形参变量只有在<strong>被调用时才分配内存单元</strong>，在调用结束时， 即刻释放所分配的内存单元。因此，<strong>形参只有在函数内部有效。</strong> 函数调用结束返回主调函数后则不能再使用该形参变量。</p><p>1)      值传递：有一个形参向函数所属的栈拷贝数据的过程，如果值传递的对象是类对象    或是大的结构体对象，将耗费一定的时间和空间。（传值）</p><p>2)   指针传递：同样有一个形参向函数所属的栈拷贝数据的过程，但拷贝的数据是一个固定为4字节的地址。（<strong>传值，传递的是地址值</strong>）</p><p>3)   引用传递：同样有上述的数据拷贝过程，但其是针对地址的，相当于为该数据所在的地址起了一个别名。（<strong>传地址</strong>）</p><p>效率上讲，指针传递和引用传递比值传递效率高。一般主张使用引用传递，代码逻辑上更加紧凑、清晰。</p><h3 id="简述智能指针原理"><a href="#简述智能指针原理" class="headerlink" title="简述智能指针原理"></a>简述智能指针原理</h3><p><a href="https://mp.weixin.qq.com/s/x--v5kPtrA8NQpzAmhj_Yw" target="_blank" rel="noopener">参考1</a></p><p><a href="https://www.cnblogs.com/lanxuezaipiao/p/4132096.html" target="_blank" rel="noopener">参考2</a></p><p><a href="https://www.cnblogs.com/wxquare/p/4759020.html" target="_blank" rel="noopener">参考3</a></p><p><strong>【1】为什么提出智能指针</strong></p><p>在智能指针出现以前，我们通常使用 new 和 delete 来管理动态分配的内存，但这种方式存在几个常见的问题：</p><p><strong>(1)忘记 delete 内存：</strong>会导致内存泄漏问题，且除非是内存耗尽否则很难检测到这种错误。</p><p><strong>(2)使用已经释放掉的对象：</strong>如果能够记得在释放掉内存后将指针置空并在下次使用前判空，尚可避免这种错误。</p><p><strong>(3)同一块内存释放两次：</strong>如果有两个指针指向相同的动态分配对象，则很容易发生这种错误。</p><p><strong>(4)发生异常时的内存泄漏：</strong>若在 new 和 delete 之间发生异常，则会导致内存泄漏。</p><p><strong>【2】智能指针的设计思想</strong></p><p>简单的总结下就是：<strong>将基本类型指针封装为类对象指针（这个类肯定是个模板，以适应不同基本类型的需求），并在析构函数里编写delete语句删除指针指向的内存空间。</strong></p><p><strong>【3】智能指针的使用</strong></p><p>C++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且第一个已经被11弃用。</p><p>为什么要使用智能指针：</p><p>智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。</p><ol><li><strong>auto_ptr（c++98的方案，cpp11已经抛弃）</strong></li></ol><p>采用所有权模式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">auto_ptr</span>&lt; <span class="built_in">string</span>&gt; p1 (<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"I reigned lonely as a cloud.”));</span></span><br><span class="line"><span class="string">auto_ptr&lt;string&gt; p2;</span></span><br><span class="line"><span class="string">p2 = p1; //auto_ptr不会报错.</span></span><br></pre></td></tr></table></figure><p>此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃问题！</p><ol><li><strong>unique_ptr（替换auto_ptr）</strong></li></ol><p>unique_ptr实现独占式拥有或严格拥有概念，<strong>保证同一时间内只有一个智能指针可以指向该对象</strong>。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。</p><p>采用所有权模式，还是上面那个例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; p3 (``<span class="keyword">new</span>` `<span class="built_in">string</span> (``<span class="string">"auto"</span>``));   ``<span class="comment">//#4``unique_ptr&lt;string&gt; p4；                       ``//#5``p4 = p3;``//此时会报错！！`</span></span><br></pre></td></tr></table></figure><p>编译器认为p4=p3非法，避免了p3不再指向有效数据的问题。因此，unique_ptr比auto_ptr更安全。</p><p>另外unique_ptr还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; pu1(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"hello world"</span>));</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; pu2;</span><br><span class="line">pu2 = pu1;                                      <span class="comment">// #1 not allowed</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; pu3;</span><br><span class="line">pu3 = <span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt;(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"You"</span>));   <span class="comment">// #2 allowed</span></span><br></pre></td></tr></table></figure><p>其中#1留下悬挂的unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的auto_ptr 。</p><p>注：如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个unique_ptr赋给另一个。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; ps1, ps2;</span><br><span class="line">ps1 = demo(<span class="string">"hello"</span>);</span><br><span class="line">ps2 = move(ps1);</span><br><span class="line">ps1 = demo(<span class="string">"alexia"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *ps2 &lt;&lt; *ps1 &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><ol><li><strong>shared_ptr</strong></li></ol><p>shared_ptr实现共享式拥有概念。<strong>多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。</strong>从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。</p><p>shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。</p><p>成员函数：</p><p>use_count 返回引用计数的个数</p><p>unique 返回是否是独占所有权( use_count 为 1)</p><p>swap 交换两个 shared_ptr 对象(即交换所拥有的对象)</p><p>reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少</p><p>get 返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如 shared_ptr<int> sp(new int(1)); sp 与 sp.get()是等价的</int></p><ol><li><strong>weak_ptr</strong>（解决shared_ptr循环引用引出的）</li></ol><p>weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象. 进行该对象的内存管理的是那个强引用的 shared_ptr. weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。<strong>weak_ptr是用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。</strong>它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。</p><p>以下实例为智能指针的循环引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;B&gt; pb_;  <span class="comment">//只是定义了指针，并没有资源</span></span><br><span class="line">~A()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"A delete\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;A&gt; pa_; <span class="comment">//只是定义了指针，并没有资源</span></span><br><span class="line">~B()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"B delete\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;B&gt; pb(<span class="keyword">new</span> B());   </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pb.use_count() &lt;&lt; <span class="built_in">endl</span>;      <span class="comment">//pb占用了new出来的资源  输出1</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pb-&gt;pa_.use_count() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//pb-&gt;pa_ 只是定义了指针，并没有资源  输出0</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;A&gt; pa(<span class="keyword">new</span> A());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pb.use_count() &lt;&lt; <span class="built_in">endl</span>;      <span class="comment">//输出1</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pa.use_count() &lt;&lt; <span class="built_in">endl</span>;      <span class="comment">//输出1</span></span><br><span class="line">pb-&gt;pa_ = pa;</span><br><span class="line">pa-&gt;pb_ = pb;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pb.use_count() &lt;&lt; <span class="built_in">endl</span>;      <span class="comment">//输出2</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pa.use_count() &lt;&lt; <span class="built_in">endl</span>;      <span class="comment">//输出2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fun();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：没析构</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="请你回答一下智能指针有没有内存泄露的情况"><a href="#请你回答一下智能指针有没有内存泄露的情况" class="headerlink" title="请你回答一下智能指针有没有内存泄露的情况"></a>请你回答一下智能指针有没有内存泄露的情况</h3><p>当两个对象相互使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。例如：6中代码</p><p>上述代码中，A有一个shared_ptr类型的成员指向B，而B也有一个shared_ptr类型的成员指向A。然后在创建A和B对象时也使用了智能指针pa和pb，随后将pa和pb分别又赋值给B的智能指针成员A和A的智能指针成员B。从而形成了一个循环引用：</p><p>如何解决：</p><p>为了解决循环引用导致的内存泄漏，引入了weak_ptr弱指针，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。</p><p><strong>把类A中的share_ptr改成之后能析构掉资源：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">B delete</span><br><span class="line">A delete</span><br></pre></td></tr></table></figure><h3 id="什么是内存泄漏-memory-leak"><a href="#什么是内存泄漏-memory-leak" class="headerlink" title="什么是内存泄漏(memory leak)"></a>什么是内存泄漏(memory leak)</h3><p>参考回答:</p><p>内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，<strong>失去了对该段内存的控制，因而造成了内存的浪费。</strong><br>内存泄漏的分类：</p><ol><li>堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过<strong>malloc,realloc new</strong>等从堆中分配的一块内存，再是完成后必须通过调用对应的 <strong>free或者delete</strong> 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak.</li><li>系统资源泄露（Resource Leak）。<strong>主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉</strong>，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。</li><li><strong>没有将基类的析构函数定义为虚函数。</strong>当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。</li></ol><h3 id="如何判断内存泄漏？"><a href="#如何判断内存泄漏？" class="headerlink" title="如何判断内存泄漏？"></a>如何判断内存泄漏？</h3><p>参考回答:</p><p>内存泄漏通常是由于调用了malloc/new等内存申请的操作，但是缺少了对应的free/delete。为了判断内存是否泄露，我们一方面可以使用linux环境下的内存泄漏检查工具<strong>Valgrind</strong>(音标|‘vælgrind|),windows下由MicroSoft公司自己开发的一个工具——<strong>LeakDiag</strong>，另一方面我们在<strong>写代码时可以添加内存申请和释放的统计功能</strong>，统计当前申请和释放的内存是否一致，以此来判断内存是否泄露。（即在对象的构造函数,中对全局变量进行+1，在析函数中-1）</p><h3 id="数组和指针的区别"><a href="#数组和指针的区别" class="headerlink" title="数组和指针的区别"></a>数组和指针的区别</h3><p>参考回答:</p><p>指针和数组的主要区别如下：</p><div class="table-container"><table><thead><tr><th>指针</th><th>数组</th></tr></thead><tbody><tr><td>保存数据的地址</td><td>保存数据</td></tr><tr><td>间接访问数据，首先获得指针的内容，然后将其作为地址，从该地址中提取数据</td><td>直接访问数据，</td></tr><tr><td>通常用于动态的数据结构</td><td>通常用于固定数目且数据类型相同的元素</td></tr><tr><td>通过Malloc分配内存，free释放内存</td><td>隐式的分配和删除</td></tr><tr><td>通常指向匿名数据，操作匿名函数</td><td>自身即为数据名</td></tr></tbody></table></div><h3 id="野指针是什么？"><a href="#野指针是什么？" class="headerlink" title="野指针是什么？"></a>野指针是什么？</h3><p>参考回答:</p><p>野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针</p><h3 id="引用和指针"><a href="#引用和指针" class="headerlink" title="引用和指针"></a>引用和指针</h3><p><strong>定义：</strong><br>1、引用：</p><p>C++是C语言的继承，它可进行过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行以继承和多态为特点的面向对象的程序设计。引用就是C++对C语言的重要扩充。引用就是某一变量的一个别名，对引用的操作与对变量直接操作完全一样。引用的声明方法：类型标识符 &amp;引用名=目标变量名；引用引入了对象的一个同义词。定义引用的表示方法与定义指针相似，只是用&amp;代替了*。</p><p>2、指针：</p><p>指针利用地址，它的值直接指向存在电脑存储器中另一个地方的值。由于通过地址能找到所需的变量单元，可以说，地址指向该变量单元。因此，将地址形象化的称为“指针”。意思是通过它能找到以它为地址的内存单元。</p><p><strong>区别：</strong></p><p>1)   <strong>指针是一个实体</strong>，需要分配内存空间。引用只是变量的别名，不需要分配内存空间。</p><p>2)   <strong>引用在定义的时候必须进行初始化，并且不能够改变。</strong>指针在定义的时候不一定要初始化，并且指向的空间可变。（注：不能有引用的值不能为NULL）</p><p>3)   <strong>有多级指针，但是没有多级引用</strong>，只能有一级引用。</p><p>4)   <strong>指针和引用的自增运算</strong>结果不一样。（指针是指向下一个空间，引用时引用的变量值加1）</p><p>5)   <strong>sizeof</strong> 引用得到的是所指向的变量（对象）的大小，而sizeof 指针得到的是指针本身的大小。</p><p>6)   <strong>引用访问一个变量是直接访问，而指针访问一个变量是间接访问。</strong></p><p>7)   <strong>使用指针前最好做类型检查</strong>，防止野指针的出现；</p><p>8)   <strong>引用底层是通过指针实现的</strong>；</p><p>9)   作为参数时也不同，传指针的实质是传值，传递的值是指针的地址；传引用的实质是传地址，传递的是变量的地址。</p><h3 id="为什么析构函数必须是虚函数？C-默认的析构函数不是虚函数"><a href="#为什么析构函数必须是虚函数？C-默认的析构函数不是虚函数" class="headerlink" title="为什么析构函数必须是虚函数？C++默认的析构函数不是虚函数"></a>为什么析构函数必须是虚函数？C++默认的析构函数不是虚函数</h3><p>将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。</p><p>C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。</p><h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>参考回答:</p><p>1、定义<br>函数指针是指向函数的指针变量。</p><p>函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数。</p><p>C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。</p><p>2、用途：</p><p>调用函数和做函数的参数，比如回调函数。</p><p>3、示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">fun</span><span class="params">(<span class="keyword">char</span> * p)</span>  </span>&#123;…&#125;       <span class="comment">// 函数fun</span></span><br><span class="line"><span class="keyword">char</span> * (*pf)(<span class="keyword">char</span> * p);             <span class="comment">// 函数指针pf</span></span><br><span class="line">pf = fun;                        <span class="comment">// 函数指针pf指向函数fun</span></span><br><span class="line">pf(p);                        <span class="comment">// 通过函数指针pf调用函数fun</span></span><br></pre></td></tr></table></figure><p>15.请你来说一下fork函数</p><p>参考回答:</p><p>Fork：创建一个和当前进程映像一样的进程可以通过fork( )系统调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> fork(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure><p>成功调用fork( )会创建一个新的进程，它几乎与调用fork( )的进程一模一样，这两个进程都会继续运行。在子进程中，成功的fork( )调用会返回0。在父进程中fork( )返回子进程的pid。如果出现错误，fork( )返回一个负值。</p><p>最常见的fork( )用法是创建一个新的进程，然后使用exec( )载入二进制映像，替换当前进程的映像。这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。这种“派生加执行”的方式是很常见的。</p><p>在早期的Unix系统中，创建进程比较原始。当调用fork时，内核会把所有的内部数据结构复制一份，复制进程的页表项，然后把父进程的地址空间中的内容逐页的复制到子进程的地址空间中。但从内核角度来说，逐页的复制方式是十分耗时的。现代的Unix系统采取了更多的优化，例如Linux，采用了写时复制的方法，而不是对父进程空间进程整体复制。</p><h3 id="map和set有什么区别，分别又是怎么实现的？"><a href="#map和set有什么区别，分别又是怎么实现的？" class="headerlink" title="map和set有什么区别，分别又是怎么实现的？"></a>map和set有什么区别，分别又是怎么实现的？</h3><p>参考回答:</p><p>map和set都是C++的关联容器，其底层实现都是红黑树（RB-Tree）。由于 map 和set所开放的各种操作接口，RB-tree 也都提供了，所以<strong>几乎所有的 map 和set的操作行为，都只是转调 RB-tree 的操作行为。</strong></p><p>map和set区别在于：</p><p>（1）map中的元素是key-value（关键字—值）对：<strong>关键字起到索引的作用</strong>，值则表示与索引相关联的数据；Set与之相对就是关键字的简单集合，set中每个元素只包含一个关键字。</p><p>（2）<strong>set的迭代器是const的，不允许修改元素的值；map允许修改value，但不允许修改key。</strong>其原因是因为map和set是根据关键字排序来保证其有序性的，如果允许修改key的话，那么首先需要删除该键，然后调节平衡，再插入修改后的键值，调节平衡，如此一来，严重破坏了map和set的结构，导致iterator失效，不知道应该指向改变前的位置，还是指向改变后的位置。所以STL中将set的迭代器设置成const，不允许修改迭代器的值；而map的迭代器则不允许修改key值，允许修改value值。</p><p>（3）<strong>map支持下标操作，set不支持下标操作。map可以用key做下标，map的下标运算符[ ]将关键码作为下标去执行查找</strong>，如果关键码不存在，则插入一个具有该关键码和mapped_type类型默认值的元素至map中，因此下标运算符[ ]在map应用中需要慎用，const_map不能用，只希望确定某一个关键值是否存在而不希望插入元素时也不应该使用，mapped_type类型没有默认值也不应该使用。如果find能解决需要，尽可能用find。</p><h3 id="C-中struct和class的区别"><a href="#C-中struct和class的区别" class="headerlink" title="C++中struct和class的区别"></a>C++中struct和class的区别</h3><p>在C++中，可以用struct和class定义类，都可以继承。区别在于：structural的默认继承权限和默认访问权限是public，而class的默认继承权限和默认访问权限是private。<br>另外，class还可以定义模板类形参，比如template <class t, int i>。</class></p><h3 id="一个C-源文件从文本到可执行文件经历的过程？"><a href="#一个C-源文件从文本到可执行文件经历的过程？" class="headerlink" title="一个C++源文件从文本到可执行文件经历的过程？"></a>一个C++源文件从文本到可执行文件经历的过程？</h3><p>对于C++源文件，从文本到可执行文件一般需要四个过程：<br>预处理阶段：对源代码文件中<strong>文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件。</strong></p><p>编译阶段：将经过预处理后的预编译文件转换成特定汇编代码，<strong>生成汇编文件</strong></p><p>汇编阶段：将编译阶段生成的<strong>汇编文件转化成机器码，生成可重定位目标文件</strong></p><p>链接阶段：将<strong>多个目标文件及所需要的库连接</strong>成最终的<strong>可执行目标文件</strong></p><h3 id="include头文件的顺序以及双引号””和尖括号-lt-gt-的区别？"><a href="#include头文件的顺序以及双引号””和尖括号-lt-gt-的区别？" class="headerlink" title="include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别？"></a>include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别？</h3><p>Include头文件的顺序：对于include的头文件来说，如果在文件a.h中声明一个在文件b.h中定义的变量，而不引用b.h。那么要在a.c文件中引用b.h文件，并且要先引用b.h，后引用a.h,否则汇报变量类型未声明错误。</p><p>双引号和尖括号的区别：编译器预处理阶段查找头文件的路径不一样。</p><p>对于使用<strong>双引号包含的头文件</strong>，查找头文件路径的顺序为：</p><p>（1）当前头文件目录</p><p>（2）编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）</p><p>（3）系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径</p><p>对于使用<strong>尖括号包含的头文件</strong>，查找头文件的路径顺序为：</p><p>（1）编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）</p><p>（2）系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径</p><h3 id="malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？"><a href="#malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？" class="headerlink" title="malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？"></a>malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？</h3><p>Malloc函数用于动态分配内存。为了减少内存碎片和系统调用的开销，<strong>malloc其采用内存池的方式，先申请大块内存作为堆区，然后将堆区分为多个内存块，以块作为内存管理的基本单位。</strong>当用户申请内存时，直接从堆区分配一块合适的空闲块。Malloc采用隐式链表结构将堆区分成连续的、大小不一的块，包含已分配块和未分配块；同时malloc采用显示链表结构来管理所有的空闲块，即使用一个双向链表将空闲块连接起来，每一个空闲块记录了一个连续的、未分配的地址。</p><p>当进行内存分配时，Malloc会通过隐式链表遍历所有的空闲块，选择满足要求的块进行分配；当进行内存合并时，malloc采用边界标记法，根据每个块的前后块是否已经分配来决定是否进行块合并。</p><p><strong>Malloc在申请内存时，一般会通过brk或者mmap系统调用进行申请。其中当申请内存小于128K时，会使用系统函数brk在堆区中分配；而当申请内存大于128K时，会使用系统函数mmap在映射区分配。</strong></p><h3 id="什么时候会发生段错误"><a href="#什么时候会发生段错误" class="headerlink" title="什么时候会发生段错误"></a>什么时候会发生段错误</h3><p>段错误通常发生在访问非法内存地址的时候，具体来说分为以下几种情况：<br>使用野指针</p><p>试图修改字符串常量的内容</p><h3 id="C-中static关键字作用"><a href="#C-中static关键字作用" class="headerlink" title="C++中static关键字作用"></a><strong>C++中static关键字作用</strong></h3><p><a href="https://www.cnblogs.com/songdanzju/p/7422380.html" target="_blank" rel="noopener">参考</a></p><p><strong>不考虑类，static的作用主要有三条。</strong></p><p>【1】<strong>隐藏</strong>（可以说是最重要的一条，static函数，static变量均可）</p><p>当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。</p><p>举例来说明。同时编译两个源文件，一个是a.c，另一个是main.c。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.c</span></span><br><span class="line"><span class="keyword">char</span> a = <span class="string">'A'</span>; <span class="comment">// global variable</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">msg</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"Hello\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//main.c  C中普通函数可以这样不包含头文件就可以调用，但是在C++中要包含，为规范最好都包含</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">extern</span> <span class="keyword">char</span> a; <span class="comment">// extern variable must be declared before use</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"%c "</span>, a);</span><br><span class="line">     (<span class="keyword">void</span>)msg();</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的运行结果是：</p><p>A Hello</p><p>如果加了static，就会对其它源文件隐藏。例如在a和msg的定义前加上static，main.c就看不到它们了。利用这一特性可以在不同的文件中定义同名函数和同名变量，而<strong>不必担心命名冲突</strong>。<strong>static可以用作函数和变量的前缀，对于函数来讲，static的作用仅限于隐藏.</strong></p><p><strong>【2】保持变量内容的持久</strong>（<strong>理解！！！</strong>static变量中的记忆功能和全局生存期）</p><p><strong>存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。</strong>共有<strong>两种变量存储在静态存储区：全局变量和static变量</strong>，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的。虽然这种用法不常见</p><p>PS：如果作为<strong>static局部变量在函数内定义，它的生存期为整个源程序，但是其作用域仍与自动变量相同，只能在定义该变量的函数内使用该变量。退出该函数后， 尽管该变量还继续存在，但不能使用它。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">＃include &lt;stdio.h&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">10</span>; <span class="comment">//在第一次进入这个函数的时候，变量a被初始化为10，以后不再执行赋值操作！并接着自减1，以后每次进入该函数，a</span></span><br><span class="line">    <span class="keyword">return</span> count--; <span class="comment">//就不会被再次初始化了，仅进行自减1的操作；在static发明前，要达到同样的功能，则只能使用全局变量：    </span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"global\t\tlocal static\n"</span>);</span><br><span class="line">     <span class="keyword">for</span>(; count &lt;= <span class="number">10</span>; ++count)</span><br><span class="line">               <span class="built_in">printf</span>(<span class="string">"%d\t\t%d\n"</span>, count, fun());</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的运行结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">global  local static</span><br><span class="line">1  10</span><br><span class="line">2   9</span><br><span class="line">3   8</span><br><span class="line">4   7</span><br><span class="line">5   6</span><br><span class="line">6   5</span><br><span class="line">7   4</span><br><span class="line">8   3</span><br><span class="line">9   2</span><br><span class="line">10  1</span><br></pre></td></tr></table></figure><p>—-基于以上两点可以得出一个结论：<strong>把局部变量改变为静态变量后是改变了它的存储方式</strong>即<strong>改变了它的生存期</strong>。把全局变量改变为静态变量后是<strong>改变了它的作用域</strong>， 限制了它的使用范围。因此static 这个说明符在不同的地方所起的作用是不同的。</p><p>【3】static的第三个作用是<strong>默认初始化为0</strong>（static变量）</p><p>其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。<strong>在静态数据区，内存中所有的字节默认值都是0x00</strong>，某些时候这一特点可以减少程序员的工作量。比如初始化一个稀疏矩阵，我们可以一个一个地把所有元素都置0，然后把不是0的几个元素赋值。如果定义成静态的，就省去了一开始置0的操作。<strong>再比如要把一个字符数组当字符串来用，但又觉得每次在字符数组末尾加‘\0’;太麻烦。如果把字符串定义成静态的，</strong>就省去了这个麻烦，因为那里本来就是‘\0’;不妨做个小实验验证一下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">＃include &lt;stdio.h&gt;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i;</span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"integer: %d; string: (begin)%s(end)"</span>, a, str);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的运行结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">integer: 0; string: (begin) (end)</span><br></pre></td></tr></table></figure><p>最后对static的三条作用做一句话总结。<strong>首先static的最主要功能是隐藏，其次因为static变量存放在静态存储区，所以它具备持久性和默认值0.</strong> </p><p><strong>在考虑类的情况下：</strong></p><p><strong>【4】类中的static成员</strong></p><p>static成员变量：</p><p>1) <strong>一个类中可以有一个或多个静态成员变量，所有的对象都共享这些静态成员变量，都可以引用它。</strong></p><p>2) static 成员变量和普通 static 变量一样，都在内存分区中的DATA段（静态区），到程序结束时才释放。这就意味着，<strong>static 成员变量不随对象的创建而分配内存，也不随对象的销毁而释放内存。</strong>而普通成员变量在对象创建时分配内存，在对象销毁时释放内存。</p><p>3) <strong><u>静态成员变量必须初始化，而且只能在类体外进行</u>。</strong>例如：</p><p>int Student::m_total = 10;</p><p>初始化时可以赋初值，也可以不赋值。如果不赋值，那么会被默认初始化为 0。<strong>全局数据区的变量都有默认的初始值 0，而动态数据区（堆区、栈区）变量的默认值是不确定的，一般认为是垃圾值。</strong></p><p>4) <strong>静态成员变量既可以通过对象名访问，也可以通过类名访问</strong>，但要遵循 private、protected 和 public 关键字的访问权限限制。当通过对象名访问时，对于不同的对象，访问的是同一份内存。</p><p>static成员函数：</p><p>关于静态成员函数，可以总结为以下几点：</p><p>1）静态成员之间可以相互访问，包括<strong>静态成员函数访问静态成员变量和访问静态成员函数</strong>。<strong>静态成员函数不能访问非静态成员函数和非静态数据成员，非静态成员函数可以任意地访问静态成员函数和静态数据成员；</strong></p><p>原因：由于static修饰的类成员属于类，不属于对象，因此static类成员函数是没有this指针的，this指针是指向本对象的指针。正因为没有this指针，所以static类成员函数不能访问非static的类成员，只能访问 static修饰的类成员。</p><p>2）<strong>静态成员函数</strong>由于不与任何的对象相关联，因此它不具有this指针。因而它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，<strong>只能调用其余的静态成员函数与访问静态数据成员</strong>。</p><p><strong>注意：</strong>因为static成员不是任何对象的组成部分，所以<strong>static成员函数不能被声明为const</strong>。毕竟，将成员函数声明为const就是承诺不会修改该函数所属的对象，而static成员函数不属于任何对象。</p><p>最后，<strong>static成员函数也不能被声明为虚函数、volatile</strong>。举例如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span>&#123;</span></span><br><span class="line">    virtual static void funcl()；//错误</span><br><span class="line">    static void func2()const；//错误</span><br><span class="line">    static void func3()volatile；//错误</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p><strong>static成员函数不能被virtual修饰</strong>，static成员不属于任何对象或实例，所以加上virtual没有任何实际意义；静态成员函数没有this指针，虚函数的实现是为每一个对象分配一个vptr指针，而vptr是通过this指针调用的，所以不能为virtual；虚函数的调用关系，<strong>this-&gt;vfptr-&gt;vtable-&gt;virtual function</strong></p><h3 id="const作用"><a href="#const作用" class="headerlink" title="const作用"></a>const作用</h3><p>1)   【定义常量】<strong>阻止一个变量被改变，可以使用const关键字</strong>。在<strong>定义该const变量时，通常需要对它进行初始化</strong>，因为以后就没有机会再去改变它了；   </p><p>2)   【修饰指针】<strong>对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；</strong>   </p><p>3)   【修饰函数形参】在一个<strong>函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；</strong>   </p><p>4)   【类型转换】const类型变量可以通过类型转换符<strong>const_cast将const类型转换为非const类型</strong>；</p><p>5)  【类的成员变量】<strong>const类型变量必须定义的时候进行初始化</strong>，因此也导致如果<strong>类的成员变量</strong>有const类型的变量，那么该变量<strong>必须在类的初始化列表中进行初始化；</strong></p><p>6)【类的成员函数】<strong>const 成员函数可以使用类中的所有成员变量，但是不能修改它们的值，这种措施主要还是为了保护数据而设置的。</strong>const 成员函数也称为常成员函数。  需要注意的是，必须在成员函数的声明和定义处同时加上 const 关键字。</p><p>7）【常对象】常对象以及常对象指针，它们都只能调用 const 成员变量或函数。</p><h3 id="extern用法"><a href="#extern用法" class="headerlink" title="extern用法"></a>extern用法</h3><p>1)   extern修饰变量的声明</p><p>如果文件a.c需要引用b.c中变量int v，就可以在a.c中声明extern int v，然后就可以引用变量v。</p><p>2)   extern修饰函数的声明</p><p>如果文件a.c需要引用b.c中的函数，比如在b.c中原型是int fun(int mu)，那么就可以在a.c中声明extern int fun（int mu），然后就能使用fun来做任何事情。</p><p>3)   extern修饰符可用于指示C或者C＋＋函数的调用规范。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br><span class="line"><span class="comment">/*...*/</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="拷贝构造函数、深拷贝、浅拷贝"><a href="#拷贝构造函数、深拷贝、浅拷贝" class="headerlink" title="拷贝构造函数、深拷贝、浅拷贝"></a>拷贝构造函数、深拷贝、浅拷贝</h3><p>最常见的拷贝构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Student::Student(<span class="keyword">const</span> Student &amp;stu)&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_name = stu.m_name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_age = stu.m_age;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_score = stu.m_score;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"Copy constructor was called."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1) 为什么必须是当前类的引用呢？</strong></p><p>如果拷贝构造函数的参数不是当前类的引用，而是当前类的对象，那么在调用拷贝构造函数时，会将另外一个对象直接传递给形参，这本身就是一次拷贝，会再次调用拷贝构造函数，然后又将一个对象直接传递给了形参，将继续调用拷贝构造函数……这个过程会一直持续下去，没有尽头，陷入死循环。</p><p><strong>2) 为什么是 const 引用呢？</strong></p><p>(a)拷贝构造函数的目的是用其它对象的数据来初始化当前对象，并<strong>没有期望更改其它对象的数据</strong>，添加 const 限制后，这个含义更加明确了。</p><p>(b)另外一个原因是，<strong>添加 const 限制后，可以将 const 对象和非 const 对象传递给形参了</strong>，因为非 const 类型可以转换为 const 类型。如果没有 const 限制，就不能将 const 对象传递给形参，因为 const 类型不能转换为非 const 类型，这就意味着，不能使用 const 对象来初始化当前对象了。</p><p><strong>3)默认拷贝构造函数、浅拷贝、深拷贝</strong></p><p>（a）浅拷贝： 浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝。</p><p>  (b)深拷贝： 深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变，这就是深拷贝。</p><p>如果程序员<strong>没有显式地定义拷贝构造函数，那么编译器会自动生成一个默认的拷贝构造函数</strong>。这个默认的拷贝构造函数属于浅拷贝。</p><p><strong>当类持有其它资源时，如动态分配的内存、打开的文件、指向其他数据的指针、网络连接等，默认拷贝构造函数就不能拷贝这些资源，我们必须显式地定义拷贝构造函数</strong>，以完整地拷贝对象的所有数据。这种方式为<strong>深拷贝。</strong></p><p><strong>4）浅拷贝与深拷贝区别分析</strong></p><p><a href="https://blog.csdn.net/caoshangpa/article/details/79226270" target="_blank" rel="noopener">参考博客</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">char</span> *name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Student();</span><br><span class="line">~Student();</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">Student::Student()</span><br><span class="line">&#123;</span><br><span class="line">name = <span class="keyword">new</span> <span class="keyword">char</span>(<span class="number">20</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Student"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">Student::~Student()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"~Student "</span> &lt;&lt; (<span class="keyword">int</span>)name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">delete</span> name;</span><br><span class="line">name = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#123;<span class="comment">// 花括号让s1和s2变成局部对象，方便测试</span></span><br><span class="line">Student s1;</span><br><span class="line"><span class="function">Student <span class="title">s2</span><span class="params">(s1)</span></span>;<span class="comment">// 复制对象</span></span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Student</span><br><span class="line">~Student 3735080</span><br><span class="line">~Student 3735080</span><br></pre></td></tr></table></figure><p>执行结果：调用一次构造函数，调用两次析构函数，两个对象的指针成员所指内存相同，这会导致什么问题呢？name指针被分配一次内存，但是程序结束时该内存却被释放了两次，会导致崩溃！</p><p>这是由于编译系统在我们没有自己定义拷贝构造函数时，会在拷贝对象时调用默认拷贝构造函数，进行的是浅拷贝！即对指针name拷贝后会出现两个指针指向同一个内存空间。</p><img src="/2019/04/03/C-面试题1/01.png"><p>所以，在对含有指针成员的对象进行拷贝时，必须要自己定义拷贝构造函数，使拷贝后的对象指针成员有自己的内存空间，即进行深拷贝，这样就避免了内存泄漏发生。</p><p><strong>对于成员变量存在指针变量的对象，浅拷贝带来问题的本质在于析构函数释放多次堆内存</strong>，使用std::shared_ptr，可以完美解决这个问题。</p><h3 id="C-模板"><a href="#C-模板" class="headerlink" title="C++模板"></a>C++模板</h3><p><strong>函数模板：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> 类型参数<span class="number">1</span> , <span class="keyword">typename</span> 类型参数<span class="number">2</span> , ...&gt; 返回值类型  函数名(形参列表)&#123;</span><br><span class="line">    <span class="comment">//在函数体中可以使用类型参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所谓函数模板，实际上是建立一个通用函数，它所用到的数据的类型（包括返回值类型、形参类型、局部变量类型）可以不具体指定，而是用一个虚拟的类型来代替（实际上是用一个标识符来占位），等发生函数调用时再根据传入的实参来逆推出真正的类型。这个通用函数就称为函数模板（Function Template）。</p><p><strong>类模板：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> 类型参数<span class="number">1</span> , <span class="keyword">typename</span> 类型参数<span class="number">2</span> , …&gt; <span class="class"><span class="keyword">class</span> 类名&#123;</span></span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类模板在实例化时必须显式地指明数据类型，编译器不能根据给定的数据推演出数据类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Point&lt;<span class="keyword">float</span>, <span class="keyword">char</span>*&gt; p3(<span class="number">12.4</span>, <span class="string">"东经180度"</span>);</span><br><span class="line">Point&lt;<span class="keyword">char</span>*, <span class="keyword">char</span>*&gt; *p = <span class="keyword">new</span> Point&lt;<span class="keyword">char</span>*, <span class="keyword">char</span>*&gt;(<span class="string">"东经180度"</span>, <span class="string">"北纬210度"</span>);</span><br></pre></td></tr></table></figure><h3 id="C与C-中truct区别，C-中struct与class区别"><a href="#C与C-中truct区别，C-中struct与class区别" class="headerlink" title="C与C++中truct区别，C++中struct与class区别"></a>C与C++中truct区别，C++中struct与class区别</h3><p>C语言和C++中struct的区别？</p><div class="table-container"><table><thead><tr><th>struct</th><th>C语言</th><th>C++</th></tr></thead><tbody><tr><td>成员</td><td>没有函数成员，只有数据</td><td>函数和数据都可以有</td></tr><tr><td>访问权限</td><td>没有访问权限的设定，及对外不隐藏数据</td><td>有访问权限的设定private,public,protected</td></tr><tr><td>是否可以继承</td><td>不可以</td><td>有继承关系</td></tr></tbody></table></div><p>C++中struct和class的区别？</p><div class="table-container"><table><thead><tr><th>C++</th><th>struct</th><th>class</th></tr></thead><tbody><tr><td>访问默认权限</td><td>struct默认是public</td><td>class默认是private</td></tr><tr><td>继承默认权限</td><td>struct默认是public</td><td>class默认是private</td></tr><tr><td>定义模板参数</td><td>不可以</td><td>可以</td></tr></tbody></table></div><h3 id="strcpy、strncpy与memcpy的区别与使用方法"><a href="#strcpy、strncpy与memcpy的区别与使用方法" class="headerlink" title="strcpy、strncpy与memcpy的区别与使用方法"></a>strcpy、strncpy与memcpy的区别与使用方法</h3><p>函数说明</p><p>void  <em>memcpy(void </em>s1,  const void *s2,  size_t  n);</p><p>char  <em>strcpy(char </em>s2, const char *s1);     </p><p>char  <em>strncpy(char </em>s2, const char *s1, size_t n);</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//strcpy和strncpy是用在字符数组中，而不是</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> s1[<span class="number">4</span>] = &#123;<span class="string">'y'</span>,<span class="string">'u'</span>,<span class="string">'e'</span>,<span class="string">'\0'</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> s2[<span class="number">6</span>] = &#123; <span class="string">'y'</span>, <span class="string">'a'</span>, <span class="string">'n'</span>, <span class="string">'g'</span>,<span class="string">'y'</span>,<span class="string">'\0'</span> &#125;;</span><br><span class="line"><span class="comment">//strcpy(s1,s2);   //缓冲溢出   s1数组为 y a n g,无‘\0’</span></span><br><span class="line"><span class="comment">//strcpy(s2, s1);    //正常，s2为  y u e '\0' y '\0'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//strncpy(s1, s2,5);  //当n&gt;s1数组长度时，s1数组为 y a n g,无‘\0’</span></span><br><span class="line"><span class="comment">//strncpy(s1, s2, 2);   //当n&lt;s1数组长度时,只拷贝n个字符到s1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">strncpy</span>(s2, s1, <span class="number">5</span>);   <span class="comment">//如果s1指向的数组是一个比n短的字符串，</span></span><br><span class="line"><span class="comment">//则在s2定义的数组后面补空字符，直到写入了n个字符。</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项</p><p>strcpy 是依据 “\0” 作为结束判断的，如果 s2 的空间不够，则会引起 buffer overflow。</p><p>memcpy用来在内存中复制数据，<strong>由于字符串是以“\0”结尾的，所以对于在数据中包含“\0”的数据只能用memcpy，如:”hell\0oworld”。</strong></p><p>Strncpy和memcpy很相似，只不过它在一个终止的空字符处停止。当n&gt;strlen(s1)时，<strong>给s2不够数的空间里填充“\0”；当n&lt;=strlen(s1)时，s2是没有结束符“\0”的。</strong></p><p>这里隐藏了一个事实，就是s2指向的内存一定会被写n个字符。</p><p>所以总的来说注意：</p><p>1、s2指向的空间要足够拷贝；使用strcpy时，s2指向的空间要大于等于s1指向的空间；使用strncpy或memcpy时，s2指向的空间要大于或等于n。</p><p>2、使用strncpy或memcpy时，n应该大于strlen(s1)，或者说最好n &gt;= strlen(s1)+1；这个1 就是最后的“\0”。</p><p>3、使用strncpy时，确保s2的最后一个字符是“\0”。</p><h3 id="右值与右值引用"><a href="#右值与右值引用" class="headerlink" title="右值与右值引用"></a>右值与右值引用</h3><p><a href="https://blog.csdn.net/china_jeffery/article/details/78520237" target="_blank" rel="noopener">参考</a></p><p>补充1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="number">2</span> <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function">3 </span>&#123;</span><br><span class="line"><span class="number">4</span>     <span class="function">T <span class="title">t</span><span class="params">(<span class="built_in">std</span>::move(a))</span></span>;  <span class="comment">// a为空，t占有a的初始数据</span></span><br><span class="line"><span class="number">5</span>     a = <span class="built_in">std</span>::move(b); <span class="comment">//  b为空， a占有b的初始数据</span></span><br><span class="line"><span class="number">6</span>     b = <span class="built_in">std</span>::move(t); <span class="comment">// t为空，b占有a的初始数据</span></span><br><span class="line"><span class="number">7</span> &#125;</span><br></pre></td></tr></table></figure><p>补充2：</p><p>1)    拷贝构造函数中，对于指针，我们一定要采用深层复制，而<strong>移动构造函数中，对于指针，我们采用浅层复制。</strong>浅层复制之所以危险，是因为两个指针共同指向一片内存空间，若第一个指针将其释放，另一个指针的指向就不合法了。所以我们只要避免第一个指针释放空间就可以了。避免的方法就是<strong>将第一个指针（比如a-&gt;value）置为NULL，这样在调用析构函数的时候，由于有判断是否为NULL的语句，所以析构a的时候并不会回收a-&gt;value指向的空间；</strong><br>2)    移动构造函数的参数是一个右值或者将亡值的引用。也就是说，<strong>只用用一个右值，或者将亡值初始化另一个对象的时候，才会调用移动构造函数。</strong>而那个move语句，就是将一个左值变成一个将亡值。</p><h3 id="构成多态时为什么构造函数不定义为虚函数，析构函数通常定义为虚函数？"><a href="#构成多态时为什么构造函数不定义为虚函数，析构函数通常定义为虚函数？" class="headerlink" title="构成多态时为什么构造函数不定义为虚函数，析构函数通常定义为虚函数？"></a>构成多态时为什么构造函数不定义为虚函数，析构函数通常定义为虚函数？</h3><p>（1）虚函数表是在编译阶段生成的，里面没有存放虚函数的的实际物理地址，只有运行完构造函数进行初始化了，才能通过虚函数表里面的虚函数入口地址访问虚函数，因此构造函数，定义为虚函数没有意义。</p><p>（2）析构函数通常要定义为虚函数，否则当基类指针指向派生类，然后delete基类指针的时候，派生类的析构函数无法执行。</p><h3 id="虚函数表属于每一个对象，为什么？"><a href="#虚函数表属于每一个对象，为什么？" class="headerlink" title="虚函数表属于每一个对象，为什么？"></a>虚函数表属于每一个对象，为什么？</h3><p>虚函数表是在编译阶段生成的，里面没有存放虚函数的的实际物理地址，只有运行完构造函数进行初始化了，才能通过虚函数表里面的虚函数入口地址访问虚函数，因此虚函数表属于对象，而不属于类。他是一种晚绑定机制。</p><h3 id="类构造函数的初始化列表"><a href="#类构造函数的初始化列表" class="headerlink" title="类构造函数的初始化列表"></a>类构造函数的初始化列表</h3><p>1)   必须使用成员初始化的四种情况</p><p>①       当初始化一个引用成员时；</p><p>②       当初始化一个常量成员时；</p><p>③       当调用一个基类的构造函数，而它拥有一组参数时；</p><p>④       当调用一个成员类的构造函数，而它拥有一组参数时；</p><p>2）为什么用成员初始化列表会快一些？</p><p>列表初始化是给数据成员分配内存空间时就进行初始化，这样可以避免赋值操作而产生的临时对象，临时对象的出现会降低程序的效率。</p><h3 id="构造函数和析构函数可以调用虚函数吗，为什么"><a href="#构造函数和析构函数可以调用虚函数吗，为什么" class="headerlink" title="构造函数和析构函数可以调用虚函数吗，为什么"></a>构造函数和析构函数可以调用虚函数吗，为什么</h3><p>在C++中，提倡不在构造函数和析构函数中调用虚函数；<br>1)    构造函数和析构函数调用虚函数时都<strong>不使用动态联编</strong>，如果在构造函数或析构函数中调用虚函数，则运行的是为构造函数或析构函数自身类型定义的版本；<br>2)    因为<strong>父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化，因此调用子类的虚函数时不安全</strong>的，故而C++不会进行动态联编；<br>3)    析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。所以<strong>在调用基类的析构函数时，派生类对象的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义。</strong></p><p>静态联编：编译阶段就将函数实现与函数调用关联起来；<br>动态连编：在程序执行阶段才将函数实现和调用关联；</p><p>注意：动态联编是针对C++的多态，C语言全部都是静态联编；</p><h3 id="类的构造函数与析构函数执行顺序"><a href="#类的构造函数与析构函数执行顺序" class="headerlink" title="类的构造函数与析构函数执行顺序"></a>类的构造函数与析构函数执行顺序</h3><p>1)       构造函数顺序</p><p>①     基类构造函数。</p><p>②     成员类对象构造函数。</p><p>③     派生类构造函数。</p><p>2)       析构函数顺序</p><p>①     调用派生类的析构函数；</p><p>②     调用成员类对象的析构函数；</p><p>③     调用基类的析构函数。</p><h3 id="什么情况会自动生成默认构造函数？"><a href="#什么情况会自动生成默认构造函数？" class="headerlink" title="什么情况会自动生成默认构造函数？"></a>什么情况会自动生成默认构造函数？</h3><p><a href="http://www.cppblog.com/chenglong7997/articles/169731.html" target="_blank" rel="noopener">经典参考资料</a></p><p>1)    含有带有默认构造函数的类成员对象；<br>2)    继承带有默认构造函数的基类；<br>3)    有虚函数的类<br>4)    进行虚继承的类</p><h3 id="C-里面的多态"><a href="#C-里面的多态" class="headerlink" title="C++里面的多态"></a>C++里面的多态</h3><p>1）静态多态（重载，模板）<br>是在编译的时候，就确定调用函数的类型。<br>（2）动态多态（覆盖，虚函数实现）<br>在运行的时候，才确定调用的是哪个函数，动态绑定。运行基类指针指向派生类的对象，并调用派生类的函数。</p><p>下面是构成运行时多态的条件：<br>必须存在继承关系；<br>继承关系中必须有同名的虚函数，并且它们是遮蔽（覆盖）关系。<br>存在基类的指针，通过该指针调用虚函数。</p><h3 id="类什么时候会析构？"><a href="#类什么时候会析构？" class="headerlink" title="类什么时候会析构？"></a>类什么时候会析构？</h3><p>1)    对象生命周期结束，被销毁时；<br>2)    delete指向对象的指针时，或delete指向对象的基类类型指针，而其基类虚构函数是虚函数时；<br>3)    对象i是对象o的成员，o的析构函数被调用时，对象i的析构函数也被调用。</p><h3 id="组合与继承优缺点？"><a href="#组合与继承优缺点？" class="headerlink" title="组合与继承优缺点？"></a>组合与继承优缺点？</h3><p>（1）继承<br>继承的优点是子类可以重写父类的方法来<strong>方便地实现对父类的扩展</strong>。<br>继承的缺点有以下几点：<br>①：<strong>父类的内部细节对子类是可见的。</strong><br>②：子类从父类继承的方法在<strong>编译时就确定下来了</strong>，所以<strong>无法在运行期间改变从父类继承的方法的行为</strong>。<br>③：如果对父类的方法做了修改的话（比如增加了一个参数），则子类的方法必须做出相应的修改。所以说子类与父类是一种<strong>高耦合</strong>，违背了面向对象思想。<br>（2）组合<br>组合也就是设计类的时候把要组合的类的对象加入到该类中作为自己的成员变量。<br>组合的优点：<br>①：当前对象只能通过所包含的那个对象去调用其方法，所以所包含的对象的<strong>内部细节对当前对象时不可见的</strong>。<br>②：当前对象与包含的对象是一个<strong>低耦合</strong>关系，如果修改包含对象的类中代码不需要修改当前对象类的代码。<br>③：当前对象可以在<strong>运行时动态的绑定所包含的对象</strong>。可以通过set方法给所包含对象赋值。<br>组合的缺点：①：<strong>容易产生过多的对象</strong>。②：为了能组合多个对象，必须仔细对接口进行定义。</p><p>补充：组合的构造函数执行顺序为：<strong>先调用内嵌对象的构造函数，然后执行组合类构造函数的函数体，析构函数调用顺序相反。</strong></p><h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p><a href="https://www.cnblogs.com/jimodetiantang/p/9016826.html" target="_blank" rel="noopener">C++之Lambda表达式</a></p><p><a href="https://blog.csdn.net/iloveyousunna/article/details/78532398" target="_blank" rel="noopener">c++中lambda表达式的用法</a></p><p>1)    利用lambda表达式可以编写内嵌的匿名函数，用以替换独立函数或者函数对象；</p><p>2)    lambda表达式的语法定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[函数对象参数] (操作符重载函数参数) mutable 或 exception 声明 -&gt; 返回值类型 &#123;函数体&#125;</span><br></pre></td></tr></table></figure><p>3)    lambda必须使用尾置返回来指定返回类型，可以忽略参数列表和返回值，但必须永远包含捕获列表和函数体；</p><h3 id="C-重写（覆盖）、重载、重定义"><a href="#C-重写（覆盖）、重载、重定义" class="headerlink" title="C++重写（覆盖）、重载、重定义"></a><strong>C++重写（覆盖）、重载、重定义</strong></h3><p>1 重载overload</p><p><strong>在一个类中</strong>，方法名相同而参数不同的几个方法，但是不能靠返回类型来判断。</p><p>2 重写（覆盖）override</p><p><strong>函数特征相同，但是具体实现不同。</strong></p><p>a、最重要的一点，重写是<strong>子类与父类</strong>之间的。</p><p>b、被重写的函数不能是 static 的。</p><p>c、<strong>函数三要素（函数名、函数参数、函数返回类型）完全一样</strong></p><p>d、如果父类中有virtual关键字，这种父子之间的关系叫做虚函数重写</p><p>3 重定义redefining</p><p><strong>子类重新定义父类中</strong>有相同名称的非虚函数 ( 参数列表可以不同 )</p><h3 id="volatile作用"><a href="#volatile作用" class="headerlink" title="volatile作用"></a>volatile作用</h3><p>1&gt; 告诉compiler 不能做任何优化<br>2&gt; 用volatile 定义的变量会在程序外被改变,每次都必须从内存中读取，而不能重复使用放在cache或寄存器中的备份。</p><h3 id="什么时候编译器产生默认构造函数"><a href="#什么时候编译器产生默认构造函数" class="headerlink" title="什么时候编译器产生默认构造函数"></a>什么时候编译器产生默认构造函数</h3><p>   那么到底什么时候编译器会为我们产生nontrivial default constructor(有用的默认构造函数)呢?有下面四中情况:</p><p>​       <strong>①如果一个类里面某个成员对象有默认构造函数,编译器就会为我们的类产生默认构造函数。</strong></p><p>​       原因：编译器需要显式的来调用这个类成员对象的默认构造函数。</p><p>​       编译器合成的nontrivial default constructor仅仅调用类成员对象的默认构造函数,而不对我们类里面的其它变量做任何初始化操作。</p><p>​        <strong>②如果一个派生类的基类有默认构造函数,那么编译器会为派生类合成一个默认构造函数。</strong></p><p>​        原因:因为派生类被合成时需要显式调用基类的默认构造函数。</p><p>​        <strong>③类中有虚函数</strong></p><p>​        编译器必须自己产生一个默认构造函数来完成虚函数表的初始化操作。</p><p>​        <strong>④如果一个类虚继承于其它类。</strong></p><p>​     编译器必须自己产生一个默认构造函数来完成虚基类表的初始化操作。</p><h3 id="C-函数对象"><a href="#C-函数对象" class="headerlink" title="C++函数对象"></a>C++函数对象</h3><p>如果一个类将()运算符重载为成员函数，这个类就称为函数对象类，这个类的对象就是函数对象。<strong>函数对象是一个对象</strong>，但是<strong>使用的形式看起来像函数调用，实际上也执行了函数调用</strong>，因而得名。</p><p>下面是一个函数对象的例子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CAverage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3)</span></span></span><br><span class="line"><span class="function">    </span>&#123;  <span class="comment">//重载()运算符</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>)(a1 + a2 + a3) / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CAverage average;  <span class="comment">//能够求三个整数平均数的函数对象</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; average(<span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>);  <span class="comment">//等价于 cout &lt;&lt; average.operator(3, 2, 3);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2. 66667</span><br></pre></td></tr></table></figure><h3 id="虚继承及其内存模型"><a href="#虚继承及其内存模型" class="headerlink" title="虚继承及其内存模型"></a>虚继承及其内存模型</h3><p><a href="http://c.biancheng.net/cpp/biancheng/view/3005.html" target="_blank" rel="noopener">参考</a></p><p>为了解决多继承时的命名冲突和冗余数据问题，C++ 提出了虚继承，使得在派生类中只保留一份间接基类的成员。</p><p>普通的继承内存模型如下：B继承A，C继承B，D继承C</p><img src="/2019/04/03/C-面试题1/02.jpg"><p>假设 A 是 B 的虚基类，B 又是 C 的虚基类，那么各个对象的内存模型如下图所示：</p><img src="/2019/04/03/C-面试题1/03.jpg"><p>VC对于虚继承，对象内存的设计：</p><p>VC 引入了<strong>虚基类表</strong>，如果某个派生类有一个或多个虚基类，编译器就会在派生类对象中安插一个指针，指向虚基类表。虚基类表其实就是一个数组，数组中的元素存放的是各个虚基类的偏移。</p><p>假设 A 是 B 的虚基类，同时 B 又是 C 的虚基类</p><img src="/2019/04/03/C-面试题1/04.jpg"><p>假设 A、B、C、D 类的继承关系为：</p><img src="/2019/04/03/C-面试题1/05.jpg"><p>内存模型如下图所示：</p><img src="/2019/04/03/C-面试题1/06.jpg"><p><strong>总结：每多一层虚继承，对象里面多一个指向虚基类表的指针。</strong></p><h3 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h3><p><a href="https://www.jianshu.com/p/9e083ea23b23" target="_blank" rel="noopener">参考1：单继承虚函数表</a></p><p><a href="https://blog.51cto.com/10740026/1748140" target="_blank" rel="noopener">参考2：多继承虚函数表</a></p><p><strong>虚函数：</strong></p><p>注意：可以只将基类中的函数声明为虚函数，这样所有派生类中具有遮蔽（覆盖）关系的同名函数都将自动成为虚函数。</p><p><strong>构成多态条件：</strong></p><p><strong>单继承虚函数表：</strong></p><p>虚函数表是一个指针数组，每个元素对应一个虚函数的函数指针，普通的函数即非虚函数，其调用不需要经过虚表。</p><p>基类如果有 虚函数，几重继承就有几个虚函数表，如果子类对父类的虚函数重写了，虚函数表中对应位置指针则指向子类重写的<strong>虚函数</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~A();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data1, m_data2;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span></span>;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~B();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data1, m_data4;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2019/04/03/C-面试题1/07.jpg"><p><strong>多继承虚函数表：</strong></p><p>例如：class Derive : public Base1, public Base2</p><p>Base1，Base2中有虚函数，则Derive 的对象有两个指向虚函数表的指针，分别指向Base1和Base2的虚函数表。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;为什么标准头文件都有类似以下的结构？&quot;&gt;&lt;a href=&quot;#为什么标准头文件都有类似以下的结构？&quot; class=&quot;headerlink&quot; title=&quot;为什么标准头文件都有类似以下的结构？&quot;&gt;&lt;/a&gt;为什么标准头文件都有类似以下的结构？&lt;/h3&gt;&lt;figure c
      
    
    </summary>
    
    
      <category term="C++基础" scheme="http://yuemingyang7010.github.io/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="C++基础" scheme="http://yuemingyang7010.github.io/tags/C-%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面试题" scheme="http://yuemingyang7010.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>2-QT中互斥与信号量</title>
    <link href="http://yuemingyang7010.github.io/2019/04/03/2-QT%E4%B8%AD%E4%BA%92%E6%96%A5%E4%B8%8E%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    <id>http://yuemingyang7010.github.io/2019/04/03/2-QT中互斥与信号量/</id>
    <published>2019-04-03T05:52:09.000Z</published>
    <updated>2019-07-06T08:34:57.020Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-QMutex类"><a href="#1-QMutex类" class="headerlink" title="1.QMutex类"></a>1.QMutex类</h2><p>QMutex的目的是保护对象、数据结构或代码段，以便一次只有一个线程可以访问它(这类似于Java synchronized关键字)。通常最好将互斥锁与QMutexLocker一起使用，因为这样可以很容易地确保一致地执行锁定和解锁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> number = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    number *= <span class="number">5</span>;</span><br><span class="line">    number /= <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    number *= <span class="number">3</span>;</span><br><span class="line">    number /= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺陷：如中代码中间退出，比如有多个if条件里面有return，则导致无法ulock,造成死锁。</p><p>解决方法：在每个return之前注意添加unlock，或者用更加方便的</p><h2 id="2-QMutexLocker类"><a href="#2-QMutexLocker类" class="headerlink" title="2.QMutexLocker类"></a>2.QMutexLocker类</h2><p>使用方法：</p><p>（1）先定义一个QMutex类的变量</p><p>（2）在需要上锁的地方定义一个QMutexLocker类的变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMutex&gt;</span></span></span><br><span class="line">QMutex qMutex;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程槽函数</span></span><br><span class="line"><span class="keyword">void</span> WorkThread::startThreadSlot()</span><br><span class="line">&#123;</span><br><span class="line">     <span class="function">QMutexLocker <span class="title">m_lock</span><span class="params">(&amp;qMutex)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(isStop)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">0</span>;n&lt;<span class="number">10</span>;n++)</span><br><span class="line">            qDebug()&lt;&lt;n&lt;&lt;n&lt;&lt;n&lt;&lt;n&lt;&lt;n&lt;&lt;n&lt;&lt;n&lt;&lt;n;</span><br><span class="line">         QThread::sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-信号量QSemaphore类"><a href="#3-信号量QSemaphore类" class="headerlink" title="3.信号量QSemaphore类"></a>3.信号量QSemaphore类</h2><p>信号量可以理解为对互斥量功能的扩展，互斥量只能锁定一次而信号量可以获取多次，它可以用来保存一定数量的同种资源。</p><p><strong>以下以单个生产者和单个消费者模型举例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSemaphore&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QThread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> DataSize=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> BufferSize=<span class="number">80</span>;</span><br><span class="line"><span class="keyword">int</span> buffer[BufferSize];<span class="comment">//缓存数据</span></span><br><span class="line"><span class="function">QSemaphore <span class="title">freeBytes</span><span class="params">(BufferSize)</span></span>;<span class="comment">//freeBytes信号量控制可被生产者填充的缓冲部分</span></span><br><span class="line"><span class="function">QSemaphore <span class="title">usedBytes</span><span class="params">(<span class="number">0</span>)</span></span>;<span class="comment">//usedBytes信号量控制可被消费者读取的缓冲区部分</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> :</span> <span class="keyword">public</span> QThread</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Producer();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">Producer::Producer()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> Producer::run()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;DataSize;i++)</span><br><span class="line">    &#123;</span><br><span class="line">       freeBytes.acquire();<span class="comment">//生产者线程首先获取一个空闲单元，如果此时缓冲区培被消费者尚未读取的数据填满，对</span></span><br><span class="line">       <span class="comment">//此函数的调用就会阻塞，直到消费者读取了这些数据为止</span></span><br><span class="line">       buffer[i%BufferSize]=(i%BufferSize);<span class="comment">//一旦生成者获取了某个空闲单元，就使当前的缓存单元序号填写这个缓冲区单元</span></span><br><span class="line">       usedBytes.release();<span class="comment">//调用该函数将可用资源加1，表示消费者此时可以读取这个刚刚填写的单元</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Consumer继承QThread类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> :</span> <span class="keyword">public</span> QThread</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Consumer();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">Consumer::Consumer()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> Consumer::run()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;DataSize;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        usedBytes.acquire();<span class="comment">//消费者线程首先获取一个可被读取的单元，如果缓冲区中没有包含任何可以读取的数据，对此函数的调用就会阻塞，直到生产者生产了一些数据为止</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"%d"</span>,buffer[i%BufferSize]);<span class="comment">//一旦消费者读取了这个单元，会将这个单元的内容打印出来</span></span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">16</span>==<span class="number">0</span>&amp;&amp;i!=<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"\n"</span>);</span><br><span class="line"> </span><br><span class="line">        freeBytes.release();<span class="comment">//调用该函数使得这个单元变为空闲，已被生产者下次填充</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"> </span><br><span class="line">    Producer producer;</span><br><span class="line">    Consumer consumer;</span><br><span class="line"> </span><br><span class="line">    producer.start();</span><br><span class="line">    consumer.start();</span><br><span class="line"> </span><br><span class="line">    producer.wait();</span><br><span class="line">    consumer.wait();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>互斥量可以锁定一次，而信号量可以在设置上限大小的情况下，获取多次，可以用来保护一定数量的同种资源。在使用acquire函数跨线程获取n个资源。release(n)可以释放n个资源。当没有足够的资源时，调用者将被阻塞直到有足够的资源可用。</p><p><strong>一个生产者与多个消费者：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QSemaphore&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QThread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function">QSemaphore <span class="title">vacancy</span><span class="params">(<span class="number">10</span>)</span></span>;      <span class="comment">//资源上限</span></span><br><span class="line"><span class="function">QSemaphore <span class="title">produce</span><span class="params">(<span class="number">0</span>)</span></span>;       <span class="comment">//产品数量</span></span><br><span class="line">QMutex mutex;                <span class="comment">//互斥锁</span></span><br><span class="line"><span class="keyword">int</span> buffer[<span class="number">5</span>];               <span class="comment">//缓冲区可以放5个产品</span></span><br><span class="line"><span class="keyword">int</span> numtaken=<span class="number">30</span>;</span><br><span class="line"><span class="keyword">int</span> takei=<span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span>:</span><span class="keyword">public</span> QThread</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//生产者线程</span></span><br><span class="line"><span class="keyword">void</span> Producer::run()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">30</span>;i++)    <span class="comment">//生产30次产品</span></span><br><span class="line">    &#123;</span><br><span class="line">        vacancy.acquire();</span><br><span class="line">        buffer[i%<span class="number">5</span>]=i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"produced %d\n"</span>,i);</span><br><span class="line">        produce.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span>:</span><span class="keyword">public</span> QThread</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> Consumer::run()         <span class="comment">//消费者线程</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(numtaken&gt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        produce.acquire();</span><br><span class="line">        mutex.lock();        <span class="comment">//从缓冲区取出一个产品,多个消费者,不能同时取出,故用了互斥锁</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread %ul take %d from buffer[%d] \n"</span>,currentThreadId(),buffer[takei%<span class="number">5</span>],takei%<span class="number">5</span>);</span><br><span class="line">        takei++;</span><br><span class="line">        numtaken--;</span><br><span class="line">        mutex.unlock();</span><br><span class="line">        vacancy.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    Producer producer;</span><br><span class="line">    Consumer consumerA;</span><br><span class="line">    Consumer consumerB;</span><br><span class="line">    Consumer consumerC;</span><br><span class="line">    producer.start();</span><br><span class="line">    consumerA.start();</span><br><span class="line">    consumerB.start();</span><br><span class="line">    consumerC.start();</span><br><span class="line">    producer.wait();</span><br><span class="line">    consumerA.wait();</span><br><span class="line">    consumerB.wait();</span><br><span class="line">    consumerC.wait();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如图1所示：</p><img src="/2019/04/03/2-QT中互斥与信号量/01.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-QMutex类&quot;&gt;&lt;a href=&quot;#1-QMutex类&quot; class=&quot;headerlink&quot; title=&quot;1.QMutex类&quot;&gt;&lt;/a&gt;1.QMutex类&lt;/h2&gt;&lt;p&gt;QMutex的目的是保护对象、数据结构或代码段，以便一次只有一个线程可以访问它(这类
      
    
    </summary>
    
    
      <category term="C++基础" scheme="http://yuemingyang7010.github.io/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://yuemingyang7010.github.io/categories/C-%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="C++基础" scheme="http://yuemingyang7010.github.io/tags/C-%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://yuemingyang7010.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
