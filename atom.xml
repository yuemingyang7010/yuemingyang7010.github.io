<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yue</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yuemingyang7010.github.io/"/>
  <updated>2019-11-05T15:08:06.948Z</updated>
  <id>http://yuemingyang7010.github.io/</id>
  
  <author>
    <name>Mingyang Yue</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深度学习目标检测</title>
    <link href="http://yuemingyang7010.github.io/2019/11/05/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    <id>http://yuemingyang7010.github.io/2019/11/05/深度学习目标检测/</id>
    <published>2019-11-05T08:07:51.000Z</published>
    <updated>2019-11-05T15:08:06.948Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Two-stage的目标检测算法"><a href="#Two-stage的目标检测算法" class="headerlink" title="Two-stage的目标检测算法"></a>Two-stage的目标检测算法</h2><p>CNN卷积特征<br>R.Girshick et al.，2014提出R-CNN到faster RCNN</p><p>端到端的目标检测（RPN网络）<br>准确度高、速度相对one-stage慢</p><h3 id="Two-stage基本流程"><a href="#Two-stage基本流程" class="headerlink" title="Two-stage基本流程"></a>Two-stage基本流程</h3><p><img src="/2019/11/05/深度学习目标检测/01.png" alt></p><h3 id="Two-stage常见算法"><a href="#Two-stage常见算法" class="headerlink" title="Two-stage常见算法"></a>Two-stage常见算法</h3><p>·RCNN<br>·Fast RCNN<br>·Faster RCNN<br>·Faster RCNN变种</p><p><img src="/2019/11/05/深度学习目标检测/02.png" alt></p><h3 id="Two-stage核心组件"><a href="#Two-stage核心组件" class="headerlink" title="Two-stage核心组件"></a>Two-stage核心组件</h3><p>CNN网络 + RPN网络</p><p><strong>CNN网络设计原则:</strong></p><p>(1)从简到繁再到简的卷积神经网<br>(2)多尺度特征融合的网络<br>(3)更轻量级的CNN网络</p><p><strong>RPN网络:</strong><br>(1)区域推荐（Anchor机制）<br>(2)ROI Pooling<br>(3)分类和回归</p><p><img src="/2019/11/05/深度学习目标检测/03.png" alt></p><p><strong>区域推荐（Anchor机制）</strong></p><p><img src="/2019/11/05/深度学习目标检测/04.png" alt></p><p>每一个像素点为一个anchor,以该点为中心生成候选框，若每个点生成9个候选框，</p><p><img src="/2019/11/05/深度学习目标检测/05.png" alt></p><h3 id="Two-stage改进方向"><a href="#Two-stage改进方向" class="headerlink" title="Two-stage改进方向"></a>Two-stage改进方向</h3><p>·更好的网络特征<br>·更精准的RPN<br>·更完善的ROI分类<br>·样本后处理<br>·更大的mini-Batch</p><h2 id="基于One-stage的目标检测算法"><a href="#基于One-stage的目标检测算法" class="headerlink" title="基于One-stage的目标检测算法"></a>基于One-stage的目标检测算法</h2><p>·使用CNN卷积特征<br>·直接回归物体的类别概率和位置坐标值（无region proposal）<br>·准确度低、速度相对two-stage快</p><h3 id="One-stage基本流程"><a href="#One-stage基本流程" class="headerlink" title="One-stage基本流程"></a>One-stage基本流程</h3><p><img src="/2019/11/05/深度学习目标检测/06.png" alt></p><h3 id="One-stage常见算法"><a href="#One-stage常见算法" class="headerlink" title="One-stage常见算法"></a>One-stage常见算法</h3><p>·Yolov1/v2/V3<br>·SSD/DSSD等<br>·Retina-Net<br>·…</p><p><img src="/2019/11/05/深度学习目标检测/07.png" alt></p><h3 id="One-stage核心组件"><a href="#One-stage核心组件" class="headerlink" title="One-stage核心组件"></a>One-stage核心组件</h3><p>CNN网络+回归网络</p><p><strong>CNN网络设计原则:</strong><br>(1)从简到繁再到简的卷积神经网<br>(2)多尺度特征融合的网络<br>(3)更轻量级的CNN网络</p><h2 id="One-stage-VS-Two-stage"><a href="#One-stage-VS-Two-stage" class="headerlink" title="One-stage VS Two-stage"></a>One-stage VS Two-stage</h2><p><img src="/2019/11/05/深度学习目标检测/08.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Two-stage的目标检测算法&quot;&gt;&lt;a href=&quot;#Two-stage的目标检测算法&quot; class=&quot;headerlink&quot; title=&quot;Two-stage的目标检测算法&quot;&gt;&lt;/a&gt;Two-stage的目标检测算法&lt;/h2&gt;&lt;p&gt;CNN卷积特征&lt;br&gt;R.G
      
    
    </summary>
    
    
      <category term="深度学习" scheme="http://yuemingyang7010.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="目标检测" scheme="http://yuemingyang7010.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
    
      <category term="DeepLearning" scheme="http://yuemingyang7010.github.io/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>传统目标检测</title>
    <link href="http://yuemingyang7010.github.io/2019/11/05/%E4%BC%A0%E7%BB%9F%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    <id>http://yuemingyang7010.github.io/2019/11/05/传统目标检测/</id>
    <published>2019-11-05T03:23:00.000Z</published>
    <updated>2019-11-05T07:58:49.535Z</updated>
    
    <content type="html"><![CDATA[<h3 id="传统目标检测方法基本流程："><a href="#传统目标检测方法基本流程：" class="headerlink" title="传统目标检测方法基本流程："></a><strong>传统目标检测方法基本流程：</strong></h3><p><img src="/2019/11/05/传统目标检测/01.png" alt></p><p>特征主要是：颜色、纹理、形状或更高层次特征。</p><p>NMS：对候选框进行非极大值抑制。</p><h3 id="Viola-Jones（常用于人脸检测）"><a href="#Viola-Jones（常用于人脸检测）" class="headerlink" title="Viola-Jones（常用于人脸检测）"></a>Viola-Jones（常用于人脸检测）</h3><p><strong>关键点：</strong></p><p>(1)Haar特征提取(其实是一种纹理特征)<br>(2)训练人脸分类器（Adaboost 算法等）<br>(3)滑动窗口</p><h4 id="Haar-特征（value-白-黑）"><a href="#Haar-特征（value-白-黑）" class="headerlink" title="Haar 特征（value=白-黑）"></a>Haar 特征（value=白-黑）</h4><p><img src="/2019/11/05/传统目标检测/02.png" alt></p><h4 id="Adaboost算法"><a href="#Adaboost算法" class="headerlink" title="Adaboost算法"></a>Adaboost算法</h4><p>(1)初始化样本的权重w，样本权重之和为1<br>(2)训练弱分类器<br>(3)更新样本权重<br>(4)循环第2步<br>(5)结合做个分类器结果，进行投票</p><h3 id="HOG-SVM（行人检测）"><a href="#HOG-SVM（行人检测）" class="headerlink" title="HOG+SVM（行人检测）"></a>HOG+SVM（行人检测）</h3><h4 id="算法步骤："><a href="#算法步骤：" class="headerlink" title="算法步骤："></a>算法步骤：</h4><p>(1)提取HOG特征<br>(2)训练SVM分类器<br>(3)利用滑动窗口提取目标区域，进行分类判断<br>(4)NMS<br>(5)输出检测结果</p><h4 id="HOG特征"><a href="#HOG特征" class="headerlink" title="HOG特征"></a>HOG特征</h4><p>(1)灰度化+Gamma变换<br>(2)计算梯度map<br>(3)图像划分成小的cell，统计每个cell梯度直方图    </p><p>(4)多个cell组成一个block，特征归一化<br>(5)多个block串联，并归一化</p><h3 id="DPM（物体检测）"><a href="#DPM（物体检测）" class="headerlink" title="DPM（物体检测）"></a>DPM（物体检测）</h3><p>2008年Pedro Felzenszwalb提出<br>VOC，07，08，09年的检测冠军<br>2010VOC授予“终身成就奖”<br>HOG的扩展<br>利用SVM训练得到物体的梯度</p><p>比HOG+SVM更快</p><h4 id="DPM特征提取"><a href="#DPM特征提取" class="headerlink" title="DPM特征提取"></a>DPM特征提取</h4><p>有符号梯度+无符号梯度</p><p><img src="/2019/11/05/传统目标检测/03.png" alt></p><h4 id="后续步骤"><a href="#后续步骤" class="headerlink" title="后续步骤"></a>后续步骤</h4><p>计算DPM特征图<br>计算响应图（root filter和part filter）<br>Latent SVM分类器训练<br>检测识别</p><p><img src="/2019/11/05/传统目标检测/04.png" alt></p><h3 id="NMS（非极大值抑制算法）"><a href="#NMS（非极大值抑制算法）" class="headerlink" title="NMS（非极大值抑制算法）"></a>NMS（非极大值抑制算法）</h3><p>目的：为了消除多余的框，找到最佳的物体检测的位置<br>思想：选取那些邻域里分数最高的窗口，同时抑制那些分数低的窗口</p><h4 id="Soft-NMS-对NMS的改进"><a href="#Soft-NMS-对NMS的改进" class="headerlink" title="Soft-NMS(对NMS的改进)"></a>Soft-NMS(对NMS的改进)</h4><p>(1)相邻区域内的检测框的分数进行调整而非彻底抑制，从而提高了高检索率情况下的准确率<br>(2)在低检索率时仍能对物体检测性能有明显提升</p><p>NMS公式:</p><script type="math/tex; mode=display">s_{i}=\left\{\begin{array}{ll}{s_{i},} & {\operatorname{iou}\left(\mathcal{M}, b_{i}\right)<N_{t}} \\ {0,} & {\operatorname{iou}\left(\mathcal{M}, b_{i}\right) \geq N_{t}}\end{array}\right.</script><p>Soft-NMS公式：</p><script type="math/tex; mode=display">s_{i}=\left\{\begin{array}{ll}{s_{i},} & {\text { iou }\left(\mathcal{M}, b_{i}\right)<N_{t}} \\ {s_{i}\left(1-\operatorname{iou}\left(\mathcal{M}, b_{i}\right)\right),} & {\text { iou }\left(\mathcal{M}, b_{i}\right) \geq N_{t}}\end{array}\right.</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;传统目标检测方法基本流程：&quot;&gt;&lt;a href=&quot;#传统目标检测方法基本流程：&quot; class=&quot;headerlink&quot; title=&quot;传统目标检测方法基本流程：&quot;&gt;&lt;/a&gt;&lt;strong&gt;传统目标检测方法基本流程：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;img src=
      
    
    </summary>
    
    
      <category term="深度学习" scheme="http://yuemingyang7010.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="目标检测" scheme="http://yuemingyang7010.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
    
      <category term="DeepLearning" scheme="http://yuemingyang7010.github.io/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>目标检测基础</title>
    <link href="http://yuemingyang7010.github.io/2019/11/05/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E5%9F%BA%E7%A1%80/"/>
    <id>http://yuemingyang7010.github.io/2019/11/05/目标检测基础/</id>
    <published>2019-11-05T02:33:20.000Z</published>
    <updated>2019-11-05T03:22:21.351Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目标检测问题定义：</strong></p><p>目标检测是在图片中对<strong>可变数量</strong>的目标进行查找和分类。</p><p>难点1：目标种类与数量问题<br>难点2：目标尺度问题<br>难点3：外在环境干扰问题</p><p><strong>目标检测VS图像分类：</strong></p><p><img src="/2019/11/05/目标检测基础/01.png" alt></p><p><strong>目标检测VS目标分割：</strong></p><p><img src="/2019/11/05/目标检测基础/02.png" alt></p><p><strong>传统目标检测方法到深度学习目标检测方法的变迁：</strong></p><p><img src="/2019/11/05/目标检测基础/03.png" alt></p><p><strong>目标检测基本流程(两种)：</strong></p><p><img src="/2019/11/05/目标检测基础/04.png" alt></p><p><strong>传统目标检测方法：</strong></p><p>Viola-Jones</p><p>HOG+SVM(一般用于检测行人)</p><p>DPM(也是HOG特征，传统的巅峰之作)</p><p>…..</p><p><strong>深度学习目标检测方法:</strong><br>One-stage（YOLO和SSD系列）<br>Two-stage（Faster RCNN系列）</p><p><img src="/2019/11/05/目标检测基础/05.png" alt></p><div class="table-container"><table><thead><tr><th style="text-align:center">传统目标检测方法</th><th style="text-align:center">深度学习目标检测方法</th></tr></thead><tbody><tr><td style="text-align:center">手动设计特征</td><td style="text-align:center">深度网络学习特征</td></tr><tr><td style="text-align:center">滑动窗口</td><td style="text-align:center">Proposal或者直接回归</td></tr><tr><td style="text-align:center">传统分类器</td><td style="text-align:center">深度网络</td></tr><tr><td style="text-align:center">多步骤</td><td style="text-align:center">端到端</td></tr><tr><td style="text-align:center">准确度和实时性差</td><td style="text-align:center">准确度高和实时性好</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;目标检测问题定义：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;目标检测是在图片中对&lt;strong&gt;可变数量&lt;/strong&gt;的目标进行查找和分类。&lt;/p&gt;
&lt;p&gt;难点1：目标种类与数量问题&lt;br&gt;难点2：目标尺度问题&lt;br&gt;难点3：外在环境干扰问题&lt;/p&gt;
&lt;p&gt;&lt;s
      
    
    </summary>
    
    
      <category term="深度学习" scheme="http://yuemingyang7010.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="目标检测" scheme="http://yuemingyang7010.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
    
      <category term="DeepLearning" scheme="http://yuemingyang7010.github.io/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>神经网络基础</title>
    <link href="http://yuemingyang7010.github.io/2019/11/04/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    <id>http://yuemingyang7010.github.io/2019/11/04/神经网络基础/</id>
    <published>2019-11-04T06:32:07.000Z</published>
    <updated>2019-11-04T15:01:05.006Z</updated>
    
    <content type="html"><![CDATA[<p>神经网络的分层使得分函数变为非线性，例如一个三层的神经网络可以类比看作：</p><script type="math/tex; mode=display">s=W_{3} \max \left(0, W_{2} \max \left(0, W_{1} x\right)\right)</script><h3 id="激活函数："><a href="#激活函数：" class="headerlink" title="激活函数："></a>激活函数：</h3><h4 id="神经元的数学模型："><a href="#神经元的数学模型：" class="headerlink" title="神经元的数学模型："></a>神经元的数学模型：</h4><p><img src="/2019/11/04/神经网络基础/01.png" alt="激活函数数学模型"></p><p>只要在神经元的输出端有一个合适的损失函数，就能让单个神经元变成一个线性分类器。一个单独的神经元可以用来实现一个二分类分类器，比如二分类的Softmax或者SVM分类器。</p><h4 id="常用激活函数："><a href="#常用激活函数：" class="headerlink" title="常用激活函数："></a>常用激活函数：</h4><p><img src="/2019/11/04/神经网络基础/02.png" alt></p><p><strong>Sigmoid:</strong></p><ul><li>Squashes the numbers between [0,1]</li><li>Problems with sigmoid:<ul><li>big values neurons <strong><em>kill</em></strong> the gradients.<ul><li>Gradients are in most cases near 0 (Big values/small values), that kills the updates if the graph/network are large.</li></ul></li><li>Not Zero-centered.<ul><li>Didn’t produce zero-mean data.</li></ul></li><li><code>exp()</code> is a bit compute expensive.</li></ul></li></ul><p><strong>Tanh:</strong></p><ul><li><p>Squashes the numbers between [-1,1]</p></li><li><p>Zero centered.</p></li><li><p>Still big values neurons “kill” the gradients.</p></li><li><p><code>Tanh(x)</code> is the equation $\tanh (x)=2 \sigma(2 x)-1$.</p></li></ul><p><strong>RELU (Rectified linear unit):</strong></p><ul><li><code>RELU(x) = max(0,x)</code></li><li>Doesn’t kill the gradients.<ul><li>Only small values that are killed. Killed the gradient in the half</li></ul></li><li>Computationally efficient.</li><li>Converges much faster than Sigmoid and Tanh <code>(6x)</code></li><li>Problems:<ul><li><strong>Not zero centered.</strong></li></ul></li><li>If weights aren’t initialized good, maybe 75% of the neurons will be dead and thats a waste computation. But its still works. This is an active area of research to optimize this.</li><li>To solve the issue mentioned above, people might <strong>initialize all the biases by 0.01</strong></li></ul><p><strong>Leaky RELU:（较为推荐）</strong></p><ul><li><code>leaky_RELU(x) = max(0.01x,x)</code></li><li><strong>Doesn’t kill the gradients from both sides.</strong></li><li>Computationally efficient.</li><li>Converges much faster than Sigmoid and Tanh (6x)</li><li>Will not die.</li><li>PRELU is placing the 0.01 by a variable alpha which is learned as a parameter.</li></ul><p><strong>Maxout :</strong></p><ul><li><code>maxout(x) = max(w1.T*x + b1, w2.T*x + b2)</code></li><li>Generalizes(一般化归纳) RELU（w1,b1=0时候） and Leaky RELU</li><li>Doesn’t die!</li><li><p>Problems:</p><ul><li>double the number of parameters per neuron</li></ul></li></ul><p><strong>Exponential(指数) linear units (ELU):</strong></p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ELU(x) = &#123; x                                           if x &gt; 0</span><br><span class="line">   alpah *(exp(x) -1)                   if x &lt;= 0</span><br><span class="line">           # alpah are a learning parameter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>It has all the benefits of RELU</p></li><li><p>Closer to zero mean outputs and adds some robustness to noise.</p></li><li><p>problems</p><ul><li><code>exp()</code> is a bit compute expensive. </li></ul></li></ul><p>总结：用ReLU非线性函数。注意设置好学习率，或许可以监控你的网络中死亡的神经元占的比例。如果单元死亡问题困扰你，就试试<strong>Leaky ReLU或者Maxout</strong>，不要再用sigmoid了。也可以试试tanh，但是其效果应该不如ReLU或者Maxout。</p><h3 id="神经网络结构："><a href="#神经网络结构：" class="headerlink" title="神经网络结构："></a><strong>神经网络结构：</strong></h3><p><img src="/2019/11/04/神经网络基础/03.png" alt></p><p>左边2层网络，右边3层的网络</p><p><strong>命名规则：</strong>当我们说N层神经网络的时候，我们没有把输入层算入。</p><p><strong>输出层：</strong>和神经网络中其他层不同，<strong>输出层的神经元一般是不会有激活函数的</strong>（或者也可以认为它们有一个线性相等的激活函数）。这是因为最后的输出层大多用于表示分类评分值，因此是任意值的实数，或者某种实数值的目标数（比如在回归中）。</p><p><strong>确定网络尺寸：</strong>用来度量神经网络的尺寸的标准主要有两个：一个是神经元的个数，另一个是参数的个数，用上面图示的两个网络举例：第二个网络有4+4+1=9个神经元，[3x4]+[4x4]+[4x1]=32个权重，4+4+1=9个偏置，共41个可学习的参数。</p><h4 id="前向传播计算举例："><a href="#前向传播计算举例：" class="headerlink" title="前向传播计算举例："></a>前向传播计算举例：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个3层神经网络的前向传播:</span></span><br><span class="line">f = <span class="keyword">lambda</span> x: <span class="number">1.0</span>/(<span class="number">1.0</span> + np.exp(-x)) <span class="comment"># 激活函数(用的sigmoid)</span></span><br><span class="line">x = np.random.randn(<span class="number">3</span>, <span class="number">1</span>) <span class="comment"># 含3个数字的随机输入向量(3x1)</span></span><br><span class="line">h1 = f(np.dot(W1, x) + b1) <span class="comment"># 计算第一个隐层的激活数据(4x1)</span></span><br><span class="line">h2 = f(np.dot(W2, h1) + b2) <span class="comment"># 计算第二个隐层的激活数据(4x1)</span></span><br><span class="line">out = np.dot(W3, h2) + b3 <span class="comment"># 神经元输出(1x1)</span></span><br></pre></td></tr></table></figure><p>全连接层的前向传播一般就是先进行一个矩阵乘法，然后加上偏置并运用激活函数。在上面的代码中，W1，W2，W3，b1，b2，b3都是网络中可以学习的参数。注意x并不是一个单独的列向量，而可以是一个批量的训练数据（其中每个输入样本将会是x中的一列），所有的样本将会被并行化的高效计算出来。</p><h3 id="设置层的数量和尺寸"><a href="#设置层的数量和尺寸" class="headerlink" title="设置层的数量和尺寸:"></a>设置层的数量和尺寸:</h3><p><img src="/2019/11/04/神经网络基础/04.png" alt></p><p>​        在上图中，可以看见有更多神经元的神经网络可以表达更复杂的函数。然而这既是优势也是不足，优势是可以分类更复杂的数据，不足是可能造成对训练数据的过拟合。<strong>过拟合（Overfitting）</strong>是网络对数据中的<strong>噪声有很强的拟合能力，而没有重视数据间（假设）的潜在基本关系。</strong>举例来说，有20个神经元隐层的网络拟合了所有的训练数据，但是其代价是把决策边界变成了许多不相连的红绿区域。而有3个神经元的模型的表达能力只能用比较宽泛的方式去分类数据。它将数据看做是两个大块，并把个别在绿色区域内的红色点看做噪声。在实际中，这样可以在测试数据中获得更好的<strong>泛化（generalization）</strong>能力。</p><p><strong>防止过拟合的常用方法：</strong>L2正则化，dropout和输入噪音等。</p><p>正则化强度是控制神经网络过拟合的好方法。看下图结果：</p><p><img src="/2019/11/04/神经网络基础/05.png" alt></p><p>不同正则化强度的效果：每个神经网络都有20个隐层神经元，但是<strong>随着正则化强度增加，它的决策边界变得更加平滑。</strong></p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>（1）神经网络是一个<strong>通用函数近似器</strong>，神经网络可以近似任何连续函数。</p><p>（2）不应该因为害怕出现过拟合而使用小网络。相反，<strong>应该进尽可能使用大网络，然后使用正则化技巧来控制过拟合，通常更大容量的模型，使用更强的正则化。</strong></p><h3 id="数据预处理："><a href="#数据预处理：" class="headerlink" title="数据预处理："></a><strong>数据预处理：</strong></h3><p>关于数据预处理我们有3个常用的符号，数据矩阵<strong>X</strong>，假设其尺寸是<strong>[N x D]</strong>（<strong>N</strong>是数据样本的数量，<strong>D</strong>是数据的维度）。</p><h4 id="方法组合1（常用）："><a href="#方法组合1（常用）：" class="headerlink" title="方法组合1（常用）："></a>方法组合1（常用）：</h4><p><strong>均值减法（Mean subtraction）即零中心化</strong></p><p>是预处理最常用的形式。它对数据中每个独立<em>特征</em>减去平均值，从几何上可以理解为在每个维度上都<strong>将数据云的中心都迁移到原点</strong>。在numpy中，该操作可以通过代码<strong>X -= np.mean(X, axis=0)</strong>实现。而对于图像，更常用的是对所有像素都减去一个值，可以用<strong>X -= np.mean(X)</strong>实现，也可以在3个颜色通道上分别操作。</p><p><strong>归一化（Normalization）</strong></p><p>是指将数据的<strong>所有维度都归一化，使其数值范围都近似相等</strong>。有两种常用方法可以实现归一化。第一种是先对数据做零中心化（zero-centered）处理，然后每个维度都除以其标准差，实现代码为<strong>X /= np.std(X, axis=0)</strong>。第二种方法是对每个维度都做归一化，使得每个维度的最大和最小值是1和-1。由于像素的数值范围几乎是一致的（都在0-255之间），所以进行这个额外的预处理步骤并不是很必要。</p><p><img src="/2019/11/04/神经网络基础/06.png" alt></p><p>​                       (a)原始                                                (b)对(a)零中心化                                (c)对(b)归一化          </p><h4 id="方法组合2（实际在卷积神经网络中几乎不用）："><a href="#方法组合2（实际在卷积神经网络中几乎不用）：" class="headerlink" title="方法组合2（实际在卷积神经网络中几乎不用）："></a>方法组合2（实际在卷积神经网络中几乎不用）：</h4><p><strong>PCA</strong></p><p>利用这个性质来<strong>对数据降维</strong>，只要使用前面的小部分特征向量，丢弃掉那些包含的数据没有方差的维度。 这个操作也被称为主成分分析PCA。经过上面的操作，将原始的数据集的大小由[N x D]降到了[N x 100]，留下了数据中包含最大<strong>方差</strong>的100个维度。</p><p><strong>白化</strong></p><p>白化操作的输入是特征基准上的数据，然后对每个维度除以其特征值来对数值范围进行归一化。该变换的几何解释是：如果数据服从多变量的高斯分布，那么经过白化后，数据的分布将会是一个均值为零，且协方差相等的矩阵。</p><p><img src="/2019/11/04/神经网络基础/07.png" alt></p><p>​                       (a)原始                                                (b)对(a)PCA降维                                (c)对(b)白化          </p><h4 id="实际做法总结："><a href="#实际做法总结：" class="headerlink" title="实际做法总结："></a>实际做法总结：</h4><p>应该先分成训练/验证/测试集，<strong>只是从训练集中求图片平均值</strong>，然后各个集（训练/验证/测试集）中的图像再减去这个平均值。</p><h3 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a>初始化：</h3><p><strong>权重初始化：</strong></p><p>当前的推荐是使用ReLU激活函数，并且使用<strong>w = np.random.randn(n) * sqrt(2.0/n)</strong>来进行权重初始化。</p><p><strong>偏置（biases）的初始化：</strong></p><p>通常使用0来初始化偏置参数。</p><p><strong>批量归一化（Batch Normalization）</strong></p><p>批量归一化可以理解为在网络的每一层之前都做预处理，只是这种操作以另一种方式与网络集成在了一起。通常意味着全连接层（或者是卷积层，后续会讲）与激活函数之间添加一个BatchNorm层。在实践中，使用了批量归一化的网络对于不好的初始值有更强的鲁棒性。</p><h3 id="正则化-Regularization"><a href="#正则化-Regularization" class="headerlink" title="正则化 Regularization"></a>正则化 Regularization</h3><p><strong>L2正则化</strong></p><p>最常用，损失函数加上$\frac{1}{2} \lambda w^{2}$</p><p><strong>L1正则化</strong></p><p>相对常用的，$\lambda|w|$。L1和L2正则化也可以进行组合：$\lambda_{1}|w|+\lambda_{2} w^{2}$。在实践中，如果不是特别关注某些明确的特征选择，一般说来L2正则化都会比L1正则化效果好。</p><p><strong>最大范式约束（Max norm constraints）</strong></p><p>要求神经元中的权重向量[公式]必须满足$\vec{w}$这一条件，一般$|\vec{w}|_{2}&lt;c$值为3或者4。有研究者发文称在使用这种正则化方法时效果更好。这种正则化还有一个良好的性质，即使在学习率设置过高的时候，网络中也不会出现数值“爆炸”，这是因为它的参数更新始终是被限制着的。</p><p><strong>随机失活（Dropout）</strong></p><p>是一个简单又极其有效的正则化方法。与L1正则化，L2正则化和最大范式约束等方法互为补充。在训练的时候，随机失活的实现方法是让神经元以超参数$p$的概率被激活或者被设置为0。</p><p><img src="/2019/11/04/神经网络基础/08.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;神经网络的分层使得分函数变为非线性，例如一个三层的神经网络可以类比看作：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
s=W_{3} \max \left(0, W_{2} \max \left(0, W_{1} x\right)\
      
    
    </summary>
    
    
      <category term="深度学习" scheme="http://yuemingyang7010.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="CS231N笔记" scheme="http://yuemingyang7010.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/CS231N%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="DeepLearning" scheme="http://yuemingyang7010.github.io/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>最优化</title>
    <link href="http://yuemingyang7010.github.io/2019/10/31/%E6%9C%80%E4%BC%98%E5%8C%96/"/>
    <id>http://yuemingyang7010.github.io/2019/10/31/最优化/</id>
    <published>2019-10-31T02:45:54.000Z</published>
    <updated>2019-11-04T06:30:46.974Z</updated>
    
    <content type="html"><![CDATA[<p>最优化是寻找能使得损失函数值最小化的参数$W$的过程。</p><p>计算梯度有两种方法：一个是缓慢的近似方法（<strong>数值梯度法</strong>），但实现相对简单。另一个方法（<strong>分析梯度法</strong>）计算迅速，结果精确，但是实现时容易出错，且需要使用微分。现在对两种方法进行介绍：</p><h3 id="数值梯度法："><a href="#数值梯度法：" class="headerlink" title="数值梯度法："></a>数值梯度法：</h3><p>在每个维度上产生一个很小的变化h，通过观察函数值变化，计算函数在该维度上的偏导数。最后，所有的梯度存储在变量grad中。</p><p>一般两种方式：</p><p>(1)$\frac{f(x+h)}{h}$</p><p>(2)实际中用中心插值公式$\frac{f(x+h)-f(x-h)}{2 h}$效果较好</p><p><strong>在梯度负方向上更新：</strong>在上面的代码中，为了计算<strong>W_new</strong>，要注意我们是向着梯度df的负方向去更新，这是因为我们希望损失函数值是降低而不是升高。</p><p><strong>效率问题：</strong>一幅32*32的3彩色图像，对应有3073个参数，损失函数每走一步就需要计算3073次损失函数的梯度。现代神经网络很容易就有上千万的参数，显然这个策略不适合大规模数据，需要更好的策略。</p><h3 id="微分分析计算梯度："><a href="#微分分析计算梯度：" class="headerlink" title="微分分析计算梯度："></a><strong>微分分析计算梯度：</strong></h3><p>直接对函数进行微分，求出公式，缺点是容易出错，因此在实际操作时常常将分析梯度法的结果和数值梯度法的结果作比较，以此来检查其实现的正确性，这个步骤叫做<strong>梯度检查</strong>。</p><h4 id="梯度下降："><a href="#梯度下降：" class="headerlink" title="梯度下降："></a><strong>梯度下降：</strong></h4><p>梯度下降是对神经网络的损失函数最优化中最常用的方法。他的普通版本是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 普通的梯度下降</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">  weights_grad = evaluate_gradient(loss_fun, data, weights)</span><br><span class="line">  weights += - step_size * weights_grad <span class="comment"># 进行梯度更新</span></span><br></pre></td></tr></table></figure><h4 id="小批量数据梯度下降（Mini-batch-gradient-descent）："><a href="#小批量数据梯度下降（Mini-batch-gradient-descent）：" class="headerlink" title="小批量数据梯度下降（Mini-batch gradient descent）："></a>小批量数据梯度下降（Mini-batch gradient descent）：</h4><p>在大规模的应用中（比如ILSVRC挑战赛），训练数据可以达到百万级量级。如果像这样计算整个训练集，来获得仅仅一个参数的更新就太浪费了。一个常用的方法是计算训练集中的小批量（batches）数据。例如，在目前最高水平的卷积神经网络中，一个典型的小批量包含256个例子，而整个训练集是多少呢？一百二十万个。这个小批量数据就用来实现一个参数更新：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 普通的小批量数据梯度下降</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">  data_batch = sample_training_data(data, <span class="number">256</span>) <span class="comment"># 256个数据</span></span><br><span class="line">  weights_grad = evaluate_gradient(loss_fun, data_batch, weights)</span><br><span class="line">  weights += - step_size * weights_grad <span class="comment"># 参数更新</span></span><br></pre></td></tr></table></figure><p>​        小批量数据的梯度就是对整个数据集梯度的一个近似。在实践中通过计算小批量数据的梯度可以实现更快速地收敛，并以此来进行更频繁的参数更新。</p><p>​        小批量数据策略有个极端情况，那就是每个批量中只有1个数据样本，这种策略被称为<strong>随机梯度下降</strong>（Stochastic Gradient Descent 简称<strong>SGD</strong>），即使SGD在技术上是指每次使用1个数据来计算梯度，你还是会听到人们使用SGD来指代小批量数据梯度下降（或者用MGD来指代小批量数据梯度下降，而BGD来指代则相对少见）。小批量数据的大小是一个<strong>超参数</strong>，但是<strong>一般并不需要通过交叉验证来调参</strong>。它一般由存储器的限制来决定的，或者干脆设置为同样大小，<strong>比如32，64，128等。之所以使用2的指数</strong>，是因为在实际中许多向量化操作实现的时候，如果输入数据量是2的倍数，那么运算更快。</p><h3 id="反向传播："><a href="#反向传播：" class="headerlink" title="反向传播："></a>反向传播：</h3><p>​        注意训练集是给定的（在机器学习中通常都是这样），而权重是可以控制的变量。因此，即使能用反向传播计算输入数据[公式] 上的梯度，但在实践为了进行参数更新，通常也只计算参数（比如$W,b$）的梯度。然而$x_i$的梯度有时仍然是有用的：比如将神经网络所做的事情可视化便于直观理解的时候，就能用上。</p><p>​        任何可微分的函数都可以看做门。可以将多个门组合成一个门，也可以根据需要将一个函数分拆成多个门。以Sigmoid为例：</p><script type="math/tex; mode=display">f(w, x)=\frac{1}{1+e^{-\left(w_{0} x_{0}+w_{1} x_{1}+w_{2}\right)}}</script><p><img src="/2019/10/31/最优化/001.png" alt></p><p>总结：</p><p><strong>分段计算</strong>在反向传播的实现中很重要。应该将函数分成不同的模块，这样计算局部梯度相对容易，然后基于链式法则将其“链”起来。重要的是，不需要把这些表达式写在纸上然后演算它的完整求导公式，因为实际上并不需要关于输入变量的梯度的数学公式。只需要将表达式分成不同的可以求导的模块（模块可以是矩阵向量的乘法操作，或者取最大值操作，或者加法操作等），然后在反向传播中一步一步地计算梯度。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最优化是寻找能使得损失函数值最小化的参数$W$的过程。&lt;/p&gt;
&lt;p&gt;计算梯度有两种方法：一个是缓慢的近似方法（&lt;strong&gt;数值梯度法&lt;/strong&gt;），但实现相对简单。另一个方法（&lt;strong&gt;分析梯度法&lt;/strong&gt;）计算迅速，结果精确，但是实现时容易出错，
      
    
    </summary>
    
    
      <category term="深度学习" scheme="http://yuemingyang7010.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="CS231N笔记" scheme="http://yuemingyang7010.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/CS231N%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="DeepLearning" scheme="http://yuemingyang7010.github.io/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>分类器</title>
    <link href="http://yuemingyang7010.github.io/2019/10/28/%E5%88%86%E7%B1%BB%E5%99%A8/"/>
    <id>http://yuemingyang7010.github.io/2019/10/28/分类器/</id>
    <published>2019-10-28T09:01:45.000Z</published>
    <updated>2019-11-01T01:31:31.170Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线性分类器"><a href="#线性分类器" class="headerlink" title="线性分类器"></a>线性分类器</h2><p>神经网络方法包含两部分组成：<strong>评分函数（score function）和损失函数（loss function）</strong></p><h3 id="线性分类器评分函数"><a href="#线性分类器评分函数" class="headerlink" title="线性分类器评分函数"></a>线性分类器评分函数</h3><p>评分函数是原始图像数据到类别分值的映射，损失函数是用来量化预测分类标签的得分与真实标签之间一致性的。</p><script type="math/tex; mode=display">f\left(x_{i}, W, b\right)=W x_{i}+b</script><p>矩阵<strong>W</strong>被称为<strong>权重（weights）</strong>。<strong>b</strong>被称为<strong>偏差向量（bias vector）</strong></p><p><strong>线性分类器的理解：</strong></p><p><img src="/2019/10/28/分类器/001.jpg" alt></p><p><strong>将图像看做高维度的点</strong>：</p><p>可以把图像看做这个高维度空间中的一个点（即每张图像是3072维空间中的一个点）。整个数据集就是一个点的集合，每个点都带有1个分类标签。</p><p>既然定义每个分类类别的分值是权重和图像的矩阵乘，那么<strong>每个分类类别的分数就是这个空间中的一个线性函数的函数值。</strong>我们没办法可视化3072维空间中的线性函数，但假设<strong>把这些维度挤压到二维</strong>，那么就可以看看这些分类器在做什么</p><p><img src="/2019/10/28/分类器/002.jpg" alt></p><p>从上面可以看到，<strong>W</strong>的每一行都是一个分类类别的分类器。对于这些数字的几何解释是：如果改变其中一行的数字，会看见分类器在空间中对应的直线开始向着不同方向旋转。而偏差<strong>b</strong>，则允许分类器对应的直线平移。</p><p><strong>偏差和权重的合并技巧：</strong></p><script type="math/tex; mode=display">f\left(x_{i}, W\right)=W x_{i}</script><p>以CIFAR-10为例，那么[公式]的大小就变成[3073x1]，而不是[3072x1]了，多出了包含常量1的1个维度）。W大小就是[10x3073]了。[公式]中多出来的这一列对应的就是偏差值[公式]，具体见下图：</p><p><img src="/2019/10/28/分类器/003.jpg" alt></p><h3 id="线性分类器损失函数："><a href="#线性分类器损失函数：" class="headerlink" title="线性分类器损失函数："></a>线性分类器损失函数：</h3><p>当评分函数输出结果与真实结果之间差异越大，损失函数输出越大，反之越小。</p><p><strong>(1)多类支持向量机损失 Multiclass Support Vector Machine Loss：</strong></p><script type="math/tex; mode=display">L_{i}=\sum_{j \neq y_{i}} \max \left(0, s_{j}-s_{y_{i}}+\Delta\right)</script><p>SVM的损失函数想要正确分类类别$y_i$的分数比不正确类别分数高，而且至少要高$\Delta$。如果不满足这点，就开始计算损失值。</p><p><strong>举例</strong>：用一个例子演示公式是如何计算的。假设有3个分类，并且得到了分值S=[13,-7,11]。其中第一个类别是正确类别，即$y_i=0$。同时假设$\Delta$是10（后面会详细介绍该超参数）。上面的公式是将所有不正确分类（$j\neq y_i$)）加起来，所以我们得到两个部分（认为正确分类的分值最高）：</p><script type="math/tex; mode=display">L i=\max (0,-7-13+10)+\max (0,11-13+10)</script><p>对于线性评分函数，可以将损失函数的公式稍微改写一下：</p><script type="math/tex; mode=display">L_{i}=\sum_{j \neq y_{i}} \max \left(0, w_{j}^{T} x_{i}-w_{y_{i}}^{T} x_{i}+\Delta\right)</script><p>关于0的阀值：$max(0,-)$函数，它常被称为<strong>折叶损失（hinge loss）</strong>。有时候会听到人们使用<strong>平方折叶损失</strong>SVM（即L2-SVM），它使用的是$max(0,-)^2$，将更强烈（平方地而不是线性地）地惩罚过界的边界值。不使用平方是更标准的版本，但是在某些数据集中，平方折叶损失会工作得更好。<strong>可以通过交叉验证来决定使用哪个。</strong></p><p><strong>(2)正则化(Regularization):</strong></p><p>上面损失函数有一个问题。假设有一个数据集和一个权重集<strong>W</strong>能够正确地分类每个数据（即所有的边界都满足，对于所有的i都有$L_i=0$）。问题在于这个<strong>W</strong>并不唯一：可能有很多相似的W都能正确地分类所有的数据。</p><p>我们希望能向某些特定的权重<strong>W</strong>添加一些偏好，对其他权重则不添加，以此来消除模糊性。这一点是能够实现的，方法是向损失函数增加一个正则化惩罚（regularization penalty）$R(W)$部分。最常用的正则化惩罚是L2范式，L2范式通过对所有参数进行逐元素的平方惩罚来抑制大数值的权重：</p><script type="math/tex; mode=display">R(W)=\sum_{k} \sum_{l} W_{k, l}^{2}</script><p>上面的表达式中，将<strong>W</strong>中所有元素平方后求和。注意<strong>正则化函数不是数据的函数，仅基于权重</strong>。包含正则化惩罚后，就能够给出完整的多类SVM损失函数了，它由两个部分组成：<strong>数据损失</strong>（data loss），即所有样例的的平均损失$L_i$，以及<strong>正则化损失</strong>（regularization loss）。完整公式如下所示：</p><script type="math/tex; mode=display">L=\frac{1}{N} \sum_{i} \sum_{j \neq y_{i}}\left[\max \left(0, f\left(x_{i} ; W\right)_{j}-f\left(x_{i} ; W\right)_{y_{i}}+\Delta\right)\right]+\lambda \sum_{k} \sum_{l} W_{k, l}^{2}</script><p>其中，N是训练集的数据量。现在正则化惩罚添加到了损失函数里面，并用超参数$\lambda$来计算其权重。该超参数无法简单确定，需要通过交叉验证来获取。</p><p><strong>注意:</strong>和权重不同，偏差没有这样的效果，因为它们并不控制输入维度上的影响强度。因此通常只对权重[公式]正则化，而不正则化偏差[公式]。在实际操作中，可发现这一操作的影响可忽略不计。最后，因为正则化惩罚的存在，不可能在所有的例子中得到0的损失值，这是因为只有当[公式]的特殊情况下，才能得到损失值为0。</p><p><strong>正则化惩罚好的性质：</strong></p><p>对大数值权重进行惩罚，可以提升其泛化能力，因为这就意味着没有哪个维度能够独自对于整体分值有过大的影响。</p><p><strong>实际考虑设置Delta：</strong> <strong>在绝大多数情况下设为$ \Delta = 1.0$都是安全的</strong>。超参数$ \Delta$和$ \lambda$看起来是两个不同的超参数，但实际上他们一起控制同一个权衡：即损失函数中的数据损失和正则化损失之间的权衡。理解这一点的关键是要知道，权重<strong>W</strong>的大小对于分类分值有直接影响（当然对他们的差异也有直接影响）：当我们将<strong>W</strong>中值缩小，分类分值之间的差异也变小，反之亦然。因此，不同分类分值之间的边界的具体值（比如[公式]或[公式]）从某些角度来看是没意义的，<strong>因为权重自己就可以控制差异变大和缩小。也就是说，真正的权衡是我们允许权重能够变大到何种程度（通过正则化强度$ \lambda$来控制）。</strong></p><h2 id="Softmax分类器"><a href="#Softmax分类器" class="headerlink" title="Softmax分类器"></a>Softmax分类器</h2><p>SVM是最常用的两个分类器之一，而另一个就是Softmax分类器。Softmax分类器就可以理解为逻辑回归分类器面对多个分类的一般化归纳。SVM将输出$f(x_i,W)$作为每个分类的评分（因为无定标，所以难以直接解释）。与SVM不同，Softmax的输出（归一化的分类概率）更加直观，并且从概率上可以解释。在Softmax分类器中，函数映射$f(x_i,W)=Wx_i$保持不变，但将这些评分值视为每个分类的未归一化的对数概率，并且将折叶损失（hinge loss）替换为<strong>交叉熵损失</strong>（cross-entropy loss）。公式如下：</p><script type="math/tex; mode=display">L i=-\log \left(\frac{e^{f_{y_{i}}}}{\sum_{j} e^{f_{j}}}\right)</script><p>$f_{j}(z)=\frac{e^{z_{j}}}{\sum_{k} e^{z_{k}}}$被称作softmax 函数.</p><p>概率论解释：</p><script type="math/tex; mode=display">P\left(y_{i} | x_{i}, W\right)=\frac{e^{f_{y_{i}}}}{\sum_{j} e^{f_{j}}}</script><p>可以解释为是给定图像数据$x_i$，以$W$为参数，分配给正确分类标签$ y_i$的归一化概率。</p><p><strong>实操事项：注意数值稳定。</strong></p><p>编程实现softmax函数计算的时候，中间项$ e^{f_{y_{i}}}$和$ \sum_{j} e^{f_{j}}$因为存在指数函数，所以数值可能非常大。除以大数值可能导致数值计算的不稳定，所以学会使用归一化技巧非常重要。如果在分式的分子和分母都乘以一个常数$ C$，并把它变换到求和之中，就能得到一个从数学上等价的公式：</p><script type="math/tex; mode=display">\frac{e^{f_{y_{i}}}}{\sum_{j} e^{f_{j}}}=\frac{C e^{f_{y_{i}}}}{C \sum_{j} e^{f_{j}}}=\frac{e^{f_{y_{i}}+\log C}}{\sum_{j} e^{f_{j}+\log C}}</script><p>$ C$的值可自由选择，不会影响计算结果，通过使用这个技巧可以提高计算中的数值稳定性。通常将$ C$设为$ logC = -max f_j$。该技巧简单地说，就是应该将向量$f$中的数值进行平移，使得最大值为0。代码实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f = np.array([<span class="number">123</span>, <span class="number">456</span>, <span class="number">789</span>]) <span class="comment"># 例子中有3个分类，每个评分的数值都很大</span></span><br><span class="line">p = np.exp(f) / np.sum(np.exp(f)) <span class="comment"># 不妙：数值问题，可能导致数值爆炸</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 那么将f中的值平移到最大值为0：</span></span><br><span class="line">f -= np.max(f) <span class="comment"># f becomes [-666, -333, 0]</span></span><br><span class="line">p = np.exp(f) / np.sum(np.exp(f)) <span class="comment"># 现在OK了，将给出正确结果</span></span><br></pre></td></tr></table></figure><h2 id="SVM和Softmax的比较"><a href="#SVM和Softmax的比较" class="headerlink" title="SVM和Softmax的比较"></a>SVM和Softmax的比较</h2><p><strong>命名规则：</strong>精确地说，SVM分类器使用的是折叶损失（hinge loss），有时候又被称为最大边界损失（max-margin loss）。Softmax分类器使用的是交叉熵损失（corss-entropy loss）。</p><p><img src="/2019/10/28/分类器/004.png" alt></p><p>Softmax分类器为每个分类提供了“可能性”,即给出了每种分类的归一化概率。</p><p>​        在实际使用中，SVM和Softmax经常是相似的：通常说来，两种分类器的表现差别很小，不同的人对于哪个分类器更好有不同的看法。相对于Softmax分类器，SVM更加“局部目标化（local objective）”，这既可以看做是一个特性，也可以看做是一个劣势。考虑一个评分是[10, -2, 3]的数据，其中第一个分类是正确的。那么一个SVM（$\Delta = 1$）会看到正确分类相较于不正确分类，已经得到了比边界值还要高的分数，它就会认为损失值是0。SVM对于数字个体的细节是不关心的：如果分数是[10, -100, -100]或者[10, 9, 9]，对于SVM来说没设么不同，只要满足超过边界值等于1，那么损失值就等于0。</p><p>​        对于softmax分类器，情况则不同。对于[10, 9, 9]来说，计算出的损失值就远远高于[10, -100, -100]的。换句话来说，softmax分类器对于分数是永远不会满意的：正确分类总能得到更高的可能性，错误分类总能得到更低的可能性，损失值总是能够更小。但是，SVM只要边界值被满足了就满意了，不会超过限制去细微地操作具体分数。这可以被看做是SVM的一种特性。举例说来，一个汽车的分类器应该把他的大量精力放在如何分辨小轿车和大卡车上，而不应该纠结于如何与青蛙进行区分，因为区分青蛙得到的评分已经足够低了。</p><h2 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h2><p>1）基于参数的评分函数。该函数将原始图像像素映射为分类评分值（例如：一个线性函数）。<br>2）损失函数。该函数能够根据分类评分和训练集图像数据实际分类的一致性，衡量某个具体参数集的质量好坏。损失函数有多种版本和不同的实现方式（例如：Softmax或SVM）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;线性分类器&quot;&gt;&lt;a href=&quot;#线性分类器&quot; class=&quot;headerlink&quot; title=&quot;线性分类器&quot;&gt;&lt;/a&gt;线性分类器&lt;/h2&gt;&lt;p&gt;神经网络方法包含两部分组成：&lt;strong&gt;评分函数（score function）和损失函数（loss funct
      
    
    </summary>
    
    
      <category term="深度学习" scheme="http://yuemingyang7010.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="CS231N笔记" scheme="http://yuemingyang7010.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/CS231N%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="DeepLearning" scheme="http://yuemingyang7010.github.io/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>多线程编程</title>
    <link href="http://yuemingyang7010.github.io/2019/08/29/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    <id>http://yuemingyang7010.github.io/2019/08/29/多线程编程/</id>
    <published>2019-08-29T05:52:09.000Z</published>
    <updated>2019-08-30T01:32:49.284Z</updated>
    
    <content type="html"><![CDATA[<p>从C++11新标准开始，C++语言本身增加了对多线程的支持，意味着使用C++可实现多线程程序的可移植，跨平台。一个书写良好的程序，必须等所有的子线程执行完毕之后，主线程才能结束。</p><p><a href="https://www.bilibili.com/video/av48611530/?p=10" target="_blank" rel="noopener">C++并发与多线程视频教程</a></p><p><a href="https://www.jianshu.com/p/5d273e4e3cbb" target="_blank" rel="noopener">[c++11]多线程编程(一)——初识</a></p><p><a href="https://www.jianshu.com/p/109df8a7e627" target="_blank" rel="noopener">[c++11]多线程编程(二)——理解线程类的构造函数</a></p><p><a href="https://www.jianshu.com/p/4a2578dd9b5d" target="_blank" rel="noopener">[c++11]多线程编程(三)——竞争条件与互斥锁</a></p><p><a href="https://www.jianshu.com/p/c01e992a3d9d" target="_blank" rel="noopener">[c++11]多线程编程(四)——死锁(Dead Lock)</a></p><p><a href="https://www.jianshu.com/p/34d219380d90" target="_blank" rel="noopener">[c++11]多线程编程(五)——unique_lock</a></p><p><a href="https://www.jianshu.com/p/c1dfa1d40f53" target="_blank" rel="noopener">[c++11]多线程编程(六)——条件变量(Condition Variable)</a></p><p><a href="https://www.cnblogs.com/moodlxs/p/10111601.html" target="_blank" rel="noopener">C++11 使用异步编程std::async和std::future</a></p><h2 id="C-11创建线程基本方法"><a href="#C-11创建线程基本方法" class="headerlink" title="C++11创建线程基本方法"></a>C++11创建线程基本方法</h2><h3 id="1-1-使用函数创建线程"><a href="#1-1-使用函数创建线程" class="headerlink" title="1.1 使用函数创建线程"></a>1.1 使用函数创建线程</h3><h4 id="1-添加头文件"><a href="#1-添加头文件" class="headerlink" title="1 添加头文件"></a>1 添加头文件</h4><p>添加头文件以使用多线程：#include <thread></thread></p><h4 id="2-创建初始函数"><a href="#2-创建初始函数" class="headerlink" title="2  创建初始函数"></a>2  创建初始函数</h4><p>定义一个函数，这个函数将会作为我们创建的线程的初始函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"start executing my thread..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 在程序中添加线程，以及基本的线程函数</p><p>新建一个线程使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread 线程名称（初始函数）</span><br></pre></td></tr></table></figure><p><strong>join()函数</strong></p><p>用法：线程名称.join()</p><p>说明：使用该函数后，<strong>主线程阻塞到这里，当子线程执行完毕，这个join()函数就执行完毕，主线程也就可以继续运行了。</strong></p><p><strong>detach()函数</strong></p><p>传统多线程程序，主线程要等待子线程执行完毕，然后自己再退出。</p><p>deteach的意思是分离，<strong>也就是主线程不必和子线程汇合了，主线程与子线程各自执行。</strong>引入detach()是为了避免让主线程逐个等待子线程结,但是以后就不能被主线程控制或者回收了，不太推荐用，除非子线程与主线程业务无关。</p><p><strong>joinable()函数</strong></p><p><strong>判断是否可以成功使用join()或者detach()，返回true则可以，返回false则不可以。</strong></p><p>最后的完整程序如下，您可以通过依次运行mythread.join()，mythread.detach()函数查看程序运行结果以加深对这几个函数的理解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"子线程运行"</span> &lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">mythread</span><span class="params">(thread_function)</span></span>;        <span class="comment">// 传递初始函数作为线程的参数</span></span><br><span class="line">    <span class="keyword">if</span>(mythread.joinable())</span><br><span class="line">        mythread.join();                     <span class="comment">// 使用join()函数阻塞主线程直至子线程执行完毕</span></span><br><span class="line">    <span class="keyword">if</span>(mythread.joinable())</span><br><span class="line">        mythread.detach();                   <span class="comment">// 使用detach()函数让子线程和主线程并行运行，主线程也不再等待子线程。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"主线程运行"</span> &lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-运行结果分析"><a href="#4-运行结果分析" class="headerlink" title="4 运行结果分析"></a>4 运行结果分析</h4><p>如果只使用join()函数，注释detach()函数，运行结果如下，为顺序执行： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">子线程运行<span class="number">1</span></span><br><span class="line">子线程运行<span class="number">2</span></span><br><span class="line">子线程运行<span class="number">3</span></span><br><span class="line">子线程运行<span class="number">4</span></span><br><span class="line">子线程运行<span class="number">5</span></span><br><span class="line">主线程运行<span class="number">1</span></span><br><span class="line">主线程运行<span class="number">2</span></span><br><span class="line">主线程运行<span class="number">3</span></span><br><span class="line">主线程运行<span class="number">4</span></span><br><span class="line">主线程运行<span class="number">5</span></span><br></pre></td></tr></table></figure><p>​    如果只使用detach()函数，运行结果如下，每次执行的结果均不相同：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">子线程运行主线程运行<span class="number">11</span></span><br><span class="line"></span><br><span class="line">主线程运行<span class="number">2</span></span><br><span class="line">子线程运行<span class="number">2</span></span><br><span class="line">子线程运行<span class="number">3</span></span><br><span class="line">子线程运行<span class="number">4</span></span><br><span class="line">子线程运行<span class="number">5</span></span><br><span class="line">主线程运行<span class="number">3</span></span><br><span class="line">主线程运行<span class="number">4</span></span><br><span class="line">主线程运行<span class="number">5</span></span><br></pre></td></tr></table></figure><p>带参数的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myprint</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span>&#123;   <span class="comment">//最好不用引用，不安全，如果是引用，线程外的n改变会影响线程工作</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; n &lt;&lt; str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">thread <span class="title">threrad1</span><span class="params">(myprint,<span class="number">5</span>,<span class="string">"yue"</span>)</span></span>;</span><br><span class="line">threrad1.join();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5yue</span><br></pre></td></tr></table></figure><h3 id="1-2-使用类对象创建线程"><a href="#1-2-使用类对象创建线程" class="headerlink" title="1.2 使用类对象创建线程"></a>1.2 使用类对象创建线程</h3><p>创建thread的时候参数不仅可以是一个函数，也可以是一个类的对象。这个类中需要重载运算符()，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 运算符重载 </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span>  <span class="comment">//不能带参数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"子线程运行"</span> &lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Thread t;</span><br><span class="line">    <span class="function">thread <span class="title">mythread</span><span class="params">(t)</span></span>;        <span class="comment">// ！！！将对象复制到线程中去，所以复制后t销毁了也没关系。！！！</span></span><br><span class="line">    <span class="keyword">if</span>(mythread.joinable())</span><br><span class="line">        mythread.join();       <span class="comment">// 使用join()函数阻塞主线程直至子线程执行完毕</span></span><br><span class="line">    <span class="keyword">if</span>(mythread.joinable())</span><br><span class="line">        mythread.detach();     <span class="comment">// 使用detach()函数让子线程和主线程并行运行，主线程也不再等待子线程。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"主线程运行"</span> &lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>detach()之后子线程就分离了，运行完了由C++运行时库回收，并且detach()之后就不能join了。</strong></p><h3 id="1-3-detach-的坑"><a href="#1-3-detach-的坑" class="headerlink" title="1.3 detach()的坑"></a>1.3 detach()的坑</h3><p>坑的原因：子线程还没运行完，主线程就运行完了。</p><p>（比如传进一个主线程中字符串数组的指针，但是用了detach(),如果主线程先退出了，此时对该数组的操作可能出问题。）</p><p>子线程参数通过构造临时对象的方式来进行传递，构造临时对象主要有两种情况<br>（1）传递int这种简单类型参数<strong>，建议使用值传递，不要使用引用</strong>，防止节外生枝。<br>（2）如果传递类对象，一律在创建线程的地方就通过隐式转换构建临时对象，然后在函数形参处使用引用（节约资源）。</p><h2 id="多线程数据共享问题分析"><a href="#多线程数据共享问题分析" class="headerlink" title="多线程数据共享问题分析"></a>多线程数据共享问题分析</h2><p>问题：（1）只读数据：是安全稳定的，不需要特别的处理手段，只是不做其他处理，线程读取的顺序不能控制；</p><p>（2）有写的情况：例如，2个线程写，8个线程读，没有特殊处理，程序会崩溃，最简单的就是读的时候不能写，写的时候不能读。（3）多线程按顺序执行问题。</p><h3 id="1-互斥量mutex"><a href="#1-互斥量mutex" class="headerlink" title="1.互斥量mutex"></a>1.互斥量mutex</h3><p>一般情况下，最简单的协调不同线程之间的调度关系，都<strong>可以使用mutex来做，本质是信号量。</strong></p><p>std::mutex 的成员函数有四个：</p><p><strong>构造函数</strong>，std::mutex不允许拷贝构造，也不允许 move 拷贝，最初产生的 mutex 对象是处于 unlocked 状态的。<br><strong>lock()</strong>，调用线程将锁住该互斥量。线程调用该函数会发生下面 3 种情况：<br>(1). 如果该互斥量当前没有被锁住，则调用线程将该互斥量锁住，<strong>直到调用 unlock之前，该线程一直拥有该锁</strong>。<br>(2). 如果当前互斥量被其他线程锁住，则当前的调用线程<strong>被阻塞住</strong>。<br>(3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。<br><strong>unlock()</strong>， 解锁，释放对互斥量的所有权。<br><strong>try_lock()</strong>，尝试锁住互斥量，如果互斥量被其他线程占有，则当前线程也不会被阻塞。线程调用该函数也会出现下面 3 种情况，<br>(1). 如果当前互斥量没有被其他线程占有，则该线程锁住互斥量，<strong>直到该线程调用 unlock 释放互斥量</strong>。<br>(2). 如果当前互斥量被其他线程锁住，则当前调用线程返回 false，而并<strong>不会被阻塞掉</strong>。<br>(3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。</p><h3 id="2-lock-guard类模板"><a href="#2-lock-guard类模板" class="headerlink" title="2.lock_guard类模板"></a>2.lock_guard类模板</h3><p><strong>功能：取代mutex的lock()和unlock()</strong></p><p>如果mu.lock()和mu.unlock()之间的语句发生了异常，会发生什么？<strong>unlock()语句没有机会执行</strong>！导致导致mu一直处于锁着的状态（死锁）。</p><p><code>为解决这一问题，c++</code>库已经提供了<code>std::lock_guard</code>类模板，将lock()放在构造函数中，unlock()放在析构函数中，使用方法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shared_print</span><span class="params">(<span class="built_in">string</span> msg, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="comment">//构造的时候帮忙上锁，析构的时候释放锁</span></span><br><span class="line"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; guard(mu);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; msg &lt;&lt; id &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当在cout之后还有比较多的代码需要执行，而又不想锁住，可添加{}，提前结束lock_guard的生命周期，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shared_print</span><span class="params">(<span class="built_in">string</span> msg, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="comment">//构造的时候帮忙上锁，析构的时候释放锁</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; guard(mu);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; msg &lt;&lt; id &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">do something</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-std-lock-mu1-mu2-…-函数模板"><a href="#3-std-lock-mu1-mu2-…-函数模板" class="headerlink" title="3.std::lock(mu1,mu2,…)函数模板"></a>3.std::lock(mu1,mu2,…)函数模板</h3><p><strong>功能：解决上锁顺序导致的死锁</strong></p><p>死锁需要两个及其以上的互斥量才会发生，举一个死锁的例子：</p><p>例如有两个互斥量，叫做锁1和锁2，有两个线程，线程1，线程2，线程1所要执行的代码中都有，对锁1加锁，然后对锁2加锁，线程2所要执行的代码中，先对锁2加锁，再对锁1加锁。  可能出现，线程1锁了锁1，准备锁2时，由于上下切换，线程2去锁了锁2，于是线程1始终无法锁锁2，线程2始终无法锁住锁1，各自拥有的锁也不释放，从而造成僵持状态。</p><p>解决方法：<strong>只要保证上锁顺序一致就不会出现死锁。</strong></p><p>std:：lock()函数模板：一次锁住两个或者两个以上的互斥量（至少两个，多了不限，1个不行）；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::lock(_mu, _mu2);</span><br></pre></td></tr></table></figure><p>//它<strong>不存在这种因为再多个线程中因为锁的顺序问题导致死锁的风险问题</strong>；<br>//std:：lock()；如果互斥量中有一个没锁柱，它就在那里等着，<strong>等所有互斥量都锁住，它才能往下走（返回）</strong>；</p><p>该方法要谨慎使用。</p><p>问题：对多个互斥量上锁后，需要unlock()，这个时候可以采用<strong>lock()和lock_guard</strong>相结合的方式，先用lock()对多个互斥量上锁，再使用<code>std::adopt_lock</code>表示无需上锁，但会在超出作用于释放锁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; guard(_mu2, <span class="built_in">std</span>::adopt_lock);</span><br><span class="line"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; guard2(_mu, <span class="built_in">std</span>::adopt_lock);</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogFile</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::mutex _mu;</span><br><span class="line">    <span class="built_in">std</span>::mutex _mu2;</span><br><span class="line">    ofstream f;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LogFile() &#123;</span><br><span class="line">        f.open(<span class="string">"log.txt"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~LogFile() &#123;</span><br><span class="line">        f.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shared_print</span><span class="params">(<span class="built_in">string</span> msg, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::lock(_mu, _mu2);</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; guard(_mu, <span class="built_in">std</span>::adopt_lock);</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; guard2(_mu2, <span class="built_in">std</span>::adopt_lock);</span><br><span class="line">        f &lt;&lt; msg &lt;&lt; id &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; msg &lt;&lt; id &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shared_print2</span><span class="params">(<span class="built_in">string</span> msg, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::lock(_mu, _mu2);</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; guard(_mu2, <span class="built_in">std</span>::adopt_lock);</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; guard2(_mu, <span class="built_in">std</span>::adopt_lock);</span><br><span class="line">        f &lt;&lt; msg &lt;&lt; id &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; msg &lt;&lt; id &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function_1</span><span class="params">(LogFile&amp; <span class="built_in">log</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&gt;<span class="number">-100</span>; i--)</span><br><span class="line">        <span class="built_in">log</span>.shared_print2(<span class="built_in">string</span>(<span class="string">"From t1: "</span>), i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LogFile <span class="built_in">log</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span><span class="params">(function_1, <span class="built_in">std</span>::ref(<span class="built_in">log</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)</span><br><span class="line">        <span class="built_in">log</span>.shared_print(<span class="built_in">string</span>(<span class="string">"From main: "</span>), i);</span><br><span class="line"></span><br><span class="line">    t1.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-unique-lock类模板"><a href="#4-unique-lock类模板" class="headerlink" title="4.unique_lock类模板"></a>4.unique_lock类模板</h3><p>功能：unique_lock取代lock_guard<br>（1）unique_lock是个类模板，工作中，一般lock_guard（绝大多数情况都能满足，推荐使用）//unique_lock比lock_guard灵活很多；效率上差一点，内存占用多一点。</p><p>（2）unique_lock的第二个参数：</p><p><strong>(a)std:：adopt_lock</strong>和lock_guard相同，就是不再让unique_lock的构造函数中lock()这个mutex;</p><p><strong>(b)std:：try_to_lock</strong><br>尝试用mutex的lock()去锁定这个mutex，但如果没有锁定成功，我也会立即返回，并不会阻塞在那里；用这个try_to_lock的前提是不能先去lock()。<br><strong>(c))std:：defer_lock</strong><br>用这个defer_lock的前提是不能自己先lock，否则会报异常。<br>defer_lock的意思就是并没有给mutext加锁：初始化了一个没有加锁的mutex。</p><p>5.条件变量condition_variable</p><p>（3）unique_lock的重更成员函数（一般在std:：defer_lock参数下） </p><p>功能：常见用法可以更加灵活地<strong>提供细粒度的锁</strong>，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogFile</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::mutex _mu;</span><br><span class="line">    ofstream f;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LogFile() &#123;</span><br><span class="line">        f.open(<span class="string">"log.txt"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~LogFile() &#123;</span><br><span class="line">        f.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shared_print</span><span class="params">(<span class="built_in">string</span> msg, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; guard(_mu);</span><br><span class="line">        <span class="comment">//do something 1</span></span><br><span class="line">        guard.unlock(); <span class="comment">//临时解锁</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//do something 2</span></span><br><span class="line"></span><br><span class="line">        guard.lock(); <span class="comment">//继续上锁</span></span><br><span class="line">        <span class="comment">// do something 3</span></span><br><span class="line">        f &lt;&lt; msg &lt;&lt; id &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; msg &lt;&lt; id &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 结束时析构guard会临时解锁</span></span><br><span class="line">        <span class="comment">// 这句话可要可不要，不写，析构的时候也会自动执行</span></span><br><span class="line">        <span class="comment">// guard.ulock();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>(a) lock()，加锁<br>(b) unlock()，(临时)解锁；<br>(c) try_lock()，尝试给互斥量加锁，如果拿不到锁，则返回false，如果拿到了锁，返回true，这个数不阳塞的；<br>(d) release()，返回它所管理的mutex对象指针，并释放所有权；也就是说，这个unique_lock和mutex不再有关系。<br>注意严格区分unlock 0和release）的区，不要混淆。用release()的话，如果已经加锁，进行该操作，有责任需要自己unlock().</p><p>（4）unique_lock所有权转移</p><p>不可复制，可移动</p><p>unique_lock和lock_guard都不能复制，lock_guard不能移动，但是unique_lock可以！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unique_lock 可以移动，不能复制</span></span><br><span class="line"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; guard1(_mu);</span><br><span class="line"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; guard2 = guard1;  <span class="comment">// error</span></span><br><span class="line"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; guard2 = <span class="built_in">std</span>::move(guard1); <span class="comment">// ok ,guard2接管guard1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// lock_guard 不能移动，不能复制</span></span><br><span class="line"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; guard1(_mu);</span><br><span class="line"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; guard2 = guard1;  <span class="comment">// error</span></span><br><span class="line"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; guard2 = <span class="built_in">std</span>::move(guard1); <span class="comment">// error</span></span><br></pre></td></tr></table></figure><h3 id="5-条件变量condition-vriable类模板"><a href="#5-条件变量condition-vriable类模板" class="headerlink" title="5.条件变量condition_vriable类模板"></a>5.条件变量condition_vriable类模板</h3><p>需要包含：#include <condition_variable></condition_variable></p><p>condition_vriable这个类需要和互斥量配合使用，用的时候我们要生成这个类的对象。</p><p>主要有以下几个函数：</p><p>wait(),notify_one(),notify_all().</p><p>wait()函数有两个参数：<br>（1）如果第二个参数lambda表达式返回值是true，那wait()直接返回；<br>（2）如果第二个参数lambda表达式返回值是false，那么wait()将解锁互斥量，并阻塞到本行，<br>            那堵塞到什么时候为止呢？堵塞到其他某个线程调用notify_one()或者notify_all()成员函数为止；<br>(3)如果wait()没有第二个参数就跟第二个参数lambda表达式返回false效果一样。</p><p>不用第二个参数的形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; locker(mu);</span><br><span class="line">q.push_front(count);</span><br><span class="line">locker.unlock();</span><br><span class="line">cond.notify_one();  <span class="comment">// Notify one waiting thread, if there is one.</span></span><br><span class="line"><span class="comment">//std::this_thread::sleep_for(std::chrono::seconds(1));</span></span><br><span class="line">count--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (data != <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; locker(mu);</span><br><span class="line"><span class="keyword">while</span> (q.empty())</span><br><span class="line">cond.wait(locker); <span class="comment">// Unlock mu and wait to be notified</span></span><br><span class="line">data = q.back();</span><br><span class="line">q.pop_back();</span><br><span class="line">locker.unlock();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"t2 got a value from t1: "</span> &lt;&lt; data &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="built_in">std</span>::mutex mu;</span><br><span class="line"><span class="built_in">std</span>::condition_variable cond;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">A a;</span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span><span class="params">(&amp;A::function_1,&amp;a)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t2</span><span class="params">(&amp;A::function_2,&amp;a)</span></span>;</span><br><span class="line">t1.join();</span><br><span class="line">t2.join();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要用第二个参数，可以不用notify_one(),直接用lambda表达式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; locker(mu);</span><br><span class="line">q.push_front(count);</span><br><span class="line">locker.unlock();</span><br><span class="line"><span class="comment">//cond.notify_one();  // Notify one waiting thread, if there is one.</span></span><br><span class="line"><span class="comment">//std::this_thread::sleep_for(std::chrono::seconds(1));</span></span><br><span class="line">count--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (data != <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; locker(mu);</span><br><span class="line"><span class="comment">//while (q.empty())</span></span><br><span class="line"><span class="comment">//cond.wait(locker); // Unlock mu and wait to be notified</span></span><br><span class="line">cond.wait(locker, [<span class="keyword">this</span>]()&#123;  <span class="comment">//一个lambda就是一个可调用的对象(函数)</span></span><br><span class="line"><span class="keyword">if</span> (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;);</span><br><span class="line">data = q.back();</span><br><span class="line">q.pop_back();</span><br><span class="line">locker.unlock();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"t2 got a value from t1: "</span> &lt;&lt; data &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="built_in">std</span>::mutex mu;</span><br><span class="line"><span class="built_in">std</span>::condition_variable cond;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">A a;</span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span><span class="params">(&amp;A::function_1,&amp;a)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t2</span><span class="params">(&amp;A::function_2,&amp;a)</span></span>;</span><br><span class="line">t1.join();</span><br><span class="line">t2.join();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>存在的坑：</strong></p><p>（1）例如上例中，如果notify_one()唤醒wait()后，wait()后面还有很多代码需要执行，在执行过程中可能下一次循环又调用了notify_one()，而这个时候function_2()并不是阻塞在wait()处，这样将会使wait()无效果。</p><p>(2)根据(1)可知，不一定两个function都是交替执行，可能function_1()执行完notify_one()之后，马上又抢到锁，即连续朝队列中插入了两个(或多个)数据。</p><h3 id="6-使用异步编程std-async和std-future"><a href="#6-使用异步编程std-async和std-future" class="headerlink" title="6.使用异步编程std::async和std::future"></a>6.使用异步编程std::async和std::future</h3><p>需要包含 #include <future></future></p><p>std::future可以从异步任务中获取结果，一般与std::async配合使用，<strong>std::async</strong>用于创建异步任务，实际上就是<strong>创建一个线程执行相应任务。</strong></p><p>std::async就是异步编程的高级封装，封装了std::future的操作，基本上可以代替std::thread 的所有事情。</p><p>future对象是std::async、std::promise、std::packaged_task的底层对象，用来<strong>传递其他线程中操作的数据结果。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mythread</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"mythread start"</span> &lt;&lt; <span class="string">" threadID:"</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">chrono::<span class="function">milliseconds <span class="title">sleep1</span><span class="params">(<span class="number">1000</span>)</span></span>;</span><br><span class="line">this_thread::sleep_for(sleep1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"mythread end"</span> &lt;&lt; <span class="string">" threadID:"</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"main"</span> &lt;&lt; <span class="string">"threadID:"</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">future&lt;<span class="keyword">int</span>&gt; result = async(mythread);   <span class="comment">//async()创建一个异步任务（线程），将运行结果返回给futrue.</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"子线程返回值:"</span> &lt;&lt; result.get() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//阻塞在get()这里，等待mythread()执行完毕，拿到结果</span></span><br><span class="line">    <span class="comment">//result.wait();  // 等待线程返回，本省并不返回结果。</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mainthreadID:9964</span><br><span class="line">mythread start threadID:9964</span><br><span class="line">mythread end threadID:9964</span><br><span class="line">子线程返回值:5</span><br></pre></td></tr></table></figure><p>代码说明：</p><p>std::async会首先创建线程执行， 任务创建之后，std::async立即返回一个std::future对象。主线程既可使用<strong>std::future::get获取结果，如果调用过程中，任务尚未完成，则主线程阻塞至任务完成。</strong>　主线程也可使用std::future::wait_for等待结果返回，wait_for可设置超时时间，如果在超时时间之内任务完成，则返回std::future_status::ready状态；如果在超时时间之内任务尚未完成，则返回std::future_status::timeout状态。</p><p>注意：futrue的get()只能对一个任务执行一次，比如上例中不能get()两次。</p><p>如果传入的是一个带参数的类的成员函数，写法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;condition_variable&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;deque&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;mutex&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mythread</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"mythread start"</span> &lt;&lt; <span class="string">" threadID:"</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">chrono::<span class="function">milliseconds <span class="title">sleep1</span><span class="params">(<span class="number">1000</span>)</span></span>;</span><br><span class="line">this_thread::sleep_for(sleep1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"mythread end"</span> &lt;&lt; <span class="string">" threadID:"</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">A a;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"main"</span> &lt;&lt; <span class="string">"threadID:"</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">future&lt;<span class="keyword">int</span>&gt; result = async(&amp;A::mythread,&amp;a,<span class="number">10</span>);   <span class="comment">//async()创建一个异步任务（线程），将运行结果返回给futrue.</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"子线程返回值:"</span> &lt;&lt; result.get() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//阻塞在get()这里，等待mythread()执行完毕，拿到结果</span></span><br><span class="line">    <span class="comment">//result.wait();  // 等待线程返回，本省并不返回结果。</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mainthreadID:10208</span><br><span class="line">mythread start threadID:10208</span><br><span class="line">mythread end threadID:10208</span><br><span class="line">子线程返回值:10</span><br></pre></td></tr></table></figure><h3 id="7-std-：promise类模板"><a href="#7-std-：promise类模板" class="headerlink" title="7.std:：promise类模板"></a>7.std:：promise类模板</h3><p>需要包含 #include <future></future></p><p>std::promise是C++11并发编程中常用的一个类，常配合std::future使用。其作用是<strong>在一个线程t1中保存一个类型typename T的值，可供相绑定的std::future对象在另一线程t2中获取。</strong></p><p>关键点：（1）std::promise与std::future相绑定；（2）std::promise的对象set_value()，std::future的对象get()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Thread_Fun1</span><span class="params">(<span class="built_in">std</span>::promise&lt;<span class="keyword">int</span>&gt; &amp;p,<span class="keyword">int</span> temp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//为了突出效果，可以使线程休眠5s</span></span><br><span class="line"><span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">500</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> iVal = temp;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"传入数据(int)："</span> &lt;&lt; iVal &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入数据iVal</span></span><br><span class="line">p.set_value(iVal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Thread_Fun2</span><span class="params">(<span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt; &amp;f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//阻塞函数，直到收到相关联的std::promise对象传入的数据</span></span><br><span class="line"><span class="keyword">auto</span> iVal = f.get();<span class="comment">//iVal = 233</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"收到数据(int)："</span> &lt;&lt; iVal &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//声明一个std::promise对象pr1，其保存的值类型为int</span></span><br><span class="line"><span class="built_in">std</span>::promise&lt;<span class="keyword">int</span>&gt; pr1;</span><br><span class="line"><span class="comment">//声明一个std::future对象fu1，并通过std::promise的get_future()函数与pr1绑定</span></span><br><span class="line"><span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt; fu1 = pr1.get_future();</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">233</span>;</span><br><span class="line"><span class="comment">//创建一个线程t1，将函数Thread_Fun1及对象pr1放在线程里面执行</span></span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span><span class="params">(Thread_Fun1, <span class="built_in">std</span>::ref(pr1),<span class="number">233</span>)</span></span>;</span><br><span class="line"><span class="comment">//创建一个线程t2，将函数Thread_Fun2及对象fu1放在线程里面执行</span></span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t2</span><span class="params">(Thread_Fun2, <span class="built_in">std</span>::ref(fu1))</span></span>;</span><br><span class="line"></span><br><span class="line">t1.join();</span><br><span class="line">t2.join();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：上例其实使将主线程中的参数，传递给Thread_Fun1，然后再传递给Thread_Fun2，如果Thread_Fun1不含参数，直接set_value(233)，也会得到相同结果。</p><h3 id="8-原子操作atomic"><a href="#8-原子操作atomic" class="headerlink" title="8.原子操作atomic"></a>8.原子操作atomic</h3><p>互序量的加锁一般是针对一个代码段（几行代码），而<strong>原子操作针对的一般都是一个变量</strong>，而不是一个代码段；</p><p>通常非常适合用来控制代码块运行的<strong>全局标志位bool flag,还有计数值count等。</strong></p><p>原子操作，它表示在多个线程访问同一个全局资源的时候，能够确保所有其他线程都不在同一时间访问该资源。也就是确保了在同一时刻只有一个线程对这个资源进行访问。这有点<strong>类似互斥对象对共享资源的访问的保护，但是原子操作更加接近底层，因而效率更高。</strong></p><p>例如三个线程同时执行如下代码，由于num++编译后可能变成3条汇编，多个线程同时执行会使计算结果不正确。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程函数,内部对num自增1000万次</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000000</span>;i++) </span><br><span class="line">    &#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别不加锁，加锁，用原子操作进行实验：</p><p>实验结论（多线程操作全局变量，三个线程，每个线程对整型自增1000万次）</p><ol><li><p>非原子操作，不加锁，效率很高，但<strong>无法得到正确的结果；</strong></p></li><li><p>非原子操作，加锁，<strong>效率很低</strong>，大约和无锁的相差20倍，但结果正确；</p></li><li><p>原子操作，<strong>效率很高</strong>，大约是有锁实现的5倍，且结果正确。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">atomic&lt;<span class="keyword">int</span>&gt; num(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数,内部对num自增1000万次</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">clock_t</span> startClock = clock();   <span class="comment">// 记下开始时间</span></span><br><span class="line"><span class="comment">// 3个线程,创建即运行</span></span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(Add)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">(Add)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">t3</span><span class="params">(Add)</span></span>;</span><br><span class="line"><span class="comment">// 等待3个线程结束</span></span><br><span class="line">t1.join();</span><br><span class="line">t2.join();</span><br><span class="line">t3.join();</span><br><span class="line"><span class="keyword">clock_t</span> endClock = clock();     <span class="comment">// 记下结束时间</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"耗时:"</span> &lt;&lt; endClock - startClock &lt;&lt; <span class="string">",单位:"</span> &lt;&lt; CLOCKS_PER_SEC &lt;&lt; <span class="string">",result:"</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">耗时:1767,单位:1000,result:30000000</span><br></pre></td></tr></table></figure><h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><h2 id="C-11处理常见的多线程问题"><a href="#C-11处理常见的多线程问题" class="headerlink" title="C++11处理常见的多线程问题"></a>C++11处理常见的多线程问题</h2><h3 id="leetcode1114-按顺序打印"><a href="#leetcode1114-按顺序打印" class="headerlink" title="leetcode1114 按顺序打印"></a>leetcode1114 按顺序打印</h3><p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/95889253" target="_blank" rel="noopener">参考</a></p><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>我们提供了一个类：</p><p>public class Foo {<br>  public void one() { print(“one”); }<br>  public void two() { print(“two”); }<br>  public void three() { print(“three”); }<br>}<br>三个不同的线程将会共用一个 Foo 实例。</p><p>线程 A 将会调用 one() 方法<br>线程 B 将会调用 two() 方法<br>线程 C 将会调用 three() 方法<br>请设计修改程序，以确保 two() 方法在 one() 方法之后被执行，three() 方法在 two() 方法之后被执行。</p><p>示例 1:</p><p>输入: [1,2,3]<br>输出: “onetwothree”<br>解释:<br>有三个线程会被异步启动。<br>输入 [1,2,3] 表示线程 A 将会调用 one() 方法，线程 B 将会调用 two() 方法，线程 C 将会调用 three() 方法。<br>正确的输出是 “onetwothree”。<br>示例 2:</p><p>输入: [1,3,2]<br>输出: “onetwothree”<br>解释:<br>输入 [1,3,2] 表示线程 A 将会调用 one() 方法，线程 B 将会调用 three() 方法，线程 C 将会调用 two() 方法。<br>正确的输出是 “onetwothree”。</p><p>注意:</p><p>尽管输入中的数字似乎暗示了顺序，但是我们并不保证线程在操作系统中的调度顺序。</p><p>你看到的输入格式主要是为了确保测试的全面性。</p><h4 id="方法0：用一个mutex与标志位结合-耗时长"><a href="#方法0：用一个mutex与标志位结合-耗时长" class="headerlink" title="方法0：用一个mutex与标志位结合(耗时长)"></a>方法0：用一个mutex与标志位结合(耗时长)</h4><p>执行用时 :<strong>4192 ms</strong>, 在所有 C++ 提交中击败了<strong>5.10%</strong>的用户</p><p>内存消耗 :9.3 MB, 在所有 C++ 提交中击败了100.00%的用户</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo() &#123;</span><br><span class="line">        flag=<span class="number">1</span>;</span><br><span class="line">        count=<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">first</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printFirst)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag==<span class="number">1</span>)&#123;</span><br><span class="line">                mu.lock();</span><br><span class="line">                <span class="comment">// printFirst() outputs "first". Do not change or remove this line.</span></span><br><span class="line">                printFirst();  </span><br><span class="line">                count--;</span><br><span class="line">                mu.unlock();</span><br><span class="line">                flag=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">second</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printSecond)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag==<span class="number">2</span>)&#123;</span><br><span class="line">                mu.lock();</span><br><span class="line">                <span class="comment">// printSecond() outputs "second". Do not change or remove this line.</span></span><br><span class="line">                printSecond();  </span><br><span class="line">                count--;</span><br><span class="line">                mu.unlock();</span><br><span class="line">                flag=<span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">third</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printThird)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag==<span class="number">3</span>)&#123;</span><br><span class="line">                mu.lock();</span><br><span class="line">                <span class="comment">// printThird() outputs "third". Do not change or remove this line.</span></span><br><span class="line">                printThird();  </span><br><span class="line">                count--;</span><br><span class="line">                mu.unlock();</span><br><span class="line">                flag=<span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printFirst</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"one"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printSecond</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"two"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printThird</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"three"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    mutex mu;</span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="方法1：用两个mutex锁"><a href="#方法1：用两个mutex锁" class="headerlink" title="方法1：用两个mutex锁"></a>方法1：用两个mutex锁</h4><p><strong>一个锁能控制两个线程的执行顺序。这个题中我们需要保持三个函数是按顺序执行的，则需要两个锁m1和m2。</strong></p><p>在开始的时候，两个锁都锁起来。first()可以直接执行，second()等待m1释放之后执行，third()等待m2释放之后执行。first()结束之后释放m1，second()结束之后释放m2.因此三个的顺序都协调一致了。</p><p>C++代码如下：</p><p>执行用时 :<strong>8 ms</strong>, 在所有 C++ 提交中击败了<strong>93.41%</strong>的用户</p><p>内存消耗 :9.1 MB, 在所有 C++ 提交中击败了100.00%的用户</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    mutex m1, m2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo() &#123;</span><br><span class="line">        m1.lock();</span><br><span class="line">        m2.lock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">first</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printFirst)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// printFirst() outputs "first". Do not change or remove this line.</span></span><br><span class="line">        printFirst();</span><br><span class="line">        m1.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">second</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printSecond)</span> </span>&#123;</span><br><span class="line">        m1.lock();</span><br><span class="line">        <span class="comment">// printSecond() outputs "second". Do not change or remove this line.</span></span><br><span class="line">        printSecond();</span><br><span class="line">        m1.unlock();</span><br><span class="line">        m2.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">third</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printThird)</span> </span>&#123;</span><br><span class="line">        m2.lock();</span><br><span class="line">        <span class="comment">// printThird() outputs "third". Do not change or remove this line.</span></span><br><span class="line">        printThird();</span><br><span class="line">        m2.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"first"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSecond</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"second"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printThird</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"third"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法2：promise-future"><a href="#方法2：promise-future" class="headerlink" title="方法2：promise/future"></a>方法2：promise/future</h4><p>这也是C++11中的新特性，可以把promise和future当做是在不同线程之间传递值的方式。在某个线程中对promise中生产一个数据，可以在另外一个线程中从future中获取这个数据。</p><p><strong>promise和future是绑定在一起的，可以调用promise::get_future()获取与其绑定的future。</strong><br><strong>future.wait()方法对当前的线程进行阻塞，等待与其绑定的promise调用set_value()方法。</strong><br><strong>future.get()方法对当前的线程进行阻塞，等待与其绑定的promise调用set_value()方法的返回值。</strong><br>因此实现线程的同步的方法会很方便。C++代码如下：</p><p>执行用时 :<strong>16 ms</strong>, 在所有 C++ 提交中击败了69.55%的用户</p><p>内存消耗 :9.4 MB, 在所有 C++ 提交中击败了100.00%的用户</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::promise&lt;<span class="keyword">void</span>&gt; p1;</span><br><span class="line">    <span class="built_in">std</span>::promise&lt;<span class="keyword">void</span>&gt; p2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">first</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printFirst)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// printFirst() outputs "first". Do not change or remove this line.</span></span><br><span class="line">        printFirst();</span><br><span class="line">        p1.set_value();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">second</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printSecond)</span> </span>&#123;</span><br><span class="line">        p1.get_future().wait();</span><br><span class="line">        <span class="comment">// printSecond() outputs "second". Do not change or remove this line.</span></span><br><span class="line">        printSecond();</span><br><span class="line">        p2.set_value();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">third</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printThird)</span> </span>&#123;</span><br><span class="line">        p2.get_future().wait();</span><br><span class="line">        <span class="comment">// printThird() outputs "third". Do not change or remove this line.</span></span><br><span class="line">        printThird();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"first"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSecond</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"second"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printThird</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"third"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="leetcode1115-交替打印FooBar"><a href="#leetcode1115-交替打印FooBar" class="headerlink" title="leetcode1115 交替打印FooBar"></a>leetcode1115 交替打印FooBar</h3><h4 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h4><p>我们提供一个类：</p><p>class FooBar {<br>  public void foo() {<br>    for (int i = 0; i &lt; n; i++) {<br>      print(“foo”);<br>    }<br>  }</p><p>  public void bar() {<br>    for (int i = 0; i &lt; n; i++) {<br>      print(“bar”);<br>    }<br>  }<br>}<br>两个不同的线程将会共用一个 FooBar 实例。其中一个线程将会调用 foo() 方法，另一个线程将会调用 bar() 方法。</p><p>请设计修改程序，以确保 “foobar” 被输出 n 次。</p><p>示例 1:</p><p>输入: n = 1<br>输出: “foobar”<br>解释: 这里有两个线程被异步启动。其中一个调用 foo() 方法, 另一个调用 bar() 方法，”foobar” 将被输出一次。<br>示例 2:</p><p>输入: n = 2<br>输出: “foobarfoobar”<br>解释: “foobar” 将被输出两次。</p><h4 id="方法：mutex交替加锁"><a href="#方法：mutex交替加锁" class="headerlink" title="方法：mutex交替加锁"></a>方法：mutex交替加锁</h4><p>执行用时 :<strong>28 ms</strong>, 在所有 C++ 提交中击败了44.50%的用户</p><p>内存消耗 :10.6 MB, 在所有 C++ 提交中击败了100.00%的用户</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    mutex m1,m2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    FooBar(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        m2.lock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printFoo)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            m1.lock();</span><br><span class="line">        <span class="comment">// printFoo() outputs "foo". Do not change or remove this line.</span></span><br><span class="line">        printFoo();</span><br><span class="line">            m2.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printBar)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            m2.lock();</span><br><span class="line">        <span class="comment">// printBar() outputs "bar". Do not change or remove this line.</span></span><br><span class="line">        printBar();</span><br><span class="line">            m1.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printFoo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Foo"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printBar</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Bar"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3个线程按照123的顺序循环打印一个字符串的每一个字符。"><a href="#3个线程按照123的顺序循环打印一个字符串的每一个字符。" class="headerlink" title="3个线程按照123的顺序循环打印一个字符串的每一个字符。"></a>3个线程按照123的顺序循环打印一个字符串的每一个字符。</h3><p><strong>本人笔记本测试用了33ms</strong></p><p>结合标志位和一个全局的mutex</p><h4 id="方法0：比较菜的方法"><a href="#方法0：比较菜的方法" class="headerlink" title="方法0：比较菜的方法"></a>方法0：比较菜的方法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> m_data = <span class="string">"abcdefghijklmnopqrstuvwxyz"</span>;  <span class="comment">//临界资源1</span></span><br><span class="line"><span class="keyword">int</span> len = m_data.size();</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;    <span class="comment">//临界资源2</span></span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>; <span class="comment">//临界资源3</span></span><br><span class="line">mutex mu;     <span class="comment">//不同线程共用一把锁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (i &lt; len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">mu.lock();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; m_data[i++] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">mu.unlock();</span><br><span class="line">flag = <span class="number">1</span>;   <span class="comment">//由于每个线程lock之外用的了flag,</span></span><br><span class="line"><span class="comment">//所以flag不能在unlock前改变，否则thread2线程可能马上进入if条件内，并抢用没有释放的锁</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (i &lt; len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">mu.lock();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; m_data[i++] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">mu.unlock();</span><br><span class="line">flag = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread3</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (i &lt; len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">2</span>) &#123;</span><br><span class="line">mu.lock();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; m_data[i++] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">mu.unlock();</span><br><span class="line">flag = <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">thread <span class="title">tesk01</span><span class="params">(thread1)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">tesk02</span><span class="params">(thread2)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">tesk03</span><span class="params">(thread3)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (tesk02.joinable())</span><br><span class="line">tesk02.join();</span><br><span class="line"><span class="keyword">if</span> (tesk01.joinable())</span><br><span class="line">tesk01.join();</span><br><span class="line"><span class="keyword">if</span> (tesk03.joinable())</span><br><span class="line">tesk03.join();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从C++11新标准开始，C++语言本身增加了对多线程的支持，意味着使用C++可实现多线程程序的可移植，跨平台。一个书写良好的程序，必须等所有的子线程执行完毕之后，主线程才能结束。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/
      
    
    </summary>
    
    
      <category term="C++基础" scheme="http://yuemingyang7010.github.io/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://yuemingyang7010.github.io/categories/C-%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="C++基础" scheme="http://yuemingyang7010.github.io/tags/C-%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://yuemingyang7010.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务</title>
    <link href="http://yuemingyang7010.github.io/2019/08/20/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    <id>http://yuemingyang7010.github.io/2019/08/20/分布式/</id>
    <published>2019-08-20T01:27:53.000Z</published>
    <updated>2019-08-22T04:30:38.681Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本地事务与分布式事务"><a href="#本地事务与分布式事务" class="headerlink" title="本地事务与分布式事务"></a>本地事务与分布式事务</h2><img src="/2019/08/20/分布式/08/20/分布式/01.png"><h2 id="两阶段提交协议-2PC"><a href="#两阶段提交协议-2PC" class="headerlink" title="两阶段提交协议(2PC)"></a>两阶段提交协议(2PC)</h2><p>两种常见方案：</p><img src="/2019/08/20/分布式/08/20/分布式/03.png"><h3 id="基于XA协议的两阶段提交方案"><a href="#基于XA协议的两阶段提交方案" class="headerlink" title="基于XA协议的两阶段提交方案"></a>基于XA协议的两阶段提交方案</h3><p>交易中间件与数据库通过 XA 接口规范，使用两阶段提交来完成一个全局事务， XA 规范的基础是两阶段提交协议。<br>第一阶段是表决阶段，所有参与者都将本事务能否成功的信息反馈发给协调者；第二阶段是执行阶段，协调者根据所有参与者的反馈，通知所有参与者，步调一致地在所有分支上提交或者回滚。</p><img src="/2019/08/20/分布式/08/20/分布式/02.png"><p>两阶段提交方案应用非常广泛，几乎所有商业OLTP数据库都支持XA协议。但是<strong>两阶段提交方案锁定资源时间长，对性能影响很大</strong>，基本不适合解决微服务事务问题。</p><h3 id="TCC（Try-Confirm-Cancel）两阶段补偿型方案"><a href="#TCC（Try-Confirm-Cancel）两阶段补偿型方案" class="headerlink" title="TCC（Try-Confirm-Cancel）两阶段补偿型方案"></a>TCC（Try-Confirm-Cancel）两阶段补偿型方案</h3><p><a href="https://wenku.baidu.com/view/be946bec0975f46527d3e104.html" target="_blank" rel="noopener">TCC方案</a>在电商、金融领域落地较多。TCC方案其实是两阶段提交的一种改进。其将整个业务逻辑的每个分支显式的分成了Try、Confirm、Cancel三个操作。Try部分完成业务的准备工作，confirm部分完成业务的提交，cancel部分完成事务的回滚。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;本地事务与分布式事务&quot;&gt;&lt;a href=&quot;#本地事务与分布式事务&quot; class=&quot;headerlink&quot; title=&quot;本地事务与分布式事务&quot;&gt;&lt;/a&gt;本地事务与分布式事务&lt;/h2&gt;&lt;img src=&quot;/2019/08/20/分布式/08/20/分布式/01.pn
      
    
    </summary>
    
    
      <category term="分布式" scheme="http://yuemingyang7010.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="http://yuemingyang7010.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题</title>
    <link href="http://yuemingyang7010.github.io/2019/07/30/LeetCode%E5%88%B7%E9%A2%98/"/>
    <id>http://yuemingyang7010.github.io/2019/07/30/LeetCode刷题/</id>
    <published>2019-07-30T15:21:56.000Z</published>
    <updated>2019-11-01T00:44:14.032Z</updated>
    
    <content type="html"><![CDATA[<h3 id><a href="#" class="headerlink" title=" "></a> </h3><h3 id="两数之和-1-易"><a href="#两数之和-1-易" class="headerlink" title="两数之和(1.易)"></a>两数之和(1.易)</h3><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><p>示例:</p><p>给定 nums = [2, 7, 11, 15], target = 9</p><p>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p><p>两遍遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            m[nums[i]] = i; <span class="comment">//先遍历一遍数组，建立HashMap映射</span></span><br><span class="line">        &#125;</span><br><span class="line">           <span class="comment">//然后再遍历一遍，开始查找，找到则记录index</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (m.count(t) &amp;&amp; m[t] != i) &#123;<span class="comment">//if里面的条件用于判断查找到的数字不是第一个数字</span></span><br><span class="line">                res.push_back(i);</span><br><span class="line">                res.push_back(m[t]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一次遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m.count(target - nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;i, m[target - nums[i]]&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            m[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="最小因式分解-625-中"><a href="#最小因式分解-625-中" class="headerlink" title="最小因式分解(625. 中)"></a>最小因式分解(625. 中)</h3><p>给定一个正整数 a，找出最小的正整数 b 使得 b 的所有数位相乘恰好等于 a。如果不存在这样的结果或者结果不是 32 位有符号整数，返回 0。</p><p>样例 1</p><p>输入：48<br>输出：68</p><p>样例 2</p><p>输入：15<br>输出：35</p><p>思路：</p><p>当该数小于10，直接返回该数，其他数分解出的因数一定是个位数字，即范围是[2, 9]。那我们就可以从大到小开始找因数，首先查找9是否是因数，是要能整除a，就是其因数，如果是的话，就加入到结果res的末尾，a自除以9，我们用while循环查找9，直到取出所有的9，然后取8，7，6…以此类推，如果a能成功的被分解的话，最后a的值应该为1，如果a值大于1，说明无法被分解，返回0。最后还要看我们结果res字符转为整型是否越界，越界的话还是返回0，参见代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">smallestFactorization</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a &lt; <span class="number">10</span>) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>, cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">9</span>; i &gt;= <span class="number">2</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (a % i == <span class="number">0</span>) &#123;</span><br><span class="line">                res += cnt * i;</span><br><span class="line">                <span class="keyword">if</span> (res &gt; INT_MAX) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                a /= i;</span><br><span class="line">                cnt *= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (a == <span class="number">1</span>) ? res : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="无重复字符的最长子串-3-中"><a href="#无重复字符的最长子串-3-中" class="headerlink" title="无重复字符的最长子串(3.中)"></a>无重复字符的最长子串(3.中)</h3><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:</p><p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:</p><p>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:</p><p>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p><p>思路：滑动窗口+HashMap</p><p>​        例如”abcabcbb”，让你手动找无重复字符的子串，比如子串a，b，c，然后又出现了一个a，那么此时就应该去掉第一次出现的a，然后继续往后，又出现了一个b，则应该去掉一次出现的b，以此类推，最终发现最长的长度为3。</p><p>​        用HashMap来建立字符和其出现位置之间的映射。进一步考虑，由于字符会重复出现，到底是保存所有出现的位置呢，还是只记录一个位置？我们之前手动推导的方法实际上是维护了一个<strong>滑动窗口</strong>，<strong>窗口内的都是没有重复的字符</strong>，我们需要尽可能的扩大窗口的大小。由于窗口在不停向右滑动，所以<strong>我们只关心每个字符最后出现的位置，并建立映射。窗口的右边界就是当前遍历到的字符的位置</strong>，为了求出窗口的大小，我们需要一个<strong>变量left来指向滑动窗口的左边界</strong>，这样，如果当前遍历到的字符从未出现过，那么直接扩大右边界，<strong>如果之前出现过</strong>，那么就<strong>分两种情况，在或不在滑动窗口内</strong>，如果不在滑动窗口内，那么就没事，当前字符可以加进来，如果在的话，就需要先在滑动窗口内去掉这个已经出现过的字符了，去掉的方法并不需要将左边界left一位一位向右遍历查找，由于我们的HashMap已经保存了该重复字符最后出现的位置，所以<strong>直接移动left指针就可以</strong>了。我们维护一个结果res，每次用出现过的窗口大小来更新结果res，就可以得到最终结果啦。</p><p>​        这里解释下程序中那个if条件语句中的两个条件m.count(s[i]) &amp;&amp; m[s[i]] &gt; left，因为一旦当前字符s[i]在HashMap已经存在映射，说明当前的字符已经出现过了，而若m[s[i]] &gt; left 成立，说明之前出现过的字符在我们的窗口内，那么如果要加上当前这个重复的字符，就要移除之前的那个，所以我们<strong>让left赋值为m[s[i]]</strong>，由于left是窗口左边界的前一个位置（这也是left初始化为-1的原因，因为窗口左边界是从0开始遍历的），所以相当于已经移除出滑动窗口了。举一个最简单的例子”aa”，当i=0时，我们建立了a-&gt;0的映射，并且此时结果res更新为1，那么当i=1的时候，我们发现a在HashMap中，并且映射值0大于left的-1，所以此时left更新为0，映射对更新为a-&gt;1，那么此时i-left还为1，不用更新结果res，那么最终结果res还为1，正确，代码如下：</p><p>解法一：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>,left=<span class="number">-1</span>,len=s.length(); <span class="comment">//left代表滑窗左边界元素的前一个元素位置</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;  <span class="comment">//key为字符串的每一个字符，value为该字符从左到右遍历过程中最后出现的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m.count(s[i]) &amp;&amp; m[s[i]]&gt;left)  <span class="comment">//如果满足字符在m中，并且还在滑动窗口中</span></span><br><span class="line">                left = m[s[i]];      <span class="comment">//更新左边界的前一个元素位置</span></span><br><span class="line">            m[s[i]] = i;   <span class="comment">//更新s[i]对应的位置，及s[i]最后出现的位置</span></span><br><span class="line">            res = max(res,i-left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>解法二：（本质和解法一完全一样）</p><p>解法二是解法一的精简模式，这里我们可以建立一个256位大小的整型数组来代替HashMap，然后我们全部初始化为-1，这样的好处是我们就不用像之前的HashMap一样要查找当前字符是否存在映射对了，对于每一个遍历到的字符，我们直接用其在数组中的值来更新left，因为默认是-1，而left初始化也是-1，所以并不会产生错误，这样就省了if判断的步骤，其余思路都一样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m[<span class="number">256</span>]=&#123;<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, left = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            left = max(left, m[s[i]]);  <span class="comment">//因为数组m初始值为-1，因此只有</span></span><br><span class="line"><span class="comment">//满足其值不为-1（即该字符出现过），并且m[s[i]]大于left的时候才会left = m[s[i]]; </span></span><br><span class="line">            m[s[i]] = i;</span><br><span class="line">            res = max(res, i - left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="两数相加-2-中"><a href="#两数相加-2-中" class="headerlink" title="两数相加(2.中)"></a>两数相加(2.中)</h3><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>示例：</p><p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p><p>思路：</p><p>new一个头结点，方便以后的操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* preHead = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);    <span class="comment">//头结点,方便后续的操作</span></span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        ListNode *cur = preHead;</span><br><span class="line">        <span class="keyword">while</span>(l1||l2)&#123;</span><br><span class="line">            <span class="keyword">int</span> ai = l1 == <span class="literal">nullptr</span> ? <span class="number">0</span> : l1-&gt;val;  <span class="comment">//l1对应位置的值，如果不存在，则补0</span></span><br><span class="line">            <span class="keyword">int</span> bi = l2 == <span class="literal">nullptr</span> ? <span class="number">0</span> : l2-&gt;val;  <span class="comment">//同上</span></span><br><span class="line">            <span class="keyword">int</span> value = (ai + bi + carry) % <span class="number">10</span>;    <span class="comment">//求相应加法运算后值</span></span><br><span class="line">            carry = (ai + bi + carry) / <span class="number">10</span>;        <span class="comment">//求相应加法运算后进位值</span></span><br><span class="line">            cur-&gt;next = <span class="keyword">new</span> ListNode(value);      <span class="comment">//尾插法   </span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//更新</span></span><br><span class="line">            l1 = l1 == <span class="literal">nullptr</span> ? <span class="literal">nullptr</span> : l1-&gt;next;  </span><br><span class="line">            l2 = l2 == <span class="literal">nullptr</span> ? <span class="literal">nullptr</span> : l2-&gt;next;</span><br><span class="line">            cur = cur-&gt;next;         </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry &gt; <span class="number">0</span>)     <span class="comment">//判断最后是否有进位，如果有，多开一个节点</span></span><br><span class="line">            cur-&gt;next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">        <span class="keyword">return</span> preHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="最长回文子串-5-中"><a href="#最长回文子串-5-中" class="headerlink" title="最长回文子串(5.中)"></a>最长回文子串(5.中)</h3><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p><p>示例 1：</p><p>输入: “babad”<br>输出: “bab”<br>注意: “aba” 也是一个有效答案。<br>示例 2：</p><p>输入: “cbbd”<br>输出: “bb”</p><p>思路：<a href="https://mp.weixin.qq.com/s?__biz=MzIwNTc4NTEwOQ==&amp;mid=2247484049&amp;idx=1&amp;sn=b3ee1a909d0c75cb9ef57df69ca36f5c&amp;chksm=972ad3eba05d5afd63dcb87c78a3b99cd6312e86c26d3727a7c7e01f0ed9a5f4f81edbee06f9&amp;mpshare=1&amp;scene=1&amp;srcid=0719xSkvzvmyhSB5d0cGY6Au&amp;key=034516426b2066d0e0aa6ab7340f5165b69a49c8183a1b4a232fae513c14ca25e69fa8220126e8ae5c517f68513d650b40ea657e95aed7b3002b7281a4c0fec8b6e601f0a455962f47f12cab9c546f51&amp;ascene=1&amp;uin=MjUzODM5ODQwNA%3D%3D&amp;devicetype=Windows+10&amp;version=62060833&amp;lang=zh_CN&amp;pass_ticket=x3FegFPx%2Bvw0qa34JSQ8rVDFtlaR46UnZVCzg53idyupd1SCO5oQv401BqivS7%2Fn" target="_blank" rel="noopener">参考</a></p><p><strong>方法一：Manacher 算法求最长回文子串:  时间复杂度O(N)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="string">""</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"><span class="built_in">string</span> str = <span class="string">"@"</span>;</span><br><span class="line"><span class="built_in">string</span> result;</span><br><span class="line"><span class="keyword">int</span> len = s.length();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">str = str + <span class="string">"#"</span> + s[i];</span><br><span class="line">str += <span class="string">"#$"</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p(str.length(), <span class="number">1</span>);</span><br><span class="line">manacher(str, p);</span><br><span class="line"><span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> imax;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.size(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (p[i] &gt; max) &#123;</span><br><span class="line">max = p[i];</span><br><span class="line">imax = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = imax - (max - <span class="number">1</span>); j &lt;= imax + (max - <span class="number">1</span>); j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (str[j] != <span class="string">'#'</span>)</span><br><span class="line">result += str[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manacher</span><span class="params">(<span class="built_in">string</span>&amp; str, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = str.length();</span><br><span class="line"><span class="keyword">int</span> id = <span class="number">0</span>;  <span class="comment">// id 为已知的 &#123;右边界最大&#125; 的回文子串的中心</span></span><br><span class="line"><span class="keyword">int</span> mx = <span class="number">1</span>;  <span class="comment">//mx则为id+P[id]，也就是这个子串的右边界</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len - <span class="number">2</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (mx &gt; i)</span><br><span class="line">p[i] = min(p[<span class="number">2</span> * id - i], mx - i);  <span class="comment">//如果mx&gt;i，则分两种情况</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">p[i] = <span class="number">1</span>;                   <span class="comment">//如果mx&lt;i，则无法用之前的p来计算，先置1</span></span><br><span class="line"><span class="keyword">for</span> (; str[i + p[i]] == str[i - p[i]]; p[i]++);  <span class="comment">//统计i对应的p[i]</span></span><br><span class="line"><span class="keyword">if</span> (mx &lt; i + p[i]) &#123;</span><br><span class="line">mx = i + p[i]; <span class="comment">//更新右边界</span></span><br><span class="line">id = i;      <span class="comment">//更新id</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方法2：暴力法 n*(n/2)(n2)  时间复杂度O(N^3)</p><p>方法3: 动态规划 O(N^2)</p><h3 id="反转链表-206-易"><a href="#反转链表-206-易" class="headerlink" title="反转链表(206. 易)"></a>反转链表(206. 易)</h3><p>反转一个单链表。</p><p>示例:</p><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL<br>进阶:<br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p><p>思路：</p><p><img src="/2019/07/30/LeetCode刷题/01.png" alt></p><p>迭代法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *newHead = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            ListNode *t = head-&gt;next;</span><br><span class="line">            head-&gt;next = newHead;</span><br><span class="line">            newHead = head;</span><br><span class="line">            head = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>递归法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* p = reverseList(head-&gt;next); <span class="comment">//把head节点之后的所有节点都反转了</span></span><br><span class="line">        head-&gt;next-&gt;next = head; <span class="comment">//head-&gt;next为原先head节点后面部分的首节点，反转后变成尾节点，所以他的下一个节点接上head节点，至此整个链表反转完成</span></span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;   <span class="comment">//此时head为新链表尾节点，其下一个节点需要置为NULL</span></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="最大子数组和-53-易"><a href="#最大子数组和-53-易" class="headerlink" title="最大子数组和(53. 易)"></a>最大子数组和(53. 易)</h3><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例:</p><p>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: <strong>连续子数组</strong> [4,-1,2,1] 的和最大，为 6。<br>进阶:</p><p>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p><p>思路：</p><p>动态规划：</p><p>dp[i] = max(dp[i-1]+nums[i],nums[i]);  //dp[i]代表以位置i元素为结尾的子数组的最大和</p><p>然后求出最大的dp[i]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> maxAns;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n,<span class="number">0</span>);   <span class="comment">//dp[i]代表以位置i元素为结尾的子数组的最大和</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        maxAns = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i] = max(dp[i<span class="number">-1</span>]+nums[i],nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(dp[i] &gt; maxAns)&#123;</span><br><span class="line">                maxAns = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxAns;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="三数之和（15-中）"><a href="#三数之和（15-中）" class="headerlink" title="三数之和（15.中）"></a>三数之和（15.中）</h3><p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p>例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p><p>满足要求的三元组集合为：<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p><p>思路：</p><p>​        我们对原数组进行<strong>排序</strong>，然后开始遍历排序后的数组，这里注意不是遍历到最后一个停止，而是到倒数第三个就可以了。这里我们可以先做个剪枝优化，就是<strong>当遍历到正数的时候就break</strong>，为啥呢，因为我们的数组现在是有序的了，如果第一个要fix的数就是正数了，那么后面的数字就都是正数，就永远不会出现和为0的情况了。然后我们还要加上<strong>重复就跳过的处理</strong>，处理方法是从第二个数开始，如果和前面的数字相等，就跳过，因为我们不想把相同的数字fix两次。</p><p>​        对于遍历到的数，用0减去这个fix的数得到一个target，然后只需要再之后找到两个数之和等于target即可。我们用两个指针分别指向fix数字之后开始的数组首尾两个数，如果两个数和正好为target，则将这两个数和fix的数一起存入结果中。然后就是跳过重复数字的步骤了，两个指针都需要检测重复数字。如果两数之和小于target，则我们将左边那个指针i右移一位，使得指向的数字增大一些。同理，如果两数之和大于target，则我们将右边那个指针j左移一位，使得指向的数字减小一些，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">        sort(nums.begin(),nums.end());  <span class="comment">//先排序</span></span><br><span class="line">        <span class="keyword">if</span>(nums.empty()||nums.back()&lt;<span class="number">0</span>||nums.front()&gt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;  <span class="comment">//数组为空、全为正数或者全为负数，结果都返回空</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;nums.size();++k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[k]&gt;<span class="number">0</span>)    <span class="comment">//当用来计算target的元素大于0的时候，证明后面的两正数之和小于0，不可能的情况</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(k&gt;<span class="number">0</span> &amp;&amp; nums[k]==nums[k<span class="number">-1</span>])  <span class="comment">//遇到用来计算target的元素相等的情况，去掉重复</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> target = <span class="number">0</span>-nums[k];</span><br><span class="line"><span class="comment">//下面一部分其实成了用左右双指针求和为target的两个数。</span></span><br><span class="line">            <span class="keyword">int</span> i=k+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> j=nums.size()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]==target)&#123;</span><br><span class="line">                    res.push_back(&#123;nums[k],nums[i],nums[j]&#125;);</span><br><span class="line">                    <span class="keyword">while</span>(i&lt;j&amp;&amp;nums[i]==nums[i+<span class="number">1</span>])  <span class="comment">//去处重复情况</span></span><br><span class="line">                        i++;</span><br><span class="line">                    <span class="keyword">while</span>(i&lt;j&amp;&amp;nums[j]==nums[j<span class="number">-1</span>])  <span class="comment">//去处重复情况</span></span><br><span class="line">                        j--;</span><br><span class="line">                    i++;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] + nums[j] &lt; target)</span><br><span class="line">                    i++;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    --j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="有效的括号-20-易"><a href="#有效的括号-20-易" class="headerlink" title="有效的括号(20. 易)"></a>有效的括号(20. 易)</h3><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p><p>示例 1:</p><p>输入: “()”<br>输出: true<br>示例 2:</p><p>输入: “()[]{}”<br>输出: true<br>示例 3:</p><p>输入: “(]”<br>输出: false<br>示例 4:</p><p>输入: “([)]”<br>输出: false<br>示例 5:</p><p>输入: “{[]}”<br>输出: true</p><p>思路：</p><p>这道题让我们验证输入的字符串是否为括号字符串，包括大括号，中括号和小括号。这里我们需要<strong>用一个栈</strong>，我们开始遍历输入字符串，如果<strong>当前字符为左半边括号时，则将其压入栈中</strong>，如果<strong>遇到右半边括号时，若此时栈为空，则直接返回false，如不为空，则取出栈顶元素</strong>，若为对应的左半边括号，则继续循环，反之返回false，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; mstack;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'('</span>||s[i] == <span class="string">'['</span>||s[i] == <span class="string">'&#123;'</span>)</span><br><span class="line">                mstack.push(s[i]);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(mstack.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">')'</span>&amp;&amp;(mstack.top() != <span class="string">'('</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">']'</span>&amp;&amp;(mstack.top() != <span class="string">'['</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">'&#125;'</span>&amp;&amp;(mstack.top() != <span class="string">'&#123;'</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                mstack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mstack.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot; &quot;&gt;&lt;/a&gt; &lt;/h3&gt;&lt;h3 id=&quot;两数之和-1-易&quot;&gt;&lt;a href=&quot;#两数之和-1-易&quot; class=&quot;headerlink&quot; title=&quot;两数之和(1.易)&quot;&gt;&lt;/a&gt;两数之
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yuemingyang7010.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法刷题" scheme="http://yuemingyang7010.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="LeetCode刷题" scheme="http://yuemingyang7010.github.io/tags/LeetCode%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>STL总结</title>
    <link href="http://yuemingyang7010.github.io/2019/07/30/STL%E6%80%BB%E7%BB%93/"/>
    <id>http://yuemingyang7010.github.io/2019/07/30/STL总结/</id>
    <published>2019-07-30T12:26:49.000Z</published>
    <updated>2019-07-30T13:44:13.338Z</updated>
    
    <content type="html"><![CDATA[<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>字符串类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1：string对象的定义和初始化以及读写</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s1;        <span class="comment">//默认构造函数，s1为空串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(s1)</span></span>;    <span class="comment">//将s2初始化为s1的一个副本</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(<span class="string">"valuee"</span>)</span></span>;   <span class="comment">//将s3初始化一个字符串面值副本</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(n,<span class="string">'c'</span>)</span></span>;      <span class="comment">//将s4 初始化为字符'c'的n个副本</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s5;               <span class="comment">//读取有效字符到遇到空格</span></span><br><span class="line">getline(<span class="built_in">cin</span>,s6);      <span class="comment">//读取字符到遇到换行，空格可读入，知道‘\n’结束（练习在下一个代码中），</span></span><br><span class="line">getline(<span class="built_in">cin</span>,s7,<span class="string">'a'</span>); <span class="comment">//一个直到‘a’结束，其中任何字符包括'\n'都能够读入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2：string对象中一些函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*------插入函数------包括迭代器操作和下标操作，下标操作更灵活*/</span></span><br><span class="line">s.insert( it , p );  <span class="comment">//把字符串p插入到it的位置</span></span><br><span class="line">s.insert(p,n,t)；   <span class="comment">//迭代器p元素之前插入n个t的副本</span></span><br><span class="line">s.insert(p,b,e);     <span class="comment">//迭代器p元素之前插入迭代器b到e之间的所有元素</span></span><br><span class="line">s.insert(p,s2,poe2,len); <span class="comment">//在下标p之前插入s2下标从poe2开始长度为len的元素</span></span><br><span class="line">s.insert(pos,cp,len);  <span class="comment">//下标pos之前插入cp数组的前len个元素。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*----------替换函数-------------------*/</span></span><br><span class="line">s.substr(i,j)   截取s串中从i到j的子串  <span class="comment">//string::npos  判断字符串是否结束</span></span><br><span class="line">s.replace ( <span class="number">3</span> , <span class="number">3</span> , <span class="string">" good "</span> ) ;   <span class="comment">//从第三个起连续三个替换为good</span></span><br><span class="line">s.assign(b,e);  <span class="comment">//用迭代器b到e范围内的元素替换s</span></span><br><span class="line">s.assign(n,t)；  <span class="comment">//用n个t的副本替换s</span></span><br><span class="line">a.assign(s1,pos2,len);   <span class="comment">//从s1的下标pos2开始连续替换len个。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------删除函数-----------------------------*/</span></span><br><span class="line">s.erase( <span class="number">3</span> )||s.erase ( <span class="number">0</span> , <span class="number">4</span> ) ;  <span class="comment">//删除第四个元素或第一到第五个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*----------------------其他函数-----------------------------*/</span></span><br><span class="line">s.find ( <span class="string">" cat "</span> ) ;  <span class="comment">//超找第一个出现的字符串”cat“，返回其下标值，查不到返回 4294967295，也可查找字符；</span></span><br><span class="line">s.append(args); <span class="comment">//将args接到s的后面</span></span><br><span class="line">s.compare ( <span class="string">" good "</span> ) ;  <span class="comment">//s与”good“比较相等返回0，比"good"大返回1，小则返回-1；</span></span><br><span class="line">reverse ( s.begin(), s.end () );  <span class="comment">//反向排序函数，即字符串反转函数</span></span><br></pre></td></tr></table></figure><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p>功能：动态数组,<strong>可随机存取</strong></p><p>底层实现 ：<br>首先开辟一定大小的数组 随着元素的增加，如果空间不够之后，以原空间大小的2倍重新开辟一块空间， 将就空间的元素挪到新空间上 在继续添加元素，一直遵循每次扩容大小是原空间大小的2倍。</p><p>相关用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//【1】初始化</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;        <span class="comment">//声明一个int型向量</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(<span class="number">10</span>);    <span class="comment">//声明一个初始大小为10的int向量</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(<span class="number">10</span>, <span class="number">1</span>); <span class="comment">//声明一个初始大小为10且值都是1的向量</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec1(vec);  <span class="comment">//调用拷贝构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp(vec.begin(), vec.begin() + <span class="number">3</span>);  <span class="comment">//用向量vec的第0个到第2个值初始化tmp</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;   </span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(<span class="built_in">array</span>, <span class="built_in">array</span> + <span class="number">5</span>);      <span class="comment">//将arr数组的元素用于初始化vec向量</span></span><br><span class="line"><span class="comment">//！！！！易错！！！！末尾指针都是指结束元素的下一个元素和vec.end()指针统一</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(&amp;arr[<span class="number">1</span>], &amp;arr[<span class="number">4</span>]); <span class="comment">//将arr[1]~arr[4]范围内的元素作为vec的初始值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//【2】大小操作</span></span><br><span class="line">vec.empty()    <span class="comment">//判断是否为空</span></span><br><span class="line">vec.size()     <span class="comment">//输出实际大小</span></span><br><span class="line">vec.max_size()  <span class="comment">//输出最大容量</span></span><br><span class="line">vec.resize()    <span class="comment">//重新定义大小,保留适当的容量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//【3】插入元素</span></span><br><span class="line">vec.push_back();            <span class="comment">//末尾添加元素</span></span><br><span class="line">vec.insert(vec.begin()+i,a); <span class="comment">//任意位置插入元素 在第i+1个元素前面插入a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//【4】删除元素</span></span><br><span class="line">vec.pop_back();     <span class="comment">//末尾删除元素 </span></span><br><span class="line">vec.clear();     <span class="comment">//清空向量元素</span></span><br><span class="line">vec.erase (vec.begin()+<span class="number">5</span>);                 <span class="comment">// erase the 6th element</span></span><br><span class="line">vec.erase (vec.begin(),vec.begin()+<span class="number">3</span>); <span class="comment">// erase the first 3 elements:</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">//【7】迭代器</span></span><br><span class="line">vec.begin();<span class="comment">//起始指针：</span></span><br><span class="line">vec.end(); <span class="comment">//指向最后一个元素的下一个位置</span></span><br><span class="line"></span><br><span class="line">vec.cbegin(); <span class="comment">//不能通过这个指针来修改所指的内容，但可以通过其他方式修改的。</span></span><br><span class="line">vec.cend();<span class="comment">//指向常量的末尾指针</span></span><br><span class="line">vec.rbegin()<span class="comment">//反向迭代器头</span></span><br><span class="line">vec.rend()<span class="comment">//反向迭代器尾</span></span><br><span class="line">vec.crbegin()</span><br><span class="line">vec.crend()</span><br><span class="line"></span><br><span class="line"><span class="comment">//【8】元素访问</span></span><br><span class="line">vec[<span class="number">1</span>]; <span class="comment">//下标访问，并不会检查是否越界</span></span><br><span class="line">vec.at(<span class="number">1</span>); <span class="comment">//at会检查是否越界，会抛出out of range异常</span></span><br><span class="line">vec.front();        <span class="comment">//访问第一个元素 </span></span><br><span class="line">vec.back();         <span class="comment">//访问最后一个元素</span></span><br><span class="line"></span><br><span class="line">vec.swap(vec2);  <span class="comment">//交换两个向量的元素</span></span><br><span class="line">swap(vec,vec2);</span><br></pre></td></tr></table></figure><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>实际上,list容器就是一个双向链表,可以高效地进行插入删除元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; first;                                <span class="comment">// empty list of ints</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; second (<span class="number">4</span>,<span class="number">100</span>);                       <span class="comment">// four ints with value 100</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; third (second.begin(),second.end());  <span class="comment">// iterating through second</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; fourth (third);                       <span class="comment">// a copy of third</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入元素</span></span><br><span class="line">a.insert(a.begin(),<span class="number">100</span>);  <span class="comment">//在a的开始位置（即头部）插入100</span></span><br><span class="line">a.insert(a.begin(),<span class="number">2</span>, <span class="number">100</span>);   <span class="comment">//在a的开始位置插入2个100</span></span><br><span class="line">a.insert(a.begin(),b.begin(), b.end());<span class="comment">//在a的开始位置插入b从开始到结束的所有位置的元素</span></span><br><span class="line"><span class="built_in">list</span>.push_back(x)  <span class="comment">//在链表尾插入元素</span></span><br><span class="line"><span class="built_in">list</span>.push_front(x) <span class="comment">//在链表头插入元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器</span></span><br><span class="line"><span class="built_in">list</span>.begin()    <span class="comment">//获得指向链表尾的指针</span></span><br><span class="line"><span class="built_in">list</span>.end()      <span class="comment">//获得指向链表尾（尾的下一个元素）的指针</span></span><br><span class="line"><span class="built_in">list</span>.rbegin()<span class="comment">//获得反向链表的头指针</span></span><br><span class="line"><span class="built_in">list</span>.rend()<span class="comment">//获得反向链表的尾（尾的下一个元素）指针</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//大小判断</span></span><br><span class="line"><span class="built_in">list</span>.empty()      <span class="comment">//判断是否为空，为空，返回true</span></span><br><span class="line"><span class="built_in">list</span>.size()  <span class="comment">//返回list的实际大小</span></span><br><span class="line"><span class="built_in">list</span>.max_size()   <span class="comment">//返回list的最大容量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获得元素</span></span><br><span class="line"><span class="built_in">list</span>.front()      <span class="comment">//获得头元素</span></span><br><span class="line"><span class="built_in">list</span>.back()       <span class="comment">//获得尾元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除操作</span></span><br><span class="line">a.erase(a.begin());  <span class="comment">//将a的第一个元素删除</span></span><br><span class="line">a.erase(a.begin(),a.end());  <span class="comment">//将a的从begin()到end()之间的元素删除。</span></span><br><span class="line"><span class="comment">//必须保证不为空</span></span><br><span class="line"><span class="built_in">list</span>.pop_back()   <span class="comment">//删除尾元素</span></span><br><span class="line"><span class="built_in">list</span>.pop_front()  <span class="comment">//删除头元素</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; a &#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">10</span>&#125;; a.remove(<span class="number">7</span>);   <span class="comment">//删除指定元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//其他操作</span></span><br><span class="line"><span class="built_in">list</span>.assign(n,value)  <span class="comment">//list将被改为n个值为value的元素</span></span><br><span class="line"><span class="built_in">list</span>.resize(x)   <span class="comment">//将链表改为长为x   超出的部分将被删除</span></span><br><span class="line">swap(a,b)   <span class="comment">//交换a,b链表的值</span></span><br><span class="line"><span class="built_in">list</span>.reverse()   <span class="comment">//将链表倒置</span></span><br><span class="line">a.merge(b)   <span class="comment">//将链表b添加到链表a的后面</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//补充以下迭代器的使用</span></span><br><span class="line"><span class="comment">//以下是四种迭代器的遍历操作（如果使用C11标准，可以直接使用auto）</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator cur1=li.begin();</span><br><span class="line">    <span class="keyword">for</span>(;cur1!=li.end();cur1++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;*cur1&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::const_iterator cur2=li.cbegin();</span><br><span class="line">    <span class="keyword">for</span>(;cur2!=li.cend();cur2++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;*cur2&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C11标准</span></span><br><span class="line">    <span class="keyword">auto</span> cur=li.begin();</span><br><span class="line">    <span class="keyword">for</span>(;cur!=li.end();cur++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;*cur&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><p>栈 （后进先出）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; sta;</span><br><span class="line"><span class="comment">//大小操作</span></span><br><span class="line">sta.empty()</span><br><span class="line">sta.size()</span><br><span class="line"></span><br><span class="line">sta.push(x)  <span class="comment">//将x加入到栈顶</span></span><br><span class="line">sta.pop() <span class="comment">//将栈顶元素弹出</span></span><br><span class="line">sta.top() <span class="comment">//返回栈顶元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//C11</span></span><br><span class="line">sta.swap(sta1) <span class="comment">//交换栈sta和sta1中的元素</span></span><br><span class="line">sta.emplace(x) <span class="comment">//将x放入到栈顶</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//栈的清空</span></span><br><span class="line"><span class="keyword">while</span>(!sta.empty()) sta.pop();</span><br></pre></td></tr></table></figure><h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><p>队列 （先进先出）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">que.size()   <span class="comment">//返回队列中元素的个数</span></span><br><span class="line">que.empty()  <span class="comment">//如果为空，返回true</span></span><br><span class="line"></span><br><span class="line">que.front()  <span class="comment">//返回第一个元素（即队首元素）</span></span><br><span class="line">que.back()   <span class="comment">//返回队尾元素</span></span><br><span class="line"></span><br><span class="line">que.pop()    <span class="comment">//删除第一个元素</span></span><br><span class="line">que.push(x)  <span class="comment">//在队尾加入一个元素</span></span><br><span class="line"></span><br><span class="line">que.swap(que1) <span class="comment">//交换que和que1的元素</span></span><br><span class="line">que.emplace(x)  <span class="comment">//向队首加入元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//queue不提供清空操作，一般手动实现</span></span><br><span class="line"><span class="keyword">while</span>(!que.empty()) que.pop();</span><br></pre></td></tr></table></figure><h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><p>优先队列 (STL中的堆)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  模板原型：</span></span><br><span class="line"><span class="comment">*  priority_queue&lt;Type,Container,Functional&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; que;     <span class="comment">//默认是降序的</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; que1;  <span class="comment">//升序队列</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt;&gt; que2;     <span class="comment">//降序队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于结构体的比较</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">int</span> score;</span><br><span class="line">student(<span class="built_in">string</span> na, <span class="keyword">int</span> sc):name(na), score(sc) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> student&amp; a, <span class="keyword">const</span> student&amp; b )</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.score &gt; b.score;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;student, <span class="built_in">vector</span>&lt;student&gt; , cmp&gt; que;   <span class="comment">//根据成绩从大到小排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//具体操作</span></span><br><span class="line">que.empty();</span><br><span class="line">que.size();</span><br><span class="line"></span><br><span class="line">que.push(x);<span class="comment">//加入元素到队尾</span></span><br><span class="line">que.pop();<span class="comment">//从队首删除元素</span></span><br><span class="line"></span><br><span class="line">que.top();     <span class="comment">//返回队首元素</span></span><br><span class="line"></span><br><span class="line">que.emplace(x)</span><br><span class="line">que.swap(que1)</span><br></pre></td></tr></table></figure><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map对于key是随机存取的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;  //使用pair与make_pair要包含头文件#include &lt;utility&gt;</span></span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; ma;</span><br><span class="line"><span class="comment">//必会操作</span></span><br><span class="line">ma.begin();         <span class="comment">//返回指向头部的迭代器</span></span><br><span class="line">ma.end();           <span class="comment">//返回指向末尾的迭代器</span></span><br><span class="line">ma[i] = A;      <span class="comment">//插入 A</span></span><br><span class="line">mp.insert(make_pair(i,A));  <span class="comment">//插入 A</span></span><br><span class="line">ma.erase(i);    <span class="comment">//删除 i</span></span><br><span class="line">ma.clear();     <span class="comment">//删除所有元素</span></span><br><span class="line">ma.find(i);     <span class="comment">//查找 i (若未找到返回 end())</span></span><br><span class="line">ma.empty();     <span class="comment">//如果map为空则返回true</span></span><br><span class="line">ma.size();      <span class="comment">//返回map中元素的个数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ma.swap();    <span class="comment">//交换两个map</span></span><br><span class="line">ma.lower_bound();   <span class="comment">//返回 &gt;=给定元素的第一个位置</span></span><br><span class="line">ma.upper_bound();   <span class="comment">//返回 &gt;给定元素的第一个位置</span></span><br><span class="line">ma.max_size();      <span class="comment">//返回可以容纳的最大元素个数</span></span><br></pre></td></tr></table></figure><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>和map操作几乎一样，只是插入的为key即为value</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; se;</span><br><span class="line"><span class="comment">//必会操作</span></span><br><span class="line">se.begin();         <span class="comment">//返回指向头部的迭代器</span></span><br><span class="line">se.end();           <span class="comment">//返回指向末尾的迭代器</span></span><br><span class="line">se.insert(A);      <span class="comment">//插入 A</span></span><br><span class="line">se.erase(A);    <span class="comment">//删除 A</span></span><br><span class="line">se.clear();     <span class="comment">//删除所有元素</span></span><br><span class="line">se.find(i);     <span class="comment">//查找 i (若未找到返回 end())</span></span><br><span class="line">se.empty();</span><br><span class="line">se.size();</span><br><span class="line">    </span><br><span class="line">se.swap();    <span class="comment">//交换两个map</span></span><br><span class="line">se.lower_bound();   <span class="comment">//返回 &gt;=给定元素的第一个位置</span></span><br><span class="line">se.upper_bound();   <span class="comment">//返回 &gt;给定元素的第一个位置</span></span><br><span class="line">se.max_size();      <span class="comment">//返回可以容纳的最大元素个数</span></span><br></pre></td></tr></table></figure><p>还有 hash_table 没有写，hash_table 是兼顾各项，在元素不 “冲突” 的情况下，上面四个可以，而且速度很快。</p><p>unordered_set、unordered_multiset、unordered_map、unordered_multimap 都是以 hash_table 作为底层实现的。所以效率要比 RB_tree 作为底层实现的 set、map、multiset、multimap 高，但是 hash_table 的缺点是没有进行排序。</p><p>stack、queue 都是以 deque（双端队列）作为底层实现的，效率问题直接看deque就行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;string&quot;&gt;&lt;a href=&quot;#string&quot; class=&quot;headerlink&quot; title=&quot;string&quot;&gt;&lt;/a&gt;string&lt;/h2&gt;&lt;p&gt;字符串类&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td 
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yuemingyang7010.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="STL总结" scheme="http://yuemingyang7010.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/STL%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="STL" scheme="http://yuemingyang7010.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL中的索引</title>
    <link href="http://yuemingyang7010.github.io/2019/07/24/MySQL%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95/"/>
    <id>http://yuemingyang7010.github.io/2019/07/24/MySQL中的索引/</id>
    <published>2019-07-24T08:28:27.000Z</published>
    <updated>2019-09-01T11:37:06.844Z</updated>
    
    <content type="html"><![CDATA[<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h2><p>排好序的快速查询的数据结构，常常类比为字典目录。</p><p>优点：<strong>大大加快数据的检索速度</strong>；</p><p>缺点：<strong>创建索引和维护索引要花费一定的时间</strong>。</p><h2 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h2><p>主键索引（PRIMAY KEY）</p><p>普通索引（INDEX）</p><p>唯一索引（UNIQUE）</p><p>联合索引</p><p>InnoDB和MyISAM会自动为<strong>主键</strong>或者声明为<strong>UNIQUE</strong>的列去自动建立B+树索引。</p><h3 id="主键索引（最常用，最好用自增ID）"><a href="#主键索引（最常用，最好用自增ID）" class="headerlink" title="主键索引（最常用，最好用自增ID）"></a>主键索引（最常用，最好用自增ID）</h3><p>为表设置了主键，数据库将自动创建主键索引</p><p>（一个表只能有一个主键，主键的值不可重复，也不可为空（NULL）。）</p><h3 id="普通索引（一表可建多个，尽量避免NULL）"><a href="#普通索引（一表可建多个，尽量避免NULL）" class="headerlink" title="普通索引（一表可建多个，尽量避免NULL）"></a>普通索引（一表可建多个，尽量避免NULL）</h3><p>注意：可以有NULL，但是<strong>尽量避免NULL</strong>：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化。因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值。</p><h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>与普通索引类似，不同的是，Mysql的索引列值必须唯一，但普通索引值可重复。</p><h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>联合索引即联合若干列组成索引，这种情况下和普通索引类似，可不唯一，可以有NULL，如果加上unique，可以使其为联合唯一索引，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t_aa <span class="keyword">add</span> <span class="keyword">unique</span> <span class="keyword">index</span>(aa,bb);</span><br></pre></td></tr></table></figure><h2 id="MySQL中创建和删除索引的语句"><a href="#MySQL中创建和删除索引的语句" class="headerlink" title="MySQL中创建和删除索引的语句"></a>MySQL中创建和删除索引的语句</h2><p>我们可以在创建表的时候指定需要建立索引的单个列或者建立联合索引的多个列：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> TALBE 表名 (</span><br><span class="line">    各种列的信息 ··· , </span><br><span class="line">    [<span class="keyword">KEY</span>|<span class="keyword">INDEX</span>] 索引名 (需要被索引的单个列或多个列)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>其中的KEY和INDEX是同义词，任意选用一个就可以。我们也可以在修改表结构的时候添加索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> [<span class="keyword">INDEX</span>|<span class="keyword">KEY</span>] 索引名 (需要被索引的单个列或多个列);</span><br></pre></td></tr></table></figure><p>也可以在修改表结构的时候删除索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> [<span class="keyword">INDEX</span>|<span class="keyword">KEY</span>] 索引名;</span><br></pre></td></tr></table></figure><p>比方说我们想在创建index_demo表的时候就为c2和c3列添加一个联合索引，可以这么写建表语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> index_demo(</span><br><span class="line">    c1 <span class="built_in">INT</span>,</span><br><span class="line">    c2 <span class="built_in">INT</span>,</span><br><span class="line">    c3 <span class="built_in">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(c1),</span><br><span class="line">    <span class="keyword">INDEX</span> idx_c2_c3 (c2, c3)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>在这个建表语句中我们创建的索引名是idx_c2_c3，这个名称可以随便起，不过我们还是建议以idx_为前缀，后边跟着需要建立索引的列名，多个列名之间用下划线_分隔开。</p><p>如果我们想删除这个索引，可以这么写：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> index_demo <span class="keyword">DROP</span> <span class="keyword">INDEX</span> idx_c2_c3;</span><br></pre></td></tr></table></figure><p>注意：主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。</p><h2 id="各种索引的区别与联系"><a href="#各种索引的区别与联系" class="headerlink" title="各种索引的区别与联系"></a>各种索引的区别与联系</h2><div class="table-container"><table><thead><tr><th>索引类型</th><th>是否要求值唯一</th><th>是否要求值不能有NULL</th></tr></thead><tbody><tr><td>主键索引</td><td>是</td><td>是</td></tr><tr><td>唯一索引</td><td>是</td><td>否</td></tr><tr><td>普通索引</td><td>否</td><td>否</td></tr></tbody></table></div><h3 id="主键索引与普通索引的区别"><a href="#主键索引与普通索引的区别" class="headerlink" title="主键索引与普通索引的区别"></a>主键索引与普通索引的区别</h3><p>如果语句是 select <em> from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；<br>如果语句是 select </em> from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。<br>也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。</p><p>总结：（1）主键索引查询一次B+树，普通索引有回表操作；（2）主键索引要求列值唯一，且无NULL，普通索引没这两个限制。</p><h3 id="主键索引与唯一索引的区别"><a href="#主键索引与唯一索引的区别" class="headerlink" title="主键索引与唯一索引的区别"></a>主键索引与唯一索引的区别</h3><p>（1）主键索引查询一次B+树，唯一索引有回表操作；（2）主键索引要求列值唯一，且无NULL，唯一索引列值唯一，但是<strong>可以有NULL</strong>。</p><h1 id="索引底层数据结构"><a href="#索引底层数据结构" class="headerlink" title="索引底层数据结构"></a>索引底层数据结构</h1><p><a href="https://www.cnblogs.com/xiaoxi/p/6894610.html?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener">本文主要参考博客</a></p><p><a href="https://blog.csdn.net/q503267755/article/details/50791794" target="_blank" rel="noopener">对于磁道、扇区和磁盘块的理解1</a></p><p><a href="https://www.cnblogs.com/yi-mu-xi/p/10939612.html" target="_blank" rel="noopener">对于磁道、扇区和磁盘块的理解2</a></p><h2 id="磁盘I-O原理"><a href="#磁盘I-O原理" class="headerlink" title="磁盘I/O原理"></a>磁盘I/O原理</h2><h3 id="扇区与磁盘块-block-的区别"><a href="#扇区与磁盘块-block-的区别" class="headerlink" title="扇区与磁盘块(block)的区别"></a>扇区与磁盘块(block)的区别</h3><p><strong>磁盘在物理层面上分为磁道，扇区</strong>（通常大小为512K），磁盘驱动器操作磁盘数据，硬盘的最小存储单位是扇区，硬盘本身没有block的概念。</p><p><strong>文件系统：</strong></p><p>文件系统若按照一个扇区一个扇区读数据速度太慢，所以有了<strong>block（磁盘块）</strong>的概念，是一个块一个块读取的，block才是文件存取的最小单位。通常一个block是4KB，该文件系统中1个块是由连续的8个扇区组成。一个块大小=一个扇区大小*2的n次方。N是可以修改的。</p><p><strong>总结：扇区是对硬盘而言，块是对文件系统而言。</strong></p><p>索引是帮助MySQL高效获取数据的排好序的数据结构</p><h2 id="B树（平衡多路查找树）"><a href="#B树（平衡多路查找树）" class="headerlink" title="B树（平衡多路查找树）"></a><strong>B树（平衡多路查找树）</strong></h2><p>B-Tree是为磁盘等外存储设备设计的一种平衡查找树。因此在讲B-Tree之前先了解下磁盘的相关知识。</p><p>系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。</p><p><strong>InnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB存储引擎中默认每个页的大小为16KB，可通过参数innodb_page_size将页的大小设置为4K、8K、16K，在MySQL中可通过如下命令查看页的大小（可以将其设置为4K）：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;innodb_page_size&apos;;</span><br></pre></td></tr></table></figure><p>而系统一个磁盘块的存储空间往往没有这么大，因此InnoDB每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小16KB。InnoDB在把磁盘数据读入到内存时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。</p><p>B-Tree结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述B-Tree，首先定义一条记录为一个二元组[key, data] ，key为记录的键值，对应表中的主键值，data为一行记录中除主键外的数据。对于不同的记录，key值互不相同。</p><p><strong>一棵m阶的B-Tree有如下特性：</strong> </p><ol><li>每个节点最多有m个孩子。 </li><li>除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子。 </li><li>若根节点不是叶子节点，则至少有2个孩子。</li><li>所有叶子节点都在同一层，且不包含其它关键字信息。 </li><li>每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn） </li><li>关键字的个数n满足：ceil(m/2)-1 &lt;= n &lt;= m-1 </li><li>ki(i=1,…n)为关键字，且关键字升序排序。 </li><li>Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)。</li></ol><p>B-Tree中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个3阶的B-Tree：</p><img src="/2019/07/24/MySQL中的索引/07/24/MySQL中的索引/01.png"><p>两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。</p><p>模拟查找关键字29的过程：</p><p>根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】<br>比较关键字29在区间（17,35），找到磁盘块1的指针P2。<br>根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】<br>比较关键字29在区间（26,30），找到磁盘块3的指针P2。<br>根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】<br>在磁盘块8中的关键字列表中找到关键字29。</p><p>分析上面过程，发现需要<strong>3次磁盘I/O操作，和3次内存查找操作。</strong>由于内存中的关键字是一个有序表结构，<strong>可以利用二分法查找提高效率</strong>。而<strong><u>3次磁盘I/O操作是影响整个B-Tree查找效率的决定因素</u></strong>。B-Tree相对于AVLTree缩减了节点个数，使每次磁盘I/O取到内存的数据都发挥了作用，从而提高了查询效率。</p><h2 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+Tree**"></a>B+Tree**</h2><p>B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。</p><p>从上一节中的B-Tree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。<strong>在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息</strong>，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。</p><p><strong>B+Tree相对于B-Tree有几点不同：</strong></p><ol><li>非叶子节点只存储键值信息。</li><li>所有叶子节点之间都有一个链指针。</li><li>数据记录都存放在叶子节点中。</li></ol><p>将上一节中的B-Tree优化，由于B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示：</p><img src="/2019/07/24/MySQL中的索引/07/24/MySQL中的索引/02.png"><p>通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对B+Tree进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。</p><h2 id="为什么使用B-Tree（B-Tree）"><a href="#为什么使用B-Tree（B-Tree）" class="headerlink" title="为什么使用B-Tree（B+Tree）"></a>为什么使用B-Tree（B+Tree）</h2><p>一般来说，索引本身也很大，<strong>不可能全部存储在内存中</strong>，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是要<strong>尽量减少查找过程中磁盘I/O的存取次数</strong>。</p><p><strong>与红黑树的比较：</strong></p><p>红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因：</p><p>（一）更少的查找次数</p><p>平衡树查找操作的时间复杂度和树高 h 相关，O(h)=O(log<sub>d</sub>N)，其中 d 为每个节点的出度。</p><p>红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。</p><p>（二）利用磁盘预读特性</p><p>为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。</p><p>操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。</p><h2 id="B-树索引和hash索引的区别"><a href="#B-树索引和hash索引的区别" class="headerlink" title="B+树索引和hash索引的区别"></a><strong>B+树索引和hash索引的区别</strong></h2><p>hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的<strong>查询效率要远高于 B-Tree 索引。</strong></p><p>既然 Hash 索引的效率要比 B-Tree 高很多，为什么大家不都用 Hash 索引而还要使用 B-Tree 索引呢？ Hash 索引本身由于其特殊性也带来了很多限制和弊端，主要有以下这些。</p><p><strong>（1）Hash 索引仅仅能满足”=”,”IN”和”&lt;=&gt;”查询，不能使用范围查询。</strong></p><p>由于 Hash 索引比较的是进行 Hash 运算之后的 Hash 值，所以它<strong>只能用于等值的过滤，不能用于基于范围的过滤</strong>，因为经过相应的 Hash 算法处理之后的 Hash 值的大小关系，并不能保证和Hash运算前完全一样。</p><p>（2）Hash 索引<strong>无法被用来避免数据的排序操作。</strong></p><p>由于 Hash 索引中存放的是经过 Hash 计算之后的 Hash 值，而且Hash值的大小关系并不一定和 Hash 运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算；</p><p>（3）Hash 索引不能利用部分索引键查询。</p><p>对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。</p><p><strong>（4）Hash 索引在任何时候都不能避免表扫描。</strong></p><p>前面已经知道，<strong>Hash 索引是将索引键通过 Hash 运算之后</strong>，将 Hash运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中，<strong>由于不同索引键存在相同 Hash 值**</strong>，所以即使取满足某个 Hash 键值的数据的记录条数，也无法从 Hash 索引中直接完成查询<strong>，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。</strong>当Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。</p><h2 id="磁盘存取原理"><a href="#磁盘存取原理" class="headerlink" title="磁盘存取原理"></a><strong>磁盘存取原理</strong></h2><p>​      上面说过，索引一般以文件形式存储在磁盘上，索引检索需要磁盘I/O操作。与主存不同，磁盘I/O存在机械运动耗费，因此磁盘I/O的时间消耗是巨大的。</p><p>​      下图是磁盘的整体结构示意图。</p><img src="/2019/07/24/MySQL中的索引/07/24/MySQL中的索引/03.png"><p>一个磁盘由大小相同且同轴的圆形盘片组成，磁盘可以转动（各个磁盘必须同步转动）。在磁盘的一侧有磁头支架，磁头支架固定了一组磁头，每个磁头负责存取一个磁盘的内容。磁头不能转动，但是可以沿磁盘半径方向运动（实际是斜切向运动），每个磁头同一时刻也必须是同轴的，即从正上方向下看，所有磁头任何时候都是重叠的（不过目前已经有多磁头独立技术，可不受此限制）。</p><p>​      下图是磁盘结构的示意图。</p><img src="/2019/07/24/MySQL中的索引/07/24/MySQL中的索引/04.png"><p>盘片被划分成一系列同心环，圆心是盘片中心，每个同心环叫做一个磁道，所有半径相同的磁道组成一个柱面。磁道被沿半径线划分成一个个小的段，每个段叫做一个扇区，每个扇区是磁盘的最小存储单元。为了简单起见，我们下面假设磁盘只有一个盘片和一个磁头。</p><p>​      当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间。</p><h2 id="局部性原理与磁盘预读"><a href="#局部性原理与磁盘预读" class="headerlink" title="局部性原理与磁盘预读"></a><strong>局部性原理与磁盘预读</strong></h2><p> 由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：</p><p>​      当一个数据被用到时，其附近的数据也通常会马上被使用。</p><h2 id="B-Tree索引的性能分析"><a href="#B-Tree索引的性能分析" class="headerlink" title="B-/+Tree索引的性能分析"></a><strong>B-/+Tree索引的性能分析</strong></h2><p>​      到这里终于可以分析B-/+Tree索引的性能了。</p><p>​    数据库系统的设计者巧<strong>妙利用了磁盘预读原理</strong>，<strong>将一个节点的大小设为等于一个页</strong>，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：</p><p>​     每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p><p>​     B-Tree中一次检索最多需要h-1次I/O（<strong>根节点常驻内存</strong>），渐进复杂度为O(h)=O(logdN)O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。</p><p>​     综上所述，用B-Tree作为索引结构效率是非常高的。</p><h1 id="MySQL索引实现"><a href="#MySQL索引实现" class="headerlink" title="MySQL索引实现"></a><strong>MySQL索引实现</strong></h1><p>在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的，下面主要讨论MyISAM和InnoDB两个存储引擎的索引实现方式。</p><h2 id="MyISAM索引实现"><a href="#MyISAM索引实现" class="headerlink" title="MyISAM索引实现"></a><strong>MyISAM索引实现</strong></h2><p>MyISAM引擎使用B+Tree作为索引结构，<strong>叶节点的data域存放的是数据记录的地址</strong>。下图是MyISAM索引的原理图：</p><img src="/2019/07/24/MySQL中的索引/07/24/MySQL中的索引/07.png"><p>这里设表一共有三列，假设我们以Col1为主键，则上图是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。<strong>在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。</strong>如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：</p><img src="/2019/07/24/MySQL中的索引/07/24/MySQL中的索引/08.png"><h2 id="InnoDB索引实现"><a href="#InnoDB索引实现" class="headerlink" title="InnoDB索引实现"></a><strong>InnoDB索引实现</strong></h2><p>​     虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。</p><p>​     第一个重大区别是<strong>InnoDB的数据文件本身就是索引文件。</strong>从上文知道，<strong>MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。</strong>而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的<strong>叶节点data域保存了完整的数据记录</strong>。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p><img src="/2019/07/24/MySQL中的索引/07/24/MySQL中的索引/09.png"><p>​    上图是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p><p>​      <strong>第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。</strong>例如，下图为定义在Col3上的一个辅助索引：</p><img src="/2019/07/24/MySQL中的索引/07/24/MySQL中的索引/10.png"><p>这里以英文字符的ASCII码作为比较准则。<strong><u>聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</u></strong></p><p>​     了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么<strong>不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。</strong>再例如，用<strong>非单调的字段</strong>作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在<strong>插入新记录时数据文件</strong>为了维持B+Tree的特性而<strong>频繁的分裂调整</strong>，十分低效，而<strong><u>使用自增字段作为主键则是一个很好的选择。</u></strong></p><p><strong><u>对于InnoDB而言，因为节点下有数据文件，因此节点的分裂将会比较慢。对于InnoDB的主键，尽量用整型，而且是递增的整型。如果是无规律的数据，将会产生页的分裂，影响速度。</u></strong></p><h2 id="InnoDB索引和MyISAM索引的区别："><a href="#InnoDB索引和MyISAM索引的区别：" class="headerlink" title="InnoDB索引和MyISAM索引的区别："></a><strong>InnoDB索引</strong>和<strong>MyISAM索引</strong>的区别：</h2><p><strong>一是主索引的区别，InnoDB的数据文件本身就是索引文件。而MyISAM的索引和数据是分开的。</strong></p><p><strong>二是辅助索引的区别：InnoDB的辅助索引data域存储相应记录主键的值而不是地址。而MyISAM的辅助索引和主索引没有多大区别。</strong></p><p><strong>InnoDB的主索引文件上，直接存放该行数据，称为聚簇索引。次索引指向对主键的引用。</strong></p><p><strong>Myisam中，主索引和次索引都指向物理行。</strong></p><p>补充：<strong>索引覆盖</strong></p><p>索引覆盖是指如果查询的列恰好是索引的一部分，那么查询只需要在索引文件上进行，不需要回行到磁盘再找数据（<strong>即不需要回表查找</strong>）。这种查询速度非常快，称为“索引覆盖”。</p><h2 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a><strong>聚簇索引与非聚簇索引</strong></h2><h3 id="1、聚簇索引"><a href="#1、聚簇索引" class="headerlink" title="1、聚簇索引"></a><strong>1、聚簇索引</strong></h3><p>​    所谓聚簇索引，就是指<strong><u>主索引</u>文件和数据文件为同一份文件，聚簇索引主要用在Innodb存储引擎中。</strong>在该索引实现方式中B+Tree的叶子节点上的data就是数据本身，key为主键，如果是一般索引的话，data便会指向对应的主索引(<strong>然后再进行一次索引</strong>)，如下图所示：</p><img src="/2019/07/24/MySQL中的索引/07/24/MySQL中的索引/05.png"><p>  在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。<strong>做这个优化的目的是为了提高区间访问的性能</strong>，例如上图中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。</p><h3 id="2、非聚簇索引"><a href="#2、非聚簇索引" class="headerlink" title="2、非聚簇索引"></a><strong>2、非聚簇索引</strong></h3><p>​    非聚簇索引就是<strong>指B+Tree的叶子节点上的data，并不是数据本身，而是数据存放的地址。</strong>主索引和辅助索引没啥区别，只是主索引中的key一定得是唯一的。主要用在MyISAM存储引擎中，如下图：</p><img src="/2019/07/24/MySQL中的索引/07/24/MySQL中的索引/06.png"><p><strong>非聚簇索引比聚簇索引多了一次读取数据的IO操作，所以查找性能上会差。</strong></p><h2 id="联合索引-1"><a href="#联合索引-1" class="headerlink" title="联合索引"></a>联合索引</h2><h3 id="联合索引的B-树结构"><a href="#联合索引的B-树结构" class="headerlink" title="联合索引的B+树结构"></a>联合索引的B+树结构</h3><p>我们用（name，age）这个联合索引来分析</p><img src="/2019/07/24/MySQL中的索引/07/24/MySQL中的索引/11.jpg"><p>可以看到，索引项是按照索引定义里面出现的字段顺序排序的。</p><p>当你的逻辑需求是查到所有名字是“张三”的人时，可以快速定位到 ID4，然后向后遍历得到所有需要的结果。</p><p>只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。</p><p>基于上面对最左前缀索引的说明，我们来讨论一个问题：在建立联合索引的时候，如何安排索引内的字段顺序。</p><p>使用越频繁的字段通常可以放在最左侧。</p><h3 id="多个单列索引和联合索引的区别"><a href="#多个单列索引和联合索引的区别" class="headerlink" title="多个单列索引和联合索引的区别"></a>多个单列索引和联合索引的区别</h3><p>多个单列索引：</p><p>多个单列索引在多条件查询时只会生效第一个索引！所以多条件联合查询时最好建联合索引！</p><div class="table-container"><table><thead><tr><th>where语句查询情况</th><th>实际用的索引</th></tr></thead><tbody><tr><td>a and b and c</td><td>a</td></tr><tr><td>a or b or c</td><td>a,b,c(查询结果有去重)</td></tr></tbody></table></div><p>联合索引本质：</p><p>当创建(a,b,c)联合索引时，<strong>相当于创建了(a)单列索引，(a,b)联合索引以及(a,b,c)联合索引</strong>想要索引生效的话,只能使用 a和a,b和a,b,c三种组合；当然，我们上面测试过，a,c组合也可以，但实际上只用到了a的索引，c并没有用到！生效情况如下表：</p><div class="table-container"><table><thead><tr><th>where语句查询情况</th><th>索引</th><th>实际用的索引</th></tr></thead><tbody><tr><td>a</td><td>联合索引</td><td>a</td></tr><tr><td>b</td><td>NULL</td><td>×</td></tr><tr><td>c</td><td>NULL</td><td>×</td></tr><tr><td>a and b</td><td>联合索引</td><td>(a,b)</td></tr><tr><td>a and c</td><td>联合索引</td><td>a</td></tr><tr><td>b and c</td><td>NULL</td><td>×</td></tr><tr><td>a and b and c</td><td>联合索引</td><td>(a,b,c)</td></tr></tbody></table></div><p><strong>总结：</strong>索引的最左原则（左前缀原则），如（c1,c2,c3,c4….cN）的联合索引，where 条件按照索引建立的字段顺序来使用（<strong>不代表and条件必须按照顺序来写</strong>），<strong>如果中间某列没有条件，或使用like会导致后面的列不能使用索引。</strong></p><p>（如面试题：现在有a b 作为联合索引，有一条sql语句 where b &gt; 0 and a = 7 和 where a&gt;0 and b = 7分别会用到索引吗？  会）</p><p><strong>最左前缀：</strong>顾名思义，就是最左优先，上例中我们创建了lname_fname_age多列索引,相当于创建了(lname)单列索引，(lname,fname)组合索引以及(lname,fname,age)组合索引。</p><p><a href="https://blog.csdn.net/mrxiky/article/details/81775194" target="_blank" rel="noopener">参考博客:多个单列索引和联合索引的区别</a></p><h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><h3 id="1-独立的列"><a href="#1-独立的列" class="headerlink" title="1. 独立的列"></a>1. 独立的列</h3><p>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。</p><p>例如下面的查询不能使用 actor_id 列的索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> sakila.actor <span class="keyword">WHERE</span> actor_id + <span class="number">1</span> = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h3 id="2-多列索引"><a href="#2-多列索引" class="headerlink" title="2. 多列索引"></a>2. 多列索引</h3><p>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> film_id, actor_ <span class="keyword">id</span> <span class="keyword">FROM</span> sakila.film_actor</span><br><span class="line"><span class="keyword">WHERE</span> actor_id = <span class="number">1</span> <span class="keyword">AND</span> film_id = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="3-索引列的顺序"><a href="#3-索引列的顺序" class="headerlink" title="3. 索引列的顺序"></a>3. 索引列的顺序</h3><p>让选择性最强的索引列放在前面。</p><p>索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。</p><p>例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> staff_id)/<span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> staff_id_selectivity,</span><br><span class="line"><span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> customer_id)/<span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> customer_id_selectivity,</span><br><span class="line"><span class="keyword">COUNT</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> payment;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   staff_id_selectivity: 0.0001</span><br><span class="line">customer_id_selectivity: 0.0373</span><br><span class="line">               COUNT(*): 16049</span><br></pre></td></tr></table></figure><h3 id="4-前缀索引"><a href="#4-前缀索引" class="headerlink" title="4. 前缀索引"></a>4. 前缀索引</h3><p>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。</p><p>前缀长度的选取需要根据索引选择性来确定。</p><h3 id="5-覆盖索引"><a href="#5-覆盖索引" class="headerlink" title="5. 覆盖索引"></a>5. 覆盖索引</h3><p>索引包含所有需要查询的字段的值。</p><p>具有以下优点：</p><ul><li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li><li>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</li><li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</li></ul><h2 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h2><ul><li>大大减少了服务器需要扫描的数据行数。</li><li>帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。</li><li>将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。</li></ul><h2 id="索引的使用条件"><a href="#索引的使用条件" class="headerlink" title="索引的使用条件"></a>索引的使用条件</h2><ul><li>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；</li><li>对于中到大型的表，索引就非常有效；</li><li>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;索引&quot;&gt;&lt;a href=&quot;#索引&quot; class=&quot;headerlink&quot; title=&quot;索引&quot;&gt;&lt;/a&gt;索引&lt;/h1&gt;&lt;h2 id=&quot;什么是索引？&quot;&gt;&lt;a href=&quot;#什么是索引？&quot; class=&quot;headerlink&quot; title=&quot;什么是索引？&quot;&gt;&lt;/a&gt;什
      
    
    </summary>
    
    
      <category term="数据库" scheme="http://yuemingyang7010.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="http://yuemingyang7010.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
    
    
      <category term="数据库" scheme="http://yuemingyang7010.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Linux IO模式及select、poll、epoll</title>
    <link href="http://yuemingyang7010.github.io/2019/07/21/Linux-IO%E6%A8%A1%E5%BC%8F%E5%8F%8Aselect%E3%80%81poll%E3%80%81epoll/"/>
    <id>http://yuemingyang7010.github.io/2019/07/21/Linux-IO模式及select、poll、epoll/</id>
    <published>2019-07-21T12:33:33.000Z</published>
    <updated>2019-08-05T15:42:06.884Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="noopener">转载出处</a></p><p>同步IO和异步IO，阻塞IO和非阻塞IO分别是什么，到底有什么区别？不同的人在不同的上下文下给出的答案是不同的。所以先限定一下本文的上下文。</p><p><strong>本文讨论的背景是Linux环境下的network IO。</strong></p><h1 id="一-概念说明"><a href="#一-概念说明" class="headerlink" title="一 概念说明"></a>一 概念说明</h1><p>在进行解释之前，首先要说明几个概念：</p><ul><li>用户空间和内核空间</li><li>进程切换</li><li>进程的阻塞</li><li>文件描述符</li><li>缓存 I/O</li></ul><h2 id="用户空间与内核空间"><a href="#用户空间与内核空间" class="headerlink" title="用户空间与内核空间"></a>用户空间与内核空间</h2><p>现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。<strong>操作系统的核心是内核，独立于普通的应用程序</strong>，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。</p><h2 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h2><p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。</p><p>从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：</p><ol><li>保存处理机上下文，包括程序计数器和其他寄存器。</li><li>更新PCB信息。</li><li>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。</li><li>选择另一个进程执行，并更新其PCB。</li><li>更新内存管理的数据结构。</li><li>恢复处理机上下文。</li></ol><p>注：总而言之就是很耗资源，具体的可以参考这篇文章：进程切换</p><h2 id="进程的阻塞"><a href="#进程的阻塞" class="headerlink" title="进程的阻塞"></a>进程的阻塞</h2><p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。<code>当进程进入阻塞状态，是不占用CPU资源的</code>。</p><h2 id="文件描述符fd"><a href="#文件描述符fd" class="headerlink" title="文件描述符fd"></a>文件描述符fd</h2><p>文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。</p><p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。<strong>当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。</strong>在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p><h2 id="缓存-I-O"><a href="#缓存-I-O" class="headerlink" title="缓存 I/O"></a>缓存 I/O</h2><p>缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p><p><strong>缓存 I/O 的缺点：</strong><br>数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</p><h1 id="二-IO模式"><a href="#二-IO模式" class="headerlink" title="二 IO模式"></a>二 IO模式</h1><p>刚才说了，对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段：</p><ol><li><strong><u>等待数据准备 (Waiting for the data to be ready)</u></strong></li><li><strong><u>将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</u></strong></li></ol><p>正式因为这两个阶段，linux系统产生了下面五种网络模式的方案。</p><ul><li>阻塞 I/O（blocking IO）</li><li>非阻塞 I/O（nonblocking IO）</li><li>I/O 多路复用（ IO multiplexing）</li><li>信号驱动 I/O（ signal driven IO）</li><li>异步 I/O（asynchronous IO）</li></ul><p>注：由于signal driven IO在实际中并不常用，所以我这只提及剩下的四种IO Model。</p><h2 id="阻塞-I-O（blocking-IO）"><a href="#阻塞-I-O（blocking-IO）" class="headerlink" title="阻塞 I/O（blocking IO）"></a>阻塞 I/O（blocking IO）</h2><p>在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：</p><img src="/2019/07/21/Linux-IO模式及select、poll、epoll/07/21/Linux-IO模式及select、poll、epoll/01.png"><p>当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 所以，blocking IO的特点就是在IO执行的两个阶段都被block了。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="非阻塞-I-O（nonblocking-IO）"><a href="#非阻塞-I-O（nonblocking-IO）" class="headerlink" title="非阻塞 I/O（nonblocking IO）"></a>非阻塞 I/O（nonblocking IO）</h2><p>linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：</p><img src="/2019/07/21/Linux-IO模式及select、poll、epoll/07/21/Linux-IO模式及select、poll、epoll/02.png"><p>当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 所以，nonblocking IO的特点是用户进程需要**不断的主动询问**kernel数据好了没有。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="I-O-多路复用（-IO-multiplexing）"><a href="#I-O-多路复用（-IO-multiplexing）" class="headerlink" title="I/O 多路复用（ IO multiplexing）"></a>I/O 多路复用（ IO multiplexing）</h2><p>IO multiplexing就是我们说的select，poll，epoll，有些地方也称这种IO方式为event driven IO。select/epoll的好处就在于<strong>单个process就可以同时处理多个网络连接的IO</strong>。它的基本原理就是select，poll，epoll这个function会<strong>不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。</strong></p><img src="/2019/07/21/Linux-IO模式及select、poll、epoll/07/21/Linux-IO模式及select、poll、epoll/03.png"><p><code>当用户进程调用了select，那么整个进程会被block</code>，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，<strong>select就会返回</strong>。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; 所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待</span><br><span class="line">&gt; 多个文件描述符，而这些文件描述符（套接字描述符）其中的任意</span><br><span class="line">&gt; 一个进入读就绪状态，select()函数就可以返回。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，<strong>用select的优势在于它可以同时处理多个connection。</strong></p><p>所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。<strong>select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。</strong>）</p><p>在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</p><h2 id="异步-I-O（asynchronous-IO）"><a href="#异步-I-O（asynchronous-IO）" class="headerlink" title="异步 I/O（asynchronous IO）"></a>异步 I/O（asynchronous IO）</h2><p>linux下的asynchronous IO其实用得很少。先看一下它的流程：</p><img src="/2019/07/21/Linux-IO模式及select、poll、epoll/07/21/Linux-IO模式及select、poll、epoll/04.png"><p>用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="blocking和non-blocking的区别"><a href="#blocking和non-blocking的区别" class="headerlink" title="blocking和non-blocking的区别"></a>blocking和non-blocking的区别</h3><p>调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。</p><h3 id="synchronous-IO和asynchronous-IO的区别"><a href="#synchronous-IO和asynchronous-IO的区别" class="headerlink" title="synchronous IO和asynchronous IO的区别"></a>synchronous IO和asynchronous IO的区别</h3><p>在说明synchronous IO和asynchronous IO的区别之前，需要先给出两者的定义。POSIX的定义是这样子的：<br>- A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;<br>- An asynchronous I/O operation does not cause the requesting process to be blocked;</p><p>两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。</p><p>有人会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。</p><p>而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。</p><p><strong>各个IO Model的比较如图所示：</strong></p><img src="/2019/07/21/Linux-IO模式及select、poll、epoll/07/21/Linux-IO模式及select、poll、epoll/05.png"><p>通过上面的图片，可以发现non-blocking IO和asynchronous IO的区别还是很明显的。在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。</p><h1 id="三-I-O-多路复用之select、poll、epoll详解"><a href="#三-I-O-多路复用之select、poll、epoll详解" class="headerlink" title="三 I/O 多路复用之select、poll、epoll详解"></a>三 I/O 多路复用之select、poll、epoll详解</h1><p>select，poll，epoll都是IO多路复用的机制。I/O多路复用就是通过一种机制，<strong>一个进程可以监视多个描述符，一旦某个描述符就绪</strong>（一般是读就绪或者写就绪），<strong>能够通知程序进行相应的读写操作。</strong>但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。（这里啰嗦下）</p><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span> <span class="params">(<span class="keyword">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述副就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以 通过遍历fdset，来找到就绪的描述符。</p><p><strong>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select的一 个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024</strong>，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但 是这样也会造成效率的降低。</p><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span> <span class="params">(struct pollfd *fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>不同与select使用三个位图来表示三个fdset的方式，poll使用一个 pollfd的指针实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="keyword">short</span> events; <span class="comment">/* requested events to watch */</span></span><br><span class="line">    <span class="keyword">short</span> revents; <span class="comment">/* returned events witnessed */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>pollfd结构包含了要监视的event和发生的event，不再使用select“参数-值”传递的方式。同时，pollfd并没有最大数量限制（但是数量过大后性能也是会下降）。 和select函数一样，poll返回后，需要轮询pollfd来获取就绪的描述符。</p><blockquote><p>从上面看，<strong>select和poll都需要在返回后，`通过遍历文件描述符来获取已经就绪的socket</strong>`。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。</p></blockquote><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>epoll是在2.6内核中提出的，是之前的select和poll的增强版本。<strong>相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</strong></p><h3 id="一-epoll操作过程"><a href="#一-epoll操作过程" class="headerlink" title="一 epoll操作过程"></a>一 epoll操作过程</h3><p>epoll操作过程需要三个接口，分别如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int epoll_create(int size)；//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>1. int epoll_create(int size);</strong><br>创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大，这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值，<code>参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议</code>。<br>当创建好epoll句柄后，它就会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</p><ol><li>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；<br>函数是对指定描述符fd执行op操作。</li></ol><ul><li>epfd：是epoll_create()的返回值。</li><li>op：表示op操作，用三个宏来表示：添加EPOLL_CTL_ADD，删除EPOLL_CTL_DEL，修改EPOLL_CTL_MOD。分别添加、删除和修改对fd的监听事件。</li><li>fd：是需要监听的fd（文件描述符）</li><li>epoll_event：是告诉内核需要监听什么事，struct epoll_event结构如下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">  <span class="keyword">__uint32_t</span> events;  <span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data;  <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//events可以是以下几个宏的集合：</span></span><br><span class="line">EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</span><br><span class="line">EPOLLOUT：表示对应的文件描述符可以写；</span><br><span class="line">EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</span><br><span class="line">EPOLLERR：表示对应的文件描述符发生错误；</span><br><span class="line">EPOLLHUP：表示对应的文件描述符被挂断；</span><br><span class="line">EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。</span><br><span class="line">EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</span><br></pre></td></tr></table></figure><p><strong>3. int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</strong><br>等待epfd上的io事件，最多返回maxevents个事件。<br>参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</p><h3 id="二-工作模式"><a href="#二-工作模式" class="headerlink" title="二 工作模式"></a>二 工作模式</h3><p>　epoll对文件描述符的操作有两种模式：<strong>LT（level trigger）</strong>和<strong>ET（edge trigger）</strong>。LT模式是默认模式，LT模式与ET模式的区别如下：<br>　　<strong>LT模式</strong>：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<code>应用程序可以不立即处理该事件</code>。下次调用epoll_wait时，会再次响应应用程序并通知此事件。<br>　　<strong>ET模式</strong>：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<code>应用程序必须立即处理该事件</code>。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p><h4 id="1-LT模式"><a href="#1-LT模式" class="headerlink" title="1. LT模式"></a>1. LT模式</h4><p>LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。</p><h4 id="2-ET模式"><a href="#2-ET模式" class="headerlink" title="2. ET模式"></a>2. ET模式</h4><p>ET(edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)</p><p>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p><h4 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h4><p>假如有这样一个例子：</p><ol><li>我们已经把一个用来从管道中读取数据的文件句柄(RFD)添加到epoll描述符</li><li>这个时候从管道的另一端被写入了2KB的数据</li><li>调用epoll_wait(2)，并且它会返回RFD，说明它已经准备好读取操作</li><li>然后我们读取了1KB的数据</li><li>调用epoll_wait(2)……</li></ol><p><strong>LT模式：</strong><br>如果是LT模式，那么在第5步调用epoll_wait(2)之后，仍然能受到通知。</p><p><strong>ET模式：</strong><br>如果我们在第1步将RFD添加到epoll描述符的时候使用了EPOLLET标志，那么在第5步调用epoll_wait(2)之后将有可能会挂起，因为剩余的数据还存在于文件的输入缓冲区内，而且数据发出端还在等待一个针对已经发出数据的反馈信息。只有在监视的文件句柄上发生了某个事件的时候 ET 工作模式才会汇报事件。因此在第5步的时候，调用者可能会放弃等待仍在存在于文件输入缓冲区内的剩余数据。</p><p>当使用epoll的ET模型来工作时，当产生了一个EPOLLIN事件后，<br>读数据的时候需要考虑的是当recv()返回的大小如果等于请求的大小，那么很有可能是缓冲区还有数据未读完，也意味着该次事件还没有处理完，所以还需要再次读取：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(rs)&#123;</span><br><span class="line">  buflen = recv(activeevents[i].data.fd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(buflen &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 由于是非阻塞的模式,所以当errno为EAGAIN时,表示当前缓冲区已无数据可读</span></span><br><span class="line">    <span class="comment">// 在这里就当作是该次事件已处理处.</span></span><br><span class="line">    <span class="keyword">if</span>(errno == EAGAIN)&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(buflen == <span class="number">0</span>)&#123;</span><br><span class="line">     <span class="comment">// 这里表示对端的socket已正常关闭.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(buflen == <span class="keyword">sizeof</span>(buf)&#123;</span><br><span class="line">      rs = <span class="number">1</span>;   <span class="comment">// 需要再次读取</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span>&#123;</span><br><span class="line">      rs = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Linux中的EAGAIN含义</strong></p></blockquote><p>Linux环境下开发经常会碰到很多错误(设置errno)，其中EAGAIN是其中比较常见的一个错误(比如用在非阻塞操作中)。<br>从字面上来看，是提示再试一次。这个错误经常出现在当应用程序进行一些非阻塞(non-blocking)操作(对文件或socket)的时候。</p><p>例如，以 O_NONBLOCK的标志打开文件/socket/FIFO，如果你连续做read操作而没有数据可读。此时程序不会阻塞起来等待数据准备就绪返回，read函数会返回一个错误EAGAIN，提示你的应用程序现在没有数据可读请稍后再试。<br>又例如，当一个系统调用(比如fork)因为没有足够的资源(比如虚拟内存)而执行失败，返回EAGAIN提示其再调用一次(也许下次就能成功)。</p><h3 id="三-代码演示"><a href="#三-代码演示" class="headerlink" title="三 代码演示"></a>三 代码演示</h3><p>下面是一段不完整的代码且格式不对，意在表述上面的过程，去掉了一些模板代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPADDRESS   <span class="meta-string">"127.0.0.1"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT        8787</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE     1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTENQ     5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FDSIZE      1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPOLLEVENTS 100</span></span><br><span class="line"></span><br><span class="line">listenfd = socket_bind(IPADDRESS,PORT);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">EPOLLEVENTS</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个描述符</span></span><br><span class="line">epollfd = epoll_create(FDSIZE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加监听描述符事件</span></span><br><span class="line">add_event(epollfd,listenfd,EPOLLIN);</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环等待</span></span><br><span class="line"><span class="keyword">for</span> ( ; ; )&#123;</span><br><span class="line">    <span class="comment">//该函数返回已经准备好的描述符事件数目</span></span><br><span class="line">    ret = epoll_wait(epollfd,events,EPOLLEVENTS,<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">//处理接收到的连接</span></span><br><span class="line">    handle_events(epollfd,events,ret,listenfd,buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//事件处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_events</span><span class="params">(<span class="keyword">int</span> epollfd,struct epoll_event *events,<span class="keyword">int</span> num,<span class="keyword">int</span> listenfd,<span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i;</span><br><span class="line">     <span class="keyword">int</span> fd;</span><br><span class="line">     <span class="comment">//进行遍历;这里只要遍历已经准备好的io事件。num并不是当初epoll_create时的FDSIZE。</span></span><br><span class="line">     <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; num;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         fd = events[i].data.fd;</span><br><span class="line">        <span class="comment">//根据描述符的类型和事件类型进行处理</span></span><br><span class="line">         <span class="keyword">if</span> ((fd == listenfd) &amp;&amp;(events[i].events &amp; EPOLLIN))</span><br><span class="line">            handle_accpet(epollfd,listenfd);</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN)</span><br><span class="line">            do_read(epollfd,fd,buf);</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLOUT)</span><br><span class="line">            do_write(epollfd,fd,buf);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加事件</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add_event</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">int</span> state)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.events = state;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    epoll_ctl(epollfd,EPOLL_CTL_ADD,fd,&amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理接收到的连接</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_accpet</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> listenfd)</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> clifd;     </span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span>     </span><br><span class="line">     <span class="keyword">socklen_t</span>  cliaddrlen;     </span><br><span class="line">     clifd = accept(listenfd,(struct sockaddr*)&amp;cliaddr,&amp;cliaddrlen);     </span><br><span class="line">     <span class="keyword">if</span> (clifd == <span class="number">-1</span>)         </span><br><span class="line">     perror(<span class="string">"accpet error:"</span>);     </span><br><span class="line">     <span class="keyword">else</span> &#123;         </span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"accept a new client: %s:%d\n"</span>,inet_ntoa(cliaddr.sin_addr),cliaddr.sin_port);                       <span class="comment">//添加一个客户描述符和事件         </span></span><br><span class="line">         add_event(epollfd,clifd,EPOLLIN);     </span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读处理</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_read</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">char</span> *buf)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nread;</span><br><span class="line">    nread = read(fd,buf,MAXSIZE);</span><br><span class="line">    <span class="keyword">if</span> (nread == <span class="number">-1</span>)     &#123;         </span><br><span class="line">        perror(<span class="string">"read error:"</span>);         </span><br><span class="line">        close(fd); <span class="comment">//记住close fd        </span></span><br><span class="line">        delete_event(epollfd,fd,EPOLLIN); <span class="comment">//删除监听 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>)     &#123;         </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"client close.\n"</span>);</span><br><span class="line">        close(fd); <span class="comment">//记住close fd       </span></span><br><span class="line">        delete_event(epollfd,fd,EPOLLIN); <span class="comment">//删除监听 </span></span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="keyword">else</span> &#123;         </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"read message is : %s"</span>,buf);        </span><br><span class="line">        <span class="comment">//修改描述符对应的事件，由读改为写         </span></span><br><span class="line">        modify_event(epollfd,fd,EPOLLOUT);     </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写处理</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_write</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">char</span> *buf)</span> </span>&#123;     </span><br><span class="line">    <span class="keyword">int</span> nwrite;     </span><br><span class="line">    nwrite = write(fd,buf,<span class="built_in">strlen</span>(buf));     </span><br><span class="line">    <span class="keyword">if</span> (nwrite == <span class="number">-1</span>)&#123;         </span><br><span class="line">        perror(<span class="string">"write error:"</span>);        </span><br><span class="line">        close(fd);   <span class="comment">//记住close fd       </span></span><br><span class="line">        delete_event(epollfd,fd,EPOLLOUT);  <span class="comment">//删除监听    </span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        modify_event(epollfd,fd,EPOLLIN); </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="number">0</span>,MAXSIZE); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除事件</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete_event</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.events = state;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    epoll_ctl(epollfd,EPOLL_CTL_DEL,fd,&amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改事件</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">modify_event</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">int</span> state)</span></span>&#123;     </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.events = state;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    epoll_ctl(epollfd,EPOLL_CTL_MOD,fd,&amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注：另外一端我就省了</span></span><br></pre></td></tr></table></figure><h3 id="四-epoll总结"><a href="#四-epoll总结" class="headerlink" title="四 epoll总结"></a>四 epoll总结</h3><p>在 select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而<strong>epoll事先通过epoll_ctl()来注册一 个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait() 时便得到通知</strong>。(<code>此处去掉了遍历文件描述符，而是通过监听回调的的机制</code>。这正是epoll的魅力所在。)</p><p><strong>epoll的优点主要是一下几个方面：</strong></p><ol><li><strong>监视的描述符数量不受限制</strong>，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左 右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。select的最大缺点就是进程打开的fd是有数量限制的。这对 于连接数量比较大的服务器来说根本不能满足。虽然也可以选择多进程的解决方案( Apache就是这样实现的)，不过虽然linux上面创建进程的代价比较小，但仍旧是不可忽视的，加上进程间数据同步远比不上线程间同步的高效，所以也不是一种完美的方案。</li><li><strong>IO的效率不会随着监视fd的数量的增长而下降。</strong>epoll不同于select和poll轮询的方式，而是<strong>通过每个fd定义的回调函数来实现的。只有就绪的fd才会执行回调函数。</strong></li></ol><blockquote><p>如果没有大量的idle -connection或者dead-connection，epoll的效率并不会比select/poll高很多，但是当遇到大量的idle- connection，就会发现epoll的效率大大高于select/poll。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000003063859&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;转载出处&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;同步IO和异步IO，阻塞IO和非阻塞IO分别是什么，到底有什么区别？不同
      
    
    </summary>
    
    
      <category term="操作系统" scheme="http://yuemingyang7010.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux" scheme="http://yuemingyang7010.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"/>
    
    
      <category term="操作系统" scheme="http://yuemingyang7010.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux" scheme="http://yuemingyang7010.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>字符串</title>
    <link href="http://yuemingyang7010.github.io/2019/06/29/LeetCode-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://yuemingyang7010.github.io/2019/06/29/LeetCode-字符串/</id>
    <published>2019-06-29T05:52:09.000Z</published>
    <updated>2019-11-01T01:12:36.481Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://baijiahao.baidu.com/s?id=1605574559806098900&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">C语言字符串函数参考1</a></p><p><a href="https://www.cnblogs.com/xionghj/p/4443891.html" target="_blank" rel="noopener">C语言字符串函数参考2</a></p><p><a href="http://c.biancheng.net/cpp/biancheng/view/3284.html" target="_blank" rel="noopener">C++语言字符串函数参考</a></p><h1 id="字符串刷题方法"><a href="#字符串刷题方法" class="headerlink" title="字符串刷题方法"></a>字符串刷题方法</h1><p>字符串循环移位<br>LCS最长递增子序到   <strong>去动态规划看</strong><br>字符串全排到<br>Manacher算法<br>KMP模式串匹配<br>    附：BM算法<br>三字母字符串组合</p><h2 id="字符串循环左移"><a href="#字符串循环左移" class="headerlink" title="字符串循环左移"></a>字符串循环左移</h2><p>题目：给定一个字符串S[0..N-1]，要求把S的前k个字符移动到S的尾部，如把字符串“abcdef”前面的2个字符‘a’、b’移动到字符串的尾部，得到新字符串“cdefab”：即字符串循环左移k。<br>多说一句：循环左移n+k位和k位的效果相同，循环左移k位等价于循环右移n-k位。<br>算法要求：<br><strong>时间复杂度为O（n），空间复杂度为O（1）。</strong></p><p>分析：</p><p><strong>暴力移位法</strong><br>每次循环左移1位，调用k次即可<br>时间复杂度O（kN），空间复杂度O（1）</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> temp = S[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">S[i<span class="number">-1</span>] = S[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>三次拷贝</strong><br>S[0…k]→T[0…k]<br>S[k+1..N-1]→S[0..N-k-1]<br>T[0…k]→S[N-k…N-1]<br>时间复杂度O（N），空间复杂度O（k）</p><p><strong>优雅一点的算法</strong><br>(1)（X‘Y’)‘=YX</p><p>​        如：abcdef </p><p>​        X=ab         X’=ba </p><p>​        Y=cdef      Y’=fedc</p><p>​     （X‘Y’)‘=（bafedc）’ = cdefab</p><p>(2)时间复杂度O（N），空间复杂度O（1）</p><p>​        该问题会在“完美洗牌”算法中再次遇到。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串翻转</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReverseString</span><span class="params">(<span class="keyword">char</span>* s,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line"> <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">char</span> tem = s[left];</span><br><span class="line">        s[left++] = s[right];</span><br><span class="line">        s[right--] = t;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//n为字符串长度，m为左移多少位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LeftRotateString</span><span class="params">(<span class="keyword">char</span>* s,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    m %= n;</span><br><span class="line">    ReverseString(s,<span class="number">0</span>,m<span class="number">-1</span>);</span><br><span class="line">    ReverseString(s,m,n<span class="number">-1</span>);</span><br><span class="line">    ReverseString(s,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>该方法特别适合，反转 “I love china”为“china love I”</strong></p><h2 id="最长回文子串-leetcode-5"><a href="#最长回文子串-leetcode-5" class="headerlink" title="最长回文子串(leetcode 5)"></a>最长回文子串(leetcode 5)</h2><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p><p>示例 1：</p><p>输入: “babad”<br>输出: “bab”<br>注意: “aba” 也是一个有效答案。<br>示例 2：</p><p>输入: “cbbd”<br>输出: “bb”</p><p>思路：<a href="https://mp.weixin.qq.com/s?__biz=MzIwNTc4NTEwOQ==&amp;mid=2247484049&amp;idx=1&amp;sn=b3ee1a909d0c75cb9ef57df69ca36f5c&amp;chksm=972ad3eba05d5afd63dcb87c78a3b99cd6312e86c26d3727a7c7e01f0ed9a5f4f81edbee06f9&amp;mpshare=1&amp;scene=1&amp;srcid=0719xSkvzvmyhSB5d0cGY6Au&amp;key=034516426b2066d0e0aa6ab7340f5165b69a49c8183a1b4a232fae513c14ca25e69fa8220126e8ae5c517f68513d650b40ea657e95aed7b3002b7281a4c0fec8b6e601f0a455962f47f12cab9c546f51&amp;ascene=1&amp;uin=MjUzODM5ODQwNA%3D%3D&amp;devicetype=Windows+10&amp;version=62060833&amp;lang=zh_CN&amp;pass_ticket=x3FegFPx%2Bvw0qa34JSQ8rVDFtlaR46UnZVCzg53idyupd1SCO5oQv401BqivS7%2Fn" target="_blank" rel="noopener">参考</a></p><p><strong>方法一：Manacher 算法求最长回文子串:  时间复杂度O(N)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="string">""</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"><span class="built_in">string</span> str = <span class="string">"@"</span>;</span><br><span class="line"><span class="built_in">string</span> result;</span><br><span class="line"><span class="keyword">int</span> len = s.length();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">str = str + <span class="string">"#"</span> + s[i];</span><br><span class="line">str += <span class="string">"#$"</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p(str.length(), <span class="number">1</span>);</span><br><span class="line">manacher(str, p);</span><br><span class="line"><span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> imax;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.size(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (p[i] &gt; max) &#123;</span><br><span class="line">max = p[i];</span><br><span class="line">imax = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = imax - (max - <span class="number">1</span>); j &lt;= imax + (max - <span class="number">1</span>); j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (str[j] != <span class="string">'#'</span>)</span><br><span class="line">result += str[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manacher</span><span class="params">(<span class="built_in">string</span>&amp; str, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = str.length();</span><br><span class="line"><span class="keyword">int</span> id = <span class="number">0</span>;  <span class="comment">// id 为已知的 &#123;右边界最大&#125; 的回文子串的中心</span></span><br><span class="line"><span class="keyword">int</span> mx = <span class="number">1</span>;  <span class="comment">//mx则为id+P[id]，也就是这个子串的右边界</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len - <span class="number">2</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (mx &gt; i)</span><br><span class="line">p[i] = min(p[<span class="number">2</span> * id - i], mx - i);  <span class="comment">//如果mx&gt;i，则分两种情况</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">p[i] = <span class="number">1</span>;                   <span class="comment">//如果mx&lt;i，则无法用之前的p来计算，先置1</span></span><br><span class="line"><span class="keyword">for</span> (; str[i + p[i]] == str[i - p[i]]; p[i]++);  <span class="comment">//统计i对应的p[i]</span></span><br><span class="line"><span class="keyword">if</span> (mx &lt; i + p[i]) &#123;</span><br><span class="line">mx = i + p[i]; <span class="comment">//更新右边界</span></span><br><span class="line">id = i;      <span class="comment">//更新id</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方法2：暴力法 n*(n/2)(n2)  时间复杂度O(N^3)</p><p>方法3: 动态规划 O(N^2)</p><h2 id="KMP算法-实现-strStr-函数（leetcode-28）"><a href="#KMP算法-实现-strStr-函数（leetcode-28）" class="headerlink" title="KMP算法-实现 strStr() 函数（leetcode-28）"></a>KMP算法-实现 strStr() 函数（leetcode-28）</h2><p>KMP算法重点是求next数组：</p><p><a href="https://blog.csdn.net/v_JULY_v/article/details/7041827" target="_blank" rel="noopener">KMP经典参考文章</a></p><p>时间复杂度O(M+N)O(M+N)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getnext(<span class="built_in">string</span> str)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> len=str.size();</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next;</span><br><span class="line">            next.push_back(<span class="number">-1</span>);<span class="comment">//next数组初值为-1</span></span><br><span class="line">            <span class="keyword">int</span> j=<span class="number">0</span>,k=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;len<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(k==<span class="number">-1</span>||str[j]==str[k])<span class="comment">//str[j]后缀 str[k]前缀</span></span><br><span class="line">                &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                    k++;</span><br><span class="line">                    next.push_back(k);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    k=next[k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(needle.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;<span class="comment">//源串</span></span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;<span class="comment">//子串</span></span><br><span class="line">        <span class="keyword">int</span> len1=haystack.size();</span><br><span class="line">        <span class="keyword">int</span> len2=needle.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next;</span><br><span class="line">        next=getnext(needle);</span><br><span class="line">        <span class="keyword">while</span>((i&lt;len1)&amp;&amp;(j&lt;len2))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((j==<span class="number">-1</span>)||(haystack[i]==needle[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                j=next[j];<span class="comment">//获取下一次匹配的位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j==len2)</span><br><span class="line">            <span class="keyword">return</span> i-j;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>库函数解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(needle.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pos=haystack.find(needle);</span><br><span class="line">        <span class="keyword">return</span> pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="剑指offer目录"><a href="#剑指offer目录" class="headerlink" title="剑指offer目录"></a>剑指offer目录</h1><div class="table-container"><table><thead><tr><th>题目</th><th>难度</th><th></th></tr></thead><tbody><tr><td><a href="note://2FE9426DFA26451590280DDE2FF5D995" target="_blank" rel="noopener">15.二进制中1的个数.note</a></td><td>☆</td><td>要考虑到负数这种情况，右移数还是左移相与的数？</td></tr><tr><td><a href="note://0F2C9A08084941ACABE64F2321602B23" target="_blank" rel="noopener">38.字符串的排列.note</a></td><td>☆☆</td><td>采用递归回溯的方式实现，要考虑字符的重复，输出结果是否为字典序。</td></tr><tr><td><a href="note://6433D1219FFA437180403A8BBF8FB764" target="_blank" rel="noopener">43.1~n整数中1出现的次数.note</a></td><td>☆☆☆</td><td>设定整数点（如1、10、100等等）作为位置点i，<strong>求每个位置点为1时的数有多少个，再算出所有情况</strong>    //<strong>根据设定的整数位置，对n进行分割，分为两部分，高位n/i，低位n%i</strong></td></tr><tr><td><a href="note://00DEAC2A377142BDAAECF1A29FDD4F7D" target="_blank" rel="noopener">把数组排成最小的数.note</a></td><td>☆☆</td><td>要会用数字转字符串函数 to_string(number1),会写sort()的cmp函数。</td></tr><tr><td><a href="note://0E29AFB8ABE446BB98834AFFFF1CDCE1" target="_blank" rel="noopener">49.丑数.note</a></td><td>☆☆☆</td><td>一个丑数的因子只有2,3,5，那么丑数p = 2 ^ x <em> 3 ^ y </em> 5 ^ z</td></tr><tr><td><a href="note://7B71AF3F8E6341F6A7B00CEF6B8B1C82" target="_blank" rel="noopener">50.第一次只出现一次的字符.note</a></td><td>☆☆</td><td>采用hash思想，用int map[256]统计字符串中字符的个数，然后从头遍历字符串，到map[256]中寻找对应值，如果为1，则返回。</td></tr><tr><td><a href="note://495347488DBB4A7D8BBF97F7F6219833" target="_blank" rel="noopener">50(2).字符流中第一个只出现一次的字符.note</a></td><td>☆☆</td><td>和上题类似，只是字符串S和map[256]作为类的成员变量，每次调用insert()函数时，从字符流中添加一个字符到S的结尾，同时，更新map[256]中对应位，findFirst()仍然按照字符串顺序，遍历map数组。</td></tr><tr><td><a href="note://1BAB43C17FA84EF69194DDD5CDDECAE3" target="_blank" rel="noopener">求1+2+…+n.note</a></td><td>☆☆</td><td>采用递归代替循环，用&amp;&amp;代替if条件语句。</td></tr><tr><td><a href="note://CDEFFF8B180046AA8FD27260647AF6E8" target="_blank" rel="noopener">把字符串转换成整数.note</a></td><td>☆☆</td><td>(1)字符串指针是否为空，字符串长度是否为0；(2)考虑字符串的正负，正数要考虑带不带正号；(3)确保除了符号位以外所有的字符必须都是0~9之间的几个字符，否则返回0.</td></tr><tr><td><a href="note://3C01B41508FE4CCEA3220DA0E931715D" target="_blank" rel="noopener">19.正则表达式匹配.note</a></td><td>☆☆☆</td><td>分多种情况考虑，具体分析见链接</td></tr><tr><td><a href="note://660AC5B81F104AB5B54A6CF4A7701F09" target="_blank" rel="noopener">58(2).左旋转字符串.note</a></td><td>☆</td><td>主要熟悉下string类的一些函数的操作<a href="note://81AE2E6AD935400C912AE83D10A7DBAF" target="_blank" rel="noopener">2.16 C++ string类详解.note</a></td></tr><tr><td><a href="note://73104616EC1B4EEE947B96B4CD1EC0FF" target="_blank" rel="noopener">5.替换空格.note</a></td><td>☆☆</td><td>在同一个字符数组中，通过两个指针进行空格和%20的替换。</td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table></div><h2 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h2><p><strong>题目描述</strong></p><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><p><strong>知识补充：</strong></p><p>左移运算符m&lt;&lt;n，在左移n位时候，最左边n位丢弃，同时在最右边补上n个0；</p><p>m&gt;&gt;n时分两种情况：(1)无符号数，用0填补最左边n位；</p><p>（2）有符号数，则右移之后数字的符号位填补最左侧的n位。</p><p>如：00001010&gt;&gt;2 = 00000010            10001010&gt;&gt;3 = 11110001</p><p>思路分析：</p><p>(1)拿到题目可能第一想法，直接右移(注意：右移比除以2效率高很多)，如果输入的是负数，右移后，最左侧补上的是’1’,从而造成死循环；</p><p>(2)为了避免死循环，我们不右移输入的数字，而是将其与1,2,4,8…相与，实际采用标志位左移的方式，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">int</span>  <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">             <span class="keyword">if</span>(n&amp;flag)</span><br><span class="line">                 count++;</span><br><span class="line">             flag = flag&lt;&lt;<span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> count;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h2><p><strong>题目描述</strong></p><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p><p><strong>输入描述:</strong></p><p>输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。</p><p>思路：实际上本题需要排除重复情况，结果需要字典排序</p><p><strong>思路：</strong></p><p><strong>(1)将第一个元素与包括自身在内的所有元素交换。</strong></p><p><strong>(2)那么第一个元素是固定的，转到下一个元素。</strong></p><p><strong>(3)直到最后一个元素固定。输出。</strong></p><p><img src="/2019/06/29/LeetCode-字符串/01.png" alt></p><p>可以参考LeetCode刷题笔记：<a href="note://38033A07A3AD427AA3CA0E8ABE6D757F" target="_blank" rel="noopener">2.Permutations(中)全排列.note</a></p><p>也可以<a href="https://www.cnblogs.com/AndyJee/p/4655485.html" target="_blank" rel="noopener">参考博客:</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; Permutation(<span class="built_in">string</span> str) &#123;</span><br><span class="line">        <span class="keyword">if</span>(str.length() &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        permu(str,<span class="number">0</span>);</span><br><span class="line">        sort(result.begin(),result.end());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">permu</span><span class="params">(<span class="built_in">string</span> str,<span class="keyword">int</span> begin)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(begin == str.length()<span class="number">-1</span>)  <span class="comment">//最后一个字符的自身交换可以不考虑，如果考虑就不减1</span></span><br><span class="line">            result.push_back(str);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = begin;i&lt;str.length();i++)&#123;      </span><br><span class="line">                <span class="keyword">if</span>(begin == i || str[begin] != str[i])&#123;  <span class="comment">//排除重复的影响</span></span><br><span class="line">                    swap(str[begin],str[i]);</span><br><span class="line">                    permu(str,begin+<span class="number">1</span>);</span><br><span class="line">                    swap(str[begin],str[i]);  <span class="comment">//采用回溯的方法</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>&amp; a,<span class="keyword">char</span>&amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> temp = a;</span><br><span class="line">        a=b;</span><br><span class="line">        b=temp;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1-n整数中1出现的次数"><a href="#1-n整数中1出现的次数" class="headerlink" title="1~n整数中1出现的次数"></a>1~n整数中1出现的次数</h2><p><strong>题目描述</strong></p><p>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。</p><p><strong>思路：</strong></p><p>设定整数点（如1、10、100等等）作为位置点i（对应n的各位、十位、百位等等），分别对每个数位上有多少包含1的点进行分析，<strong>即求每个位置点为1时的数有多少个，再算出所有情况</strong></p><p>​    //<strong>根据设定的整数位置，对n进行分割，分为两部分，高位n/i，低位n%i</strong></p><p>​    //当i表示百位，且百位对应的数&gt;=2,如n=31456,i=100，则a=314,b=56，此时百位为1的次数有a/10+1=32（最高两位0~31），每一次都包含100个连续的点，即共有(a/10+1)*100个点的百位为1</p><p>​    //当i表示百位，且百位对应的数为1，如n=31156,i=100，则a=311,b=56，此时百位对应的就是1，则共有(a/10)*100+(b+1)个数</p><p>​    //当i表示百位，且百位对应的数为0,如n=31056,i=100，则a=310,b=56，此时百位为1的次数有(a/10)*100个</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> i=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i*=<span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> a=n/i;</span><br><span class="line">            <span class="keyword">int</span> b=n%i;</span><br><span class="line">            <span class="keyword">if</span>(a%<span class="number">10</span> == <span class="number">0</span>)</span><br><span class="line">                count = count+(a/<span class="number">10</span>)*i;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a%<span class="number">10</span> &gt;= <span class="number">2</span>)</span><br><span class="line">                count = count+(a/<span class="number">10</span> + <span class="number">1</span>)*i;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                count = count+(a/<span class="number">10</span>)*i+b+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a>把数组排成最小的数</h2><p><strong>题目描述</strong></p><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p><p><strong>解题思路</strong></p><p>可以看成是一个排序问题，在比较两个字符串S1和S2的大小时，应该比较的是S1+S2和S2+S1的大小，如果S1+S2&lt;S2+S1,那么应该把S1排在前面，否则应该把S2排在前面。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">PrintMinNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = numbers.size();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(numbers.begin(),numbers.end(),cmp);<span class="comment">//核心就一个sort()</span></span><br><span class="line">        <span class="built_in">string</span> result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            result += to_string(numbers[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果在类里面定义cmp要设置为静态的，直接放在类外不用这样，可能和sort()的实现有关</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> A = to_string(a)+to_string(b);</span><br><span class="line">        <span class="built_in">string</span> B = to_string(b)+to_string(a);</span><br><span class="line">        <span class="keyword">return</span> A &lt; B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h2><p><strong>题目描述</strong></p><p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p><p><strong>思路：</strong></p><p>首先从丑数的定义我们知道，一个丑数的因子只有2,3,5，那么丑数p = 2 ^ x <em> 3 ^ y </em> 5 ^ z，换句话说<strong>一个丑数一定由另一个丑数乘以2或者乘以3或者乘以5得到</strong>，那么我们从1开始乘以2,3,5，就得到2,3,5三个丑数，在从这三个丑数出发乘以2,3,5就得到4，6,10,6，9,15,10,15,25九个丑数，我们发现这种方法会得到重复的丑数，而且我们题目要求第N个丑数，这样的方法得到的丑数也是无序的。那么我们可以维护三个队列：</p><p>（1）丑数数组： 1</p><p>乘以2的队列：2</p><p>乘以3的队列：3</p><p>乘以5的队列：5</p><p>选择三个队列头最小的数2加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列；</p><p>（2）丑数数组：1,2</p><p>乘以2的队列：4</p><p>乘以3的队列：3，6</p><p>乘以5的队列：5，10</p><p>选择三个队列头最小的数3加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列；</p><p>（3）丑数数组：1,2,3</p><p>乘以2的队列：4,6</p><p>乘以3的队列：6,9</p><p>乘以5的队列：5,10,15</p><p>选择三个队列头里最小的数4加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列；</p><p>（4）丑数数组：1,2,3,4</p><p>乘以2的队列：6，8</p><p>乘以3的队列：6,9,12</p><p>乘以5的队列：5,10,15,20</p><p>选择三个队列头里最小的数5加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列；</p><p>（5）丑数数组：1,2,3,4,5</p><p>乘以2的队列：6,8,10，</p><p>乘以3的队列：6,9,12,15</p><p>乘以5的队列：10,15,20,25</p><p>选择三个队列头里最小的数6加入丑数数组，但我们发现，有两个队列头都为6，所以我们弹出两个队列头，同时将12,18,30放入三个队列；</p><p>……………………</p><p>疑问：</p><p>1.为什么分三个队列？</p><p>丑数数组里的数一定是有序的，因为我们是从丑数数组里的数乘以2,3,5选出的最小数，一定比以前未乘以2,3,5大，同时对于三个队列内部，按先后顺序乘以2,3,5分别放入，所以同一个队列内部也是有序的；</p><p>2.为什么比较三个队列头部最小的数放入丑数数组？</p><p>因为三个队列是有序的，所以取出三个头中最小的，等同于找到了三个队列所有数中最小的。</p><p>实现思路：</p><p>我们没有必要维护三个队列，只需要记录三个指针显示到达哪一步；“|”表示指针,arr表示丑数数组；</p><p>（1）1</p><p>|2</p><p>|3</p><p>|5</p><p>目前指针指向0,0,0，队列头arr[0] <em> 2 = 2,  arr[0] </em> 3 = 3,  arr[0] * 5 = 5</p><p>（2）1 2</p><p>2 |4</p><p>|3 6</p><p>|5 10</p><p>目前指针指向1,0,0，队列头arr[1] <em> 2 = 4,  arr[0] </em> 3 = 3, arr[0] * 5 = 5</p><p>（3）1 2 3</p><p>2| 4 6</p><p>3 |6 9</p><p>|5 10 15</p><p>目前指针指向1,1,0，队列头arr[1] <em> 2 = 4,  arr[1] </em> 3 = 6, arr[0] * 5 = 5</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">7</span>)</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(index);</span><br><span class="line">        res[<span class="number">0</span>] =<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> p2=<span class="number">0</span>,p3=<span class="number">0</span>,p5=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;index;i++)&#123;</span><br><span class="line">            res[i]=min_num(res[p2]*<span class="number">2</span>,res[p3]*<span class="number">3</span>,res[p5]*<span class="number">5</span>);</span><br><span class="line">            <span class="keyword">if</span>(res[i] == res[p2]*<span class="number">2</span>)</span><br><span class="line">                p2++;</span><br><span class="line">            <span class="keyword">if</span>(res[i] == res[p3]*<span class="number">3</span>)</span><br><span class="line">                p3++;</span><br><span class="line">            <span class="keyword">if</span>(res[i] == res[p5]*<span class="number">5</span>)</span><br><span class="line">                p5++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[index <span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min_num</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        a = a &lt; b?a:b;</span><br><span class="line">        a = a &lt; c?a:c;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>我所遇到过的错误分析：</strong></p><p><strong>在下面代码中，如果用if-else if-else，则会产生重复问题，比如产生两个6,6的重复。   所以一定要用if()….if()…..if()…..</strong>       </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index &lt; <span class="number">7</span>)</span><br><span class="line"><span class="keyword">return</span> index;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result(index);</span><br><span class="line">result[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> p2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> p3 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> p5 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; index; i++) &#123;</span><br><span class="line">result[i] = find_min(result[p2] * <span class="number">2</span>, result[p3] * <span class="number">3</span>, result[p5] * <span class="number">5</span>);</span><br><span class="line"><span class="keyword">if</span> (result[i] == result[p2] * <span class="number">2</span>)</span><br><span class="line">p2++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (result[i] == result[p3] * <span class="number">3</span>)</span><br><span class="line">p3++;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">p5++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result[index - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">a = a &lt; b ? a : b;</span><br><span class="line">a = a &lt; c ? a : c;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="第一次只出现一次的字符"><a href="#第一次只出现一次的字符" class="headerlink" title="第一次只出现一次的字符"></a>第一次只出现一次的字符</h2><p><strong>题目描述</strong></p><p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.</p><p><strong>思路：</strong></p><p>用STL中的map或者直接构件一个哈希表，由于本题只需要一个简单的哈希表，因此考虑实现一个简单的哈希表。</p><p><strong>每个字母根据其ASCII码值作为数组的下标对应数组的一个数字，而数组中存储的是每个字符出现的次数。这样我们就创建了一个大小为256、以字符ASCII码为键值的哈希表。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">map</span>[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : str)</span><br><span class="line">            <span class="built_in">map</span>[c]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[str[i]] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="字符流中第一个只出现一次的字符"><a href="#字符流中第一个只出现一次的字符" class="headerlink" title="字符流中第一个只出现一次的字符"></a>字符流中第一个只出现一次的字符</h2><p><strong>题目描述</strong></p><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。</p><p><strong>输出描述:</strong></p><p>如果当前字符流没有存在出现一次的字符，返回#字符。</p><p><strong>思路：</strong></p><p>类似于上一题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">         s+=ch;</span><br><span class="line">        hash[ch]++;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash[s[i]] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">char</span> hash[<span class="number">256</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="求1-2-…-n"><a href="#求1-2-…-n" class="headerlink" title="求1+2+…+n"></a>求1+2+…+n</h2><p><strong>题目：</strong></p><p>求1+2+…+n，要求不能使用乘除法、for、while、ifelse、switch、case等关键字及条件判断语句（A？B:C）。</p><p><strong>思路：</strong>采用递归，用&amp;&amp;代替if判断</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = n;</span><br><span class="line">        ans&amp;&amp;(ans += Sum_Solution(n<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="把字符串转换成整数"><a href="#把字符串转换成整数" class="headerlink" title="把字符串转换成整数"></a>把字符串转换成整数</h2><p>题目描述：</p><p>将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。</p><p>思路：本题主要考察思维严密性，注意以下几点：</p><p><strong>(1)字符串指针是否为空，字符串长度是否为0；</strong></p><p><strong>(2)考虑字符串的正负，特别是正数要考虑带不带正号；</strong></p><p><strong>(3)确保除了符号位以外所有的字符必须都是0~9之间的几个字符，否则返回0.</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> s = (str[<span class="number">0</span>] == <span class="string">'-'</span> ? <span class="number">-1</span>:<span class="number">1</span>); <span class="comment">//记录符号正负</span></span><br><span class="line">        <span class="keyword">int</span> i = ((str[<span class="number">0</span>] == <span class="string">'-'</span>)||(str[<span class="number">0</span>] == <span class="string">'+'</span>)?<span class="number">1</span>:<span class="number">0</span>); <span class="comment">//看字符串前有符号没有</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i]&gt;=<span class="string">'0'</span> &amp;&amp; str[i]&lt;=<span class="string">'9'</span>)  <span class="comment">//只有每一个单个字符都在0~9之间才合理，否则返回0</span></span><br><span class="line">                result = result*<span class="number">10</span> + str[i]-<span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result*s;  <span class="comment">//乘以符号位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h2><p><strong>题目描述</strong></p><p>请实现一个函数用来匹配包括’.’和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配</p><p><strong>思路：</strong></p><p>解这题需要把题意仔细研究清楚其多种情况。</p><p>首先通过模式串是否到结尾作为分类标准，分为两类</p><p>【1】模式串到结尾了</p><p>这种情况根据字符串是否到结尾了又分为两类：</p><p>(1)如果字符串和模式串都到了结尾，则返回true</p><p>(2)如果模式串到尾了，字符串还没到尾，肯定匹配失败,返回false</p><p>【2】模式串未到结尾</p><p>根据模式串当前字符的下一个字符是否为‘*’分为2类：</p><p>(1)若不为*，该种情况比较简单，比较字符串和模式串，分为当前字符匹配成功与失败2种；</p><p>(2)若为*，该种情况相对复杂，也是比较字符串和模式串，分为当前字符匹配成功与失败2种；</p><p>a.若匹配成功，则再分为字符串指针向后移动一位和不考虑模式串此次的成功匹配(考虑模式串出现多次连续与字符串当前位匹配成功的情况)字符串指针不向后移动两种情况，其中字符串指针向后移动一位的情况，又分为模式串指针保持在原位置和向后移动两位。具体如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> matchCore(str+<span class="number">1</span>,pattern+<span class="number">2</span>)||matchCore(str+<span class="number">1</span>,pattern)||matchCore(str,pattern+<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>b.若匹配不成功，则，字符串指针保持原位，模式串指针向后移动两位。</p><p>   为了更加直观说明，各种分类情况如下脑图：</p><p><img src="/2019/06/29/LeetCode-字符串/02.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">char</span>* pattern)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="literal">NULL</span> || pattern == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> matchCore(str,pattern);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">matchCore</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">char</span>* pattern)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果字符串和模式串都到了结尾，则返回true</span></span><br><span class="line">        <span class="keyword">if</span>(*str == <span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//如果模式串到尾了，字符串还没到尾，肯定匹配失败</span></span><br><span class="line">        <span class="keyword">if</span>(*str != <span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">///!!!!!!!!!上方为模式串到结尾了，下方是模式串未到结尾的所有情况！！！/////</span></span><br><span class="line">        <span class="keyword">if</span>(*(pattern+<span class="number">1</span>) == <span class="string">'*'</span>)&#123;  <span class="comment">//剩下情况以模式串下一个字符是否为*作为分类标准，分两类</span></span><br><span class="line">            <span class="comment">//如果当前字符串与模式串匹配上了则分为两种情况：【1】字符串和模式串相等，【2】模式串是‘.’，</span></span><br><span class="line">            <span class="comment">//且字符串没有到结尾，则继续匹配，字符串指针向后移1位，模式串指针保持原位或者向后2位</span></span><br><span class="line">            <span class="comment">//此外还要额外考虑一种情况，如字符串abc  模式串 a*a*bc,即模式串可以匹配成功，但是模式串</span></span><br><span class="line">            <span class="comment">//放弃前两位a*，用后面的字符与字符串去匹配，这种情况极易忽略，重点！！！</span></span><br><span class="line">            <span class="keyword">if</span>(*str == *pattern || (*str != <span class="string">'\0'</span>&amp;&amp;*pattern == <span class="string">'.'</span>))</span><br><span class="line">                <span class="keyword">return</span> matchCore(str+<span class="number">1</span>,pattern+<span class="number">2</span>)||matchCore(str+<span class="number">1</span>,pattern)||matchCore(str,pattern+<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">else</span>  <span class="comment">//如果字符串和模式串没配上，继续配，只能认为模式串*字符前一位字符出现0个</span></span><br><span class="line">                <span class="keyword">return</span> matchCore(str,pattern+<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(*str == *pattern || (*str != <span class="string">'\0'</span>&amp;&amp;*pattern == <span class="string">'.'</span>))</span><br><span class="line">                <span class="keyword">return</span> matchCore(str+<span class="number">1</span>,pattern+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h2><p>本题重点了解字符串string的用法：<a href="note://81AE2E6AD935400C912AE83D10A7DBAF" target="_blank" rel="noopener">2.16 C++ string类详解.note</a></p><p>对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">LeftRotateString</span><span class="params">(<span class="built_in">string</span> str, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        <span class="keyword">if</span>(len &lt; n)</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        <span class="built_in">string</span> temp = str.substr(n);</span><br><span class="line">        <span class="built_in">string</span> result = str.substr(<span class="number">0</span>,n);</span><br><span class="line">        result = temp + result;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h2><p><strong>题目描述</strong></p><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为4We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><p><strong>思路：</strong></p><p><img src="/2019/06/29/LeetCode-字符串/03.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replaceSpace</span><span class="params">(<span class="keyword">char</span> *str,<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先判断是否为空字符数组</span></span><br><span class="line">        <span class="keyword">if</span>(str == <span class="literal">NULL</span> || length &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//计算字符数组的实际长度(带\0)/////begin////</span></span><br><span class="line">        <span class="keyword">int</span> trueLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>* pTemp = str;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;str[i] != <span class="string">'\0'</span>;i++)&#123;</span><br><span class="line">            trueLength++;</span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">' '</span>)</span><br><span class="line">                count++;</span><br><span class="line">        &#125;</span><br><span class="line">        trueLength++;</span><br><span class="line">        <span class="keyword">int</span> newlength = count*<span class="number">2</span>+trueLength;</span><br><span class="line">    <span class="comment">//计算字符数组的实际长度(带\0)/////end/////</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(newlength &gt; length)<span class="comment">//如果替换空格后所需的字符数组长度小于length,则返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//进行替换////begin/////</span></span><br><span class="line">        <span class="keyword">int</span> indexOriginal = trueLength<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> indexNew = newlength<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(indexOriginal &gt;= <span class="number">0</span> &amp;&amp; indexNew &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[indexOriginal] == <span class="string">' '</span>)&#123;</span><br><span class="line">                str[indexNew--] = <span class="string">'0'</span>;</span><br><span class="line">                str[indexNew--] = <span class="string">'2'</span>;</span><br><span class="line">                str[indexNew--] = <span class="string">'%'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                str[indexNew--] = str[indexOriginal];</span><br><span class="line">            &#125;</span><br><span class="line">            indexOriginal--;</span><br><span class="line">        &#125;</span><br><span class="line">          <span class="comment">//进行替换////end/////</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://baijiahao.baidu.com/s?id=1605574559806098900&amp;amp;wfr=spider&amp;amp;for=pc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;C语言字符串函数参考1&lt;/a&gt;&lt;/p
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yuemingyang7010.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法刷题" scheme="http://yuemingyang7010.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="字符串刷题" scheme="http://yuemingyang7010.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="http://yuemingyang7010.github.io/2019/06/29/LeetCode-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://yuemingyang7010.github.io/2019/06/29/LeetCode-动态规划/</id>
    <published>2019-06-29T05:52:09.000Z</published>
    <updated>2019-10-31T04:21:12.731Z</updated>
    
    <content type="html"><![CDATA[<h3 id="最长公共子序列问题-LCS问题"><a href="#最长公共子序列问题-LCS问题" class="headerlink" title="最长公共子序列问题(LCS问题)"></a>最长公共子序列问题(LCS问题)</h3><p>给定两个字符串A和B，长度分别为m和n，要求找出它们最长的公共子序列，并<strong>返回子序列</strong>。例如：</p><p>　　A = “Hel<strong>lo</strong>W<strong>o</strong>rld”</p><p>　   B = “<strong>loo</strong>p”</p><p>当我们要求<strong>dp [i] [j]</strong>，我们要先判断<strong>A的第i个元素B的第j个元素</strong>是否相同即判断<strong>A[i - 1]</strong>和 <strong>B[j -1]</strong>是否相同，如果相同它就是<strong>dp [i-1] [j-1]+ 1</strong>，相当于在两个字符串都去掉一个字符时的<strong>最长公共子序列</strong>再加 <strong>1</strong>；否则<strong>最长公共子序列</strong>取<strong>dp[i] [j - 1]</strong> 和<strong>dp[i - 1] [j]</strong>中大者。所以整个问题的初始状态为：                                                            </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] [0]=0,dp[0] [j]=0</span><br></pre></td></tr></table></figure><p>相应的状态转移方程为：</p><script type="math/tex; mode=display">d p[i][j]=\left\{\begin{array}{ll}{\max \{d p[i-1][j], d p[i][j-1]\},} & {A[i-1] !=B[j-1]} \\ {d p[i-1][j-1]+1,} & {A[i-1]===B[j-1]}\end{array}\right.</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LCS</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str1,<span class="keyword">const</span> <span class="keyword">char</span>* str2,<span class="built_in">string</span>&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m = (<span class="keyword">int</span>)<span class="built_in">strlen</span>(str1);</span><br><span class="line"><span class="keyword">int</span> n = (<span class="keyword">int</span>)<span class="built_in">strlen</span>(str2);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &gt; dp(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;(n+<span class="number">1</span>)); </span><br><span class="line"><span class="comment">//第一步：填二维表格</span></span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= m; i++)<span class="comment">//初始状态</span></span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (str1[i - <span class="number">1</span>] == str2[j - <span class="number">1</span>])<span class="comment">//判断A的第i个字符和B的第j个字符是否相同</span></span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j] &gt; dp[i][j - <span class="number">1</span>]? dp[i - <span class="number">1</span>][j]: dp[i][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二步：从左下角找到朝左上部分遍历，不一定最终到达左上角，只要i或者j等于0则终止</span></span><br><span class="line">i = m;</span><br><span class="line">j = n;    </span><br><span class="line"><span class="keyword">while</span> ((i != <span class="number">0</span>)&amp;&amp;(j != <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (str1[i<span class="number">-1</span>] == str2[j<span class="number">-1</span>])</span><br><span class="line">&#123;</span><br><span class="line">str.push_back(str1[i]);</span><br><span class="line">i--;</span><br><span class="line">j--;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (dp[i][j - <span class="number">1</span>] &gt; dp[i - <span class="number">1</span>][j])</span><br><span class="line">j--;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">i--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">reverse(str.begin(),str.end());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* str1=<span class="string">"HelloWorld"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* str2 = <span class="string">"loop"</span>;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line">LCS(str1,str2,str);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str.c_str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历的过程：</p><p>str1[i-1] == str2[j-1] 成立时，向左上角遍历</p><p>不成立时，dp[i] [j - 1] &gt; dp[i - 1] [j] 成立则朝左遍历，否则朝上遍历</p><p><img src="/2019/06/29/LeetCode-动态规划/03.png" alt></p><h3 id="最长公共子串问题"><a href="#最长公共子串问题" class="headerlink" title="最长公共子串问题"></a>最长公共子串问题</h3><p>给定两个字符串A和B，长度分别为m和n，要求找出它们最长的公共子串，并返回其长度。例如：</p><p>A = “Hel<strong>lo</strong>World”</p><p>B = “<strong>lo</strong>op”</p><p>子序列和子串的区别：<strong>子序列和子串都是字符集合的子集，但是子序列不一定连续，但是子串一定是连续的</strong>。同样地，这里只给出动态规划的解法：定义<strong>dp[i] [j]</strong>表示以A中第i个字符结尾的子串和B中第j个字符结尾的子串的的最大公共子串(<strong>其中A中第i个字符和B中第J个字符指</strong>)的长度。</p><p>当我们要求<strong>dp[i] [j]</strong>，我们要先判断<strong>A的第i个元素B的第j个元素</strong>是否相同即判断<strong>A[i - 1]</strong>和 <strong>B[j -1]</strong>是否相同，如果相同它就是<strong>dp[i - 1] [j- 1] + 1</strong>，相当于在两个字符串都去掉一个字符时的<strong>最长公共子串</strong>再加 <strong>1</strong>；否则<strong>最长公共子串</strong>取0。所以整个问题的初始状态为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] [0]=0,dp[0] [j]=0</span><br></pre></td></tr></table></figure><p>相应的状态转移方程为：</p><script type="math/tex; mode=display">d p[i][j]=\left\{\begin{array}{ll}{0,} & {A[i-1] !=B[j-1]} \\ {d p[i-1][j-1]+1,} & {A[i-1]==-B[j-1]}\end{array}\right.</script><p>代码的实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">findLongest</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str1,<span class="keyword">const</span> <span class="keyword">char</span>* str2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m = (<span class="keyword">int</span>)<span class="built_in">strlen</span>(str1);</span><br><span class="line"><span class="keyword">int</span> n = (<span class="keyword">int</span>)<span class="built_in">strlen</span>(str2);</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> imax = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> jmax = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &gt; dp(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;(n+<span class="number">1</span>)); </span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= m; i++)<span class="comment">//初始状态</span></span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (str1[i - <span class="number">1</span>] == str2[j - <span class="number">1</span>]) &#123;<span class="comment">//判断A的第i个字符和B的第j个字符是否相同</span></span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (dp[i][j] &gt; result)<span class="comment">//当前dp[i][j]大于result，则更新公共子串最大长度，及其对应坐标</span></span><br><span class="line">&#123;</span><br><span class="line">result = dp[i][j];</span><br><span class="line">imax = i;</span><br><span class="line">jmax = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">dp[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (result != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">str.push_back(str1[imax<span class="number">-1</span>]);</span><br><span class="line">imax--;</span><br><span class="line">jmax--;</span><br><span class="line">result--;</span><br><span class="line">&#125;</span><br><span class="line">reverse(str.begin(), str.end());</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* str1=<span class="string">"HelloWorld"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* str2 = <span class="string">"loop"</span>;</span><br><span class="line"><span class="built_in">string</span> resultStr = findLongest(str1,str2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; resultStr.c_str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历的过程：</p><p>从dp最大的位置沿着左上角遍历result个字符</p><p><img src="/2019/06/29/LeetCode-动态规划/04.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;最长公共子序列问题-LCS问题&quot;&gt;&lt;a href=&quot;#最长公共子序列问题-LCS问题&quot; class=&quot;headerlink&quot; title=&quot;最长公共子序列问题(LCS问题)&quot;&gt;&lt;/a&gt;最长公共子序列问题(LCS问题)&lt;/h3&gt;&lt;p&gt;给定两个字符串A和B，长度分别为
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yuemingyang7010.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法刷题" scheme="http://yuemingyang7010.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="动态规划刷题" scheme="http://yuemingyang7010.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>贪心</title>
    <link href="http://yuemingyang7010.github.io/2019/06/24/LeetCode-%E8%B4%AA%E5%BF%83/"/>
    <id>http://yuemingyang7010.github.io/2019/06/24/LeetCode-贪心/</id>
    <published>2019-06-24T05:52:09.000Z</published>
    <updated>2019-11-01T00:54:19.386Z</updated>
    
    <content type="html"><![CDATA[<h2 id="总结目录"><a href="#总结目录" class="headerlink" title="总结目录"></a>总结目录</h2><div class="table-container"><table><thead><tr><th>题目</th><th>难度</th><th>收获与总结</th></tr></thead><tbody><tr><td>1.分饼干</td><td>易</td><td>首先<strong>对需求数组g[]和饼干大小数组s[]排序</strong>，然后循环遍历，知道其中某一个数组遍历完，循环结束。两个数组都从首元素开始遍历过程中，<strong>每次cookie加1，若能够满足其中一个孩子则child加1</strong>，遍历完成后，返回child值。</td></tr><tr><td>2.摇摆数列</td><td>中</td><td>画<strong>数字升降规律图</strong>和用<strong>状态机</strong>的方法，眼前一亮，方法值得学习借鉴。</td></tr><tr><td>3.移除K位数字</td><td>中</td><td>思路：从最高位向最低位遍历，<strong>当对应的数字比下一位数字大，并且在没有剔除完K位数时，则应该剔除该位数</strong>，这样才能保证最后的数最小，编程时可以借用<strong>栈</strong>来实现。此外还要考虑数的开头不能为0的情况，以及遍历完字符串后，仍然没有删除完K位数的情况。</td></tr><tr><td>4.用最少的弓箭击爆气球</td><td>中</td><td>将<strong>所有气球区间的左端点从小到大排序</strong>，首先以第一个气球所在区间作为射击区间，遍历第二个气球的时候<strong>更新该区间</strong>，依次不断更新，当遍历到第i个气球时，气球区间左端点大于射击区间右端点，此时设定第二个射击区间，以此类推。</td></tr></tbody></table></div><h2 id="Assign-Cookies-易"><a href="#Assign-Cookies-易" class="headerlink" title="Assign Cookies(易)"></a>Assign Cookies(易)</h2><ol><li>Assign Cookies</li></ol><p><strong>分发饼干</strong></p><p><img src="/2019/06/24/LeetCode-贪心/01.png" alt></p><p>Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj &gt;= gi, we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.</p><p><strong>Note:</strong></p><p>You may assume the greed factor is always positive. </p><p>You cannot assign more than one cookie to one child.</p><p><strong>Example 1:</strong></p><p><strong>Input:</strong> [1,2,3], [1,1]  </p><p><strong>Output:</strong> 1  </p><p><strong>Explanation:</strong> You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3.  And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content. You need to output 1. </p><p><strong>Example 2:</strong></p><p><strong>Input:</strong> [1,2], [1,2,3]  </p><p><strong>Output:</strong> 2  </p><p><strong>Explanation:</strong> You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2.  You have 3 cookies and their sizes are big enough to gratify all of the children,  You need to output 2.</p><p><img src="/2019/06/24/LeetCode-贪心/02.png" alt></p><p><img src="/2019/06/24/LeetCode-贪心/03.png" alt></p><p><img src="/2019/06/24/LeetCode-贪心/04.png" alt></p><p><img src="/2019/06/24/LeetCode-贪心/05.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; g, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::sort(g.begin(),g.end());</span><br><span class="line">        <span class="built_in">std</span>::sort(s.begin(),s.end());</span><br><span class="line">        <span class="keyword">int</span> child = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cookie = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(child &lt; g.size() &amp;&amp; cookie &lt; s.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(g[child]&lt;=s[cookie])&#123;</span><br><span class="line">                child++;</span><br><span class="line">            &#125;</span><br><span class="line">            cookie++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> child;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Wiggle-Subsequence-中"><a href="#Wiggle-Subsequence-中" class="headerlink" title="Wiggle Subsequence(中)"></a>Wiggle Subsequence(中)</h2><p>摇摆序列</p><ol><li>Wiggle Subsequence</li></ol><p><img src="/2019/06/24/LeetCode-贪心/06.png" alt></p><p>A sequence of numbers is called a <strong>wiggle sequence</strong> if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence.</p><p>For example, <strong>[1,7,4,9,2,5]</strong> is a wiggle sequence because the differences (6,-3,5,-7,3) are alternately positive and negative. In contrast, [1,4,7,2,5] and [1,7,4,5,5] are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero.</p><p>Given a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order.</p><p><strong>Example 1:</strong></p><p><strong>Input:</strong> [1,7,4,9,2,5] </p><p><strong>Output:</strong> 6</p><p> <strong>Explanation:</strong> The entire sequence is a wiggle sequence.</p><p><strong>Example 2:</strong></p><p><strong>Input:</strong> [1,17,5,10,13,15,10,5,16,8] </p><p><strong>Output:</strong> 7 </p><p><strong>Explanation:</strong> There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].</p><p><strong>Example 3:</strong></p><p><strong>Input:</strong> [1,2,3,4,5,6,7,8,9] </p><p><strong>Output:</strong> 2</p><p><strong>Follow up:</strong></p><p>Can you do it in O(<em>n</em>) time?</p><p><img src="/2019/06/24/LeetCode-贪心/07.png" alt></p><p><img src="/2019/06/24/LeetCode-贪心/08.png" alt></p><p><img src="/2019/06/24/LeetCode-贪心/09.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums.size();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> BEGIN = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> UP = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> DOWN = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> STATE = BEGIN;</span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">switch</span>(STATE)&#123;</span><br><span class="line">                <span class="keyword">case</span> BEGIN:</span><br><span class="line">                    <span class="keyword">if</span>(nums[i]&gt;nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                        STATE = UP;</span><br><span class="line">                        maxLength++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(nums[i]&lt;nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                        STATE = DOWN;</span><br><span class="line">                        maxLength++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> UP:</span><br><span class="line">                    <span class="keyword">if</span>(nums[i]&lt;nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                        STATE = DOWN;</span><br><span class="line">                        maxLength++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> DOWN:</span><br><span class="line">                    <span class="keyword">if</span>(nums[i]&gt;nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                        STATE = UP;</span><br><span class="line">                        maxLength++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Remove-K-Digits-中"><a href="#Remove-K-Digits-中" class="headerlink" title="Remove K Digits(中)"></a>Remove K Digits(中)</h2><p>移掉K位数字</p><ol><li>Remove K Digits</li></ol><p>!<img src="/2019/06/24/LeetCode-贪心/10.png" alt></p><p>Given a non-negative integer <em>num</em> represented as a string, remove <em>k</em> digits from the number so that the new number is the smallest possible.</p><p><strong>Note:</strong></p><ul><li>The length of <em>num</em> is less than 10002 and will be ≥ <em>k</em>.</li><li>The given <em>num</em> does not contain any leading zero.</li></ul><p><strong>Example 1:</strong></p><p>Input: num = “1432219”, k = 3 </p><p>Output: “1219” </p><p>Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest. </p><p><strong>Example 2:</strong></p><p>Input: num = “10200”, k = 1 </p><p>Output: “200” </p><p>Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes. </p><p><strong>Example 3:</strong></p><p>Input: num = “10”, k = 2 </p><p>Output: “0” </p><p>Explanation: Remove all the digits from the number and it is left with nothing which is 0.</p><p><img src="/2019/06/24/LeetCode-贪心/11.png" alt></p><p><img src="/2019/06/24/LeetCode-贪心/12.png" alt></p><p><img src="/2019/06/24/LeetCode-贪心/13.png" alt></p><p><img src="/2019/06/24/LeetCode-贪心/14.png" alt></p><p><img src="/2019/06/24/LeetCode-贪心/15.png" alt></p><p><img src="/2019/06/24/LeetCode-贪心/16.png" alt></p><p>自己实现的代码比上述截图稍微简洁点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeKdigits</span><span class="params">(<span class="built_in">string</span> num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; mStack;</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num.length();i++)&#123;    </span><br><span class="line">            <span class="comment">//当栈不空，且要压入的数字比栈顶数字小，且仍然可以删除数字的时候，while循环继续</span></span><br><span class="line">            <span class="keyword">while</span>((!mStack.empty()) &amp;&amp; num[i] &lt; mStack.top() &amp;&amp;  k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                mStack.pop();</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num[i] != <span class="string">'0'</span> || (!mStack.empty()))&#123; <span class="comment">//防止出现数字字符串以0开头</span></span><br><span class="line">               mStack.push(num[i]); </span><br><span class="line">            &#125;                     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//解决当字符串从头遍历到尾，k仍然大于0，如nums= "12345" k=3时，此时弹出末尾比较大的数</span></span><br><span class="line">        <span class="keyword">while</span>((!mStack.empty()) &amp;&amp; k&gt;<span class="number">0</span>)&#123; <span class="comment">//如果栈不空，且仍然可以删除数字</span></span><br><span class="line">            mStack.pop();</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!mStack.empty())&#123;   <span class="comment">//将栈中的每一个char型字符连接为字符串</span></span><br><span class="line">            ans = mStack.top() + ans;</span><br><span class="line">            mStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans == <span class="string">""</span>)&#123;   <span class="comment">//根据题目要求，当ans为空字符串时候，返回“0”</span></span><br><span class="line">            ans = <span class="string">"0"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">LeetCode优秀解答，没有用到额外的数据结构，但是纯用数组比较绕！！！</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeKdigits</span><span class="params">(<span class="built_in">string</span> num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num.size()&lt;=k)<span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">int</span> top=<span class="number">0</span>,count=<span class="number">0</span>,n=num.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span> (top&gt;<span class="number">0</span>&amp;&amp;count&lt;k&amp;&amp;num[top<span class="number">-1</span>]&gt;num[i])&#123;</span><br><span class="line">                top--;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            num[top++]=num[i];</span><br><span class="line">        &#125;</span><br><span class="line">        top=min(top,n-k);</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;i&lt;top;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (num[i]!=<span class="string">'0'</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i==top)<span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        <span class="built_in">string</span> res=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (;i&lt;top;i++)</span><br><span class="line">            res+=num[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Minimum-Number"><a href="#Minimum-Number" class="headerlink" title="Minimum Number"></a>Minimum Number</h2><ol><li>Minimum Number of Arrows to Burst Balloons</li></ol><p><img src="/2019/06/24/LeetCode-贪心/17.png" alt></p><p>There are a number of spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it’s horizontal, y-coordinates don’t matter and hence the x-coordinates of start and end of the diameter suffice. Start is always smaller than end. There will be at most 104 balloons.</p><p>An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with xstart and xend bursts by an arrow shot at x if xstart ≤ x ≤ xend. There is no limit to the number of arrows that can be shot. An arrow once shot keeps travelling up infinitely. The problem is to find the minimum number of arrows that must be shot to burst all balloons.</p><p><strong>Example:</strong></p><p><strong>Input:</strong> [[10,16], [2,8], [1,6], [7,12]]  </p><p><strong>Output:</strong> 2  </p><p><strong>Explanation:</strong> One way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x = 11 (bursting the other two balloons). </p><p><img src="/2019/06/24/LeetCode-贪心/18.png" alt></p><p><img src="/2019/06/24/LeetCode-贪心/19.png" alt></p><p><img src="/2019/06/24/LeetCode-贪心/20.png" alt></p><p><img src="/2019/06/24/LeetCode-贪心/21.png" alt></p><p><img src="/2019/06/24/LeetCode-贪心/22.png" alt></p><p><img src="/2019/06/24/LeetCode-贪心/23.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; a,<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(points.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::sort(points.begin(),points.end(),comp);</span><br><span class="line">        <span class="keyword">int</span> arrowNum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> begin = points[<span class="number">0</span>].first;</span><br><span class="line">        <span class="keyword">int</span> end = points[<span class="number">0</span>].second;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;points.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(points[i].first &lt;= end)&#123;</span><br><span class="line">                begin = points[i].first;</span><br><span class="line">                <span class="keyword">if</span>(points[i].second &lt; end)&#123;</span><br><span class="line">                    end = points[i].second;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                arrowNum++;</span><br><span class="line">                begin = points[i].first;</span><br><span class="line">                end = points[i].second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arrowNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;总结目录&quot;&gt;&lt;a href=&quot;#总结目录&quot; class=&quot;headerlink&quot; title=&quot;总结目录&quot;&gt;&lt;/a&gt;总结目录&lt;/h2&gt;&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;题目&lt;/th&gt;
&lt;t
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yuemingyang7010.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法刷题" scheme="http://yuemingyang7010.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="贪心刷题" scheme="http://yuemingyang7010.github.io/tags/%E8%B4%AA%E5%BF%83%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>栈与队列</title>
    <link href="http://yuemingyang7010.github.io/2019/06/23/LeetCode-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    <id>http://yuemingyang7010.github.io/2019/06/23/LeetCode-栈与队列/</id>
    <published>2019-06-23T05:52:09.000Z</published>
    <updated>2019-11-01T00:57:15.344Z</updated>
    
    <content type="html"><![CDATA[<h2 id="总结目录"><a href="#总结目录" class="headerlink" title="总结目录"></a>总结目录</h2><div class="table-container"><table><thead><tr><th>题目</th><th>难度</th><th>收获与总结</th></tr></thead><tbody><tr><td>1.用队列实现栈</td><td>易</td><td>只是push()函数需要修改，每次添加一个数的时候，把队列中原有的数按顺序出队列再进队列。</td></tr><tr><td>2.用栈实现队列</td><td>易</td><td>只有push()函数需要改，<strong>用一个临时栈</strong>，每次添加一个数的时候，将数据栈中数按照顺序放临时栈中，将要push()的数加入数据栈中后，再将临时栈中的数据按照顺序放回数据栈。</td></tr><tr><td>3.实现含有getMin()函数的栈</td><td>易</td><td>需要改push()和pop()函数，使用两个栈，一个正常放数据，一个记录每个push()和pop()操作对应栈中最小的数。</td></tr><tr><td>4.找出数组中第K大的数</td><td>易</td><td>利用STL中priority_queue(PriorityQueue队列,是基于最小堆原理实现),也可以用STL中的sort()函数先排序。</td></tr></tbody></table></div><h2 id="Implement-实现-Stack-using-Queues-易"><a href="#Implement-实现-Stack-using-Queues-易" class="headerlink" title="Implement(实现) Stack using Queues(易)"></a>Implement(实现) Stack using Queues(易)</h2><ol><li>Implement Stack using Queues</li></ol><p>Implement the following operations of a stack using queues.</p><ul><li>push(x) — Push element x onto stack.</li><li>pop() — Removes the element on top of the stack.</li><li>top() — Get the top element.</li><li>empty() — Return whether the stack is empty.</li></ul><p><strong>Example:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyStack <span class="built_in">stack</span> = <span class="keyword">new</span> MyStack();</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>.push(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">stack</span>.push(<span class="number">2</span>);  </span><br><span class="line"><span class="built_in">stack</span>.top();   <span class="comment">// returns 2</span></span><br><span class="line"><span class="built_in">stack</span>.pop();   <span class="comment">// returns 2</span></span><br><span class="line"><span class="built_in">stack</span>.empty(); <span class="comment">// returns false</span></span><br></pre></td></tr></table></figure><p><strong>Notes:</strong></p><ul><li>You must use <em>only</em> standard operations of a queue — which means only push to back, peek/pop from front, size, and is empty operations are valid.</li><li>Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.</li><li>You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyStack() &#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        mQueue.push(x);</span><br><span class="line">        <span class="keyword">if</span>(mQueue.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;mQueue.size() <span class="number">-1</span> ;i++)&#123;</span><br><span class="line">                mQueue.push(mQueue.front());</span><br><span class="line">                mQueue.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = mQueue.front();</span><br><span class="line">        mQueue.pop();</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mQueue.front();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mQueue.empty();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; mQueue;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="Implement-Queue-using-Stacks-易"><a href="#Implement-Queue-using-Stacks-易" class="headerlink" title="Implement Queue using Stacks(易)"></a>Implement Queue using Stacks(易)</h2><p>\232. Implement Queue using Stacks</p><p>Implement the following operations of a queue using stacks.</p><ul><li>push(x) — Push element x to the back of queue.</li><li>pop() — Removes the element from in front of queue.</li><li>peek() — Get the front element.</li><li>empty() — Return whether the queue is empty.</li></ul><p><strong>Example:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyQueue <span class="built_in">queue</span> = <span class="keyword">new</span> MyQueue();</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>.push(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">queue</span>.push(<span class="number">2</span>);  </span><br><span class="line"><span class="built_in">queue</span>.peek();  <span class="comment">// returns 1</span></span><br><span class="line"><span class="built_in">queue</span>.pop();   <span class="comment">// returns 1</span></span><br><span class="line"><span class="built_in">queue</span>.empty(); <span class="comment">// returns false</span></span><br></pre></td></tr></table></figure><p><strong>Notes:</strong></p><ul><li>You must use <em>only</em> standard operations of a stack — which means only push to top, peek/pop from top, size, and is emptyoperations are valid.</li><li>Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.</li><li>You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).</li></ul><p>class MyQueue {<br>public:<br>    /<em>* Initialize your data structure here. </em>/<br>    MyQueue() {</p><pre><code>}/** Push element x to the back of queue. */void push(int x) {    std::stacktempStack;    while(!mStack.empty()){        tempStack.push(mStack.top());        mStack.pop();    }    mStack.push(x);    while(!tempStack.empty()){        mStack.push(tempStack.top());        tempStack.pop();    }}/** Removes the element from in front of queue and returns that element. */int pop() {    int a = mStack.top();    mStack.pop();    return a;}/** Get the front element. */int peek() {    return mStack.top();}/** Returns whether the queue is empty. */bool empty() {    return mStack.empty();}</code></pre><p>private:<br>    stackmStack;<br>    stacktempStack;<br>};</p><p>/**</p><ul><li>Your MyQueue object will be instantiated and called as such:</li><li>MyQueue obj = new MyQueue();</li><li>obj.push(x);</li><li>int param_2 = obj.pop();</li><li>int param_3 = obj.peek();</li><li>bool param_4 = obj.empty();<br>*/</li></ul><p><img src="/2019/06/23/LeetCode-栈与队列/01.png" alt></p><p><img src="/2019/06/23/LeetCode-栈与队列/02.png" alt></p><p><img src="/2019/06/23/LeetCode-栈与队列/03.png" alt></p><p><img src="/2019/06/23/LeetCode-栈与队列/04.png" alt></p><h2 id="Min-Stack-易"><a href="#Min-Stack-易" class="headerlink" title="Min Stack(易)"></a>Min Stack(易)</h2><p><img src="/2019/06/23/LeetCode-栈与队列/05.png" alt></p><p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p><ul><li>push(x) — Push element x onto stack.</li><li>pop() — Removes the element on top of the stack.</li><li>top() — Get the top element.</li><li>getMin() — Retrieve the minimum element in the stack.</li></ul><p><strong>Example:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MinStack minStack = <span class="keyword">new</span> MinStack();</span><br><span class="line">minStack.push(<span class="number">-2</span>);</span><br><span class="line">minStack.push(<span class="number">0</span>);</span><br><span class="line">minStack.push(<span class="number">-3</span>);</span><br><span class="line">minStack.getMin();   --&gt; Returns <span class="number">-3.</span></span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; Returns <span class="number">0.</span></span><br><span class="line">minStack.getMin();   --&gt; Returns <span class="number">-2.</span></span><br></pre></td></tr></table></figure><p><strong>题目思路：用两个栈，一个正常地存储数据，另一个存储每一步的最小值。</strong></p><p><img src="/2019/06/23/LeetCode-栈与队列/06.png" alt></p><p><img src="/2019/06/23/LeetCode-栈与队列/07.png" alt></p><p><img src="/2019/06/23/LeetCode-栈与队列/08.png" alt></p><p><img src="/2019/06/23/LeetCode-栈与队列/10.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MinStack() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        mStack.push(x);</span><br><span class="line">        <span class="keyword">if</span>(minStack.empty())&#123;</span><br><span class="line">            minStack.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(x &lt; minStack.top())&#123;</span><br><span class="line">                minStack.push(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                minStack.push(minStack.top());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mStack.pop();</span><br><span class="line">        minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mStack.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.top();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; mStack;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; minStack;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="Kth-Largest-Element-in-an-Array（易）"><a href="#Kth-Largest-Element-in-an-Array（易）" class="headerlink" title="Kth Largest Element in an Array（易）"></a>Kth Largest Element in an Array（易）</h2><p>Find the <strong>k</strong>th largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p><p><strong>Example 1:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>] <span class="keyword">and</span> k = <span class="number">2</span></span><br><span class="line">Output: <span class="number">5</span></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>] <span class="keyword">and</span> k = <span class="number">4</span></span><br><span class="line">Output: <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>Note:</strong> </p><p>You may assume k is always valid, 1 ≤ k ≤ array’s length.</p><p><strong>思路：直接用STL中的priority_queue（</strong>PriorityQueue队列,是基于最小堆原理实现<strong>）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>&gt;pQueue;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.size();i++)&#123;</span><br><span class="line">            pQueue.push(nums.at(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k - <span class="number">1</span>;i++)&#123;</span><br><span class="line">            pQueue.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pQueue.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;总结目录&quot;&gt;&lt;a href=&quot;#总结目录&quot; class=&quot;headerlink&quot; title=&quot;总结目录&quot;&gt;&lt;/a&gt;总结目录&lt;/h2&gt;&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;题目&lt;/th&gt;
&lt;t
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yuemingyang7010.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法刷题" scheme="http://yuemingyang7010.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="栈与队列刷题" scheme="http://yuemingyang7010.github.io/tags/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="http://yuemingyang7010.github.io/2019/06/22/LeetCode-%E9%93%BE%E8%A1%A8/"/>
    <id>http://yuemingyang7010.github.io/2019/06/22/LeetCode-链表/</id>
    <published>2019-06-22T05:52:09.000Z</published>
    <updated>2019-10-31T04:30:12.744Z</updated>
    
    <content type="html"><![CDATA[<h2 id="总结目录"><a href="#总结目录" class="headerlink" title="总结目录"></a>总结目录</h2><div class="table-container"><table><thead><tr><th>题目</th><th>难度</th><th>收获与分析</th></tr></thead><tbody><tr><td>1.两数相加(链表表示的)</td><td>中</td><td></td></tr><tr><td>2.链表逆序</td><td>易</td><td>采用头插法，通常申请一个ListNode*新的头指针。</td></tr><tr><td>3.链表逆序II</td><td>中</td><td>类似2，只是需要头尾的连接，保存好需要逆序的序列前驱元素指针和后面元素的首节点指针。</td></tr><tr><td>4.相交链表</td><td>易</td><td>方法1：用set,简单，但是需要开辟额外的空间，空间复杂度O(n);方法2：先统计两个链表的长度，然后再遍历。</td></tr><tr><td>5.判断链表是否存在环</td><td>易</td><td>方法1：用set,很好，但是用了额外空间；方法2：用快慢指针法。</td></tr><tr><td>6.返回链表环的起始节点</td><td>中</td><td>类似5，也有两种方法，重点记住，相遇节点和头结点同样速度朝前遍历，相遇的地方，即为环的起始节点。</td></tr><tr><td>7.划分链表</td><td>中</td><td>采用尾插法，额外申请两个ListNode<em>的节点，以及用于遍历的ListNode</em>指针，将节点val小于X的放在一个链表中，另一部分放…</td></tr><tr><td>8.合并两个有序链表</td><td>易</td><td>同7，采用尾插法，额外申请1个ListNode<em>的节点，以及用于遍历的ListNode</em>指针…</td></tr></tbody></table></div><h2 id="Add-Two-Numbers-中"><a href="#Add-Two-Numbers-中" class="headerlink" title="Add Two Numbers(中)"></a>Add Two Numbers(中)</h2><p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits（数字） are stored（存储） in <strong>reverse order</strong> （逆序）and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p><strong>Example:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: (<span class="number">2</span> -&gt; <span class="number">4</span> -&gt; <span class="number">3</span>) + (<span class="number">5</span> -&gt; <span class="number">6</span> -&gt; <span class="number">4</span>)</span><br><span class="line">Output: <span class="number">7</span> -&gt; <span class="number">0</span> -&gt; <span class="number">8</span></span><br><span class="line">Explanation: <span class="number">342</span> + <span class="number">465</span> = <span class="number">807.</span></span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">-1</span>)</span></span>;   <span class="comment">//头结点，（自己代码缺少头结点，导致后面不好操作）</span></span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        ListNode *prev = &amp;dummy;</span><br><span class="line">        <span class="keyword">for</span> (ListNode *pa = l1, *pb = l2;pa != <span class="literal">nullptr</span> || pb != <span class="literal">nullptr</span>;</span><br><span class="line">        pa = pa == <span class="literal">nullptr</span> ? <span class="literal">nullptr</span> : pa-&gt;next,</span><br><span class="line">        pb = pb == <span class="literal">nullptr</span> ? <span class="literal">nullptr</span> : pb-&gt;next,</span><br><span class="line">        prev = prev-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> ai = pa == <span class="literal">nullptr</span> ? <span class="number">0</span> : pa-&gt;val;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> bi = pb == <span class="literal">nullptr</span> ? <span class="number">0</span> : pb-&gt;val;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> value = (ai + bi + carry) % <span class="number">10</span>;</span><br><span class="line">            carry = (ai + bi + carry) / <span class="number">10</span>;</span><br><span class="line">            prev-&gt;next = <span class="keyword">new</span> ListNode(value);    <span class="comment">//尾插法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry &gt; <span class="number">0</span>)     <span class="comment">//判断最后是否有进位，如果有，多开一个节点</span></span><br><span class="line">            prev-&gt;next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<em>O</em>(max(<em>m</em>,<em>n</em>))，假设 <em>m</em> 和 <em>n</em> 分别表示 <em>l</em>1 和 <em>l</em>2 的长度，上面的算法最多重复 max(<em>m</em>,<em>n</em>)次。</li><li>空间复杂度：<em>O</em>(max(<em>m</em>,<em>n</em>))， 新列表的长度最多为 max(<em>m</em>,<em>n</em>)+1。</li></ul><h2 id="Reverse-Linked-List（易）"><a href="#Reverse-Linked-List（易）" class="headerlink" title="Reverse Linked List（易）"></a>Reverse Linked List（易）</h2><p>反转一个单链表。</p><p>示例:</p><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL<br>进阶:<br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p><p>思路分析：</p><p><img src="/2019/06/22/LeetCode-链表/01.png" alt></p><p><img src="/2019/06/22/LeetCode-链表/02.png" alt></p><p><img src="/2019/06/22/LeetCode-链表/03.png" alt></p><p><img src="/2019/06/22/LeetCode-链表/04.png" alt></p><p>迭代版本：**</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* pre = <span class="literal">NULL</span>; <span class="comment">//反转后的链表头，相对于旧的链表头为pre  </span></span><br><span class="line">        ListNode* cur = head; <span class="comment">//旧的链表头，为当前节点</span></span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            ListNode* tempNext = cur-&gt;next; <span class="comment">//临时存储旧链表头的下一个节点</span></span><br><span class="line">            cur-&gt;next = pre; <span class="comment">//旧链表头指向新链表头</span></span><br><span class="line">            pre = cur;  <span class="comment">//新链表头指针pre朝前移动一位</span></span><br><span class="line">            cur = tempNext; <span class="comment">//旧链表头更新为旧链表头的下一位                 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>递归版本：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* p = reverseList(head-&gt;next); <span class="comment">//从第二个节点开始反转</span></span><br><span class="line">        head-&gt;next-&gt;next = head;      <span class="comment">//上一步第二个节点反转完了应该处在链表尾，这个时候他的下一个节点接上head节点</span></span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;   <span class="comment">//head-&gt;next信息清掉</span></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2.在剑指offer上给出的是在不改变链表的结构情况下，逆序打印链表，分用栈和递归两种方式实现</p><p>(1)用栈来实现链表的逆序打印</p><p>(2)用递归实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 面试题6：从尾到头打印链表</span></span><br><span class="line"><span class="comment">// 题目：输入一个链表的头结点，从尾到头反过来打印出每个结点的值。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"..\Utilities\List.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintListReversingly_Iteratively</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;ListNode*&gt; nodes;</span><br><span class="line"></span><br><span class="line">    ListNode* pNode = pHead;</span><br><span class="line">    <span class="keyword">while</span>(pNode != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nodes.push(pNode);</span><br><span class="line">        pNode = pNode-&gt;m_pNext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!nodes.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        pNode = nodes.top();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, pNode-&gt;m_nValue);</span><br><span class="line">        nodes.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintListReversingly_Recursively</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pHead != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead-&gt;m_pNext != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            PrintListReversingly_Recursively(pHead-&gt;m_pNext);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, pHead-&gt;m_nValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Reverse-Linked-List-II（中）"><a href="#Reverse-Linked-List-II（中）" class="headerlink" title="Reverse Linked List II（中）"></a>Reverse Linked List II（中）</h2><p><strong>链表逆序II</strong></p><p>\92. Reverse Linked List II</p><p>Reverse a linked list from position <em>m</em> to <em>n</em>. Do it in one-pass.</p><p><strong>Note:</strong> 1 ≤ <em>m</em> ≤ <em>n</em> ≤ length of list.</p><p><strong>Example:</strong></p><p><strong>Input:</strong> 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, <em>m</em> = 2, <em>n</em> = 4 </p><p><strong>Output:</strong> 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</p><p><img src="/2019/06/22/LeetCode-链表/05.png" alt></p><p><img src="/2019/06/22/LeetCode-链表/06.png" alt></p><p><img src="/2019/06/22/LeetCode-链表/07.png" alt></p><p><img src="/2019/06/22/LeetCode-链表/07.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> reverseLength = n - m + <span class="number">1</span>;</span><br><span class="line">        ListNode* pre_head = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* modify_list_tail = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* new_head = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* ans_head = head;       </span><br><span class="line">        <span class="keyword">while</span>(head &amp;&amp; --m)&#123;</span><br><span class="line">            pre_head = head;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        modify_list_tail = head;</span><br><span class="line">        <span class="keyword">while</span>(head &amp;&amp; reverseLength--)&#123;</span><br><span class="line">            ListNode* next = head-&gt;next;</span><br><span class="line">            head-&gt;next = new_head;</span><br><span class="line">            new_head = head;</span><br><span class="line">            head = next;            </span><br><span class="line">        &#125;</span><br><span class="line">        modify_list_tail-&gt;next = head;</span><br><span class="line">        <span class="keyword">if</span>(pre_head)&#123;    <span class="comment">//pre_head为真代表m&gt;1</span></span><br><span class="line">            pre_head-&gt;next = new_head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ans_head = new_head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans_head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Intersection-交点-of-Two-Linked"><a href="#Intersection-交点-of-Two-Linked" class="headerlink" title="Intersection(交点) of Two Linked"></a>Intersection(交点) of Two Linked</h2><p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener"><strong>相交链表</strong></a></p><ol><li>Intersection(交点) of Two Linked Lists</li></ol><p><img src="/2019/06/22/LeetCode-链表/16.png" alt></p><p>Write a program to find the node at which the intersection of two singly linked lists begins.</p><p>For example, the following two linked lists:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A:          a1 → a2</span><br><span class="line">                   ↘</span><br><span class="line">                     c1 → c2 → c3</span><br><span class="line">                   ↗            </span><br><span class="line">B:     b1 → b2 → b3</span><br></pre></td></tr></table></figure><p>begin to intersect at node c1.</p><p><strong>Notes:</strong></p><ul><li>If the two linked lists have no intersection at all, return null.</li><li>The linked lists must retain(保持) their original structure after the function returns.</li><li>You may assume（假定） there are no cycles anywhere in the entire linked structure.</li><li>Your code should preferably run in O(n) time and use only O(1) memory.</li></ul><p><img src="/2019/06/22/LeetCode-链表/09.png" alt></p><p><img src="/2019/06/22/LeetCode-链表/10.png" alt></p><p><img src="/2019/06/22/LeetCode-链表/11.png" alt></p><p><img src="/2019/06/22/LeetCode-链表/12.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//用来计算链表的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listLength</span><span class="params">(ListNode *head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(head)&#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用来返回两个已知长度的链表的相交点的指针</span></span><br><span class="line"><span class="function">ListNode *<span class="title">findIntersection</span><span class="params">(ListNode *headL, ListNode *headS,<span class="keyword">int</span> lengthL,<span class="keyword">int</span> lengthS)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lengthDelt = <span class="number">0</span>;</span><br><span class="line">    lengthDelt = lengthL-lengthS;</span><br><span class="line">    <span class="keyword">while</span>(headL &amp;&amp; lengthDelt--)&#123;</span><br><span class="line">        headL = headL-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(headS)&#123;</span><br><span class="line">        <span class="keyword">if</span>(headL == headS)&#123;</span><br><span class="line">            <span class="keyword">return</span> headL;</span><br><span class="line">        &#125;</span><br><span class="line">        headL = headL-&gt;next;</span><br><span class="line">        headS = headS-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lengthA,lengthB;</span><br><span class="line">        lengthA = listLength(headA);</span><br><span class="line">        lengthB = listLength(headB);</span><br><span class="line">        ListNode *ans;</span><br><span class="line">        <span class="keyword">if</span>(lengthA &gt; lengthB)&#123;</span><br><span class="line">            ans = findIntersection(headA, headB,lengthA,lengthB);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ans = findIntersection(headB, headA,lengthB,lengthA);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/2019/06/22/LeetCode-链表/13.png" alt></p><p><img src="/2019/06/22/LeetCode-链表/14.png" alt></p><p><img src="/2019/06/22/LeetCode-链表/15.png" alt></p><h2 id="Linked-List-Cycle-易"><a href="#Linked-List-Cycle-易" class="headerlink" title="Linked List Cycle(易)"></a>Linked List Cycle(易)</h2><p>\141. Linked List Cycle</p><p>Given a linked list, determine if it has a cycle in it.</p><p>Follow up:</p><p><strong>Can you solve it without using extra space?</strong></p><p><strong>自己做法，用STL中的set,用了额外的空间。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">set</span>&lt;ListNode*&gt;node_set;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            num++;</span><br><span class="line">            node_set.insert(head);</span><br><span class="line">            <span class="keyword">if</span>(node_set.size() != num)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head-&gt;next;          </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>快慢指针的实现方法如下（思想讲解可参考6中）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  Node *slow = head, *fast = head;</span><br><span class="line">  <span class="keyword">while</span> (slow &amp;&amp; fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">    slow = slow-&gt;next;</span><br><span class="line">    fast = fast-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (slow == fast)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Linked-List-Cycle-II（中）"><a href="#Linked-List-Cycle-II（中）" class="headerlink" title="Linked List Cycle II（中）"></a>Linked List Cycle II（中）</h2><p><img src="/2019/06/22/LeetCode-链表/17.png" alt></p><p>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</p><p><strong>Note:</strong> Do not modify the linked list.</p><p><strong>Follow up</strong>:</p><p><strong>Can you solve it without using extra space?</strong></p><p><strong>自己做法，用STL中的set,用了额外的空间，和5几乎一样。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">set</span>&lt;ListNode*&gt;node_set;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            num++;</span><br><span class="line">            node_set.insert(head);</span><br><span class="line">            <span class="keyword">if</span>(node_set.size() != num)&#123;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head-&gt;next;          </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>经典方法：快慢指针法</strong></p><p><img src="/2019/06/22/LeetCode-链表/18.png" alt></p><p><img src="/2019/06/22/LeetCode-链表/19.png" alt></p><p><img src="/2019/06/22/LeetCode-链表/20.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* low = head;</span><br><span class="line">        ListNode* meet = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//先求出相遇点的位置</span></span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; low &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            low = low-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast == low)&#123;</span><br><span class="line">                meet = fast;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再求出环的交点的位置</span></span><br><span class="line">        <span class="keyword">while</span>(head &amp;&amp; meet)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head == meet)&#123;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            meet = meet-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Partition-（划分）List-中"><a href="#Partition-（划分）List-中" class="headerlink" title="Partition （划分）List(中)"></a>Partition （划分）List(中)</h2><p><img src="/2019/06/22/LeetCode-链表/21.png" alt></p><p>Given a linked list and a value <em>x</em>, partition it such that all nodes less than <em>x</em> come before nodes greater than or equal to <em>x</em>.</p><p>You should preserve the original relative order of the nodes in each of the two partitions.</p><p><strong>Example:</strong></p><p><strong>Input:</strong> head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, <em>x</em> = 3 </p><p><strong>Output:</strong> 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode  <span class="title">lessHead</span><span class="params">(<span class="number">0</span>)</span></span>;       <span class="comment">//设置两个临时节点</span></span><br><span class="line">        <span class="function">ListNode  <span class="title">moreHead</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        ListNode* pLess = &amp;lessHead; <span class="comment">//设置两个指针用于对两个链表的尾插</span></span><br><span class="line">        ListNode* pMore = &amp;moreHead;</span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;val &lt; x)&#123;</span><br><span class="line">                pLess-&gt;next = head;</span><br><span class="line">                pLess = pLess-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                pMore-&gt;next = head;</span><br><span class="line">                pMore = pMore-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pLess-&gt;next = moreHead.next;</span><br><span class="line">        pMore-&gt;next = <span class="literal">NULL</span>;         <span class="comment">//此句要加，不然跑不过，纳闷中...</span></span><br><span class="line">        <span class="keyword">return</span> lessHead.next; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/2019/06/22/LeetCode-链表/22.png" alt></p><p><img src="/2019/06/22/LeetCode-链表/23.png" alt></p><p><img src="/2019/06/22/LeetCode-链表/24.png" alt></p><p><img src="/2019/06/22/LeetCode-链表/25.png" alt></p><h2 id="Merge-合并-Two-Sorted-Lists-易"><a href="#Merge-合并-Two-Sorted-Lists-易" class="headerlink" title="Merge(合并) Two Sorted Lists(易)"></a>Merge(合并) Two Sorted Lists(易)</h2><p><img src="/2019/06/22/LeetCode-链表/26.png" alt></p><p><img src="/2019/06/22/LeetCode-链表/27.png" alt></p><p><img src="/2019/06/22/LeetCode-链表/28.png" alt></p><ol><li>Merge Two Sorted Lists</li></ol><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p><p>Example:</p><p>Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4</p><p>Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* newHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* pTemp  = newHead;</span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">                pTemp-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                pTemp-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pTemp = pTemp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将比较后某一个原始链表剩余部分直接插到新的链表后方</span></span><br><span class="line">        <span class="keyword">if</span>(l1)&#123;   <span class="comment">//如果l1有剩余</span></span><br><span class="line">            pTemp-&gt;next  = l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l2)&#123;</span><br><span class="line">            pTemp-&gt;next  = l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;总结目录&quot;&gt;&lt;a href=&quot;#总结目录&quot; class=&quot;headerlink&quot; title=&quot;总结目录&quot;&gt;&lt;/a&gt;总结目录&lt;/h2&gt;&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;题目&lt;/th&gt;
&lt;t
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yuemingyang7010.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法刷题" scheme="http://yuemingyang7010.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="链表刷题" scheme="http://yuemingyang7010.github.io/tags/%E9%93%BE%E8%A1%A8%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-其他</title>
    <link href="http://yuemingyang7010.github.io/2019/06/21/%E5%89%91%E6%8C%87offer-%E5%85%B6%E4%BB%96/"/>
    <id>http://yuemingyang7010.github.io/2019/06/21/剑指offer-其他/</id>
    <published>2019-06-21T05:52:09.000Z</published>
    <updated>2019-06-28T06:38:31.735Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>位运算：</p><div class="table-container"><table><thead><tr><th>题目</th><th>难度</th><th></th></tr></thead><tbody><tr><td><a href="note://016376B881D24D5DA4E1252EBAAD3CBB" target="_blank" rel="noopener">不用加减乘除做加法.note</a></td><td>☆☆</td><td>a^b代表不进位的二进制加法，(a&amp;b)&lt;&lt;1为二进制加法所有的进位信息，然后通过循环或者递归，直到进位为0。   扩展题：不使用新的变量，交换两个变量的值</td></tr></tbody></table></div><p>动态规划：</p><div class="table-container"><table><thead><tr><th>题目</th><th>难度</th><th></th></tr></thead><tbody><tr><td><a href="note://E574D3AC0C7D4F1994EE0A3196695E28" target="_blank" rel="noopener">9.变态跳台阶.note</a></td><td>☆</td><td>和动态规划中的跳台阶类似</td></tr><tr><td><a href="note://EE2B5194B93E47D7856EB6CCFA736BF9" target="_blank" rel="noopener">10.矩形覆盖.note</a></td><td>☆</td><td>从简单例子开始推导，得到状态转移方程和斐波那契数列一致。</td></tr></tbody></table></div><p>思维严密性：</p><div class="table-container"><table><thead><tr><th>题目</th><th>难度</th><th></th></tr></thead><tbody><tr><td><a href="note://C7ED1D57EA364E5C9299E2F20BD87951" target="_blank" rel="noopener">16.数值的整数次方.note</a></td><td>☆</td><td>考虑base正负零，exponent正负零。</td></tr></tbody></table></div><h2 id="不用加减乘除做加法"><a href="#不用加减乘除做加法" class="headerlink" title="不用加减乘除做加法"></a>不用加减乘除做加法</h2><p><strong>题目：</strong></p><p>不用加减乘除做加法</p><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p><p><strong>解析：</strong></p><p>　　首先看十进制是如何做的： 5+7=12，三步走</p><p>第一步：相加各位的值，不算进位，得到2。</p><p>第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。</p><p>第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。</p><p>　　</p><p>同样我们可以用三步走的方式计算二进制值相加： 5-101，7-111</p><p>第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。</p><p>第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&amp;111)&lt;&lt;1。</p><p>第三步重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&amp;1010)&lt;&lt;1。 继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(num2 != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = num1^num2; <span class="comment">//二进制不带进位的加法</span></span><br><span class="line">            num2 = (num1 &amp; num2)&lt;&lt;<span class="number">1</span>; <span class="comment">//二进制加法的每一位进位情况</span></span><br><span class="line">            num1 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num1;  <span class="comment">//直到进位为0，返回num1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>扩展题目：</strong></p><p>不使用新的变量，交换两个变量的值</p><p>①基于加减法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a + b; </span><br><span class="line">b = a - b; </span><br><span class="line">a = a - b;</span><br></pre></td></tr></table></figure><p>②基于异或运算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a ^ b; </span><br><span class="line">b = a ^ b; </span><br><span class="line">a = a ^ b;</span><br></pre></td></tr></table></figure><h2 id="变态跳台阶"><a href="#变态跳台阶" class="headerlink" title="变态跳台阶"></a>变态跳台阶</h2><p><strong>题目描述</strong></p><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><p><strong>思路：动态规划</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(number+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(number==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(number == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(number == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=number;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">                dp[i] += dp[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[number];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="矩形覆盖"><a href="#矩形覆盖" class="headerlink" title="矩形覆盖"></a>矩形覆盖</h2><p><strong>题目描述</strong></p><p>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p><p>思路：</p><p>依旧是斐波那契数列</p><p>2<em>n的大矩形，和n个2</em>1的小矩形</p><p>其中target*2为大矩阵的大小</p><p>有以下几种情形：</p><p>1⃣️      target &lt;= 0 大矩形为&lt;= 2*0,直接return 1；</p><p>2⃣️      target = 1大矩形为2*1，只有一种摆放方法，return1；</p><p>3⃣️      target = 2 大矩形为2*2，有两种摆放方法，return2；</p><p>4⃣️      target = n 分为两步考虑：</p><p>​        第一次摆放一块 2*1 的小矩阵，则摆放方法总共为f(target - 1)</p><img src="/2019/06/21/剑指offer-其他/06/21/剑指offer-其他/01.png"><p>第一次摆放一块1*2的小矩阵，则摆放方法总共为f(target-2)</p><p>因为，摆放了一块1<em>2的小矩阵（用√√表示），对应下方的1</em>2（用××表示）摆放方法就确定了，所以为f(targte-2)</p><img src="/2019/06/21/剑指offer-其他/06/21/剑指offer-其他/02.png"><p>实际是一个动态规划，也是一个斐波那契数列，此处按照斐波那契数列求解;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rectCover</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> prepre = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> cur;</span><br><span class="line">        <span class="keyword">if</span>(number ==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(number == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(number == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=number;i++)&#123;</span><br><span class="line">                cur = prepre + pre;</span><br><span class="line">                prepre = pre;</span><br><span class="line">                pre = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h2><p><strong>题目描述</strong></p><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p><p>思路：重点考察思维的严密性，对于double int 这种数据类型，不能上来就默认为正，分别考虑正、负和零的情况，从而发现以下几种特殊情况：</p><p>（1）底数为0.0，指数为负数，会导致分母为零的异常；</p><p>（2）底数为0.0，指数为0，无意义；</p><p>（3）注意指数分正负两种情况时，数学表达式不同。</p><p>优化：常规思路，在循环中，一直底数*底数，但是当指数不太大时可以考虑采用递归的方式实现如下算式，时间复杂度会大大降低。</p><img src="/2019/06/21/剑指offer-其他/06/21/剑指offer-其他/03.png"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(base==<span class="number">0.0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(exponent == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(exponent &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">pow</span>(base,exponent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>/<span class="built_in">pow</span>(base,-exponent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;p&gt;位运算：&lt;/p&gt;
&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;题目&lt;/th
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yuemingyang7010.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="剑指offer" scheme="http://yuemingyang7010.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="http://yuemingyang7010.github.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-链表、队列与栈</title>
    <link href="http://yuemingyang7010.github.io/2019/06/20/%E5%89%91%E6%8C%87offer-%E9%93%BE%E8%A1%A8%E3%80%81%E9%98%9F%E5%88%97%E4%B8%8E%E6%A0%88/"/>
    <id>http://yuemingyang7010.github.io/2019/06/20/剑指offer-链表、队列与栈/</id>
    <published>2019-06-20T05:52:09.000Z</published>
    <updated>2019-06-28T06:30:40.056Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><div class="table-container"><table><thead><tr><th>题目</th><th>难度</th><th></th></tr></thead><tbody><tr><td><a href="note://267A264815194320AE99C6456F7F9067" target="_blank" rel="noopener">6.从尾到头打印链表.note</a></td><td>☆</td><td>即链表逆序，如果不能改变原始链表结构，可用栈</td></tr><tr><td><a href="note://188647273FFD47D28D4BC73B9689F456" target="_blank" rel="noopener">22.链表中倒数第K个节点.note</a></td><td>☆</td><td>快慢指针法</td></tr><tr><td><a href="note://1EB18F62FA924217AF3E9890E393B48F" target="_blank" rel="noopener">25.合并两个排序的链表.note</a></td><td>☆</td><td>先获取新链表头(两链表最小的头)，然后按照递增方式连接，最后将某一个剩余一段的链表直接接上。</td></tr><tr><td><a href="note://A4047F5CE1E345E2917C4B71250C1BFB" target="_blank" rel="noopener">35.复杂链表的复制.note</a></td><td>☆☆☆</td><td>细心！！分三步：1，复制每个节点，插在其后；2，复制每个旧节点的random到新节点；3.拆分节点。</td></tr><tr><td><a href="note://2B3B33D6AFDE4BD98362D2EC0146B083" target="_blank" rel="noopener">圆圈中最后剩下的数.note</a></td><td>☆☆☆</td><td>约瑟夫环问题，采用STL中的list构成环形链表。</td></tr><tr><td></td><td></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>题目</th><th>难度</th><th></th></tr></thead><tbody><tr><td><a href="note://E97F872F78694F578300934A2651FFB5" target="_blank" rel="noopener">9.用两个栈实现队列(易).note</a></td><td>☆</td><td>模拟队列先进先出，一个栈存数据，另一个栈临时放数据。</td></tr><tr><td><a href="note://EFF3BEAF7B584C859F553D330A86E4E2" target="_blank" rel="noopener">30.包含min函数的栈.note</a></td><td>☆</td><td>设置两个栈，一个存放数据，一个存放每一步数据栈中最小的数。</td></tr><tr><td><a href="note://E815AA4D2EF94E8CA776D8A770604A4F" target="_blank" rel="noopener">31.栈的压入、弹出序列.note</a></td><td>☆☆☆</td><td>用一个栈来模拟压入弹出操作。</td></tr><tr><td></td><td></td></tr></tbody></table></div><h2 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h2><p><strong>题目描述</strong></p><p>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</p><p><strong>思路分析：</strong></p><p>其实本题和链表逆序很类似，链表逆序要求改变链表，采用头插法。此题逆序打印链表，一般理解为不改变链表结构，因此采用栈的结构。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  struct ListNode &#123;</span></span><br><span class="line"><span class="comment">*        int val;</span></span><br><span class="line"><span class="comment">*        struct ListNode *next;</span></span><br><span class="line"><span class="comment">*        ListNode(int x) :</span></span><br><span class="line"><span class="comment">*              val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">*        &#125;</span></span><br><span class="line"><span class="comment">*  &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;ListNode*&gt; nodes;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mVector;</span><br><span class="line">        ListNode* pNodes = head;</span><br><span class="line">        <span class="keyword">while</span>(pNodes != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            nodes.push(pNodes);</span><br><span class="line">            pNodes = pNodes-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!nodes.empty())&#123;</span><br><span class="line">            pNodes = nodes.top();</span><br><span class="line">            mVector.push_back(pNodes-&gt;val);</span><br><span class="line">            nodes.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mVector;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="链表中倒数第K个节点"><a href="#链表中倒数第K个节点" class="headerlink" title="链表中倒数第K个节点"></a>链表中倒数第K个节点</h2><p>输入一个链表，输出该链表中倒数第k个结点。</p><p>思路：快慢指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">int val;</span></span><br><span class="line"><span class="comment">struct ListNode *next;</span></span><br><span class="line"><span class="comment">ListNode(int x) :</span></span><br><span class="line"><span class="comment">val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">FindKthToTail</span><span class="params">(ListNode* pListHead, <span class="keyword">unsigned</span> <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = pListHead;</span><br><span class="line">        ListNode* low = pListHead;</span><br><span class="line">        <span class="keyword">while</span>(k &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;   <span class="comment">//防止越界错误！！！要加</span></span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            low = low-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h2><p><strong>题目描述</strong></p><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p><img src="/2019/06/20/剑指offer-链表、队列与栈/06/20/剑指offer-链表、队列与栈/01.png"><p>非递归代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">int val;</span></span><br><span class="line"><span class="comment">struct ListNode *next;</span></span><br><span class="line"><span class="comment">ListNode(int x) :</span></span><br><span class="line"><span class="comment">val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">Merge</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead1 ==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> pHead2;</span><br><span class="line">        <span class="keyword">if</span>(pHead2 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> pHead1;</span><br><span class="line">        ListNode* pre_head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* pTemp = pre_head;</span><br><span class="line">        <span class="keyword">while</span>(pHead1 !=<span class="literal">NULL</span> &amp;&amp; pHead2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pHead1-&gt;val &lt; pHead2-&gt;val)&#123;</span><br><span class="line">                pTemp-&gt;next = pHead1;</span><br><span class="line">                pHead1 = pHead1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                pTemp-&gt;next = pHead2;</span><br><span class="line">                pHead2 = pHead2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pTemp = pTemp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将比较后某一个原始链表剩余部分直接插到新的链表后方</span></span><br><span class="line">        <span class="keyword">if</span>(pHead1)</span><br><span class="line">            pTemp-&gt;next = pHead1;</span><br><span class="line">        <span class="keyword">if</span>(pHead2)</span><br><span class="line">            pTemp-&gt;next = pHead2;</span><br><span class="line">        ListNode* ans = pre_head-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> pre_head;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h2><p><strong>题目描述</strong></p><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p><p>思路：(在不借助辅助空间的情况下，实现O(n)的时间效率)</p><p>分为三步走：</p><img src="/2019/06/20/剑指offer-链表、队列与栈/06/20/剑指offer-链表、队列与栈/02.png"><img src="/2019/06/20/剑指offer-链表、队列与栈/06/20/剑指offer-链表、队列与栈/03.png"><img src="/2019/06/20/剑指offer-链表、队列与栈/06/20/剑指offer-链表、队列与栈/04.png"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct RandomListNode &#123;</span></span><br><span class="line"><span class="comment">    int label;</span></span><br><span class="line"><span class="comment">    struct RandomListNode *next, *random;</span></span><br><span class="line"><span class="comment">    RandomListNode(int x) :</span></span><br><span class="line"><span class="comment">            label(x), next(NULL), random(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">RandomListNode* <span class="title">Clone</span><span class="params">(RandomListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//第一步：遍历链表，复制每个结点，如复制结点A得到A1，将结点A1插到结点A后面；</span></span><br><span class="line">        RandomListNode* curNode = pHead;</span><br><span class="line">        <span class="keyword">while</span>(curNode != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            RandomListNode* pCloned = <span class="keyword">new</span> RandomListNode(<span class="number">0</span>);</span><br><span class="line">            pCloned-&gt;label = curNode-&gt;label;</span><br><span class="line">            pCloned-&gt;next = curNode-&gt;next;</span><br><span class="line">            pCloned-&gt;random = <span class="literal">NULL</span>;</span><br><span class="line">            curNode-&gt;next = pCloned;</span><br><span class="line">            curNode = pCloned-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第二步：重新遍历链表，复制老结点的随机指针给新结点，如A1.random = A.random.next;</span></span><br><span class="line">        curNode = pHead;</span><br><span class="line">        <span class="keyword">while</span>(curNode != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            RandomListNode* pCloned = curNode-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(curNode-&gt;random != <span class="literal">NULL</span>)&#123;  <span class="comment">//！！！！很关键的一个判断，不然就出现野指针</span></span><br><span class="line">                pCloned-&gt;random = curNode-&gt;random-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            curNode = pCloned-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第三步：拆分链表，将链表拆分为原链表和复制后的链表</span></span><br><span class="line">        curNode = pHead;</span><br><span class="line">        RandomListNode* pCloneHead = pHead-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(curNode != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            RandomListNode* pCloneNode = curNode-&gt;next;  <span class="comment">//临时存放当前节点的下一个指针</span></span><br><span class="line">            curNode-&gt;next = curNode-&gt;next-&gt;next;  <span class="comment">//原始链表，隔一个节点连接一个</span></span><br><span class="line">            <span class="comment">//复制后链表，隔一个节点连接一个，但是要考虑该节点是最后一个的情况</span></span><br><span class="line">            pCloneNode-&gt;next = pCloneNode-&gt;next == <span class="literal">NULL</span>?<span class="literal">NULL</span>:pCloneNode-&gt;next-&gt;next;</span><br><span class="line">            curNode = curNode-&gt;next;  <span class="comment">//移到下一个原始节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pCloneHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="圆圈中最后剩下的数"><a href="#圆圈中最后剩下的数" class="headerlink" title="圆圈中最后剩下的数"></a>圆圈中最后剩下的数</h2><p>圆圈中最后剩下的数</p><p>题目：0，1，n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p><p><strong>思路：用约瑟夫环的思想</strong></p><p>例如，0、1、2、3、4这5个数字组成一个圆圈（如图6.3所示），从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p><img src="/2019/06/20/剑指offer-链表、队列与栈/06/20/剑指offer-链表、队列与栈/05.png"><p>可以用模板库中的std:list来模拟一个环形链表。由于std:：list本身并不是一个环形结构，因此每当迭代器（Iterator）扫描到链表末尾的时候，我们要记得把迭代器移到链表的头部。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">1</span> || m &lt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; mlist;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">mlist.push_back(i);</span><br><span class="line"><span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> it = mlist.begin();</span><br><span class="line"><span class="keyword">int</span> k = m - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (mlist.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (k--) &#123;</span><br><span class="line">it++;</span><br><span class="line"><span class="keyword">if</span> (it == mlist.end())</span><br><span class="line">it = mlist.begin();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">it = mlist.erase(it);</span><br><span class="line"><span class="keyword">if</span> (it == mlist.end())</span><br><span class="line">it = mlist.begin();</span><br><span class="line">k = m - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mlist.front();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="用两个栈实现队列-易"><a href="#用两个栈实现队列-易" class="headerlink" title="用两个栈实现队列(易)"></a>用两个栈实现队列(易)</h2><p><strong>题目描述</strong></p><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!stack1.empty())&#123;</span><br><span class="line">            stack2.push(stack1.top());</span><br><span class="line">            stack1.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">        <span class="keyword">while</span>(!stack2.empty())&#123;</span><br><span class="line">            stack1.push(stack2.top());</span><br><span class="line">            stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> top = stack1.top();</span><br><span class="line">        stack1.pop();</span><br><span class="line">        <span class="keyword">return</span> top;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h2><p><strong>题目描述</strong></p><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</p><img src="/2019/06/20/剑指offer-链表、队列与栈/06/20/剑指offer-链表、队列与栈/06.png"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        dataStack.push(value);</span><br><span class="line">        <span class="keyword">if</span>(minStack.empty())&#123;</span><br><span class="line">            minStack.push(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(value &lt; minStack.top())</span><br><span class="line">                minStack.push(value);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                minStack.push(minStack.top());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dataStack.pop();</span><br><span class="line">        minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dataStack.top();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.top();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; dataStack;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; minStack;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h2><p><strong>题目描述</strong></p><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p><p><strong>思路:用一个栈来模拟压入弹出操作。</strong></p><p>如果下一个弹出的数字刚好是栈顶数字, 那么直接弹出;如果下一个弹出的数字不在栈顶, 则把<strong>压栈序列</strong>中还没有入栈的数字压入辅助栈,直到把下一个需要弹出的数字压入栈顶为止;如果所有数字都压入栈后仍然没有找到下一个弹出的数字, 那么该序列不可能是一个弹出序列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsPopOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pushV,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; popV)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pushV.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;pushV.size();i++)&#123;</span><br><span class="line">            dataStack.push(pushV[i]);</span><br><span class="line">            <span class="keyword">while</span>(j&lt;popV.size()&amp;&amp;dataStack.top() == popV[j])&#123;</span><br><span class="line">                dataStack.pop();</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dataStack.empty();  <span class="comment">//若压栈完了，没能全部弹出，说明不是弹出序列，反之是</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; dataStack;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;题目&lt;/th&gt;
&lt;th&gt;难度&lt;/th
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yuemingyang7010.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="剑指offer" scheme="http://yuemingyang7010.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="http://yuemingyang7010.github.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-树</title>
    <link href="http://yuemingyang7010.github.io/2019/06/19/%E5%89%91%E6%8C%87offer-%E6%A0%91/"/>
    <id>http://yuemingyang7010.github.io/2019/06/19/剑指offer-树/</id>
    <published>2019-06-19T05:52:09.000Z</published>
    <updated>2019-06-28T06:28:12.544Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><div class="table-container"><table><thead><tr><th>题目</th><th>难度</th><th></th></tr></thead><tbody><tr><td><a href="note://8DDF3522701B494690B73B66DAD632FD" target="_blank" rel="noopener">7.重建二叉树.note</a></td><td>☆☆☆</td><td>采用递归的方式不断找出根节点和左右子树</td></tr><tr><td><a href="note://053AB99ED0AE4E2BB8B2998BD0231A5C" target="_blank" rel="noopener">树的子结构.note</a></td><td>☆☆☆☆</td><td>第一步在树A中找到和B的根结点的值一样的结点R,第二步再判断树A中以R为根节点的子树是不是包含和树B一样的结构。</td></tr><tr><td><a href="note://BB74C82F4C8142CC98BD69937C0185AD" target="_blank" rel="noopener">二叉树的镜像.note</a></td><td>☆☆</td><td>先交换根节点的左右子节点，再将子节点作为根节点进行递归镜像操作。</td></tr><tr><td><a href="note://604E14887ACB4A54B2DB840DF409A161" target="_blank" rel="noopener">从上往下打印二叉树.note</a></td><td>☆</td><td>根节点入队列，然后出队列，出队时将其左右孩子入队，循环操作进行队列出队，每次出队将其左右孩子入队。当队列为空时，整棵树层序遍历完毕。</td></tr><tr><td><a href="note://3FE09CB0553C4995AD5C56B1C18156BD" target="_blank" rel="noopener">二叉搜索树的后序遍历序列.note</a></td><td>☆☆</td><td><strong>BST的后序序列的合法序列</strong>是，对于一个序列S，最后一个元素是x （也就是根），如果去掉最后一个元素的序列为T，那么T满足：T可以分成两段，前一段（左子树）小于x，后一段（右子树）大于x，且这两段（子树）都是合法的后序序列。完美的递归定义。</td></tr><tr><td><a href="note://D0DBBA55ED06432BA749C0EAAF85AFBA" target="_blank" rel="noopener">36.二叉搜索树与双向链表.note</a></td><td>☆☆</td><td>改造中序遍历，设置一个pre和cur，将中序遍历打印的过程替换为前后连接pre和cur</td></tr><tr><td><a href="note://1A9A17C46DAF4E429528B2BA288CEBC1" target="_blank" rel="noopener">二叉树深度.note</a></td><td>☆</td><td>采用尾递归的方式</td></tr><tr><td><a href="note://5138177E05AC400A82052CE734DB2196" target="_blank" rel="noopener">55.判断树是否为平衡二叉树.note</a></td><td>☆☆</td><td>性质：是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。  <strong>因此递归函数每次要计算出子树的高度。</strong></td></tr><tr><td></td><td></td></tr></tbody></table></div><h2 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h2><p><strong>题目描述</strong></p><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><p><strong>解题思路：采用递归方法</strong></p><img src="/2019/06/19/剑指offer-树/06/19/剑指offer-树/01.png"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">reConstructBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> reConstruct(pre,<span class="number">0</span>,pre.size()<span class="number">-1</span>,vin,<span class="number">0</span>,vin.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">reConstruct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre,<span class="keyword">int</span> startPre,<span class="keyword">int</span> endPre,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vin,<span class="keyword">int</span> startIn,<span class="keyword">int</span> endIn)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(startPre &gt; endPre||startIn &gt; endIn)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(pre[startPre]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=startIn;i&lt;=endIn;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vin[i] == pre[startPre])&#123;</span><br><span class="line">                root-&gt;left = reConstruct(pre,startPre + <span class="number">1</span>,startPre+i-startIn,vin,startIn,i<span class="number">-1</span>);</span><br><span class="line">                root-&gt;right = reConstruct(pre,startPre+i-startIn+<span class="number">1</span>,endPre,vin,i+<span class="number">1</span>,endIn);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h2><p><strong>题目描述</strong></p><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p><p><strong>解题思路</strong></p><p>要查找树A中是否存在和树B结构一样的子枘我们可以分为两步：第一步在树A中找到和B的根结点的值一样的结点R,第二步再判断树A中以R为根节点的子树是不是包含和树B一样的结构。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">int val;</span></span><br><span class="line"><span class="comment">struct TreeNode *left;</span></span><br><span class="line"><span class="comment">struct TreeNode *right;</span></span><br><span class="line"><span class="comment">TreeNode(int x) :</span></span><br><span class="line"><span class="comment">val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">HasSubtree</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span>  <span class="comment">//二叉树的前序遍历</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot1 != <span class="literal">NULL</span> &amp;&amp; pRoot2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pRoot1-&gt;val == pRoot2-&gt;val)</span><br><span class="line">                result = DoseTreeHaveTree2(pRoot1,pRoot2);</span><br><span class="line">            <span class="keyword">if</span>(!result)</span><br><span class="line">                result = HasSubtree(pRoot1-&gt;left,pRoot2);</span><br><span class="line">            <span class="keyword">if</span>(!result)</span><br><span class="line">                result = HasSubtree(pRoot1-&gt;right,pRoot2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断以pRoot1为根节点的树中是否有以pRoot2为根节点的树</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">DoseTreeHaveTree2</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot2 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot1 == <span class="literal">NULL</span> || pRoot1-&gt;val != pRoot2-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> DoseTreeHaveTree2(pRoot1-&gt;left,pRoot2-&gt;left)&amp;&amp;DoseTreeHaveTree2(pRoot1-&gt;right,pRoot2-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h2><p><strong>题目描述</strong></p><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p><p><strong>输入描述:</strong></p><p>二叉树的镜像定义：</p><p>源二叉树             </p><p>​         8            </p><p>​       /             </p><p>​    6   10          </p><p>   /    /           </p><p> 5  7 9  11         </p><p>镜像二叉树             </p><p>​         8           </p><p>​        /             </p><p>​     10   6          </p><p>​     /    /           </p><p>  11  9  7   5</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">int val;</span></span><br><span class="line"><span class="comment">struct TreeNode *left;</span></span><br><span class="line"><span class="comment">struct TreeNode *right;</span></span><br><span class="line"><span class="comment">TreeNode(int x) :</span></span><br><span class="line"><span class="comment">val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode *pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            TreeNode *temp = pRoot-&gt;left;</span><br><span class="line">            pRoot-&gt;left = pRoot-&gt;right;</span><br><span class="line">            pRoot-&gt;right = temp;</span><br><span class="line">            <span class="keyword">if</span>(pRoot-&gt;left)&#123;</span><br><span class="line">                Mirror(pRoot-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pRoot-&gt;right)&#123;</span><br><span class="line">                Mirror(pRoot-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="从上往下打印二叉树"><a href="#从上往下打印二叉树" class="headerlink" title="从上往下打印二叉树"></a>从上往下打印二叉树</h2><p><strong>题目描述</strong></p><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p><p>思路：参考<a href="note://wcp153494909997195" target="_blank" rel="noopener">二叉树的递归与非递归遍历（前序、中序、后序、层序）</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">int val;</span></span><br><span class="line"><span class="comment">struct TreeNode *left;</span></span><br><span class="line"><span class="comment">struct TreeNode *right;</span></span><br><span class="line"><span class="comment">TreeNode(int x) :</span></span><br><span class="line"><span class="comment">val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; PrintFromTopToBottom(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        mQueue.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!mQueue.empty())&#123;</span><br><span class="line">            TreeNode* temp = mQueue.front();</span><br><span class="line">            result.push_back(temp-&gt;val);</span><br><span class="line">            mQueue.pop();</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;left)</span><br><span class="line">                mQueue.push(temp-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;right)</span><br><span class="line">                mQueue.push(temp-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; mQueue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="二叉搜索树的后序遍历序列"><a href="#二叉搜索树的后序遍历序列" class="headerlink" title="二叉搜索树的后序遍历序列"></a>二叉搜索树的后序遍历序列</h2><p><strong>题目描述</strong></p><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p><p><strong>思路：</strong></p><p>BST的后序序列的合法序列是，对于一个序列S，最后一个元素是x （也就是根），如果去掉最后一个元素的序列为T，那么T满足：T可以分成两段，前一段（左子树）小于x，后一段（右子树）大于x，且这两段（子树）都是合法的后序序列。完美的递归定义 : ) 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> juge(sequence,<span class="number">0</span>,sequence.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">juge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sequence,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//从右向左寻找右子树所对应的序列</span></span><br><span class="line">        <span class="keyword">int</span> i=right<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i&gt;=left &amp;&amp; sequence[i]&gt;sequence[right];i--);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;=left;j--)&#123;  <span class="comment">//寻找左子树对应的序列</span></span><br><span class="line">            <span class="keyword">if</span>(sequence[j]&gt;sequence[right])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归判断左子树和右子树是不是都符合条件，注意最后一个参数为right-1 ！！！</span></span><br><span class="line">        <span class="keyword">return</span> juge(sequence,left,i)&amp;&amp;juge(sequence,i+<span class="number">1</span>,right<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h2><p><strong>题目描述</strong></p><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p><p><strong>解题思路：</strong></p><p>该结构特点可以类比到双向链表中： </p><p>在双向链表中，每个结点也有两个指针，它们分别指向前一个结点和后一个结点。</p><p>所以这两种数据结构的结点是一致，二叉搜索树之所以为二叉搜索树，双向链表之所以为双向链表，只是因为两个指针的指向不同而已，通过改变其指针的指向来实现是完全可能的。</p><img src="/2019/06/19/剑指offer-树/06/19/剑指offer-树/02.png"><p><strong>具体实现步骤：</strong> </p><p>原先指向左子结点的指针调整为链表中指向前一个结点的指针，原先指向右子结点的指针调整为链表中指向下一个结点的指针。 </p><p>具体转换过程：按照中序遍历的方法遍历二叉搜索树，可以将该二叉树分为三个部分：根节点、左子树和右子树，当遍历结点值为4的节点时，将它分为以2为节点的左子树和以6为节点的右子树，并将4的左指针指向值为3的结点，值为3的节点的右指针指向值为4的结点，因为采用的是中序遍历，所以当遍历到根节点的时候，它的左子树已经遍历结束了，所以要对所有的子树采用递归的执行上述操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">int val;</span></span><br><span class="line"><span class="comment">struct TreeNode *left;</span></span><br><span class="line"><span class="comment">struct TreeNode *right;</span></span><br><span class="line"><span class="comment">TreeNode(int x) :</span></span><br><span class="line"><span class="comment">val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Convert</span><span class="params">(TreeNode* pRootOfTree)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TreeNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">        Tree2list(pRootOfTree,&amp;pre);  <span class="comment">//运行完之后pre对应最后一个节点</span></span><br><span class="line">        TreeNode* pHead = pre;</span><br><span class="line">        <span class="keyword">while</span>(pHead != <span class="literal">NULL</span> &amp;&amp; pHead-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">            pHead = pHead-&gt;left;</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Tree2list</span><span class="params">(TreeNode* root,TreeNode** pre)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">            Tree2list(cur-&gt;left,pre);</span><br><span class="line">        </span><br><span class="line">        cur-&gt;left = *pre;   <span class="comment">//当前节点连接前一个节点</span></span><br><span class="line">        <span class="keyword">if</span>(*pre != <span class="literal">NULL</span>)    <span class="comment">//前一个节点连接当前节点</span></span><br><span class="line">            (*pre)-&gt;right = cur;</span><br><span class="line">        *pre = cur;        <span class="comment">//更新当前节点为前一个节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">            Tree2list(cur-&gt;right,pre);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="二叉树深度"><a href="#二叉树深度" class="headerlink" title="二叉树深度"></a>二叉树深度</h2><p><strong>题目描述</strong></p><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p><p><strong>思路：采用递归的方式</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">int val;</span></span><br><span class="line"><span class="comment">struct TreeNode *left;</span></span><br><span class="line"><span class="comment">struct TreeNode *right;</span></span><br><span class="line"><span class="comment">TreeNode(int x) :</span></span><br><span class="line"><span class="comment">val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode* pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lDepth = TreeDepth(pRoot-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> rDepth = TreeDepth(pRoot-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> lDepth&gt;rDepth?(lDepth+<span class="number">1</span>):(rDepth+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="判断树是否为平衡二叉树"><a href="#判断树是否为平衡二叉树" class="headerlink" title="判断树是否为平衡二叉树"></a>判断树是否为平衡二叉树</h2><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p><p>平衡二叉树性质：是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p><p>思路：</p><p>方法一（不合适，需要重复遍历节点多次，耗时长O(n^2)））</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* pRoot)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(pRoot == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">int</span> left = maxDepth(pRoot-&gt;left);</span><br><span class="line"><span class="keyword">int</span> right = maxDepth(pRoot-&gt;right);</span><br><span class="line"><span class="keyword">int</span> diff = left-right;</span><br><span class="line"><span class="keyword">if</span>(diff &lt;<span class="number">-1</span> || diff &gt;<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> isBalanced(pRoot-&gt;left)&amp;&amp;isBalanced(pRoot-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二：</strong></p><p>用后序遍历的方式遍历整棵二叉树。在遍历某节点的左、右子节点之后，我们可以根据它的左、右子节点的深度判断它是不是平衡的，并得到当前节点的深度。当最后遍历到树的根节点的时候，也就判断了整棵二叉树是不是平衡二叉树。</p><p> //<strong>后续遍历</strong>时，遍历到一个节点，其左右子树已经遍历  依次自底向上判断，每个节点只需要遍历一次</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> isBalanced(pRoot,depth);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* pRoot,<span class="keyword">int</span> &amp;depth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(isBalanced(pRoot-&gt;left,left) &amp;&amp; isBalanced(pRoot-&gt;right,right))&#123;</span><br><span class="line">            <span class="keyword">int</span> dif = left-right;</span><br><span class="line">            <span class="keyword">if</span>(dif &lt; <span class="number">-1</span> || dif &gt; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            depth = left &gt; right?(left+<span class="number">1</span>):(right+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;题目&lt;/th&gt;
&lt;th&gt;难度&lt;/th
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yuemingyang7010.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="剑指offer" scheme="http://yuemingyang7010.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="http://yuemingyang7010.github.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
</feed>
