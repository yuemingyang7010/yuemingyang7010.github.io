<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[多线程编程]]></title>
    <url>%2F2019%2F08%2F29%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[从C++11新标准开始，C++语言本身增加了对多线程的支持，意味着使用C++可实现多线程程序的可移植，跨平台。一个书写良好的程序，必须等所有的子线程执行完毕之后，主线程才能结束。 C++并发与多线程视频教程 [c++11]多线程编程(一)——初识 [c++11]多线程编程(二)——理解线程类的构造函数 [c++11]多线程编程(三)——竞争条件与互斥锁 [c++11]多线程编程(四)——死锁(Dead Lock) [c++11]多线程编程(五)——unique_lock [c++11]多线程编程(六)——条件变量(Condition Variable) C++11 使用异步编程std::async和std::future C++11创建线程基本方法1.1 使用函数创建线程1 添加头文件添加头文件以使用多线程：#include 2 创建初始函数定义一个函数，这个函数将会作为我们创建的线程的初始函数： 1234void thread_function()&#123; cout &lt;&lt; "start executing my thread..." &lt;&lt; endl;&#125; 3 在程序中添加线程，以及基本的线程函数 新建一个线程使用： 1thread 线程名称（初始函数） join()函数 用法：线程名称.join() 说明：使用该函数后，主线程阻塞到这里，当子线程执行完毕，这个join()函数就执行完毕，主线程也就可以继续运行了。 detach()函数 传统多线程程序，主线程要等待子线程执行完毕，然后自己再退出。 deteach的意思是分离，也就是主线程不必和子线程汇合了，主线程与子线程各自执行。引入detach()是为了避免让主线程逐个等待子线程结,但是以后就不能被主线程控制或者回收了，不太推荐用，除非子线程与主线程业务无关。 joinable()函数 判断是否可以成功使用join()或者detach()，返回true则可以，返回false则不可以。 最后的完整程序如下，您可以通过依次运行mythread.join()，mythread.detach()函数查看程序运行结果以加深对这几个函数的理解。 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;thread&gt;using namespace std; void thread_function()&#123; for(int i = 0; i &lt; 5; i++) cout &lt;&lt; "子线程运行" &lt;&lt; i+1 &lt;&lt; endl;&#125; int main()&#123; thread mythread(thread_function); // 传递初始函数作为线程的参数 if(mythread.joinable()) mythread.join(); // 使用join()函数阻塞主线程直至子线程执行完毕 if(mythread.joinable()) mythread.detach(); // 使用detach()函数让子线程和主线程并行运行，主线程也不再等待子线程。 for(int i = 0; i &lt; 5; i++) cout &lt;&lt; "主线程运行" &lt;&lt; i+1 &lt;&lt; endl; return 0;&#125; 4 运行结果分析如果只使用join()函数，注释detach()函数，运行结果如下，为顺序执行： 12345678910子线程运行1子线程运行2子线程运行3子线程运行4子线程运行5主线程运行1主线程运行2主线程运行3主线程运行4主线程运行5 ​ 如果只使用detach()函数，运行结果如下，每次执行的结果均不相同： 12345678910子线程运行主线程运行11主线程运行2子线程运行2子线程运行3子线程运行4子线程运行5主线程运行3主线程运行4主线程运行5 带参数的函数： 1234567891011#include &lt;iostream&gt;#include&lt;thread&gt;using namespace std;void myprint(int n,const char* str)&#123; //最好不用引用，不安全，如果是引用，线程外的n改变会影响线程工作 cout &lt;&lt; n &lt;&lt; str;&#125;int main()&#123; thread threrad1(myprint,5,"yue"); threrad1.join(); return 0;&#125; 输出： 15yue 1.2 使用类对象创建线程创建thread的时候参数不仅可以是一个函数，也可以是一个类的对象。这个类中需要重载运算符()，如下所示： 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;thread&gt;using namespace std; class Thread&#123;public: // 运算符重载 void operator()() //不能带参数 &#123; for(int i = 0; i &lt; 5; i++) cout &lt;&lt; "子线程运行" &lt;&lt; i+1 &lt;&lt; endl; &#125; &#125;; int main()&#123; Thread t; thread mythread(t); // ！！！将对象复制到线程中去，所以复制后t销毁了也没关系。！！！ if(mythread.joinable()) mythread.join(); // 使用join()函数阻塞主线程直至子线程执行完毕 if(mythread.joinable()) mythread.detach(); // 使用detach()函数让子线程和主线程并行运行，主线程也不再等待子线程。 for(int i = 0; i &lt; 5; i++) cout &lt;&lt; "主线程运行" &lt;&lt; i+1 &lt;&lt; endl; return 0;&#125; detach()之后子线程就分离了，运行完了由C++运行时库回收，并且detach()之后就不能join了。 1.3 detach()的坑坑的原因：子线程还没运行完，主线程就运行完了。 （比如传进一个主线程中字符串数组的指针，但是用了detach(),如果主线程先退出了，此时对该数组的操作可能出问题。） 子线程参数通过构造临时对象的方式来进行传递，构造临时对象主要有两种情况（1）传递int这种简单类型参数，建议使用值传递，不要使用引用，防止节外生枝。（2）如果传递类对象，一律在创建线程的地方就通过隐式转换构建临时对象，然后在函数形参处使用引用（节约资源）。 多线程数据共享问题分析问题：（1）只读数据：是安全稳定的，不需要特别的处理手段，只是不做其他处理，线程读取的顺序不能控制； （2）有写的情况：例如，2个线程写，8个线程读，没有特殊处理，程序会崩溃，最简单的就是读的时候不能写，写的时候不能读。（3）多线程按顺序执行问题。 1.互斥量mutex一般情况下，最简单的协调不同线程之间的调度关系，都可以使用mutex来做，本质是信号量。 std::mutex 的成员函数有四个： 构造函数，std::mutex不允许拷贝构造，也不允许 move 拷贝，最初产生的 mutex 对象是处于 unlocked 状态的。lock()，调用线程将锁住该互斥量。线程调用该函数会发生下面 3 种情况：(1). 如果该互斥量当前没有被锁住，则调用线程将该互斥量锁住，直到调用 unlock之前，该线程一直拥有该锁。(2). 如果当前互斥量被其他线程锁住，则当前的调用线程被阻塞住。(3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。unlock()， 解锁，释放对互斥量的所有权。try_lock()，尝试锁住互斥量，如果互斥量被其他线程占有，则当前线程也不会被阻塞。线程调用该函数也会出现下面 3 种情况，(1). 如果当前互斥量没有被其他线程占有，则该线程锁住互斥量，直到该线程调用 unlock 释放互斥量。(2). 如果当前互斥量被其他线程锁住，则当前调用线程返回 false，而并不会被阻塞掉。(3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。 2.lock_guard类模板功能：取代mutex的lock()和unlock() 如果mu.lock()和mu.unlock()之间的语句发生了异常，会发生什么？unlock()语句没有机会执行！导致导致mu一直处于锁着的状态（死锁）。 为解决这一问题，c++库已经提供了std::lock_guard类模板，将lock()放在构造函数中，unlock()放在析构函数中，使用方法如下： 12345void shared_print(string msg, int id) &#123; //构造的时候帮忙上锁，析构的时候释放锁 std::lock_guard&lt;std::mutex&gt; guard(mu); cout &lt;&lt; msg &lt;&lt; id &lt;&lt; endl;&#125; 当在cout之后还有比较多的代码需要执行，而又不想锁住，可添加{}，提前结束lock_guard的生命周期，如下： 12345678910void shared_print(string msg, int id) &#123; //构造的时候帮忙上锁，析构的时候释放锁 &#123; std::lock_guard&lt;std::mutex&gt; guard(mu); cout &lt;&lt; msg &lt;&lt; id &lt;&lt; endl; &#125; /* do something */&#125; 3.std::lock(mu1,mu2,…)函数模板功能：解决上锁顺序导致的死锁 死锁需要两个及其以上的互斥量才会发生，举一个死锁的例子： 例如有两个互斥量，叫做锁1和锁2，有两个线程，线程1，线程2，线程1所要执行的代码中都有，对锁1加锁，然后对锁2加锁，线程2所要执行的代码中，先对锁2加锁，再对锁1加锁。 可能出现，线程1锁了锁1，准备锁2时，由于上下切换，线程2去锁了锁2，于是线程1始终无法锁锁2，线程2始终无法锁住锁1，各自拥有的锁也不释放，从而造成僵持状态。 解决方法：只要保证上锁顺序一致就不会出现死锁。 std:：lock()函数模板：一次锁住两个或者两个以上的互斥量（至少两个，多了不限，1个不行）； 1std::lock(_mu, _mu2); //它不存在这种因为再多个线程中因为锁的顺序问题导致死锁的风险问题；//std:：lock()；如果互斥量中有一个没锁柱，它就在那里等着，等所有互斥量都锁住，它才能往下走（返回）； 该方法要谨慎使用。 问题：对多个互斥量上锁后，需要unlock()，这个时候可以采用lock()和lock_guard相结合的方式，先用lock()对多个互斥量上锁，再使用std::adopt_lock表示无需上锁，但会在超出作用于释放锁。 12std::lock_guard&lt;std::mutex&gt; guard(_mu2, std::adopt_lock);std::lock_guard&lt;std::mutex&gt; guard2(_mu, std::adopt_lock); 例如： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;string&gt;#include &lt;mutex&gt;#include &lt;fstream&gt;using namespace std;class LogFile &#123; std::mutex _mu; std::mutex _mu2; ofstream f;public: LogFile() &#123; f.open("log.txt"); &#125; ~LogFile() &#123; f.close(); &#125; void shared_print(string msg, int id) &#123; std::lock(_mu, _mu2); std::lock_guard&lt;std::mutex&gt; guard(_mu, std::adopt_lock); std::lock_guard&lt;std::mutex&gt; guard2(_mu2, std::adopt_lock); f &lt;&lt; msg &lt;&lt; id &lt;&lt; endl; cout &lt;&lt; msg &lt;&lt; id &lt;&lt; endl; &#125; void shared_print2(string msg, int id) &#123; std::lock(_mu, _mu2); std::lock_guard&lt;std::mutex&gt; guard(_mu2, std::adopt_lock); std::lock_guard&lt;std::mutex&gt; guard2(_mu, std::adopt_lock); f &lt;&lt; msg &lt;&lt; id &lt;&lt; endl; cout &lt;&lt; msg &lt;&lt; id &lt;&lt; endl; &#125;&#125;;void function_1(LogFile&amp; log) &#123; for(int i=0; i&gt;-100; i--) log.shared_print2(string("From t1: "), i);&#125;int main()&#123; LogFile log; std::thread t1(function_1, std::ref(log)); for(int i=0; i&lt;100; i++) log.shared_print(string("From main: "), i); t1.join(); return 0;&#125; 4.unique_lock类模板功能：unique_lock取代lock_guard（1）unique_lock是个类模板，工作中，一般lock_guard（绝大多数情况都能满足，推荐使用）//unique_lock比lock_guard灵活很多；效率上差一点，内存占用多一点。 （2）unique_lock的第二个参数： (a)std:：adopt_lock和lock_guard相同，就是不再让unique_lock的构造函数中lock()这个mutex; (b)std:：try_to_lock尝试用mutex的lock()去锁定这个mutex，但如果没有锁定成功，我也会立即返回，并不会阻塞在那里；用这个try_to_lock的前提是不能先去lock()。(c))std:：defer_lock用这个defer_lock的前提是不能自己先lock，否则会报异常。defer_lock的意思就是并没有给mutext加锁：初始化了一个没有加锁的mutex。 5.条件变量condition_variable （3）unique_lock的重更成员函数（一般在std:：defer_lock参数下） 功能：常见用法可以更加灵活地提供细粒度的锁，如下： 123456789101112131415161718192021222324252627class LogFile &#123; std::mutex _mu; ofstream f;public: LogFile() &#123; f.open("log.txt"); &#125; ~LogFile() &#123; f.close(); &#125; void shared_print(string msg, int id) &#123; std::unique_lock&lt;std::mutex&gt; guard(_mu); //do something 1 guard.unlock(); //临时解锁 //do something 2 guard.lock(); //继续上锁 // do something 3 f &lt;&lt; msg &lt;&lt; id &lt;&lt; endl; cout &lt;&lt; msg &lt;&lt; id &lt;&lt; endl; // 结束时析构guard会临时解锁 // 这句话可要可不要，不写，析构的时候也会自动执行 // guard.ulock(); &#125;&#125;; (a) lock()，加锁(b) unlock()，(临时)解锁；(c) try_lock()，尝试给互斥量加锁，如果拿不到锁，则返回false，如果拿到了锁，返回true，这个数不阳塞的；(d) release()，返回它所管理的mutex对象指针，并释放所有权；也就是说，这个unique_lock和mutex不再有关系。注意严格区分unlock 0和release）的区，不要混淆。用release()的话，如果已经加锁，进行该操作，有责任需要自己unlock(). （4）unique_lock所有权转移 不可复制，可移动 unique_lock和lock_guard都不能复制，lock_guard不能移动，但是unique_lock可以！ 123456789// unique_lock 可以移动，不能复制std::unique_lock&lt;std::mutex&gt; guard1(_mu);std::unique_lock&lt;std::mutex&gt; guard2 = guard1; // errorstd::unique_lock&lt;std::mutex&gt; guard2 = std::move(guard1); // ok ,guard2接管guard1// lock_guard 不能移动，不能复制std::lock_guard&lt;std::mutex&gt; guard1(_mu);std::lock_guard&lt;std::mutex&gt; guard2 = guard1; // errorstd::lock_guard&lt;std::mutex&gt; guard2 = std::move(guard1); // error 5.条件变量condition_vriable类模板需要包含：#include condition_vriable这个类需要和互斥量配合使用，用的时候我们要生成这个类的对象。 主要有以下几个函数： wait(),notify_one(),notify_all(). wait()函数有两个参数：（1）如果第二个参数lambda表达式返回值是true，那wait()直接返回；（2）如果第二个参数lambda表达式返回值是false，那么wait()将解锁互斥量，并阻塞到本行， 那堵塞到什么时候为止呢？堵塞到其他某个线程调用notify_one()或者notify_all()成员函数为止；(3)如果wait()没有第二个参数就跟第二个参数lambda表达式返回false效果一样。 不用第二个参数的形式： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;condition_variable&gt;#include &lt;iostream&gt;#include &lt;deque&gt;#include &lt;thread&gt;#include &lt;mutex&gt;class A&#123;public: void function_1() &#123; int count = 10; while (count &gt; 0) &#123; std::unique_lock&lt;std::mutex&gt; locker(mu); q.push_front(count); locker.unlock(); cond.notify_one(); // Notify one waiting thread, if there is one. //std::this_thread::sleep_for(std::chrono::seconds(1)); count--; &#125; &#125; void function_2() &#123; int data = 0; while (data != 1) &#123; std::unique_lock&lt;std::mutex&gt; locker(mu); while (q.empty()) cond.wait(locker); // Unlock mu and wait to be notified data = q.back(); q.pop_back(); locker.unlock(); std::cout &lt;&lt; "t2 got a value from t1: " &lt;&lt; data &lt;&lt; std::endl; &#125; &#125;private: std::deque&lt;int&gt; q; std::mutex mu; std::condition_variable cond;&#125;;int main() &#123; A a; std::thread t1(&amp;A::function_1,&amp;a); std::thread t2(&amp;A::function_2,&amp;a); t1.join(); t2.join(); return 0;&#125; 如果需要用第二个参数，可以不用notify_one(),直接用lambda表达式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;condition_variable&gt;#include &lt;iostream&gt;#include &lt;deque&gt;#include &lt;thread&gt;#include &lt;mutex&gt;class A&#123;public: void function_1() &#123; int count = 10; while (count &gt; 0) &#123; std::unique_lock&lt;std::mutex&gt; locker(mu); q.push_front(count); locker.unlock(); //cond.notify_one(); // Notify one waiting thread, if there is one. //std::this_thread::sleep_for(std::chrono::seconds(1)); count--; &#125; &#125; void function_2() &#123; int data = 0; while (data != 1) &#123; std::unique_lock&lt;std::mutex&gt; locker(mu); //while (q.empty()) //cond.wait(locker); // Unlock mu and wait to be notified cond.wait(locker, [this]()&#123; //一个lambda就是一个可调用的对象(函数) if (!q.empty()) &#123; return true; &#125; return false; &#125;); data = q.back(); q.pop_back(); locker.unlock(); std::cout &lt;&lt; "t2 got a value from t1: " &lt;&lt; data &lt;&lt; std::endl; &#125; &#125;private: std::deque&lt;int&gt; q; std::mutex mu; std::condition_variable cond;&#125;;int main() &#123; A a; std::thread t1(&amp;A::function_1,&amp;a); std::thread t2(&amp;A::function_2,&amp;a); t1.join(); t2.join(); return 0;&#125; 存在的坑： （1）例如上例中，如果notify_one()唤醒wait()后，wait()后面还有很多代码需要执行，在执行过程中可能下一次循环又调用了notify_one()，而这个时候function_2()并不是阻塞在wait()处，这样将会使wait()无效果。 (2)根据(1)可知，不一定两个function都是交替执行，可能function_1()执行完notify_one()之后，马上又抢到锁，即连续朝队列中插入了两个(或多个)数据。 6.使用异步编程std::async和std::future需要包含 #include std::future可以从异步任务中获取结果，一般与std::async配合使用，std::async用于创建异步任务，实际上就是创建一个线程执行相应任务。 std::async就是异步编程的高级封装，封装了std::future的操作，基本上可以代替std::thread 的所有事情。 future对象是std::async、std::promise、std::packaged_task的底层对象，用来传递其他线程中操作的数据结果。 123456789101112131415161718#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;future&gt;using namespace std;int mythread()&#123; cout &lt;&lt; "mythread start" &lt;&lt; " threadID:" &lt;&lt; this_thread::get_id() &lt;&lt; endl; chrono::milliseconds sleep1(1000); this_thread::sleep_for(sleep1); cout &lt;&lt; "mythread end" &lt;&lt; " threadID:" &lt;&lt; this_thread::get_id() &lt;&lt; endl; return 5;&#125;int main()&#123; cout &lt;&lt; "main" &lt;&lt; "threadID:" &lt;&lt; this_thread::get_id() &lt;&lt; endl; future&lt;int&gt; result = async(mythread); //async()创建一个异步任务（线程），将运行结果返回给futrue. cout &lt;&lt; "子线程返回值:" &lt;&lt; result.get() &lt;&lt; endl; //阻塞在get()这里，等待mythread()执行完毕，拿到结果 //result.wait(); // 等待线程返回，本省并不返回结果。 return 0;&#125; 运行结果： 1234mainthreadID:9964mythread start threadID:9964mythread end threadID:9964子线程返回值:5 代码说明： std::async会首先创建线程执行， 任务创建之后，std::async立即返回一个std::future对象。主线程既可使用std::future::get获取结果，如果调用过程中，任务尚未完成，则主线程阻塞至任务完成。 主线程也可使用std::future::wait_for等待结果返回，wait_for可设置超时时间，如果在超时时间之内任务完成，则返回std::future_status::ready状态；如果在超时时间之内任务尚未完成，则返回std::future_status::timeout状态。 注意：futrue的get()只能对一个任务执行一次，比如上例中不能get()两次。 如果传入的是一个带参数的类的成员函数，写法如下： 123456789101112131415161718192021222324252627//#include &lt;condition_variable&gt;#include &lt;iostream&gt;//#include &lt;deque&gt;#include &lt;thread&gt;//#include &lt;mutex&gt;#include &lt;future&gt;using namespace std;class A&#123;public: int mythread(int n)&#123; cout &lt;&lt; "mythread start" &lt;&lt; " threadID:" &lt;&lt; this_thread::get_id() &lt;&lt; endl; chrono::milliseconds sleep1(1000); this_thread::sleep_for(sleep1); cout &lt;&lt; "mythread end" &lt;&lt; " threadID:" &lt;&lt; this_thread::get_id() &lt;&lt; endl; return n; &#125;&#125;;int main()&#123; A a; cout &lt;&lt; "main" &lt;&lt; "threadID:" &lt;&lt; this_thread::get_id() &lt;&lt; endl; future&lt;int&gt; result = async(&amp;A::mythread,&amp;a,10); //async()创建一个异步任务（线程），将运行结果返回给futrue. cout &lt;&lt; "子线程返回值:" &lt;&lt; result.get() &lt;&lt; endl; //阻塞在get()这里，等待mythread()执行完毕，拿到结果 //result.wait(); // 等待线程返回，本省并不返回结果。 return 0;&#125; 运行结果： 1234mainthreadID:10208mythread start threadID:10208mythread end threadID:10208子线程返回值:10 7.std:：promise类模板需要包含 #include std::promise是C++11并发编程中常用的一个类，常配合std::future使用。其作用是在一个线程t1中保存一个类型typename T的值，可供相绑定的std::future对象在另一线程t2中获取。 关键点：（1）std::promise与std::future相绑定；（2）std::promise的对象set_value()，std::future的对象get() 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;future&gt;void Thread_Fun1(std::promise&lt;int&gt; &amp;p,int temp)&#123; //为了突出效果，可以使线程休眠5s std::this_thread::sleep_for(std::chrono::milliseconds(500)); int iVal = temp; std::cout &lt;&lt; "传入数据(int)：" &lt;&lt; iVal &lt;&lt; std::endl; //传入数据iVal p.set_value(iVal);&#125;void Thread_Fun2(std::future&lt;int&gt; &amp;f)&#123; //阻塞函数，直到收到相关联的std::promise对象传入的数据 auto iVal = f.get(); //iVal = 233 std::cout &lt;&lt; "收到数据(int)：" &lt;&lt; iVal &lt;&lt; std::endl;&#125;int main()&#123; //声明一个std::promise对象pr1，其保存的值类型为int std::promise&lt;int&gt; pr1; //声明一个std::future对象fu1，并通过std::promise的get_future()函数与pr1绑定 std::future&lt;int&gt; fu1 = pr1.get_future(); int num = 233; //创建一个线程t1，将函数Thread_Fun1及对象pr1放在线程里面执行 std::thread t1(Thread_Fun1, std::ref(pr1),233); //创建一个线程t2，将函数Thread_Fun2及对象fu1放在线程里面执行 std::thread t2(Thread_Fun2, std::ref(fu1)); t1.join(); t2.join(); return 0;&#125; 注意：上例其实使将主线程中的参数，传递给Thread_Fun1，然后再传递给Thread_Fun2，如果Thread_Fun1不含参数，直接set_value(233)，也会得到相同结果。 8.原子操作atomic互序量的加锁一般是针对一个代码段（几行代码），而原子操作针对的一般都是一个变量，而不是一个代码段； 通常非常适合用来控制代码块运行的全局标志位bool flag,还有计数值count等。 原子操作，它表示在多个线程访问同一个全局资源的时候，能够确保所有其他线程都不在同一时间访问该资源。也就是确保了在同一时刻只有一个线程对这个资源进行访问。这有点类似互斥对象对共享资源的访问的保护，但是原子操作更加接近底层，因而效率更高。 例如三个线程同时执行如下代码，由于num++编译后可能变成3条汇编，多个线程同时执行会使计算结果不正确。 123456789// 线程函数,内部对num自增1000万次int num = 0;void Add()&#123; for(int i=0;i&lt;10000000;i++) &#123; num++; &#125;&#125; 分别不加锁，加锁，用原子操作进行实验： 实验结论（多线程操作全局变量，三个线程，每个线程对整型自增1000万次） 非原子操作，不加锁，效率很高，但无法得到正确的结果； 非原子操作，加锁，效率很低，大约和无锁的相差20倍，但结果正确； 原子操作，效率很高，大约是有锁实现的5倍，且结果正确。 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;atomic&gt;#include&lt;thread&gt;#include&lt;vector&gt;using namespace std;atomic&lt;int&gt; num(0);// 线程函数,内部对num自增1000万次void Add()&#123; for (int i = 0; i &lt; 10000000; i++) &#123; num++; &#125;&#125;int main()&#123; clock_t startClock = clock(); // 记下开始时间 // 3个线程,创建即运行 thread t1(Add); thread t2(Add); thread t3(Add); // 等待3个线程结束 t1.join(); t2.join(); t3.join(); clock_t endClock = clock(); // 记下结束时间 cout &lt;&lt; "耗时:" &lt;&lt; endClock - startClock &lt;&lt; ",单位:" &lt;&lt; CLOCKS_PER_SEC &lt;&lt; ",result:" &lt;&lt; num &lt;&lt; endl; return 0;&#125; 1耗时:1767,单位:1000,result:30000000 单例设计模式C++11处理常见的多线程问题leetcode1114 按顺序打印参考 题目描述：我们提供了一个类： public class Foo { public void one() { print(“one”); } public void two() { print(“two”); } public void three() { print(“three”); }}三个不同的线程将会共用一个 Foo 实例。 线程 A 将会调用 one() 方法线程 B 将会调用 two() 方法线程 C 将会调用 three() 方法请设计修改程序，以确保 two() 方法在 one() 方法之后被执行，three() 方法在 two() 方法之后被执行。 示例 1: 输入: [1,2,3]输出: “onetwothree”解释:有三个线程会被异步启动。输入 [1,2,3] 表示线程 A 将会调用 one() 方法，线程 B 将会调用 two() 方法，线程 C 将会调用 three() 方法。正确的输出是 “onetwothree”。示例 2: 输入: [1,3,2]输出: “onetwothree”解释:输入 [1,3,2] 表示线程 A 将会调用 one() 方法，线程 B 将会调用 three() 方法，线程 C 将会调用 two() 方法。正确的输出是 “onetwothree”。 注意: 尽管输入中的数字似乎暗示了顺序，但是我们并不保证线程在操作系统中的调度顺序。 你看到的输入格式主要是为了确保测试的全面性。 方法0：用一个mutex与标志位结合(耗时长)执行用时 :4192 ms, 在所有 C++ 提交中击败了5.10%的用户 内存消耗 :9.3 MB, 在所有 C++ 提交中击败了100.00%的用户 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Foo &#123;public: Foo() &#123; flag=1; count=3; &#125; void first(function&lt;void()&gt; printFirst) &#123; while(count&gt;0)&#123; if(flag==1)&#123; mu.lock(); // printFirst() outputs "first". Do not change or remove this line. printFirst(); count--; mu.unlock(); flag=2; &#125; &#125; &#125; void second(function&lt;void()&gt; printSecond) &#123; while(count&gt;0)&#123; if(flag==2)&#123; mu.lock(); // printSecond() outputs "second". Do not change or remove this line. printSecond(); count--; mu.unlock(); flag=3; &#125; &#125; &#125; void third(function&lt;void()&gt; printThird) &#123; while(count&gt;0)&#123; if(flag==3)&#123; mu.lock(); // printThird() outputs "third". Do not change or remove this line. printThird(); count--; mu.unlock(); flag=4; &#125; &#125; &#125; void printFirst()&#123; cout&lt;&lt;"one"; &#125; void printSecond()&#123; cout&lt;&lt;"two"; &#125; void printThird()&#123; cout&lt;&lt;"three"; &#125;private: mutex mu; int flag; int count;&#125;; 方法1：用两个mutex锁一个锁能控制两个线程的执行顺序。这个题中我们需要保持三个函数是按顺序执行的，则需要两个锁m1和m2。 在开始的时候，两个锁都锁起来。first()可以直接执行，second()等待m1释放之后执行，third()等待m2释放之后执行。first()结束之后释放m1，second()结束之后释放m2.因此三个的顺序都协调一致了。 C++代码如下： 执行用时 :8 ms, 在所有 C++ 提交中击败了93.41%的用户 内存消耗 :9.1 MB, 在所有 C++ 提交中击败了100.00%的用户 12345678910111213141516171819202122232425262728293031323334353637383940414243class Foo &#123;private: mutex m1, m2;public: Foo() &#123; m1.lock(); m2.lock(); &#125; void first(function&lt;void()&gt; printFirst) &#123; // printFirst() outputs "first". Do not change or remove this line. printFirst(); m1.unlock(); &#125; void second(function&lt;void()&gt; printSecond) &#123; m1.lock(); // printSecond() outputs "second". Do not change or remove this line. printSecond(); m1.unlock(); m2.unlock(); &#125; void third(function&lt;void()&gt; printThird) &#123; m2.lock(); // printThird() outputs "third". Do not change or remove this line. printThird(); m2.unlock(); &#125;&#125;;void printFirst() &#123; cout &lt;&lt; "first";&#125;void printSecond() &#123; cout &lt;&lt; "second";&#125;void printThird() &#123; cout &lt;&lt; "third";&#125; 方法2：promise/future这也是C++11中的新特性，可以把promise和future当做是在不同线程之间传递值的方式。在某个线程中对promise中生产一个数据，可以在另外一个线程中从future中获取这个数据。 promise和future是绑定在一起的，可以调用promise::get_future()获取与其绑定的future。future.wait()方法对当前的线程进行阻塞，等待与其绑定的promise调用set_value()方法。future.get()方法对当前的线程进行阻塞，等待与其绑定的promise调用set_value()方法的返回值。因此实现线程的同步的方法会很方便。C++代码如下： 执行用时 :16 ms, 在所有 C++ 提交中击败了69.55%的用户 内存消耗 :9.4 MB, 在所有 C++ 提交中击败了100.00%的用户 12345678910111213141516171819202122232425262728293031323334353637383940class Foo &#123;private: std::promise&lt;void&gt; p1; std::promise&lt;void&gt; p2;public: Foo() &#123; &#125; void first(function&lt;void()&gt; printFirst) &#123; // printFirst() outputs "first". Do not change or remove this line. printFirst(); p1.set_value(); &#125; void second(function&lt;void()&gt; printSecond) &#123; p1.get_future().wait(); // printSecond() outputs "second". Do not change or remove this line. printSecond(); p2.set_value(); &#125; void third(function&lt;void()&gt; printThird) &#123; p2.get_future().wait(); // printThird() outputs "third". Do not change or remove this line. printThird(); &#125;&#125;;void printFirst() &#123; cout &lt;&lt; "first";&#125;void printSecond() &#123; cout &lt;&lt; "second";&#125;void printThird() &#123; cout &lt;&lt; "third";&#125; leetcode1115 交替打印FooBar题目描述：我们提供一个类： class FooBar { public void foo() { for (int i = 0; i &lt; n; i++) { print(“foo”); } } public void bar() { for (int i = 0; i &lt; n; i++) { print(“bar”); } }}两个不同的线程将会共用一个 FooBar 实例。其中一个线程将会调用 foo() 方法，另一个线程将会调用 bar() 方法。 请设计修改程序，以确保 “foobar” 被输出 n 次。 示例 1: 输入: n = 1输出: “foobar”解释: 这里有两个线程被异步启动。其中一个调用 foo() 方法, 另一个调用 bar() 方法，”foobar” 将被输出一次。示例 2: 输入: n = 2输出: “foobarfoobar”解释: “foobar” 将被输出两次。 方法：mutex交替加锁执行用时 :28 ms, 在所有 C++ 提交中击败了44.50%的用户 内存消耗 :10.6 MB, 在所有 C++ 提交中击败了100.00%的用户 123456789101112131415161718192021222324252627282930313233343536class FooBar &#123;private: int n; mutex m1,m2;public: FooBar(int n) &#123; this-&gt;n = n; m2.lock(); &#125; void foo(function&lt;void()&gt; printFoo) &#123; for (int i = 0; i &lt; n; i++) &#123; m1.lock(); // printFoo() outputs "foo". Do not change or remove this line. printFoo(); m2.unlock(); &#125; &#125; void bar(function&lt;void()&gt; printBar) &#123; for (int i = 0; i &lt; n; i++) &#123; m2.lock(); // printBar() outputs "bar". Do not change or remove this line. printBar(); m1.unlock(); &#125; &#125; void printFoo()&#123; cout&lt;&lt;"Foo"; &#125; void printBar()&#123; cout&lt;&lt;"Bar"; &#125;&#125;; 3个线程按照123的顺序循环打印一个字符串的每一个字符。本人笔记本测试用了33ms 结合标志位和一个全局的mutex 方法0：比较菜的方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include&lt;thread&gt;#include &lt;mutex&gt;using namespace std;string m_data = "abcdefghijklmnopqrstuvwxyz"; //临界资源1int len = m_data.size();int i = 0; //临界资源2int flag = 0; //临界资源3mutex mu; //不同线程共用一把锁void thread1() &#123; while (i &lt; len) &#123; if (flag == 0) &#123; mu.lock(); cout &lt;&lt; m_data[i++] &lt;&lt; endl; mu.unlock(); flag = 1; //由于每个线程lock之外用的了flag,//所以flag不能在unlock前改变，否则thread2线程可能马上进入if条件内，并抢用没有释放的锁 &#125; &#125;&#125;void thread2() &#123; while (i &lt; len) &#123; if (flag == 1) &#123; mu.lock(); cout &lt;&lt; m_data[i++] &lt;&lt; endl; mu.unlock(); flag = 2; &#125; &#125;&#125;void thread3() &#123; while (i &lt; len) &#123; if (flag == 2) &#123; mu.lock(); cout &lt;&lt; m_data[i++] &lt;&lt; endl; mu.unlock(); flag = 0; &#125; &#125;&#125;int main()&#123; thread tesk01(thread1); thread tesk02(thread2); thread tesk03(thread3); if (tesk02.joinable()) tesk02.join(); if (tesk01.joinable()) tesk01.join(); if (tesk03.joinable()) tesk03.join(); return 0;&#125;]]></content>
      <categories>
        <category>C++基础</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>C++基础</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式事务]]></title>
    <url>%2F2019%2F08%2F20%2F%E5%88%86%E5%B8%83%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[本地事务与分布式事务 两阶段提交协议(2PC)两种常见方案： 基于XA协议的两阶段提交方案交易中间件与数据库通过 XA 接口规范，使用两阶段提交来完成一个全局事务， XA 规范的基础是两阶段提交协议。第一阶段是表决阶段，所有参与者都将本事务能否成功的信息反馈发给协调者；第二阶段是执行阶段，协调者根据所有参与者的反馈，通知所有参与者，步调一致地在所有分支上提交或者回滚。 两阶段提交方案应用非常广泛，几乎所有商业OLTP数据库都支持XA协议。但是两阶段提交方案锁定资源时间长，对性能影响很大，基本不适合解决微服务事务问题。 TCC（Try-Confirm-Cancel）两阶段补偿型方案TCC方案在电商、金融领域落地较多。TCC方案其实是两阶段提交的一种改进。其将整个业务逻辑的每个分支显式的分成了Try、Confirm、Cancel三个操作。Try部分完成业务的准备工作，confirm部分完成业务的提交，cancel部分完成事务的回滚。]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题]]></title>
    <url>%2F2019%2F07%2F30%2FLeetCode%E5%88%B7%E9%A2%98%2F</url>
    <content type="text"><![CDATA[两数之和(1.易)给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 两遍遍历： 1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int, int&gt; m; vector&lt;int&gt; res; for (int i = 0; i &lt; nums.size(); ++i) &#123; m[nums[i]] = i; //先遍历一遍数组，建立HashMap映射 &#125; //然后再遍历一遍，开始查找，找到则记录index for (int i = 0; i &lt; nums.size(); ++i) &#123; int t = target - nums[i]; if (m.count(t) &amp;&amp; m[t] != i) &#123;//if里面的条件用于判断查找到的数字不是第一个数字 res.push_back(i); res.push_back(m[t]); break; &#125; &#125; return res; &#125;&#125;; 一次遍历： 12345678910111213class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int, int&gt; m; for (int i = 0; i &lt; nums.size(); ++i) &#123; if (m.count(target - nums[i])) &#123; return &#123;i, m[target - nums[i]]&#125;; &#125; m[nums[i]] = i; &#125; return &#123;&#125;; &#125;&#125;; 最小因式分解(625. 中)给定一个正整数 a，找出最小的正整数 b 使得 b 的所有数位相乘恰好等于 a。如果不存在这样的结果或者结果不是 32 位有符号整数，返回 0。 样例 1 输入：48输出：68 样例 2 输入：15输出：35 思路： 当该数小于10，直接返回该数，其他数分解出的因数一定是个位数字，即范围是[2, 9]。那我们就可以从大到小开始找因数，首先查找9是否是因数，是要能整除a，就是其因数，如果是的话，就加入到结果res的末尾，a自除以9，我们用while循环查找9，直到取出所有的9，然后取8，7，6…以此类推，如果a能成功的被分解的话，最后a的值应该为1，如果a值大于1，说明无法被分解，返回0。最后还要看我们结果res字符转为整型是否越界，越界的话还是返回0，参见代码如下： 12345678910111213141516class Solution &#123;public: int smallestFactorization(int a) &#123; if (a &lt; 10) return a; long long res = 0, cnt = 1; for (int i = 9; i &gt;= 2; --i) &#123; while (a % i == 0) &#123; res += cnt * i; if (res &gt; INT_MAX) return 0; a /= i; cnt *= 10; &#125; &#125; return (a == 1) ? res : 0; &#125;&#125;; 无重复字符的最长子串(3.中)给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 输入: “abcabcbb”输出: 3解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。示例 2: 输入: “bbbbb”输出: 1解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。示例 3: 输入: “pwwkew”输出: 3解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。 思路：滑动窗口+HashMap ​ 例如”abcabcbb”，让你手动找无重复字符的子串，比如子串a，b，c，然后又出现了一个a，那么此时就应该去掉第一次出现的a，然后继续往后，又出现了一个b，则应该去掉一次出现的b，以此类推，最终发现最长的长度为3。 ​ 用HashMap来建立字符和其出现位置之间的映射。进一步考虑，由于字符会重复出现，到底是保存所有出现的位置呢，还是只记录一个位置？我们之前手动推导的方法实际上是维护了一个滑动窗口，窗口内的都是没有重复的字符，我们需要尽可能的扩大窗口的大小。由于窗口在不停向右滑动，所以我们只关心每个字符最后出现的位置，并建立映射。窗口的右边界就是当前遍历到的字符的位置，为了求出窗口的大小，我们需要一个变量left来指向滑动窗口的左边界，这样，如果当前遍历到的字符从未出现过，那么直接扩大右边界，如果之前出现过，那么就分两种情况，在或不在滑动窗口内，如果不在滑动窗口内，那么就没事，当前字符可以加进来，如果在的话，就需要先在滑动窗口内去掉这个已经出现过的字符了，去掉的方法并不需要将左边界left一位一位向右遍历查找，由于我们的HashMap已经保存了该重复字符最后出现的位置，所以直接移动left指针就可以了。我们维护一个结果res，每次用出现过的窗口大小来更新结果res，就可以得到最终结果啦。 ​ 这里解释下程序中那个if条件语句中的两个条件m.count(s[i]) &amp;&amp; m[s[i]] &gt; left，因为一旦当前字符s[i]在HashMap已经存在映射，说明当前的字符已经出现过了，而若m[s[i]] &gt; left 成立，说明之前出现过的字符在我们的窗口内，那么如果要加上当前这个重复的字符，就要移除之前的那个，所以我们让left赋值为m[s[i]]，由于left是窗口左边界的前一个位置（这也是left初始化为-1的原因，因为窗口左边界是从0开始遍历的），所以相当于已经移除出滑动窗口了。举一个最简单的例子”aa”，当i=0时，我们建立了a-&gt;0的映射，并且此时结果res更新为1，那么当i=1的时候，我们发现a在HashMap中，并且映射值0大于left的-1，所以此时left更新为0，映射对更新为a-&gt;1，那么此时i-left还为1，不用更新结果res，那么最终结果res还为1，正确，代码如下： 解法一： 12345678910111213141516class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; if(s.length()==0) return 0; int res=0,left=-1,len=s.length(); //left代表滑窗左边界元素的前一个元素位置 unordered_map&lt;int,int&gt; m; //key为字符串的每一个字符，value为该字符从左到右遍历过程中最后出现的位置 for(int i=0;i&lt;len;i++)&#123; if(m.count(s[i]) &amp;&amp; m[s[i]]&gt;left) //如果满足字符在m中，并且还在滑动窗口中 left = m[s[i]]; //更新左边界的前一个元素位置 m[s[i]] = i; //更新s[i]对应的位置，及s[i]最后出现的位置 res = max(res,i-left); &#125; return res; &#125;&#125;; 解法二：（本质和解法一完全一样） 解法二是解法一的精简模式，这里我们可以建立一个256位大小的整型数组来代替HashMap，然后我们全部初始化为-1，这样的好处是我们就不用像之前的HashMap一样要查找当前字符是否存在映射对了，对于每一个遍历到的字符，我们直接用其在数组中的值来更新left，因为默认是-1，而left初始化也是-1，所以并不会产生错误，这样就省了if判断的步骤，其余思路都一样： 1234567891011121314class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int m[256]=&#123;-1&#125;; int res = 0, left = -1; for (int i = 0; i &lt; s.size(); ++i) &#123; left = max(left, m[s[i]]); //因为数组m初始值为-1，因此只有//满足其值不为-1（即该字符出现过），并且m[s[i]]大于left的时候才会left = m[s[i]]; m[s[i]] = i; res = max(res, i - left); &#125; return res; &#125;&#125;; 两数相加(2.中)给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 思路： new一个头结点，方便以后的操作 1234567891011121314151617181920212223242526272829303132/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode* preHead = new ListNode(-1); //头结点,方便后续的操作 int carry = 0; ListNode *cur = preHead; while(l1||l2)&#123; int ai = l1 == nullptr ? 0 : l1-&gt;val; //l1对应位置的值，如果不存在，则补0 int bi = l2 == nullptr ? 0 : l2-&gt;val; //同上 int value = (ai + bi + carry) % 10; //求相应加法运算后值 carry = (ai + bi + carry) / 10; //求相应加法运算后进位值 cur-&gt;next = new ListNode(value); //尾插法 //更新 l1 = l1 == nullptr ? nullptr : l1-&gt;next; l2 = l2 == nullptr ? nullptr : l2-&gt;next; cur = cur-&gt;next; &#125; if (carry &gt; 0) //判断最后是否有进位，如果有，多开一个节点 cur-&gt;next = new ListNode(carry); return preHead-&gt;next; &#125;&#125;; 最长回文子串(5.中)给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 输入: “babad”输出: “bab”注意: “aba” 也是一个有效答案。示例 2： 输入: “cbbd”输出: “bb” 思路：参考 方法一：Manacher 算法求最长回文子串: 时间复杂度O(N) 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: string longestPalindrome(string s) &#123; if (s == "") return ""; string str = "@"; string result; int len = s.length(); for (int i = 0; i &lt; len; i++) str = str + "#" + s[i]; str += "#$"; vector&lt;int&gt; p(str.length(), 1); manacher(str, p); int max = 1; int imax; for (int i = 0; i &lt; p.size(); i++) &#123; if (p[i] &gt; max) &#123; max = p[i]; imax = i; &#125; &#125; for (int j = imax - (max - 1); j &lt;= imax + (max - 1); j++) &#123; if (str[j] != '#') result += str[j]; &#125; return result; &#125; void manacher(string&amp; str, vector&lt;int&gt;&amp; p) &#123; int len = str.length(); int id = 0; // id 为已知的 &#123;右边界最大&#125; 的回文子串的中心 int mx = 1; //mx则为id+P[id]，也就是这个子串的右边界 for (int i = 1; i &lt; len - 2; i++) &#123; if (mx &gt; i) p[i] = min(p[2 * id - i], mx - i); //如果mx&gt;i，则分两种情况 else p[i] = 1; //如果mx&lt;i，则无法用之前的p来计算，先置1 for (; str[i + p[i]] == str[i - p[i]]; p[i]++); //统计i对应的p[i] if (mx &lt; i + p[i]) &#123; mx = i + p[i]; //更新右边界 id = i; //更新id &#125; &#125; &#125;&#125;; 方法2：暴力法 n*(n/2)(n2) 时间复杂度O(N^3) 方法3: 动态规划 O(N^2) 反转链表(206. 易)反转一个单链表。 示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL进阶:你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 思路： 迭代法： 123456789101112131415161718192021/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; ListNode *newHead = NULL; while (head) &#123; ListNode *t = head-&gt;next; head-&gt;next = newHead; newHead = head; head = t; &#125; return newHead; &#125;&#125;; 递归法： 12345678910111213141516171819/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if(head == NULL || head-&gt;next == NULL) return head; ListNode* p = reverseList(head-&gt;next); //把head节点之后的所有节点都反转了 head-&gt;next-&gt;next = head; //head-&gt;next为原先head节点后面部分的首节点，反转后变成尾节点，所以他的下一个节点接上head节点，至此整个链表反转完成 head-&gt;next = NULL; //此时head为新链表尾节点，其下一个节点需要置为NULL return p; &#125;&#125;; 最大子数组和(53. 易)给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 思路： 动态规划： dp[i] = max(dp[i-1]+nums[i],nums[i]); //dp[i]代表以位置i元素为结尾的子数组的最大和 然后求出最大的dp[i] 1234567891011121314151617181920212223class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int maxAns; vector&lt;int&gt; dp(n,0); //dp[i]代表以位置i元素为结尾的子数组的最大和 if(n == 0)&#123; return 0; &#125; else if(n == 1)&#123; return nums[0]; &#125; dp[0] = nums[0]; maxAns = nums[0]; for(int i=1;i&lt;n;i++)&#123; dp[i] = max(dp[i-1]+nums[i],nums[i]); if(dp[i] &gt; maxAns)&#123; maxAns = dp[i]; &#125; &#125; return maxAns; &#125;&#125;; 三数之和（15.中）给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]， 满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 思路： ​ 我们对原数组进行排序，然后开始遍历排序后的数组，这里注意不是遍历到最后一个停止，而是到倒数第三个就可以了。这里我们可以先做个剪枝优化，就是当遍历到正数的时候就break，为啥呢，因为我们的数组现在是有序的了，如果第一个要fix的数就是正数了，那么后面的数字就都是正数，就永远不会出现和为0的情况了。然后我们还要加上重复就跳过的处理，处理方法是从第二个数开始，如果和前面的数字相等，就跳过，因为我们不想把相同的数字fix两次。 ​ 对于遍历到的数，用0减去这个fix的数得到一个target，然后只需要再之后找到两个数之和等于target即可。我们用两个指针分别指向fix数字之后开始的数组首尾两个数，如果两个数和正好为target，则将这两个数和fix的数一起存入结果中。然后就是跳过重复数字的步骤了，两个指针都需要检测重复数字。如果两数之和小于target，则我们将左边那个指针i右移一位，使得指向的数字增大一些。同理，如果两数之和大于target，则我们将右边那个指针j左移一位，使得指向的数字减小一些，代码如下： 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt; &gt; res; sort(nums.begin(),nums.end()); //先排序 if(nums.empty()||nums.back()&lt;0||nums.front()&gt;0) return &#123;&#125;; //数组为空、全为正数或者全为负数，结果都返回空 for(int k=0;k&lt;nums.size();++k)&#123; if(nums[k]&gt;0) //当用来计算target的元素大于0的时候，证明后面的两正数之和小于0，不可能的情况 break; if(k&gt;0 &amp;&amp; nums[k]==nums[k-1]) //遇到用来计算target的元素相等的情况，去掉重复 continue; int target = 0-nums[k];//下面一部分其实成了用左右双指针求和为target的两个数。 int i=k+1; int j=nums.size()-1; while(i&lt;j)&#123; if(nums[i]+nums[j]==target)&#123; res.push_back(&#123;nums[k],nums[i],nums[j]&#125;); while(i&lt;j&amp;&amp;nums[i]==nums[i+1]) //去处重复情况 i++; while(i&lt;j&amp;&amp;nums[j]==nums[j-1]) //去处重复情况 j--; i++; j--; &#125; else if(nums[i] + nums[j] &lt; target) i++; else --j; &#125; &#125; return res; &#125;&#125;; 有效的括号(20. 易)给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。 示例 1: 输入: “()”输出: true示例 2: 输入: “()[]{}”输出: true示例 3: 输入: “(]”输出: false示例 4: 输入: “([)]”输出: false示例 5: 输入: “{[]}”输出: true 思路： 这道题让我们验证输入的字符串是否为括号字符串，包括大括号，中括号和小括号。这里我们需要用一个栈，我们开始遍历输入字符串，如果当前字符为左半边括号时，则将其压入栈中，如果遇到右半边括号时，若此时栈为空，则直接返回false，如不为空，则取出栈顶元素，若为对应的左半边括号，则继续循环，反之返回false，代码如下： 123456789101112131415161718class Solution &#123;public: bool isValid(string s) &#123; stack&lt;char&gt; mstack; for(int i=0;i&lt;s.length();i++)&#123; if(s[i] == '('||s[i] == '['||s[i] == '&#123;') mstack.push(s[i]); else&#123; if(mstack.empty()) return false; if(s[i] == ')'&amp;&amp;(mstack.top() != '(')) return false; if(s[i] == ']'&amp;&amp;(mstack.top() != '[')) return false; if(s[i] == '&#125;'&amp;&amp;(mstack.top() != '&#123;')) return false; mstack.pop(); &#125; &#125; return mstack.empty(); &#125;&#125;;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>LeetCode刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL总结]]></title>
    <url>%2F2019%2F07%2F30%2FSTL%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[string字符串类 12345678910111213141516171819202122232425262728293031323334353637#include &lt;string&gt;//1：string对象的定义和初始化以及读写string s1; //默认构造函数，s1为空串string s2(s1); //将s2初始化为s1的一个副本string s3("valuee"); //将s3初始化一个字符串面值副本string s4(n,'c'); //将s4 初始化为字符'c'的n个副本cin&gt;&gt;s5; //读取有效字符到遇到空格getline(cin,s6); //读取字符到遇到换行，空格可读入，知道‘\n’结束（练习在下一个代码中），getline(cin,s7,'a'); //一个直到‘a’结束，其中任何字符包括'\n'都能够读入//2：string对象中一些函数/*------插入函数------包括迭代器操作和下标操作，下标操作更灵活*/s.insert( it , p ); //把字符串p插入到it的位置s.insert(p,n,t)； //迭代器p元素之前插入n个t的副本s.insert(p,b,e); //迭代器p元素之前插入迭代器b到e之间的所有元素s.insert(p,s2,poe2,len); //在下标p之前插入s2下标从poe2开始长度为len的元素s.insert(pos,cp,len); //下标pos之前插入cp数组的前len个元素。/*----------替换函数-------------------*/s.substr(i,j) 截取s串中从i到j的子串 //string::npos 判断字符串是否结束s.replace ( 3 , 3 , " good " ) ; //从第三个起连续三个替换为goods.assign(b,e); //用迭代器b到e范围内的元素替换ss.assign(n,t)； //用n个t的副本替换sa.assign(s1,pos2,len); //从s1的下标pos2开始连续替换len个。/*-----------------------删除函数-----------------------------*/s.erase( 3 )||s.erase ( 0 , 4 ) ; //删除第四个元素或第一到第五个元素/*----------------------其他函数-----------------------------*/s.find ( " cat " ) ; //超找第一个出现的字符串”cat“，返回其下标值，查不到返回 4294967295，也可查找字符；s.append(args); //将args接到s的后面s.compare ( " good " ) ; //s与”good“比较相等返回0，比"good"大返回1，小则返回-1；reverse ( s.begin(), s.end () ); //反向排序函数，即字符串反转函数 vector功能：动态数组,可随机存取 底层实现 ：首先开辟一定大小的数组 随着元素的增加，如果空间不够之后，以原空间大小的2倍重新开辟一块空间， 将就空间的元素挪到新空间上 在继续添加元素，一直遵循每次扩容大小是原空间大小的2倍。 相关用法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;vector&gt;//【1】初始化vector&lt;int&gt; vec; //声明一个int型向量vector&lt;int&gt; vec(10); //声明一个初始大小为10的int向量vector&lt;int&gt; vec(10, 1); //声明一个初始大小为10且值都是1的向量vector&lt;int&gt; vec1(vec); //调用拷贝构造函数vector&lt;int&gt; tmp(vec.begin(), vec.begin() + 3); //用向量vec的第0个到第2个值初始化tmpint array[5] = &#123;1, 2, 3, 4, 5&#125;; vector&lt;int&gt; vec(array, array + 5); //将arr数组的元素用于初始化vec向量//！！！！易错！！！！末尾指针都是指结束元素的下一个元素和vec.end()指针统一vector&lt;int&gt; vec(&amp;arr[1], &amp;arr[4]); //将arr[1]~arr[4]范围内的元素作为vec的初始值//【2】大小操作vec.empty() //判断是否为空vec.size() //输出实际大小vec.max_size() //输出最大容量vec.resize() //重新定义大小,保留适当的容量//【3】插入元素vec.push_back(); //末尾添加元素vec.insert(vec.begin()+i,a); //任意位置插入元素 在第i+1个元素前面插入a//【4】删除元素vec.pop_back(); //末尾删除元素 vec.clear(); //清空向量元素vec.erase (vec.begin()+5); // erase the 6th elementvec.erase (vec.begin(),vec.begin()+3); // erase the first 3 elements: //【7】迭代器vec.begin(); //起始指针：vec.end(); //指向最后一个元素的下一个位置vec.cbegin(); //不能通过这个指针来修改所指的内容，但可以通过其他方式修改的。vec.cend(); //指向常量的末尾指针vec.rbegin() //反向迭代器头vec.rend() //反向迭代器尾vec.crbegin()vec.crend()//【8】元素访问vec[1]; //下标访问，并不会检查是否越界vec.at(1); //at会检查是否越界，会抛出out of range异常vec.front(); //访问第一个元素 vec.back(); //访问最后一个元素vec.swap(vec2); //交换两个向量的元素swap(vec,vec2); list实际上,list容器就是一个双向链表,可以高效地进行插入删除元素。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;list&gt;//构造函数list&lt;int&gt; first; // empty list of intslist&lt;int&gt; second (4,100); // four ints with value 100list&lt;int&gt; third (second.begin(),second.end()); // iterating through secondlist&lt;int&gt; fourth (third); // a copy of third//插入元素a.insert(a.begin(),100); //在a的开始位置（即头部）插入100a.insert(a.begin(),2, 100); //在a的开始位置插入2个100a.insert(a.begin(),b.begin(), b.end());//在a的开始位置插入b从开始到结束的所有位置的元素list.push_back(x) //在链表尾插入元素list.push_front(x) //在链表头插入元素//迭代器list.begin() //获得指向链表尾的指针list.end() //获得指向链表尾（尾的下一个元素）的指针list.rbegin() //获得反向链表的头指针list.rend() //获得反向链表的尾（尾的下一个元素）指针//大小判断list.empty() //判断是否为空，为空，返回truelist.size() //返回list的实际大小list.max_size() //返回list的最大容量//获得元素list.front() //获得头元素list.back() //获得尾元素//删除操作a.erase(a.begin()); //将a的第一个元素删除a.erase(a.begin(),a.end()); //将a的从begin()到end()之间的元素删除。//必须保证不为空list.pop_back() //删除尾元素list.pop_front() //删除头元素list&lt;int&gt; a &#123;6,7,8,9,7,10&#125;; a.remove(7); //删除指定元素//其他操作list.assign(n,value) //list将被改为n个值为value的元素list.resize(x) //将链表改为长为x 超出的部分将被删除swap(a,b) //交换a,b链表的值list.reverse() //将链表倒置a.merge(b) //将链表b添加到链表a的后面//补充以下迭代器的使用//以下是四种迭代器的遍历操作（如果使用C11标准，可以直接使用auto） list&lt;int&gt;::iterator cur1=li.begin(); for(;cur1!=li.end();cur1++)&#123; cout&lt;&lt;*cur1&lt;&lt;" "; &#125; cout&lt;&lt;endl; list&lt;int&gt;::const_iterator cur2=li.cbegin(); for(;cur2!=li.cend();cur2++)&#123; cout&lt;&lt;*cur2&lt;&lt;" "; &#125; cout&lt;&lt;endl;//C11标准 auto cur=li.begin(); for(;cur!=li.end();cur++)&#123; cout&lt;&lt;*cur&lt;&lt;" "; &#125; stack栈 （后进先出） 1234567891011121314151617#include&lt;stack&gt;stack&lt;int&gt; sta;//大小操作sta.empty()sta.size()sta.push(x) //将x加入到栈顶sta.pop() //将栈顶元素弹出sta.top() //返回栈顶元素//C11sta.swap(sta1) //交换栈sta和sta1中的元素sta.emplace(x) //将x放入到栈顶//栈的清空while(!sta.empty()) sta.pop(); queue队列 （先进先出） 1234567891011121314151617#include&lt;queue&gt;queue&lt;int&gt; que;que.size() //返回队列中元素的个数que.empty() //如果为空，返回trueque.front() //返回第一个元素（即队首元素）que.back() //返回队尾元素que.pop() //删除第一个元素que.push(x) //在队尾加入一个元素que.swap(que1) //交换que和que1的元素que.emplace(x) //向队首加入元素//queue不提供清空操作，一般手动实现while(!que.empty()) que.pop(); priority_queue优先队列 (STL中的堆) 12345678910111213141516171819202122232425262728293031323334#include&lt;queue&gt;/** 模板原型：* priority_queue&lt;Type,Container,Functional&gt;*/priority_queue&lt;int&gt; que; //默认是降序的priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; que1; //升序队列priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt;&gt; que2; //降序队列//对于结构体的比较class student &#123; public: string name; int score; student(string na, int sc):name(na), score(sc) &#123;&#125;&#125;;struct cmp &#123; bool operator() (const student&amp; a, const student&amp; b ) &#123; return a.score &gt; b.score; &#125;&#125;;priority_queue&lt;student, vector&lt;student&gt; , cmp&gt; que; //根据成绩从大到小排序//具体操作que.empty();que.size();que.push(x); //加入元素到队尾que.pop(); //从队首删除元素que.top(); //返回队首元素que.emplace(x)que.swap(que1) mapmap对于key是随机存取的 12345678910111213141516171819#include&lt;map&gt;#include &lt;utility&gt; //使用pair与make_pair要包含头文件#include &lt;utility&gt;map&lt;int, int&gt; ma;//必会操作ma.begin(); //返回指向头部的迭代器ma.end(); //返回指向末尾的迭代器ma[i] = A; //插入 Amp.insert(make_pair(i,A)); //插入 Ama.erase(i); //删除 ima.clear(); //删除所有元素ma.find(i); //查找 i (若未找到返回 end())ma.empty(); //如果map为空则返回truema.size(); //返回map中元素的个数ma.swap(); //交换两个mapma.lower_bound(); //返回 &gt;=给定元素的第一个位置ma.upper_bound(); //返回 &gt;给定元素的第一个位置ma.max_size(); //返回可以容纳的最大元素个数 set和map操作几乎一样，只是插入的为key即为value 12345678910111213141516#include&lt;set&gt;set&lt;int&gt; se;//必会操作se.begin(); //返回指向头部的迭代器se.end(); //返回指向末尾的迭代器se.insert(A); //插入 Ase.erase(A); //删除 Ase.clear(); //删除所有元素se.find(i); //查找 i (若未找到返回 end())se.empty();se.size(); se.swap(); //交换两个mapse.lower_bound(); //返回 &gt;=给定元素的第一个位置se.upper_bound(); //返回 &gt;给定元素的第一个位置se.max_size(); //返回可以容纳的最大元素个数 还有 hash_table 没有写，hash_table 是兼顾各项，在元素不 “冲突” 的情况下，上面四个可以，而且速度很快。 unordered_set、unordered_multiset、unordered_map、unordered_multimap 都是以 hash_table 作为底层实现的。所以效率要比 RB_tree 作为底层实现的 set、map、multiset、multimap 高，但是 hash_table 的缺点是没有进行排序。 stack、queue 都是以 deque（双端队列）作为底层实现的，效率问题直接看deque就行。]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>STL总结</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL中的索引]]></title>
    <url>%2F2019%2F07%2F24%2FMySQL%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[索引什么是索引？排好序的快速查询的数据结构，常常类比为字典目录。 优点：大大加快数据的检索速度； 缺点：创建索引和维护索引要花费一定的时间。 索引的分类主键索引（PRIMAY KEY） 普通索引（INDEX） 唯一索引（UNIQUE） 联合索引 InnoDB和MyISAM会自动为主键或者声明为UNIQUE的列去自动建立B+树索引。 主键索引（最常用，最好用自增ID）为表设置了主键，数据库将自动创建主键索引 （一个表只能有一个主键，主键的值不可重复，也不可为空（NULL）。） 普通索引（一表可建多个，尽量避免NULL）注意：可以有NULL，但是尽量避免NULL：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化。因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值。 唯一索引与普通索引类似，不同的是，Mysql的索引列值必须唯一，但普通索引值可重复。 联合索引联合索引即联合若干列组成索引，这种情况下和普通索引类似，可不唯一，可以有NULL，如果加上unique，可以使其为联合唯一索引，如下： 1alter table t_aa add unique index(aa,bb); MySQL中创建和删除索引的语句我们可以在创建表的时候指定需要建立索引的单个列或者建立联合索引的多个列： 1234CREATE TALBE 表名 ( 各种列的信息 ··· , [KEY|INDEX] 索引名 (需要被索引的单个列或多个列)) 其中的KEY和INDEX是同义词，任意选用一个就可以。我们也可以在修改表结构的时候添加索引： 1ALTER TABLE 表名 ADD [INDEX|KEY] 索引名 (需要被索引的单个列或多个列); 也可以在修改表结构的时候删除索引： 1ALTER TABLE 表名 DROP [INDEX|KEY] 索引名; 比方说我们想在创建index_demo表的时候就为c2和c3列添加一个联合索引，可以这么写建表语句： 1234567CREATE TABLE index_demo( c1 INT, c2 INT, c3 CHAR(1), PRIMARY KEY(c1), INDEX idx_c2_c3 (c2, c3)); 在这个建表语句中我们创建的索引名是idx_c2_c3，这个名称可以随便起，不过我们还是建议以idx_为前缀，后边跟着需要建立索引的列名，多个列名之间用下划线_分隔开。 如果我们想删除这个索引，可以这么写： 1ALTER TABLE index_demo DROP INDEX idx_c2_c3; 注意：主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。 各种索引的区别与联系 索引类型 是否要求值唯一 是否要求值不能有NULL 主键索引 是 是 唯一索引 是 否 普通索引 否 否 主键索引与普通索引的区别如果语句是 select from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；如果语句是 select from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。 总结：（1）主键索引查询一次B+树，普通索引有回表操作；（2）主键索引要求列值唯一，且无NULL，普通索引没这两个限制。 主键索引与唯一索引的区别（1）主键索引查询一次B+树，唯一索引有回表操作；（2）主键索引要求列值唯一，且无NULL，唯一索引列值唯一，但是可以有NULL。 索引底层数据结构本文主要参考博客 对于磁道、扇区和磁盘块的理解1 对于磁道、扇区和磁盘块的理解2 磁盘I/O原理扇区与磁盘块(block)的区别磁盘在物理层面上分为磁道，扇区（通常大小为512K），磁盘驱动器操作磁盘数据，硬盘的最小存储单位是扇区，硬盘本身没有block的概念。 文件系统： 文件系统若按照一个扇区一个扇区读数据速度太慢，所以有了block（磁盘块）的概念，是一个块一个块读取的，block才是文件存取的最小单位。通常一个block是4KB，该文件系统中1个块是由连续的8个扇区组成。一个块大小=一个扇区大小*2的n次方。N是可以修改的。 总结：扇区是对硬盘而言，块是对文件系统而言。 索引是帮助MySQL高效获取数据的排好序的数据结构 B树（平衡多路查找树）B-Tree是为磁盘等外存储设备设计的一种平衡查找树。因此在讲B-Tree之前先了解下磁盘的相关知识。 系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。 InnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB存储引擎中默认每个页的大小为16KB，可通过参数innodb_page_size将页的大小设置为4K、8K、16K，在MySQL中可通过如下命令查看页的大小（可以将其设置为4K）： 1mysql&gt; show variables like &apos;innodb_page_size&apos;; 而系统一个磁盘块的存储空间往往没有这么大，因此InnoDB每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小16KB。InnoDB在把磁盘数据读入到内存时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。 B-Tree结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述B-Tree，首先定义一条记录为一个二元组[key, data] ，key为记录的键值，对应表中的主键值，data为一行记录中除主键外的数据。对于不同的记录，key值互不相同。 一棵m阶的B-Tree有如下特性： 每个节点最多有m个孩子。 除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子。 若根节点不是叶子节点，则至少有2个孩子。 所有叶子节点都在同一层，且不包含其它关键字信息。 每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn） 关键字的个数n满足：ceil(m/2)-1 &lt;= n &lt;= m-1 ki(i=1,…n)为关键字，且关键字升序排序。 Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)。 B-Tree中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个3阶的B-Tree： 两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。 模拟查找关键字29的过程： 根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】比较关键字29在区间（17,35），找到磁盘块1的指针P2。根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】比较关键字29在区间（26,30），找到磁盘块3的指针P2。根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】在磁盘块8中的关键字列表中找到关键字29。 分析上面过程，发现需要3次磁盘I/O操作，和3次内存查找操作。由于内存中的关键字是一个有序表结构，可以利用二分法查找提高效率。而3次磁盘I/O操作是影响整个B-Tree查找效率的决定因素。B-Tree相对于AVLTree缩减了节点个数，使每次磁盘I/O取到内存的数据都发挥了作用，从而提高了查询效率。 B+Tree**B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。 从上一节中的B-Tree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。 B+Tree相对于B-Tree有几点不同： 非叶子节点只存储键值信息。 所有叶子节点之间都有一个链指针。 数据记录都存放在叶子节点中。 将上一节中的B-Tree优化，由于B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示： 通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对B+Tree进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。 为什么使用B-Tree（B+Tree）一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是要尽量减少查找过程中磁盘I/O的存取次数。 与红黑树的比较： 红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因： （一）更少的查找次数 平衡树查找操作的时间复杂度和树高 h 相关，O(h)=O(logdN)，其中 d 为每个节点的出度。 红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。 （二）利用磁盘预读特性 为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。 操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。 B+树索引和hash索引的区别hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引。 既然 Hash 索引的效率要比 B-Tree 高很多，为什么大家不都用 Hash 索引而还要使用 B-Tree 索引呢？ Hash 索引本身由于其特殊性也带来了很多限制和弊端，主要有以下这些。 （1）Hash 索引仅仅能满足”=”,”IN”和”&lt;=&gt;”查询，不能使用范围查询。 由于 Hash 索引比较的是进行 Hash 运算之后的 Hash 值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的 Hash 算法处理之后的 Hash 值的大小关系，并不能保证和Hash运算前完全一样。 （2）Hash 索引无法被用来避免数据的排序操作。 由于 Hash 索引中存放的是经过 Hash 计算之后的 Hash 值，而且Hash值的大小关系并不一定和 Hash 运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算； （3）Hash 索引不能利用部分索引键查询。 对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。 （4）Hash 索引在任何时候都不能避免表扫描。 前面已经知道，Hash 索引是将索引键通过 Hash 运算之后，将 Hash运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中，由于不同索引键存在相同 Hash 值**，所以即使取满足某个 Hash 键值的数据的记录条数，也无法从 Hash 索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。当Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。 磁盘存取原理​ 上面说过，索引一般以文件形式存储在磁盘上，索引检索需要磁盘I/O操作。与主存不同，磁盘I/O存在机械运动耗费，因此磁盘I/O的时间消耗是巨大的。 ​ 下图是磁盘的整体结构示意图。 一个磁盘由大小相同且同轴的圆形盘片组成，磁盘可以转动（各个磁盘必须同步转动）。在磁盘的一侧有磁头支架，磁头支架固定了一组磁头，每个磁头负责存取一个磁盘的内容。磁头不能转动，但是可以沿磁盘半径方向运动（实际是斜切向运动），每个磁头同一时刻也必须是同轴的，即从正上方向下看，所有磁头任何时候都是重叠的（不过目前已经有多磁头独立技术，可不受此限制）。 ​ 下图是磁盘结构的示意图。 盘片被划分成一系列同心环，圆心是盘片中心，每个同心环叫做一个磁道，所有半径相同的磁道组成一个柱面。磁道被沿半径线划分成一个个小的段，每个段叫做一个扇区，每个扇区是磁盘的最小存储单元。为了简单起见，我们下面假设磁盘只有一个盘片和一个磁头。 ​ 当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间。 局部性原理与磁盘预读 由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理： ​ 当一个数据被用到时，其附近的数据也通常会马上被使用。 B-/+Tree索引的性能分析​ 到这里终于可以分析B-/+Tree索引的性能了。 ​ 数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧： ​ 每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。 ​ B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。 ​ 综上所述，用B-Tree作为索引结构效率是非常高的。 MySQL索引实现在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的，下面主要讨论MyISAM和InnoDB两个存储引擎的索引实现方式。 MyISAM索引实现MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。下图是MyISAM索引的原理图： 这里设表一共有三列，假设我们以Col1为主键，则上图是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示： InnoDB索引实现​ 虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。 ​ 第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。 ​ 上图是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。 ​ 第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，下图为定义在Col3上的一个辅助索引： 这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。 ​ 了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。 对于InnoDB而言，因为节点下有数据文件，因此节点的分裂将会比较慢。对于InnoDB的主键，尽量用整型，而且是递增的整型。如果是无规律的数据，将会产生页的分裂，影响速度。 InnoDB索引和MyISAM索引的区别：一是主索引的区别，InnoDB的数据文件本身就是索引文件。而MyISAM的索引和数据是分开的。 二是辅助索引的区别：InnoDB的辅助索引data域存储相应记录主键的值而不是地址。而MyISAM的辅助索引和主索引没有多大区别。 InnoDB的主索引文件上，直接存放该行数据，称为聚簇索引。次索引指向对主键的引用。 Myisam中，主索引和次索引都指向物理行。 补充：索引覆盖 索引覆盖是指如果查询的列恰好是索引的一部分，那么查询只需要在索引文件上进行，不需要回行到磁盘再找数据（即不需要回表查找）。这种查询速度非常快，称为“索引覆盖”。 聚簇索引与非聚簇索引1、聚簇索引​ 所谓聚簇索引，就是指主索引文件和数据文件为同一份文件，聚簇索引主要用在Innodb存储引擎中。在该索引实现方式中B+Tree的叶子节点上的data就是数据本身，key为主键，如果是一般索引的话，data便会指向对应的主索引(然后再进行一次索引)，如下图所示： 在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如上图中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。 2、非聚簇索引​ 非聚簇索引就是指B+Tree的叶子节点上的data，并不是数据本身，而是数据存放的地址。主索引和辅助索引没啥区别，只是主索引中的key一定得是唯一的。主要用在MyISAM存储引擎中，如下图： 非聚簇索引比聚簇索引多了一次读取数据的IO操作，所以查找性能上会差。 联合索引联合索引的B+树结构我们用（name，age）这个联合索引来分析 可以看到，索引项是按照索引定义里面出现的字段顺序排序的。 当你的逻辑需求是查到所有名字是“张三”的人时，可以快速定位到 ID4，然后向后遍历得到所有需要的结果。 只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。 基于上面对最左前缀索引的说明，我们来讨论一个问题：在建立联合索引的时候，如何安排索引内的字段顺序。 使用越频繁的字段通常可以放在最左侧。 多个单列索引和联合索引的区别多个单列索引： 多个单列索引在多条件查询时只会生效第一个索引！所以多条件联合查询时最好建联合索引！ where语句查询情况 实际用的索引 a and b and c a a or b or c a,b,c(查询结果有去重) 联合索引本质： 当创建(a,b,c)联合索引时，相当于创建了(a)单列索引，(a,b)联合索引以及(a,b,c)联合索引想要索引生效的话,只能使用 a和a,b和a,b,c三种组合；当然，我们上面测试过，a,c组合也可以，但实际上只用到了a的索引，c并没有用到！生效情况如下表： where语句查询情况 索引 实际用的索引 a 联合索引 a b NULL × c NULL × a and b 联合索引 (a,b) a and c 联合索引 a b and c NULL × a and b and c 联合索引 (a,b,c) 总结：索引的最左原则（左前缀原则），如（c1,c2,c3,c4….cN）的联合索引，where 条件按照索引建立的字段顺序来使用（不代表and条件必须按照顺序来写），如果中间某列没有条件，或使用like会导致后面的列不能使用索引。 （如面试题：现在有a b 作为联合索引，有一条sql语句 where b &gt; 0 and a = 7 和 where a&gt;0 and b = 7分别会用到索引吗？ 会） 最左前缀：顾名思义，就是最左优先，上例中我们创建了lname_fname_age多列索引,相当于创建了(lname)单列索引，(lname,fname)组合索引以及(lname,fname,age)组合索引。 参考博客:多个单列索引和联合索引的区别 索引优化1. 独立的列在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。 例如下面的查询不能使用 actor_id 列的索引： 1SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5; 2. 多列索引在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。 12SELECT film_id, actor_ id FROM sakila.film_actorWHERE actor_id = 1 AND film_id = 1; 3. 索引列的顺序让选择性最强的索引列放在前面。 索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。 例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。 1234SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,COUNT(*)FROM payment; 123 staff_id_selectivity: 0.0001customer_id_selectivity: 0.0373 COUNT(*): 16049 4. 前缀索引对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。 前缀长度的选取需要根据索引选择性来确定。 5. 覆盖索引索引包含所有需要查询的字段的值。 具有以下优点： 索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。 一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。 对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。 索引的优点 大大减少了服务器需要扫描的数据行数。 帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。 将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。 索引的使用条件 对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效； 对于中到大型的表，索引就非常有效； 但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux IO模式及select、poll、epoll]]></title>
    <url>%2F2019%2F07%2F21%2FLinux-IO%E6%A8%A1%E5%BC%8F%E5%8F%8Aselect%E3%80%81poll%E3%80%81epoll%2F</url>
    <content type="text"><![CDATA[转载出处 同步IO和异步IO，阻塞IO和非阻塞IO分别是什么，到底有什么区别？不同的人在不同的上下文下给出的答案是不同的。所以先限定一下本文的上下文。 本文讨论的背景是Linux环境下的network IO。 一 概念说明在进行解释之前，首先要说明几个概念： 用户空间和内核空间 进程切换 进程的阻塞 文件描述符 缓存 I/O 用户空间与内核空间现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。 进程切换为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。 从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化： 保存处理机上下文，包括程序计数器和其他寄存器。 更新PCB信息。 把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。 选择另一个进程执行，并更新其PCB。 更新内存管理的数据结构。 恢复处理机上下文。 注：总而言之就是很耗资源，具体的可以参考这篇文章：进程切换 进程的阻塞正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。当进程进入阻塞状态，是不占用CPU资源的。 文件描述符fd文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。 文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。 缓存 I/O缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。 缓存 I/O 的缺点：数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。 二 IO模式刚才说了，对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段： 等待数据准备 (Waiting for the data to be ready) 将数据从内核拷贝到进程中 (Copying the data from the kernel to the process) 正式因为这两个阶段，linux系统产生了下面五种网络模式的方案。 阻塞 I/O（blocking IO） 非阻塞 I/O（nonblocking IO） I/O 多路复用（ IO multiplexing） 信号驱动 I/O（ signal driven IO） 异步 I/O（asynchronous IO） 注：由于signal driven IO在实际中并不常用，所以我这只提及剩下的四种IO Model。 阻塞 I/O（blocking IO）在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样： 当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。 12&gt; 所以，blocking IO的特点就是在IO执行的两个阶段都被block了。&gt; 非阻塞 I/O（nonblocking IO）linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子： 当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。 12&gt; 所以，nonblocking IO的特点是用户进程需要**不断的主动询问**kernel数据好了没有。&gt; I/O 多路复用（ IO multiplexing）IO multiplexing就是我们说的select，poll，epoll，有些地方也称这种IO方式为event driven IO。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。 当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。 1234&gt; 所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待&gt; 多个文件描述符，而这些文件描述符（套接字描述符）其中的任意&gt; 一个进入读就绪状态，select()函数就可以返回。&gt; 这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。 所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。） 在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。 异步 I/O（asynchronous IO）linux下的asynchronous IO其实用得很少。先看一下它的流程： 用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。 总结blocking和non-blocking的区别调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。 synchronous IO和asynchronous IO的区别在说明synchronous IO和asynchronous IO的区别之前，需要先给出两者的定义。POSIX的定义是这样子的：- A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;- An asynchronous I/O operation does not cause the requesting process to be blocked; 两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。 有人会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。 而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。 各个IO Model的比较如图所示： 通过上面的图片，可以发现non-blocking IO和asynchronous IO的区别还是很明显的。在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。 三 I/O 多路复用之select、poll、epoll详解select，poll，epoll都是IO多路复用的机制。I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。（这里啰嗦下） select1int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述副就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以 通过遍历fdset，来找到就绪的描述符。 select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select的一 个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但 是这样也会造成效率的降低。 poll1int poll (struct pollfd *fds, unsigned int nfds, int timeout); 不同与select使用三个位图来表示三个fdset的方式，poll使用一个 pollfd的指针实现。 12345struct pollfd &#123; int fd; /* file descriptor */ short events; /* requested events to watch */ short revents; /* returned events witnessed */&#125;; pollfd结构包含了要监视的event和发生的event，不再使用select“参数-值”传递的方式。同时，pollfd并没有最大数量限制（但是数量过大后性能也是会下降）。 和select函数一样，poll返回后，需要轮询pollfd来获取就绪的描述符。 从上面看，select和poll都需要在返回后，`通过遍历文件描述符来获取已经就绪的socket`。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。 epollepoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。 一 epoll操作过程epoll操作过程需要三个接口，分别如下： 123int epoll_create(int size)；//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout); 1. int epoll_create(int size);创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大，这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值，参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。当创建好epoll句柄后，它就会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。 int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；函数是对指定描述符fd执行op操作。 epfd：是epoll_create()的返回值。 op：表示op操作，用三个宏来表示：添加EPOLL_CTL_ADD，删除EPOLL_CTL_DEL，修改EPOLL_CTL_MOD。分别添加、删除和修改对fd的监听事件。 fd：是需要监听的fd（文件描述符） epoll_event：是告诉内核需要监听什么事，struct epoll_event结构如下： 12345678910111213struct epoll_event &#123; __uint32_t events; /* Epoll events */ epoll_data_t data; /* User data variable */&#125;;//events可以是以下几个宏的集合：EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；EPOLLOUT：表示对应的文件描述符可以写；EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；EPOLLERR：表示对应的文件描述符发生错误；EPOLLHUP：表示对应的文件描述符被挂断；EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里 3. int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);等待epfd上的io事件，最多返回maxevents个事件。参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。 二 工作模式 epoll对文件描述符的操作有两种模式：LT（level trigger）和ET（edge trigger）。LT模式是默认模式，LT模式与ET模式的区别如下： LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。 ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。 1. LT模式LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。 2. ET模式ET(edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once) ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。 3. 总结假如有这样一个例子： 我们已经把一个用来从管道中读取数据的文件句柄(RFD)添加到epoll描述符 这个时候从管道的另一端被写入了2KB的数据 调用epoll_wait(2)，并且它会返回RFD，说明它已经准备好读取操作 然后我们读取了1KB的数据 调用epoll_wait(2)…… LT模式：如果是LT模式，那么在第5步调用epoll_wait(2)之后，仍然能受到通知。 ET模式：如果我们在第1步将RFD添加到epoll描述符的时候使用了EPOLLET标志，那么在第5步调用epoll_wait(2)之后将有可能会挂起，因为剩余的数据还存在于文件的输入缓冲区内，而且数据发出端还在等待一个针对已经发出数据的反馈信息。只有在监视的文件句柄上发生了某个事件的时候 ET 工作模式才会汇报事件。因此在第5步的时候，调用者可能会放弃等待仍在存在于文件输入缓冲区内的剩余数据。 当使用epoll的ET模型来工作时，当产生了一个EPOLLIN事件后，读数据的时候需要考虑的是当recv()返回的大小如果等于请求的大小，那么很有可能是缓冲区还有数据未读完，也意味着该次事件还没有处理完，所以还需要再次读取： 1234567891011121314151617181920212223while(rs)&#123; buflen = recv(activeevents[i].data.fd, buf, sizeof(buf), 0); if(buflen &lt; 0)&#123; // 由于是非阻塞的模式,所以当errno为EAGAIN时,表示当前缓冲区已无数据可读 // 在这里就当作是该次事件已处理处. if(errno == EAGAIN)&#123; break; &#125; else&#123; return; &#125; &#125; else if(buflen == 0)&#123; // 这里表示对端的socket已正常关闭. &#125; if(buflen == sizeof(buf)&#123; rs = 1; // 需要再次读取 &#125; else&#123; rs = 0; &#125;&#125; Linux中的EAGAIN含义 Linux环境下开发经常会碰到很多错误(设置errno)，其中EAGAIN是其中比较常见的一个错误(比如用在非阻塞操作中)。从字面上来看，是提示再试一次。这个错误经常出现在当应用程序进行一些非阻塞(non-blocking)操作(对文件或socket)的时候。 例如，以 O_NONBLOCK的标志打开文件/socket/FIFO，如果你连续做read操作而没有数据可读。此时程序不会阻塞起来等待数据准备就绪返回，read函数会返回一个错误EAGAIN，提示你的应用程序现在没有数据可读请稍后再试。又例如，当一个系统调用(比如fork)因为没有足够的资源(比如虚拟内存)而执行失败，返回EAGAIN提示其再调用一次(也许下次就能成功)。 三 代码演示下面是一段不完整的代码且格式不对，意在表述上面的过程，去掉了一些模板代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#define IPADDRESS "127.0.0.1"#define PORT 8787#define MAXSIZE 1024#define LISTENQ 5#define FDSIZE 1000#define EPOLLEVENTS 100listenfd = socket_bind(IPADDRESS,PORT);struct epoll_event events[EPOLLEVENTS];//创建一个描述符epollfd = epoll_create(FDSIZE);//添加监听描述符事件add_event(epollfd,listenfd,EPOLLIN);//循环等待for ( ; ; )&#123; //该函数返回已经准备好的描述符事件数目 ret = epoll_wait(epollfd,events,EPOLLEVENTS,-1); //处理接收到的连接 handle_events(epollfd,events,ret,listenfd,buf);&#125;//事件处理函数static void handle_events(int epollfd,struct epoll_event *events,int num,int listenfd,char *buf)&#123; int i; int fd; //进行遍历;这里只要遍历已经准备好的io事件。num并不是当初epoll_create时的FDSIZE。 for (i = 0;i &lt; num;i++) &#123; fd = events[i].data.fd; //根据描述符的类型和事件类型进行处理 if ((fd == listenfd) &amp;&amp;(events[i].events &amp; EPOLLIN)) handle_accpet(epollfd,listenfd); else if (events[i].events &amp; EPOLLIN) do_read(epollfd,fd,buf); else if (events[i].events &amp; EPOLLOUT) do_write(epollfd,fd,buf); &#125;&#125;//添加事件static void add_event(int epollfd,int fd,int state)&#123; struct epoll_event ev; ev.events = state; ev.data.fd = fd; epoll_ctl(epollfd,EPOLL_CTL_ADD,fd,&amp;ev);&#125;//处理接收到的连接static void handle_accpet(int epollfd,int listenfd)&#123; int clifd; struct sockaddr_in cliaddr; socklen_t cliaddrlen; clifd = accept(listenfd,(struct sockaddr*)&amp;cliaddr,&amp;cliaddrlen); if (clifd == -1) perror("accpet error:"); else &#123; printf("accept a new client: %s:%d\n",inet_ntoa(cliaddr.sin_addr),cliaddr.sin_port); //添加一个客户描述符和事件 add_event(epollfd,clifd,EPOLLIN); &#125; &#125;//读处理static void do_read(int epollfd,int fd,char *buf)&#123; int nread; nread = read(fd,buf,MAXSIZE); if (nread == -1) &#123; perror("read error:"); close(fd); //记住close fd delete_event(epollfd,fd,EPOLLIN); //删除监听 &#125; else if (nread == 0) &#123; fprintf(stderr,"client close.\n"); close(fd); //记住close fd delete_event(epollfd,fd,EPOLLIN); //删除监听 &#125; else &#123; printf("read message is : %s",buf); //修改描述符对应的事件，由读改为写 modify_event(epollfd,fd,EPOLLOUT); &#125; &#125;//写处理static void do_write(int epollfd,int fd,char *buf) &#123; int nwrite; nwrite = write(fd,buf,strlen(buf)); if (nwrite == -1)&#123; perror("write error:"); close(fd); //记住close fd delete_event(epollfd,fd,EPOLLOUT); //删除监听 &#125;else&#123; modify_event(epollfd,fd,EPOLLIN); &#125; memset(buf,0,MAXSIZE); &#125;//删除事件static void delete_event(int epollfd,int fd,int state) &#123; struct epoll_event ev; ev.events = state; ev.data.fd = fd; epoll_ctl(epollfd,EPOLL_CTL_DEL,fd,&amp;ev);&#125;//修改事件static void modify_event(int epollfd,int fd,int state)&#123; struct epoll_event ev; ev.events = state; ev.data.fd = fd; epoll_ctl(epollfd,EPOLL_CTL_MOD,fd,&amp;ev);&#125;//注：另外一端我就省了 四 epoll总结在 select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一 个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait() 时便得到通知。(此处去掉了遍历文件描述符，而是通过监听回调的的机制。这正是epoll的魅力所在。) epoll的优点主要是一下几个方面： 监视的描述符数量不受限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左 右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。select的最大缺点就是进程打开的fd是有数量限制的。这对 于连接数量比较大的服务器来说根本不能满足。虽然也可以选择多进程的解决方案( Apache就是这样实现的)，不过虽然linux上面创建进程的代价比较小，但仍旧是不可忽视的，加上进程间数据同步远比不上线程间同步的高效，所以也不是一种完美的方案。 IO的效率不会随着监视fd的数量的增长而下降。epoll不同于select和poll轮询的方式，而是通过每个fd定义的回调函数来实现的。只有就绪的fd才会执行回调函数。 如果没有大量的idle -connection或者dead-connection，epoll的效率并不会比select/poll高很多，但是当遇到大量的idle- connection，就会发现epoll的效率大大高于select/poll。]]></content>
      <categories>
        <category>操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串]]></title>
    <url>%2F2019%2F06%2F29%2FLeetCode-%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[C语言字符串函数参考1 C语言字符串函数参考2 C++语言字符串函数参考 字符串刷题方法字符串循环移位LCS最长递增子序到 去动态规划看字符串全排到Manacher算法KMP模式串匹配 附：BM算法三字母字符串组合 字符串循环左移题目：给定一个字符串S[0..N-1]，要求把S的前k个字符移动到S的尾部，如把字符串“abcdef”前面的2个字符‘a’、b’移动到字符串的尾部，得到新字符串“cdefab”：即字符串循环左移k。多说一句：循环左移n+k位和k位的效果相同，循环左移k位等价于循环右移n-k位。算法要求：时间复杂度为O（n），空间复杂度为O（1）。 分析： 暴力移位法每次循环左移1位，调用k次即可时间复杂度O（kN），空间复杂度O（1） 例如： 123456int temp = S[0];for(int j=0;j&lt;k;j++)&#123; for(int i=1;i&lt;len;i++)&#123; S[i-1] = S[i]; &#125;&#125; 三次拷贝S[0…k]→T[0…k]S[k+1..N-1]→S[0..N-k-1]T[0…k]→S[N-k…N-1]时间复杂度O（N），空间复杂度O（k） 优雅一点的算法(1)（X‘Y’)‘=YX ​ 如：abcdef ​ X=ab X’=ba ​ Y=cdef Y’=fedc ​ （X‘Y’)‘=（bafedc）’ = cdefab (2)时间复杂度O（N），空间复杂度O（1） ​ 该问题会在“完美洗牌”算法中再次遇到。 123456789101112131415//字符串翻转void ReverseString(char* s,int left,int right)&#123; while(left &lt; right)&#123; char tem = s[left]; s[left++] = s[right]; s[right--] = t; &#125; &#125;//n为字符串长度，m为左移多少位void LeftRotateString(char* s,int n,int m)&#123; m %= n; ReverseString(s,0,m-1); ReverseString(s,m,n-1); ReverseString(s,0,n-1);&#125; 该方法特别适合，反转 “I love china”为“china love I” 最长回文子串(leetcode 5)给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 输入: “babad”输出: “bab”注意: “aba” 也是一个有效答案。示例 2： 输入: “cbbd”输出: “bb” 思路：参考 方法一：Manacher 算法求最长回文子串: 时间复杂度O(N) 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: string longestPalindrome(string s) &#123; if (s == "") return ""; string str = "@"; string result; int len = s.length(); for (int i = 0; i &lt; len; i++) str = str + "#" + s[i]; str += "#$"; vector&lt;int&gt; p(str.length(), 1); manacher(str, p); int max = 1; int imax; for (int i = 0; i &lt; p.size(); i++) &#123; if (p[i] &gt; max) &#123; max = p[i]; imax = i; &#125; &#125; for (int j = imax - (max - 1); j &lt;= imax + (max - 1); j++) &#123; if (str[j] != '#') result += str[j]; &#125; return result; &#125; void manacher(string&amp; str, vector&lt;int&gt;&amp; p) &#123; int len = str.length(); int id = 0; // id 为已知的 &#123;右边界最大&#125; 的回文子串的中心 int mx = 1; //mx则为id+P[id]，也就是这个子串的右边界 for (int i = 1; i &lt; len - 2; i++) &#123; if (mx &gt; i) p[i] = min(p[2 * id - i], mx - i); //如果mx&gt;i，则分两种情况 else p[i] = 1; //如果mx&lt;i，则无法用之前的p来计算，先置1 for (; str[i + p[i]] == str[i - p[i]]; p[i]++); //统计i对应的p[i] if (mx &lt; i + p[i]) &#123; mx = i + p[i]; //更新右边界 id = i; //更新id &#125; &#125; &#125;&#125;; 方法2：暴力法 n*(n/2)(n2) 时间复杂度O(N^3) 方法3: 动态规划 O(N^2) KMP算法-实现 strStr() 函数（leetcode-28）KMP算法重点是求next数组： KMP经典参考文章 时间复杂度O(M+N)O(M+N) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123;public: vector&lt;int&gt; getnext(string str) &#123; int len=str.size(); vector&lt;int&gt; next; next.push_back(-1);//next数组初值为-1 int j=0,k=-1; while(j&lt;len-1) &#123; if(k==-1||str[j]==str[k])//str[j]后缀 str[k]前缀 &#123; j++; k++; next.push_back(k); &#125; else &#123; k=next[k]; &#125; &#125; return next; &#125; int strStr(string haystack, string needle) &#123; if(needle.empty()) return 0; int i=0;//源串 int j=0;//子串 int len1=haystack.size(); int len2=needle.size(); vector&lt;int&gt; next; next=getnext(needle); while((i&lt;len1)&amp;&amp;(j&lt;len2)) &#123; if((j==-1)||(haystack[i]==needle[j])) &#123; i++; j++; &#125; else &#123; j=next[j];//获取下一次匹配的位置 &#125; &#125; if(j==len2) return i-j; return -1; &#125;&#125;; 库函数解法： 12345678910class Solution &#123;class Solution &#123;public: int strStr(string haystack, string needle) &#123; if(needle.empty()) return 0; int pos=haystack.find(needle); return pos; &#125;&#125;; 剑指offer目录 题目 难度 15.二进制中1的个数.note ☆ 要考虑到负数这种情况，右移数还是左移相与的数？ 38.字符串的排列.note ☆☆ 采用递归回溯的方式实现，要考虑字符的重复，输出结果是否为字典序。 43.1~n整数中1出现的次数.note ☆☆☆ 设定整数点（如1、10、100等等）作为位置点i，求每个位置点为1时的数有多少个，再算出所有情况 //根据设定的整数位置，对n进行分割，分为两部分，高位n/i，低位n%i 把数组排成最小的数.note ☆☆ 要会用数字转字符串函数 to_string(number1),会写sort()的cmp函数。 49.丑数.note ☆☆☆ 一个丑数的因子只有2,3,5，那么丑数p = 2 ^ x 3 ^ y 5 ^ z 50.第一次只出现一次的字符.note ☆☆ 采用hash思想，用int map[256]统计字符串中字符的个数，然后从头遍历字符串，到map[256]中寻找对应值，如果为1，则返回。 50(2).字符流中第一个只出现一次的字符.note ☆☆ 和上题类似，只是字符串S和map[256]作为类的成员变量，每次调用insert()函数时，从字符流中添加一个字符到S的结尾，同时，更新map[256]中对应位，findFirst()仍然按照字符串顺序，遍历map数组。 求1+2+…+n.note ☆☆ 采用递归代替循环，用&amp;&amp;代替if条件语句。 把字符串转换成整数.note ☆☆ (1)字符串指针是否为空，字符串长度是否为0；(2)考虑字符串的正负，正数要考虑带不带正号；(3)确保除了符号位以外所有的字符必须都是0~9之间的几个字符，否则返回0. 19.正则表达式匹配.note ☆☆☆ 分多种情况考虑，具体分析见链接 58(2).左旋转字符串.note ☆ 主要熟悉下string类的一些函数的操作2.16 C++ string类详解.note 5.替换空格.note ☆☆ 在同一个字符数组中，通过两个指针进行空格和%20的替换。 二进制中1的个数题目描述 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 知识补充： 左移运算符m&lt;&lt;n，在左移n位时候，最左边n位丢弃，同时在最右边补上n个0； m&gt;&gt;n时分两种情况：(1)无符号数，用0填补最左边n位； （2）有符号数，则右移之后数字的符号位填补最左侧的n位。 如：00001010&gt;&gt;2 = 00000010 10001010&gt;&gt;3 = 11110001 思路分析： (1)拿到题目可能第一想法，直接右移(注意：右移比除以2效率高很多)，如果输入的是负数，右移后，最左侧补上的是’1’,从而造成死循环； (2)为了避免死循环，我们不右移输入的数字，而是将其与1,2,4,8…相与，实际采用标志位左移的方式，代码如下： 12345678910111213class Solution &#123;public: int NumberOf1(int n) &#123; int count = 0; int flag = 1; while(flag)&#123; if(n&amp;flag) count++; flag = flag&lt;&lt;1; &#125; return count; &#125;&#125;; 字符串的排列题目描述 输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 输入描述: 输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。 思路：实际上本题需要排除重复情况，结果需要字典排序 思路： (1)将第一个元素与包括自身在内的所有元素交换。 (2)那么第一个元素是固定的，转到下一个元素。 (3)直到最后一个元素固定。输出。 可以参考LeetCode刷题笔记：2.Permutations(中)全排列.note 也可以参考博客: 123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;string&gt; Permutation(string str) &#123; if(str.length() &lt;= 0) return result; permu(str,0); sort(result.begin(),result.end()); return result; &#125; void permu(string str,int begin)&#123; if(begin == str.length()-1) //最后一个字符的自身交换可以不考虑，如果考虑就不减1 result.push_back(str); else&#123; for(int i = begin;i&lt;str.length();i++)&#123; if(begin == i || str[begin] != str[i])&#123; //排除重复的影响 swap(str[begin],str[i]); permu(str,begin+1); swap(str[begin],str[i]); //采用回溯的方法 &#125; &#125; &#125; &#125; void swap(char&amp; a,char&amp; b)&#123; char temp = a; a=b; b=temp; &#125;private: vector&lt;string&gt; result;&#125;; 1~n整数中1出现的次数题目描述 求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。 思路： 设定整数点（如1、10、100等等）作为位置点i（对应n的各位、十位、百位等等），分别对每个数位上有多少包含1的点进行分析，即求每个位置点为1时的数有多少个，再算出所有情况 ​ //根据设定的整数位置，对n进行分割，分为两部分，高位n/i，低位n%i ​ //当i表示百位，且百位对应的数&gt;=2,如n=31456,i=100，则a=314,b=56，此时百位为1的次数有a/10+1=32（最高两位0~31），每一次都包含100个连续的点，即共有(a/10+1)*100个点的百位为1 ​ //当i表示百位，且百位对应的数为1，如n=31156,i=100，则a=311,b=56，此时百位对应的就是1，则共有(a/10)*100+(b+1)个数 ​ //当i表示百位，且百位对应的数为0,如n=31056,i=100，则a=310,b=56，此时百位为1的次数有(a/10)*100个 12345678910111213141516171819class Solution &#123;public: int NumberOf1Between1AndN_Solution(int n) &#123; int count =0; long i=1; for(i=1;i&lt;=n;i*=10)&#123; int a=n/i; int b=n%i; if(a%10 == 0) count = count+(a/10)*i; else if(a%10 &gt;= 2) count = count+(a/10 + 1)*i; else count = count+(a/10)*i+b+1; &#125; return count; &#125;&#125;; 把数组排成最小的数题目描述 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 解题思路 可以看成是一个排序问题，在比较两个字符串S1和S2的大小时，应该比较的是S1+S2和S2+S1的大小，如果S1+S2&lt;S2+S1,那么应该把S1排在前面，否则应该把S2排在前面。 123456789101112131415161718192021class Solution &#123;public: string PrintMinNumber(vector&lt;int&gt; numbers) &#123; int n = numbers.size(); if(n==0)&#123; return ""; &#125; sort(numbers.begin(),numbers.end(),cmp);//核心就一个sort() string result; for(int i=0;i&lt;n;i++)&#123; result += to_string(numbers[i]); &#125; return result; &#125; //如果在类里面定义cmp要设置为静态的，直接放在类外不用这样，可能和sort()的实现有关 static bool cmp(int a,int b)&#123; string A = to_string(a)+to_string(b); string B = to_string(b)+to_string(a); return A &lt; B; &#125;&#125;; 丑数题目描述 把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 思路： 首先从丑数的定义我们知道，一个丑数的因子只有2,3,5，那么丑数p = 2 ^ x 3 ^ y 5 ^ z，换句话说一个丑数一定由另一个丑数乘以2或者乘以3或者乘以5得到，那么我们从1开始乘以2,3,5，就得到2,3,5三个丑数，在从这三个丑数出发乘以2,3,5就得到4，6,10,6，9,15,10,15,25九个丑数，我们发现这种方法会得到重复的丑数，而且我们题目要求第N个丑数，这样的方法得到的丑数也是无序的。那么我们可以维护三个队列： （1）丑数数组： 1 乘以2的队列：2 乘以3的队列：3 乘以5的队列：5 选择三个队列头最小的数2加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列； （2）丑数数组：1,2 乘以2的队列：4 乘以3的队列：3，6 乘以5的队列：5，10 选择三个队列头最小的数3加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列； （3）丑数数组：1,2,3 乘以2的队列：4,6 乘以3的队列：6,9 乘以5的队列：5,10,15 选择三个队列头里最小的数4加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列； （4）丑数数组：1,2,3,4 乘以2的队列：6，8 乘以3的队列：6,9,12 乘以5的队列：5,10,15,20 选择三个队列头里最小的数5加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列； （5）丑数数组：1,2,3,4,5 乘以2的队列：6,8,10， 乘以3的队列：6,9,12,15 乘以5的队列：10,15,20,25 选择三个队列头里最小的数6加入丑数数组，但我们发现，有两个队列头都为6，所以我们弹出两个队列头，同时将12,18,30放入三个队列； …………………… 疑问： 1.为什么分三个队列？ 丑数数组里的数一定是有序的，因为我们是从丑数数组里的数乘以2,3,5选出的最小数，一定比以前未乘以2,3,5大，同时对于三个队列内部，按先后顺序乘以2,3,5分别放入，所以同一个队列内部也是有序的； 2.为什么比较三个队列头部最小的数放入丑数数组？ 因为三个队列是有序的，所以取出三个头中最小的，等同于找到了三个队列所有数中最小的。 实现思路： 我们没有必要维护三个队列，只需要记录三个指针显示到达哪一步；“|”表示指针,arr表示丑数数组； （1）1 |2 |3 |5 目前指针指向0,0,0，队列头arr[0] 2 = 2, arr[0] 3 = 3, arr[0] * 5 = 5 （2）1 2 2 |4 |3 6 |5 10 目前指针指向1,0,0，队列头arr[1] 2 = 4, arr[0] 3 = 3, arr[0] * 5 = 5 （3）1 2 3 2| 4 6 3 |6 9 |5 10 15 目前指针指向1,1,0，队列头arr[1] 2 = 4, arr[1] 3 = 6, arr[0] * 5 = 5 12345678910111213141516171819202122232425class Solution &#123;public: int GetUglyNumber_Solution(int index) &#123; if(index &lt; 7) return index; vector&lt;int&gt; res(index); res[0] =1; int p2=0,p3=0,p5=0; for(int i=1;i&lt;index;i++)&#123; res[i]=min_num(res[p2]*2,res[p3]*3,res[p5]*5); if(res[i] == res[p2]*2) p2++; if(res[i] == res[p3]*3) p3++; if(res[i] == res[p5]*5) p5++; &#125; return res[index -1]; &#125; int min_num(int a,int b,int c)&#123; a = a &lt; b?a:b; a = a &lt; c?a:c; return a; &#125;&#125;; 我所遇到过的错误分析： 在下面代码中，如果用if-else if-else，则会产生重复问题，比如产生两个6,6的重复。 所以一定要用if()….if()…..if()….. 123456789101112131415161718192021222324252627class Solution &#123;public: int GetUglyNumber_Solution(int index) &#123; if (index &lt; 7) return index; vector&lt;int&gt; result(index); result[0] = 1; int p2 = 0; int p3 = 0; int p5 = 0; for (int i = 1; i &lt; index; i++) &#123; result[i] = find_min(result[p2] * 2, result[p3] * 3, result[p5] * 5); if (result[i] == result[p2] * 2) p2++; else if (result[i] == result[p3] * 3) p3++; else p5++; &#125; return result[index - 1]; &#125; int find_min(int a, int b, int c) &#123; a = a &lt; b ? a : b; a = a &lt; c ? a : c; return a; &#125;&#125;; 第一次只出现一次的字符题目描述 在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）. 思路： 用STL中的map或者直接构件一个哈希表，由于本题只需要一个简单的哈希表，因此考虑实现一个简单的哈希表。 每个字母根据其ASCII码值作为数组的下标对应数组的一个数字，而数组中存储的是每个字符出现的次数。这样我们就创建了一个大小为256、以字符ASCII码为键值的哈希表。 1234567891011121314class Solution &#123;public: int FirstNotRepeatingChar(string str) &#123; int map[256] = &#123;0&#125;; for(auto c : str) map[c]++; for(int i = 0; i &lt; str.length(); i++) &#123; if(map[str[i]] == 1) return i; &#125; return -1; &#125;&#125;; 字符流中第一个只出现一次的字符题目描述 请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。 输出描述: 如果当前字符流没有存在出现一次的字符，返回#字符。 思路： 类似于上一题 12345678910111213141516171819202122class Solution&#123;public: //Insert one char from stringstream void Insert(char ch) &#123; s+=ch; hash[ch]++; &#125; //return the first appearence once char in current stringstream char FirstAppearingOnce() &#123; for(int i=0;i&lt;s.length();i++)&#123; if(hash[s[i]] == 1) return s[i]; &#125; return '#'; &#125;private: string s; char hash[256]=&#123;0&#125;;&#125;; 求1+2+…+n题目： 求1+2+…+n，要求不能使用乘除法、for、while、ifelse、switch、case等关键字及条件判断语句（A？B:C）。 思路：采用递归，用&amp;&amp;代替if判断 12345678class Solution &#123;public: int Sum_Solution(int n) &#123; int ans = n; ans&amp;&amp;(ans += Sum_Solution(n-1)); return ans; &#125;&#125;; 把字符串转换成整数题目描述： 将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。 思路：本题主要考察思维严密性，注意以下几点： (1)字符串指针是否为空，字符串长度是否为0； (2)考虑字符串的正负，特别是正数要考虑带不带正号； (3)确保除了符号位以外所有的字符必须都是0~9之间的几个字符，否则返回0. 123456789101112131415161718class Solution &#123;public: int StrToInt(string str) &#123; int len = str.length(); if(len == 0) return 0; int s = (str[0] == '-' ? -1:1); //记录符号正负 int i = ((str[0] == '-')||(str[0] == '+')?1:0); //看字符串前有符号没有 long long result = 0; for(;i&lt;len;i++)&#123; if(str[i]&gt;='0' &amp;&amp; str[i]&lt;='9') //只有每一个单个字符都在0~9之间才合理，否则返回0 result = result*10 + str[i]-'0'; else return 0; &#125; return result*s; //乘以符号位 &#125;&#125;; 正则表达式匹配题目描述 请实现一个函数用来匹配包括’.’和’‘的正则表达式。模式中的字符’.’表示任意一个字符，而’‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但是与”aa.a”和”ab*a”均不匹配 思路： 解这题需要把题意仔细研究清楚其多种情况。 首先通过模式串是否到结尾作为分类标准，分为两类 【1】模式串到结尾了 这种情况根据字符串是否到结尾了又分为两类： (1)如果字符串和模式串都到了结尾，则返回true (2)如果模式串到尾了，字符串还没到尾，肯定匹配失败,返回false 【2】模式串未到结尾 根据模式串当前字符的下一个字符是否为‘*’分为2类： (1)若不为*，该种情况比较简单，比较字符串和模式串，分为当前字符匹配成功与失败2种； (2)若为*，该种情况相对复杂，也是比较字符串和模式串，分为当前字符匹配成功与失败2种； a.若匹配成功，则再分为字符串指针向后移动一位和不考虑模式串此次的成功匹配(考虑模式串出现多次连续与字符串当前位匹配成功的情况)字符串指针不向后移动两种情况，其中字符串指针向后移动一位的情况，又分为模式串指针保持在原位置和向后移动两位。具体如下： 1return matchCore(str+1,pattern+2)||matchCore(str+1,pattern)||matchCore(str,pattern+2); b.若匹配不成功，则，字符串指针保持原位，模式串指针向后移动两位。 为了更加直观说明，各种分类情况如下脑图： 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: bool match(char* str, char* pattern) &#123; if(str == NULL || pattern == NULL) return false; return matchCore(str,pattern); &#125; bool matchCore(char* str, char* pattern)&#123; //如果字符串和模式串都到了结尾，则返回true if(*str == '\0' &amp;&amp; *pattern == '\0') return true; //如果模式串到尾了，字符串还没到尾，肯定匹配失败 if(*str != '\0' &amp;&amp; *pattern == '\0') return false;///!!!!!!!!!上方为模式串到结尾了，下方是模式串未到结尾的所有情况！！！///// if(*(pattern+1) == '*')&#123; //剩下情况以模式串下一个字符是否为*作为分类标准，分两类 //如果当前字符串与模式串匹配上了则分为两种情况：【1】字符串和模式串相等，【2】模式串是‘.’， //且字符串没有到结尾，则继续匹配，字符串指针向后移1位，模式串指针保持原位或者向后2位 //此外还要额外考虑一种情况，如字符串abc 模式串 a*a*bc,即模式串可以匹配成功，但是模式串 //放弃前两位a*，用后面的字符与字符串去匹配，这种情况极易忽略，重点！！！ if(*str == *pattern || (*str != '\0'&amp;&amp;*pattern == '.')) return matchCore(str+1,pattern+2)||matchCore(str+1,pattern)||matchCore(str,pattern+2); else //如果字符串和模式串没配上，继续配，只能认为模式串*字符前一位字符出现0个 return matchCore(str,pattern+2); &#125; else&#123; if(*str == *pattern || (*str != '\0'&amp;&amp;*pattern == '.')) return matchCore(str+1,pattern+1); else return false; &#125; &#125;&#125;; 左旋转字符串本题重点了解字符串string的用法：2.16 C++ string类详解.note 对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。 123456789101112class Solution &#123;public: string LeftRotateString(string str, int n) &#123; int len = str.length(); if(len &lt; n) return str; string temp = str.substr(n); string result = str.substr(0,n); result = temp + result; return result; &#125;&#125;; 替换空格题目描述 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为4We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 思路： 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: void replaceSpace(char *str,int length) &#123; //先判断是否为空字符数组 if(str == NULL || length &lt;= 0) return; //计算字符数组的实际长度(带\0)/////begin//// int trueLength = 0; char* pTemp = str; int count = 0; for(int i=0;str[i] != '\0';i++)&#123; trueLength++; if(str[i] == ' ') count++; &#125; trueLength++; int newlength = count*2+trueLength; //计算字符数组的实际长度(带\0)/////end///// if(newlength &gt; length)//如果替换空格后所需的字符数组长度小于length,则返回 return; //进行替换////begin///// int indexOriginal = trueLength-1; int indexNew = newlength-1; while(indexOriginal &gt;= 0 &amp;&amp; indexNew &gt;= 0)&#123; if(str[indexOriginal] == ' ')&#123; str[indexNew--] = '0'; str[indexNew--] = '2'; str[indexNew--] = '%'; &#125; else&#123; str[indexNew--] = str[indexOriginal]; &#125; indexOriginal--; &#125; //进行替换////end///// &#125;&#125;;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>字符串刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划]]></title>
    <url>%2F2019%2F06%2F29%2FLeetCode-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[最长公共子序列问题(LCS问题)给定两个字符串A和B，长度分别为m和n，要求找出它们最长的公共子序列，并返回子序列。例如： A = “HelloWorld” B = “loop” 当我们要求dp [i] [j]，我们要先判断A的第i个元素B的第j个元素是否相同即判断A[i - 1]和 B[j -1]是否相同，如果相同它就是dp [i-1] [j-1]+ 1，相当于在两个字符串都去掉一个字符时的最长公共子序列再加 1；否则最长公共子序列取dp[i] [j - 1] 和dp[i - 1] [j]中大者。所以整个问题的初始状态为： 1dp[i] [0]=0,dp[0] [j]=0 相应的状态转移方程为： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stdlib.h&gt;using namespace std;void LCS(const char* str1,const char* str2,string&amp; str)&#123; int m = (int)strlen(str1); int n = (int)strlen(str2); vector&lt;vector&lt;char&gt; &gt; dp(m+1, vector&lt;char&gt;(n+1)); //第一步：填二维表格 int i, j; for (i = 0; i &lt;= m; i++)//初始状态 dp[i][0] = 0; for (i = 0; i &lt;= n; i++) dp[0][i] = 0; for (i = 1; i &lt;= m; i++) for (j = 1; j &lt;= n; j++) &#123; if (str1[i - 1] == str2[j - 1])//判断A的第i个字符和B的第j个字符是否相同 dp[i][j] = dp[i - 1][j - 1] + 1; else dp[i][j] = dp[i - 1][j] &gt; dp[i][j - 1]? dp[i - 1][j]: dp[i][j - 1]; &#125;//第二步：从左下角找到朝左上部分遍历，不一定最终到达左上角，只要i或者j等于0则终止 i = m; j = n; while ((i != 0)&amp;&amp;(j != 0)) &#123; if (str1[i-1] == str2[j-1]) &#123; str.push_back(str1[i]); i--; j--; &#125; else &#123; if (dp[i][j - 1] &gt; dp[i - 1][j]) j--; else i--; &#125; &#125; reverse(str.begin(),str.end());&#125;int main() &#123; const char* str1="HelloWorld"; const char* str2 = "loop"; string str; LCS(str1,str2,str); cout &lt;&lt; str.c_str() &lt;&lt; endl; return 0;&#125; 遍历的过程： str1[i-1] == str2[j-1] 成立时，向左上角遍历 不成立时，dp[i] [j - 1] &gt; dp[i - 1] [j] 成立则朝左遍历，否则朝上遍历 最长公共子串问题给定两个字符串A和B，长度分别为m和n，要求找出它们最长的公共子串，并返回其长度。例如： A = “HelloWorld” B = “loop” 子序列和子串的区别：子序列和子串都是字符集合的子集，但是子序列不一定连续，但是子串一定是连续的。同样地，这里只给出动态规划的解法：定义dp[i] [j]表示以A中第i个字符结尾的子串和B中第j个字符结尾的子串的的最大公共子串(其中A中第i个字符和B中第J个字符指)的长度。 当我们要求dp[i] [j]，我们要先判断A的第i个元素B的第j个元素是否相同即判断A[i - 1]和 B[j -1]是否相同，如果相同它就是dp[i - 1] [j- 1] + 1，相当于在两个字符串都去掉一个字符时的最长公共子串再加 1；否则最长公共子串取0。所以整个问题的初始状态为： 1dp[i] [0]=0,dp[0] [j]=0 相应的状态转移方程为： 代码的实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stdlib.h&gt;using namespace std;string findLongest(const char* str1,const char* str2)&#123; int m = (int)strlen(str1); int n = (int)strlen(str2); int result = 0; int imax = 0; int jmax = 0; string str; vector&lt;vector&lt;char&gt; &gt; dp(m+1, vector&lt;char&gt;(n+1)); int i, j; for (i = 0; i &lt;= m; i++)//初始状态 dp[i][0] = 0; for (i = 0; i &lt;= n; i++) dp[0][i] = 0; for (i = 1; i &lt;= m; i++) for (j = 1; j &lt;= n; j++) &#123; if (str1[i - 1] == str2[j - 1]) &#123;//判断A的第i个字符和B的第j个字符是否相同 dp[i][j] = dp[i - 1][j - 1] + 1; if (dp[i][j] &gt; result)//当前dp[i][j]大于result，则更新公共子串最大长度，及其对应坐标 &#123; result = dp[i][j]; imax = i; jmax = j; &#125; &#125; else dp[i][j] = 0; &#125; while (result != 0) &#123; str.push_back(str1[imax-1]); imax--; jmax--; result--; &#125; reverse(str.begin(), str.end()); return str;&#125;int main() &#123; const char* str1="HelloWorld"; const char* str2 = "loop"; string resultStr = findLongest(str1,str2); cout &lt;&lt; resultStr.c_str() &lt;&lt; endl; return 0;&#125; 遍历的过程： 从dp最大的位置沿着左上角遍历result个字符]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>动态规划刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心]]></title>
    <url>%2F2019%2F06%2F24%2FLeetCode-%E8%B4%AA%E5%BF%83%2F</url>
    <content type="text"><![CDATA[总结目录 题目 难度 收获与总结 1.分饼干 易 首先对需求数组g[]和饼干大小数组s[]排序，然后循环遍历，知道其中某一个数组遍历完，循环结束。两个数组都从首元素开始遍历过程中，每次cookie加1，若能够满足其中一个孩子则child加1，遍历完成后，返回child值。 2.摇摆数列 中 画数字升降规律图和用状态机的方法，眼前一亮，方法值得学习借鉴。 3.移除K位数字 中 思路：从最高位向最低位遍历，当对应的数字比下一位数字大，并且在没有剔除完K位数时，则应该剔除该位数，这样才能保证最后的数最小，编程时可以借用栈来实现。此外还要考虑数的开头不能为0的情况，以及遍历完字符串后，仍然没有删除完K位数的情况。 4.用最少的弓箭击爆气球 中 将所有气球区间的左端点从小到大排序，首先以第一个气球所在区间作为射击区间，遍历第二个气球的时候更新该区间，依次不断更新，当遍历到第i个气球时，气球区间左端点大于射击区间右端点，此时设定第二个射击区间，以此类推。 Assign Cookies(易) Assign Cookies 分发饼干 Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj &gt;= gi, we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number. Note: You may assume the greed factor is always positive. You cannot assign more than one cookie to one child. Example 1: Input: [1,2,3], [1,1] Output: 1 Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content. You need to output 1. Example 2: Input: [1,2], [1,2,3] Output: 2 Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. You have 3 cookies and their sizes are big enough to gratify all of the children, You need to output 2. 123456789101112131415161718#include &lt;vector&gt;#include &lt;algorithm&gt;class Solution &#123;public: int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123; std::sort(g.begin(),g.end()); std::sort(s.begin(),s.end()); int child = 0; int cookie = 0; while(child &lt; g.size() &amp;&amp; cookie &lt; s.size())&#123; if(g[child]&lt;=s[cookie])&#123; child++; &#125; cookie++; &#125; return child; &#125;&#125;; Wiggle Subsequence(中)摇摆序列 Wiggle Subsequence A sequence of numbers is called a wiggle sequence if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence. For example, [1,7,4,9,2,5] is a wiggle sequence because the differences (6,-3,5,-7,3) are alternately positive and negative. In contrast, [1,4,7,2,5] and [1,7,4,5,5] are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero. Given a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order. Example 1: Input: [1,7,4,9,2,5] Output: 6 Explanation: The entire sequence is a wiggle sequence. Example 2: Input: [1,17,5,10,13,15,10,5,16,8] Output: 7 Explanation: There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8]. Example 3: Input: [1,2,3,4,5,6,7,8,9] Output: 2 Follow up: Can you do it in O(n) time? 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: int wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() &lt; 2)&#123; return nums.size(); &#125; const int BEGIN = 0; const int UP = 1; const int DOWN = 2; int STATE = BEGIN; int maxLength = 1; for(int i=1;i&lt;nums.size();i++)&#123; switch(STATE)&#123; case BEGIN: if(nums[i]&gt;nums[i-1])&#123; STATE = UP; maxLength++; &#125; else if(nums[i]&lt;nums[i-1])&#123; STATE = DOWN; maxLength++; &#125; break; case UP: if(nums[i]&lt;nums[i-1])&#123; STATE = DOWN; maxLength++; &#125; break; case DOWN: if(nums[i]&gt;nums[i-1])&#123; STATE = UP; maxLength++; &#125; break; &#125; &#125; return maxLength; &#125;&#125;; Remove K Digits(中)移掉K位数字 Remove K Digits Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible. Note: The length of num is less than 10002 and will be ≥ k. The given num does not contain any leading zero. Example 1: Input: num = “1432219”, k = 3 Output: “1219” Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest. Example 2: Input: num = “10200”, k = 1 Output: “200” Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes. Example 3: Input: num = “10”, k = 2 Output: “0” Explanation: Remove all the digits from the number and it is left with nothing which is 0. 自己实现的代码比上述截图稍微简洁点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stack&gt;class Solution &#123;public: string removeKdigits(string num, int k) &#123; std::stack&lt;char&gt; mStack; string ans = ""; for(int i=0;i&lt;num.length();i++)&#123; //当栈不空，且要压入的数字比栈顶数字小，且仍然可以删除数字的时候，while循环继续 while((!mStack.empty()) &amp;&amp; num[i] &lt; mStack.top() &amp;&amp; k&gt;0)&#123; mStack.pop(); k--; &#125; if(num[i] != '0' || (!mStack.empty()))&#123; //防止出现数字字符串以0开头 mStack.push(num[i]); &#125; &#125; //解决当字符串从头遍历到尾，k仍然大于0，如nums= "12345" k=3时，此时弹出末尾比较大的数 while((!mStack.empty()) &amp;&amp; k&gt;0)&#123; //如果栈不空，且仍然可以删除数字 mStack.pop(); k--; &#125; while(!mStack.empty())&#123; //将栈中的每一个char型字符连接为字符串 ans = mStack.top() + ans; mStack.pop(); &#125; if(ans == "")&#123; //根据题目要求，当ans为空字符串时候，返回“0” ans = "0"; &#125; return ans; &#125;&#125;;LeetCode优秀解答，没有用到额外的数据结构，但是纯用数组比较绕！！！class Solution &#123;public: string removeKdigits(string num, int k) &#123; if (num.size()&lt;=k)return "0"; int top=0,count=0,n=num.size(); for (int i=0;i&lt;n;i++)&#123; while (top&gt;0&amp;&amp;count&lt;k&amp;&amp;num[top-1]&gt;num[i])&#123; top--; count++; &#125; num[top++]=num[i]; &#125; top=min(top,n-k); int i=0; for (;i&lt;top;i++)&#123; if (num[i]!='0')break; &#125; if (i==top)return "0"; string res=""; for (;i&lt;top;i++) res+=num[i]; return res; &#125;&#125;; Minimum Number Minimum Number of Arrows to Burst Balloons There are a number of spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it’s horizontal, y-coordinates don’t matter and hence the x-coordinates of start and end of the diameter suffice. Start is always smaller than end. There will be at most 104 balloons. An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with xstart and xend bursts by an arrow shot at x if xstart ≤ x ≤ xend. There is no limit to the number of arrows that can be shot. An arrow once shot keeps travelling up infinitely. The problem is to find the minimum number of arrows that must be shot to burst all balloons. Example: Input: [[10,16], [2,8], [1,6], [7,12]] Output: 2 Explanation: One way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x = 11 (bursting the other two balloons). 12345678910111213141516171819202122232425262728293031#include &lt;algorithm&gt;#include &lt;vector&gt;bool comp(const pair&lt;int, int&gt;&amp; a,const pair&lt;int, int&gt;&amp; b)&#123; return a.first &lt; b.first;&#125;class Solution &#123;public: int findMinArrowShots(vector&lt;pair&lt;int, int&gt;&gt;&amp; points) &#123; if(points.size() == 0)&#123; return 0; &#125; std::sort(points.begin(),points.end(),comp); int arrowNum = 1; int begin = points[0].first; int end = points[0].second; for(int i=1;i&lt;points.size();i++)&#123; if(points[i].first &lt;= end)&#123; begin = points[i].first; if(points[i].second &lt; end)&#123; end = points[i].second; &#125; &#125; else&#123; arrowNum++; begin = points[i].first; end = points[i].second; &#125; &#125; return arrowNum; &#125;&#125;;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>贪心刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈与队列]]></title>
    <url>%2F2019%2F06%2F23%2FLeetCode-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[总结目录 题目 难度 收获与总结 1.用队列实现栈 易 只是push()函数需要修改，每次添加一个数的时候，把队列中原有的数按顺序出队列再进队列。 2.用栈实现队列 易 只有push()函数需要改，用一个临时栈，每次添加一个数的时候，将数据栈中数按照顺序放临时栈中，将要push()的数加入数据栈中后，再将临时栈中的数据按照顺序放回数据栈。 3.实现含有getMin()函数的栈 易 需要改push()和pop()函数，使用两个栈，一个正常放数据，一个记录每个push()和pop()操作对应栈中最小的数。 4.找出数组中第K大的数 易 利用STL中priority_queue(PriorityQueue队列,是基于最小堆原理实现),也可以用STL中的sort()函数先排序。 Implement(实现) Stack using Queues(易) Implement Stack using Queues Implement the following operations of a stack using queues. push(x) — Push element x onto stack. pop() — Removes the element on top of the stack. top() — Get the top element. empty() — Return whether the stack is empty. Example: 1234567MyStack stack = new MyStack();stack.push(1);stack.push(2); stack.top(); // returns 2stack.pop(); // returns 2stack.empty(); // returns false Notes: You must use only standard operations of a queue — which means only push to back, peek/pop from front, size, and is empty operations are valid. Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue. You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack). 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class MyStack &#123;public: /** Initialize your data structure here. */ MyStack() &#123; &#125; /** Push element x onto stack. */ void push(int x) &#123; mQueue.push(x); if(mQueue.size() &gt; 1)&#123; for(int i = 0;i&lt;mQueue.size() -1 ;i++)&#123; mQueue.push(mQueue.front()); mQueue.pop(); &#125; &#125; &#125; /** Removes the element on top of the stack and returns that element. */ int pop() &#123; int a = mQueue.front(); mQueue.pop(); return a; &#125; /** Get the top element. */ int top() &#123; return mQueue.front(); &#125; /** Returns whether the stack is empty. */ bool empty() &#123; return mQueue.empty(); &#125; private: queue&lt;int&gt; mQueue;&#125;; /** * Your MyStack object will be instantiated and called as such: * MyStack obj = new MyStack(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.top(); * bool param_4 = obj.empty(); */ Implement Queue using Stacks(易)\232. Implement Queue using Stacks Implement the following operations of a queue using stacks. push(x) — Push element x to the back of queue. pop() — Removes the element from in front of queue. peek() — Get the front element. empty() — Return whether the queue is empty. Example: 1234567MyQueue queue = new MyQueue();queue.push(1);queue.push(2); queue.peek(); // returns 1queue.pop(); // returns 1queue.empty(); // returns false Notes: You must use only standard operations of a stack — which means only push to top, peek/pop from top, size, and is emptyoperations are valid. Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack. You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue). class MyQueue {public: /* Initialize your data structure here. / MyQueue() { } /** Push element x to the back of queue. */ void push(int x) { std::stacktempStack; while(!mStack.empty()){ tempStack.push(mStack.top()); mStack.pop(); } mStack.push(x); while(!tempStack.empty()){ mStack.push(tempStack.top()); tempStack.pop(); } } /** Removes the element from in front of queue and returns that element. */ int pop() { int a = mStack.top(); mStack.pop(); return a; } /** Get the front element. */ int peek() { return mStack.top(); } /** Returns whether the queue is empty. */ bool empty() { return mStack.empty(); } private: stackmStack; stacktempStack;}; /** Your MyQueue object will be instantiated and called as such: MyQueue obj = new MyQueue(); obj.push(x); int param_2 = obj.pop(); int param_3 = obj.peek(); bool param_4 = obj.empty();*/ Min Stack(易) Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) — Push element x onto stack. pop() — Removes the element on top of the stack. top() — Get the top element. getMin() — Retrieve the minimum element in the stack. Example: 12345678MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; Returns -3.minStack.pop();minStack.top(); --&gt; Returns 0.minStack.getMin(); --&gt; Returns -2. 题目思路：用两个栈，一个正常地存储数据，另一个存储每一步的最小值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class MinStack &#123;public: /** initialize your data structure here. */ MinStack() &#123; &#125; void push(int x) &#123; mStack.push(x); if(minStack.empty())&#123; minStack.push(x); &#125; else&#123; if(x &lt; minStack.top())&#123; minStack.push(x); &#125; else&#123; minStack.push(minStack.top()); &#125; &#125; &#125; void pop() &#123; mStack.pop(); minStack.pop(); &#125; int top() &#123; return mStack.top(); &#125; int getMin() &#123; return minStack.top(); &#125;private: std::stack&lt;int&gt; mStack; std::stack&lt;int&gt; minStack; &#125;;/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */ Kth Largest Element in an Array（易）Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element. Example 1: 12Input: [3,2,1,5,6,4] and k = 2Output: 5 Example 2: 12Input: [3,2,3,1,2,4,5,5,6] and k = 4Output: 4 Note: You may assume k is always valid, 1 ≤ k ≤ array’s length. 思路：直接用STL中的priority_queue（PriorityQueue队列,是基于最小堆原理实现） 12345678910111213class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; priority_queue&lt;int&gt;pQueue; for(int i = 0;i &lt; nums.size();i++)&#123; pQueue.push(nums.at(i)); &#125; for(int i = 0;i &lt; k - 1;i++)&#123; pQueue.pop(); &#125; return pQueue.top(); &#125;&#125;;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>栈与队列刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表]]></title>
    <url>%2F2019%2F06%2F22%2FLeetCode-%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[总结目录 题目 难度 收获与分析 1.两数相加(链表表示的) 中 2.链表逆序 易 采用头插法，通常申请一个ListNode*新的头指针。 3.链表逆序II 中 类似2，只是需要头尾的连接，保存好需要逆序的序列前驱元素指针和后面元素的首节点指针。 4.相交链表 易 方法1：用set,简单，但是需要开辟额外的空间，空间复杂度O(n);方法2：先统计两个链表的长度，然后再遍历。 5.判断链表是否存在环 易 方法1：用set,很好，但是用了额外空间；方法2：用快慢指针法。 6.返回链表环的起始节点 中 类似5，也有两种方法，重点记住，相遇节点和头结点同样速度朝前遍历，相遇的地方，即为环的起始节点。 7.划分链表 中 采用尾插法，额外申请两个ListNode的节点，以及用于遍历的ListNode指针，将节点val小于X的放在一个链表中，另一部分放… 8.合并两个有序链表 易 同7，采用尾插法，额外申请1个ListNode的节点，以及用于遍历的ListNode指针… Add Two Numbers(中)You are given two non-empty linked lists representing two non-negative integers. The digits（数字） are stored（存储） in reverse order （逆序）and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: 123Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. 代码： 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode dummy(-1); //头结点，（自己代码缺少头结点，导致后面不好操作） int carry = 0; ListNode *prev = &amp;dummy; for (ListNode *pa = l1, *pb = l2;pa != nullptr || pb != nullptr; pa = pa == nullptr ? nullptr : pa-&gt;next, pb = pb == nullptr ? nullptr : pb-&gt;next, prev = prev-&gt;next) &#123; const int ai = pa == nullptr ? 0 : pa-&gt;val; const int bi = pb == nullptr ? 0 : pb-&gt;val; const int value = (ai + bi + carry) % 10; carry = (ai + bi + carry) / 10; prev-&gt;next = new ListNode(value); //尾插法 &#125; if (carry &gt; 0) //判断最后是否有进位，如果有，多开一个节点 prev-&gt;next = new ListNode(carry); return dummy.next; &#125;&#125;; 复杂度分析 时间复杂度：O(max(m,n))，假设 m 和 n 分别表示 l1 和 l2 的长度，上面的算法最多重复 max(m,n)次。 空间复杂度：O(max(m,n))， 新列表的长度最多为 max(m,n)+1。 Reverse Linked List（易）反转一个单链表。 示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL进阶:你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 思路分析： 迭代版本： 12345678910111213141516171819202122/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; ListNode* pre = NULL; //反转后的链表头，相对于旧的链表头为pre ListNode* cur = head; //旧的链表头，为当前节点 while(cur)&#123; ListNode* tempNext = cur-&gt;next; //临时存储旧链表头的下一个节点 cur-&gt;next = pre; //旧链表头指向新链表头 pre = cur; //新链表头指针pre朝前移动一位 cur = tempNext; //旧链表头更新为旧链表头的下一位 &#125; return pre; &#125;&#125;; 递归版本： 12345678910111213141516171819/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if(head == NULL || head-&gt;next == NULL) return head; ListNode* p = reverseList(head-&gt;next); //从第二个节点开始反转 head-&gt;next-&gt;next = head; //上一步第二个节点反转完了应该处在链表尾，这个时候他的下一个节点接上head节点 head-&gt;next = NULL; //head-&gt;next信息清掉 return p; &#125;&#125;; 2.在剑指offer上给出的是在不改变链表的结构情况下，逆序打印链表，分用栈和递归两种方式实现 (1)用栈来实现链表的逆序打印 (2)用递归实现 1234567891011121314151617181920212223242526272829303132333435// 面试题6：从尾到头打印链表// 题目：输入一个链表的头结点，从尾到头反过来打印出每个结点的值。#include "..\Utilities\List.h"#include &lt;stack&gt;void PrintListReversingly_Iteratively(ListNode* pHead)&#123; std::stack&lt;ListNode*&gt; nodes; ListNode* pNode = pHead; while(pNode != nullptr) &#123; nodes.push(pNode); pNode = pNode-&gt;m_pNext; &#125; while(!nodes.empty()) &#123; pNode = nodes.top(); printf("%d\t", pNode-&gt;m_nValue); nodes.pop(); &#125;&#125;void PrintListReversingly_Recursively(ListNode* pHead)&#123; if(pHead != nullptr) &#123; if (pHead-&gt;m_pNext != nullptr) &#123; PrintListReversingly_Recursively(pHead-&gt;m_pNext); &#125; printf("%d\t", pHead-&gt;m_nValue); &#125;&#125; Reverse Linked List II（中）链表逆序II \92. Reverse Linked List II Reverse a linked list from position m to n. Do it in one-pass. Note: 1 ≤ m ≤ n ≤ length of list. Example: Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4 Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL 12345678910111213141516171819202122232425262728293031323334353637/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseBetween(ListNode* head, int m, int n) &#123; int reverseLength = n - m + 1; ListNode* pre_head = NULL; ListNode* modify_list_tail = NULL; ListNode* new_head = NULL; ListNode* ans_head = head; while(head &amp;&amp; --m)&#123; pre_head = head; head = head-&gt;next; &#125; modify_list_tail = head; while(head &amp;&amp; reverseLength--)&#123; ListNode* next = head-&gt;next; head-&gt;next = new_head; new_head = head; head = next; &#125; modify_list_tail-&gt;next = head; if(pre_head)&#123; //pre_head为真代表m&gt;1 pre_head-&gt;next = new_head; &#125; else&#123; ans_head = new_head; &#125; return ans_head; &#125;&#125;; Intersection(交点) of Two Linked相交链表 Intersection(交点) of Two Linked Lists Write a program to find the node at which the intersection of two singly linked lists begins. For example, the following two linked lists: 12345A: a1 → a2 ↘ c1 → c2 → c3 ↗ B: b1 → b2 → b3 begin to intersect at node c1. Notes: If the two linked lists have no intersection at all, return null. The linked lists must retain(保持) their original structure after the function returns. You may assume（假定） there are no cycles anywhere in the entire linked structure. Your code should preferably run in O(n) time and use only O(1) memory. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; *///用来计算链表的长度int listLength(ListNode *head)&#123; int len = 0; while(head)&#123; head = head-&gt;next; len++; &#125; return len;&#125;//用来返回两个已知长度的链表的相交点的指针ListNode *findIntersection(ListNode *headL, ListNode *headS,int lengthL,int lengthS)&#123; int lengthDelt = 0; lengthDelt = lengthL-lengthS; while(headL &amp;&amp; lengthDelt--)&#123; headL = headL-&gt;next; &#125; while(headS)&#123; if(headL == headS)&#123; return headL; &#125; headL = headL-&gt;next; headS = headS-&gt;next; &#125; return NULL;&#125;class Solution &#123;public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; int lengthA,lengthB; lengthA = listLength(headA); lengthB = listLength(headB); ListNode *ans; if(lengthA &gt; lengthB)&#123; ans = findIntersection(headA, headB,lengthA,lengthB); &#125; else&#123; ans = findIntersection(headB, headA,lengthB,lengthA); &#125; return ans; &#125;&#125;; Linked List Cycle(易)\141. Linked List Cycle Given a linked list, determine if it has a cycle in it. Follow up: Can you solve it without using extra space? 自己做法，用STL中的set,用了额外的空间。 123456789101112131415161718192021222324/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool hasCycle(ListNode *head) &#123; std::set&lt;ListNode*&gt;node_set; int num = 0; while(head)&#123; num++; node_set.insert(head); if(node_set.size() != num)&#123; return true; &#125; head = head-&gt;next; &#125; return false; &#125;&#125;; 快慢指针的实现方法如下（思想讲解可参考6中）： 123456789 Node *slow = head, *fast = head; while (slow &amp;&amp; fast &amp;&amp; fast-&gt;next) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; if (slow == fast) return true; &#125; return false;&#125; Linked List Cycle II（中） Given a linked list, return the node where the cycle begins. If there is no cycle, return null. Note: Do not modify the linked list. Follow up: Can you solve it without using extra space? 自己做法，用STL中的set,用了额外的空间，和5几乎一样。 123456789101112131415161718192021222324/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; std::set&lt;ListNode*&gt;node_set; int num = 0; while(head)&#123; num++; node_set.insert(head); if(node_set.size() != num)&#123; return head; &#125; head = head-&gt;next; &#125; return NULL; &#125;&#125;; 经典方法：快慢指针法 12345678910111213141516171819202122232425262728293031323334/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; ListNode* fast = head; ListNode* low = head; ListNode* meet = NULL; //先求出相遇点的位置 while(fast &amp;&amp; low &amp;&amp; fast-&gt;next)&#123; fast = fast-&gt;next-&gt;next; low = low-&gt;next; if(fast == low)&#123; meet = fast; break; &#125; &#125; //再求出环的交点的位置 while(head &amp;&amp; meet)&#123; if(head == meet)&#123; return head; &#125; head = head-&gt;next; meet = meet-&gt;next; &#125; return NULL; &#125;&#125;; Partition （划分）List(中) Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions. Example: Input: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3 Output: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5 12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* partition(ListNode* head, int x) &#123; ListNode lessHead(0); //设置两个临时节点 ListNode moreHead(0); ListNode* pLess = &amp;lessHead; //设置两个指针用于对两个链表的尾插 ListNode* pMore = &amp;moreHead; while(head)&#123; if(head-&gt;val &lt; x)&#123; pLess-&gt;next = head; pLess = pLess-&gt;next; &#125; else&#123; pMore-&gt;next = head; pMore = pMore-&gt;next; &#125; head = head-&gt;next; &#125; pLess-&gt;next = moreHead.next; pMore-&gt;next = NULL; //此句要加，不然跑不过，纳闷中... return lessHead.next; &#125;&#125;; Merge(合并) Two Sorted Lists(易) Merge Two Sorted Lists Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Example: Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4 Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 12345678910111213141516171819202122232425262728293031323334/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode* newHead = new ListNode(0); ListNode* pTemp = newHead; while(l1 &amp;&amp; l2)&#123; if(l1-&gt;val &lt; l2-&gt;val)&#123; pTemp-&gt;next = l1; l1 = l1-&gt;next; &#125; else&#123; pTemp-&gt;next = l2; l2 = l2-&gt;next; &#125; pTemp = pTemp-&gt;next; &#125; //将比较后某一个原始链表剩余部分直接插到新的链表后方 if(l1)&#123; //如果l1有剩余 pTemp-&gt;next = l1; &#125; if(l2)&#123; pTemp-&gt;next = l2; &#125; return newHead-&gt;next; &#125;&#125;;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>链表刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer-其他]]></title>
    <url>%2F2019%2F06%2F21%2F%E5%89%91%E6%8C%87offer-%E5%85%B6%E4%BB%96%2F</url>
    <content type="text"><![CDATA[目录位运算： 题目 难度 不用加减乘除做加法.note ☆☆ a^b代表不进位的二进制加法，(a&amp;b)&lt;&lt;1为二进制加法所有的进位信息，然后通过循环或者递归，直到进位为0。 扩展题：不使用新的变量，交换两个变量的值 动态规划： 题目 难度 9.变态跳台阶.note ☆ 和动态规划中的跳台阶类似 10.矩形覆盖.note ☆ 从简单例子开始推导，得到状态转移方程和斐波那契数列一致。 思维严密性： 题目 难度 16.数值的整数次方.note ☆ 考虑base正负零，exponent正负零。 不用加减乘除做加法题目： 不用加减乘除做加法 写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。 解析： 首先看十进制是如何做的： 5+7=12，三步走 第一步：相加各位的值，不算进位，得到2。 第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。 第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。 同样我们可以用三步走的方式计算二进制值相加： 5-101，7-111 第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。 第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&amp;111)&lt;&lt;1。 第三步重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&amp;1010)&lt;&lt;1。 继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果。 123456789101112class Solution &#123;public: int Add(int num1, int num2) &#123; while(num2 != 0)&#123; int temp = num1^num2; //二进制不带进位的加法 num2 = (num1 &amp; num2)&lt;&lt;1; //二进制加法的每一位进位情况 num1 = temp; &#125; return num1; //直到进位为0，返回num1 &#125;&#125;; 扩展题目： 不使用新的变量，交换两个变量的值 ①基于加减法 123a = a + b; b = a - b; a = a - b; ②基于异或运算 123a = a ^ b; b = a ^ b; a = a ^ b; 变态跳台阶题目描述 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 思路：动态规划 1234567891011121314151617181920class Solution &#123;public: int jumpFloorII(int number) &#123; vector&lt;int&gt; dp(number+1,0); if(number==0) return 0; else if(number == 1) return 1; else if(number == 2) return 2; dp[0] = 1; dp[1] = 1; dp[2] = 2; for(int i=3;i&lt;=number;i++)&#123; for(int j=0;j&lt;i;j++) dp[i] += dp[j]; &#125; return dp[number]; &#125;&#125;; 矩形覆盖题目描述 我们可以用21的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 思路： 依旧是斐波那契数列 2n的大矩形，和n个21的小矩形 其中target*2为大矩阵的大小 有以下几种情形： 1⃣️ target &lt;= 0 大矩形为&lt;= 2*0,直接return 1； 2⃣️ target = 1大矩形为2*1，只有一种摆放方法，return1； 3⃣️ target = 2 大矩形为2*2，有两种摆放方法，return2； 4⃣️ target = n 分为两步考虑： ​ 第一次摆放一块 2*1 的小矩阵，则摆放方法总共为f(target - 1) 第一次摆放一块1*2的小矩阵，则摆放方法总共为f(target-2) 因为，摆放了一块12的小矩阵（用√√表示），对应下方的12（用××表示）摆放方法就确定了，所以为f(targte-2) 实际是一个动态规划，也是一个斐波那契数列，此处按照斐波那契数列求解; 12345678910111213141516171819202122class Solution &#123;public: int rectCover(int number) &#123; int prepre = 1; int pre = 2; int cur; if(number ==0) return 0; else if(number == 1) return 1; else if(number == 2) return 2; else&#123; for(int i=3;i&lt;=number;i++)&#123; cur = prepre + pre; prepre = pre; pre = cur; &#125; &#125; return cur; &#125;&#125;; 数值的整数次方题目描述 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 思路：重点考察思维的严密性，对于double int 这种数据类型，不能上来就默认为正，分别考虑正、负和零的情况，从而发现以下几种特殊情况： （1）底数为0.0，指数为负数，会导致分母为零的异常； （2）底数为0.0，指数为0，无意义； （3）注意指数分正负两种情况时，数学表达式不同。 优化：常规思路，在循环中，一直底数*底数，但是当指数不太大时可以考虑采用递归的方式实现如下算式，时间复杂度会大大降低。 1234567891011121314class Solution &#123;public: double Power(double base, int exponent) &#123; if(base==0.0) return 0.0; if(exponent == 0) return 1.0; else if(exponent &gt; 0)&#123; return pow(base,exponent); &#125; else return 1.0/pow(base,-exponent); &#125;&#125;;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer-链表、队列与栈]]></title>
    <url>%2F2019%2F06%2F20%2F%E5%89%91%E6%8C%87offer-%E9%93%BE%E8%A1%A8%E3%80%81%E9%98%9F%E5%88%97%E4%B8%8E%E6%A0%88%2F</url>
    <content type="text"><![CDATA[目录 题目 难度 6.从尾到头打印链表.note ☆ 即链表逆序，如果不能改变原始链表结构，可用栈 22.链表中倒数第K个节点.note ☆ 快慢指针法 25.合并两个排序的链表.note ☆ 先获取新链表头(两链表最小的头)，然后按照递增方式连接，最后将某一个剩余一段的链表直接接上。 35.复杂链表的复制.note ☆☆☆ 细心！！分三步：1，复制每个节点，插在其后；2，复制每个旧节点的random到新节点；3.拆分节点。 圆圈中最后剩下的数.note ☆☆☆ 约瑟夫环问题，采用STL中的list构成环形链表。 题目 难度 9.用两个栈实现队列(易).note ☆ 模拟队列先进先出，一个栈存数据，另一个栈临时放数据。 30.包含min函数的栈.note ☆ 设置两个栈，一个存放数据，一个存放每一步数据栈中最小的数。 31.栈的压入、弹出序列.note ☆☆☆ 用一个栈来模拟压入弹出操作。 从尾到头打印链表题目描述 输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 思路分析： 其实本题和链表逆序很类似，链表逆序要求改变链表，采用头插法。此题逆序打印链表，一般理解为不改变链表结构，因此采用栈的结构。 1234567891011121314151617181920212223242526272829/*** struct ListNode &#123;* int val;* struct ListNode *next;* ListNode(int x) :* val(x), next(NULL) &#123;* &#125;* &#125;;*/#include &lt;stack&gt;#include &lt;vector&gt;class Solution &#123;public: vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123; std::stack&lt;ListNode*&gt; nodes; vector&lt;int&gt; mVector; ListNode* pNodes = head; while(pNodes != NULL)&#123; nodes.push(pNodes); pNodes = pNodes-&gt;next; &#125; while(!nodes.empty())&#123; pNodes = nodes.top(); mVector.push_back(pNodes-&gt;val); nodes.pop(); &#125; return mVector; &#125;&#125;; 链表中倒数第K个节点输入一个链表，输出该链表中倒数第k个结点。 思路：快慢指针 123456789101112131415161718192021222324252627/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) &#123; ListNode* fast = pListHead; ListNode* low = pListHead; while(k &gt; 0)&#123; if(fast == NULL)&#123; return NULL; //防止越界错误！！！要加 &#125; fast = fast-&gt;next; k--; &#125; while(fast != NULL)&#123; fast = fast-&gt;next; low = low-&gt;next; &#125; return low; &#125;&#125;; 合并两个排序的链表题目描述 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 非递归代码： 123456789101112131415161718192021222324252627282930313233343536373839/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* Merge(ListNode* pHead1, ListNode* pHead2) &#123; if(pHead1 ==NULL) return pHead2; if(pHead2 == NULL) return pHead1; ListNode* pre_head = new ListNode(0); ListNode* pTemp = pre_head; while(pHead1 !=NULL &amp;&amp; pHead2 != NULL)&#123; if(pHead1-&gt;val &lt; pHead2-&gt;val)&#123; pTemp-&gt;next = pHead1; pHead1 = pHead1-&gt;next; &#125; else&#123; pTemp-&gt;next = pHead2; pHead2 = pHead2-&gt;next; &#125; pTemp = pTemp-&gt;next; &#125; //将比较后某一个原始链表剩余部分直接插到新的链表后方 if(pHead1) pTemp-&gt;next = pHead1; if(pHead2) pTemp-&gt;next = pHead2; ListNode* ans = pre_head-&gt;next; delete pre_head; return ans; &#125;&#125;; 复杂链表的复制题目描述 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） 思路：(在不借助辅助空间的情况下，实现O(n)的时间效率) 分为三步走： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/*struct RandomListNode &#123; int label; struct RandomListNode *next, *random; RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: RandomListNode* Clone(RandomListNode* pHead) &#123; if(pHead == NULL) return NULL; //第一步：遍历链表，复制每个结点，如复制结点A得到A1，将结点A1插到结点A后面； RandomListNode* curNode = pHead; while(curNode != NULL)&#123; RandomListNode* pCloned = new RandomListNode(0); pCloned-&gt;label = curNode-&gt;label; pCloned-&gt;next = curNode-&gt;next; pCloned-&gt;random = NULL; curNode-&gt;next = pCloned; curNode = pCloned-&gt;next; &#125; //第二步：重新遍历链表，复制老结点的随机指针给新结点，如A1.random = A.random.next; curNode = pHead; while(curNode != NULL)&#123; RandomListNode* pCloned = curNode-&gt;next; if(curNode-&gt;random != NULL)&#123; //！！！！很关键的一个判断，不然就出现野指针 pCloned-&gt;random = curNode-&gt;random-&gt;next; &#125; curNode = pCloned-&gt;next; &#125; //第三步：拆分链表，将链表拆分为原链表和复制后的链表 curNode = pHead; RandomListNode* pCloneHead = pHead-&gt;next; while(curNode != NULL)&#123; RandomListNode* pCloneNode = curNode-&gt;next; //临时存放当前节点的下一个指针 curNode-&gt;next = curNode-&gt;next-&gt;next; //原始链表，隔一个节点连接一个 //复制后链表，隔一个节点连接一个，但是要考虑该节点是最后一个的情况 pCloneNode-&gt;next = pCloneNode-&gt;next == NULL?NULL:pCloneNode-&gt;next-&gt;next; curNode = curNode-&gt;next; //移到下一个原始节点 &#125; return pCloneHead; &#125;&#125;; 圆圈中最后剩下的数圆圈中最后剩下的数 题目：0，1，n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。 思路：用约瑟夫环的思想 例如，0、1、2、3、4这5个数字组成一个圆圈（如图6.3所示），从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。 可以用模板库中的std:list来模拟一个环形链表。由于std:：list本身并不是一个环形结构，因此每当迭代器（Iterator）扫描到链表末尾的时候，我们要记得把迭代器移到链表的头部。 123456789101112131415161718192021222324252627class Solution &#123;public: int LastRemaining_Solution(int n, int m) &#123; if (n &lt; 1 || m &lt; 1) return -1; list&lt;int&gt; mlist; for (int i = 0; i &lt; n; i++) mlist.push_back(i); long count = 0; auto it = mlist.begin(); int k = m - 1; while (mlist.size() &gt; 1) &#123; while (k--) &#123; it++; if (it == mlist.end()) it = mlist.begin(); &#125; it = mlist.erase(it); if (it == mlist.end()) it = mlist.begin(); k = m - 1; &#125; return mlist.front(); &#125;&#125;; 用两个栈实现队列(易)题目描述 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 12345678910111213141516171819202122232425class Solution&#123;public: void push(int node) &#123; while(!stack1.empty())&#123; stack2.push(stack1.top()); stack1.pop(); &#125; stack1.push(node); while(!stack2.empty())&#123; stack1.push(stack2.top()); stack2.pop(); &#125; &#125; int pop() &#123; int top = stack1.top(); stack1.pop(); return top; &#125;private: stack&lt;int&gt; stack1; stack&lt;int&gt; stack2;&#125;; 包含min函数的栈题目描述 定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。 12345678910111213141516171819202122232425262728class Solution &#123;public: void push(int value) &#123; dataStack.push(value); if(minStack.empty())&#123; minStack.push(value); &#125; else&#123; if(value &lt; minStack.top()) minStack.push(value); else minStack.push(minStack.top()); &#125; &#125; void pop() &#123; dataStack.pop(); minStack.pop(); &#125; int top() &#123; return dataStack.top(); &#125; int min() &#123; return minStack.top(); &#125;private: std::stack&lt;int&gt; dataStack; std::stack&lt;int&gt; minStack;&#125;; 栈的压入、弹出序列题目描述 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 思路:用一个栈来模拟压入弹出操作。 如果下一个弹出的数字刚好是栈顶数字, 那么直接弹出;如果下一个弹出的数字不在栈顶, 则把压栈序列中还没有入栈的数字压入辅助栈,直到把下一个需要弹出的数字压入栈顶为止;如果所有数字都压入栈后仍然没有找到下一个弹出的数字, 那么该序列不可能是一个弹出序列。 1234567891011121314151617class Solution &#123;public: bool IsPopOrder(vector&lt;int&gt; pushV,vector&lt;int&gt; popV) &#123; if(pushV.size()==0) return false; for(int i=0,j=0;i&lt;pushV.size();i++)&#123; dataStack.push(pushV[i]); while(j&lt;popV.size()&amp;&amp;dataStack.top() == popV[j])&#123; dataStack.pop(); j++; &#125; &#125; return dataStack.empty(); //若压栈完了，没能全部弹出，说明不是弹出序列，反之是 &#125;private: std::stack&lt;int&gt; dataStack;&#125;;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer-树]]></title>
    <url>%2F2019%2F06%2F19%2F%E5%89%91%E6%8C%87offer-%E6%A0%91%2F</url>
    <content type="text"><![CDATA[目录 题目 难度 7.重建二叉树.note ☆☆☆ 采用递归的方式不断找出根节点和左右子树 树的子结构.note ☆☆☆☆ 第一步在树A中找到和B的根结点的值一样的结点R,第二步再判断树A中以R为根节点的子树是不是包含和树B一样的结构。 二叉树的镜像.note ☆☆ 先交换根节点的左右子节点，再将子节点作为根节点进行递归镜像操作。 从上往下打印二叉树.note ☆ 根节点入队列，然后出队列，出队时将其左右孩子入队，循环操作进行队列出队，每次出队将其左右孩子入队。当队列为空时，整棵树层序遍历完毕。 二叉搜索树的后序遍历序列.note ☆☆ BST的后序序列的合法序列是，对于一个序列S，最后一个元素是x （也就是根），如果去掉最后一个元素的序列为T，那么T满足：T可以分成两段，前一段（左子树）小于x，后一段（右子树）大于x，且这两段（子树）都是合法的后序序列。完美的递归定义。 36.二叉搜索树与双向链表.note ☆☆ 改造中序遍历，设置一个pre和cur，将中序遍历打印的过程替换为前后连接pre和cur 二叉树深度.note ☆ 采用尾递归的方式 55.判断树是否为平衡二叉树.note ☆☆ 性质：是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 因此递归函数每次要计算出子树的高度。 重建二叉树题目描述 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 解题思路：采用递归方法 1234567891011121314151617181920212223242526272829/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) &#123; return reConstruct(pre,0,pre.size()-1,vin,0,vin.size()-1); &#125; TreeNode* reConstruct(vector&lt;int&gt; pre,int startPre,int endPre,vector&lt;int&gt; vin,int startIn,int endIn)&#123; if(startPre &gt; endPre||startIn &gt; endIn)&#123; return NULL; &#125; TreeNode* root = new TreeNode(pre[startPre]); for(int i=startIn;i&lt;=endIn;i++)&#123; if(vin[i] == pre[startPre])&#123; root-&gt;left = reConstruct(pre,startPre + 1,startPre+i-startIn,vin,startIn,i-1); root-&gt;right = reConstruct(pre,startPre+i-startIn+1,endPre,vin,i+1,endIn); break; &#125; &#125; return root; &#125;&#125;; 树的子结构题目描述 输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 解题思路 要查找树A中是否存在和树B结构一样的子枘我们可以分为两步：第一步在树A中找到和B的根结点的值一样的结点R,第二步再判断树A中以R为根节点的子树是不是包含和树B一样的结构。 123456789101112131415161718192021222324252627282930313233/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2) //二叉树的前序遍历 &#123; bool result = false; if(pRoot1 != NULL &amp;&amp; pRoot2 != NULL)&#123; if(pRoot1-&gt;val == pRoot2-&gt;val) result = DoseTreeHaveTree2(pRoot1,pRoot2); if(!result) result = HasSubtree(pRoot1-&gt;left,pRoot2); if(!result) result = HasSubtree(pRoot1-&gt;right,pRoot2); &#125; return result; &#125; //判断以pRoot1为根节点的树中是否有以pRoot2为根节点的树 bool DoseTreeHaveTree2(TreeNode* pRoot1, TreeNode* pRoot2)&#123; if(pRoot2 == NULL) return true; if(pRoot1 == NULL || pRoot1-&gt;val != pRoot2-&gt;val) return false; return DoseTreeHaveTree2(pRoot1-&gt;left,pRoot2-&gt;left)&amp;&amp;DoseTreeHaveTree2(pRoot1-&gt;right,pRoot2-&gt;right); &#125;&#125;; 二叉树的镜像题目描述 操作给定的二叉树，将其变换为源二叉树的镜像。 输入描述: 二叉树的镜像定义： 源二叉树 ​ 8 ​ / \ ​ 6 10 / \ / \ 5 7 9 11 镜像二叉树 ​ 8 ​ / \ ​ 10 6 ​ / \ / \ 11 9 7 5 12345678910111213141516171819202122232425/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: void Mirror(TreeNode *pRoot) &#123; if(pRoot != NULL)&#123; TreeNode *temp = pRoot-&gt;left; pRoot-&gt;left = pRoot-&gt;right; pRoot-&gt;right = temp; if(pRoot-&gt;left)&#123; Mirror(pRoot-&gt;left); &#125; if(pRoot-&gt;right)&#123; Mirror(pRoot-&gt;right); &#125; &#125; &#125;&#125;; 从上往下打印二叉树题目描述 从上往下打印出二叉树的每个节点，同层节点从左至右打印。 思路：参考二叉树的递归与非递归遍历（前序、中序、后序、层序） 123456789101112131415161718192021222324252627282930/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: vector&lt;int&gt; PrintFromTopToBottom(TreeNode* root) &#123; vector&lt;int&gt; result; if(root == NULL) return result; mQueue.push(root); while(!mQueue.empty())&#123; TreeNode* temp = mQueue.front(); result.push_back(temp-&gt;val); mQueue.pop(); if(temp-&gt;left) mQueue.push(temp-&gt;left); if(temp-&gt;right) mQueue.push(temp-&gt;right); &#125; return result; &#125;private: queue&lt;TreeNode*&gt; mQueue;&#125;; 二叉搜索树的后序遍历序列题目描述 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 思路： BST的后序序列的合法序列是，对于一个序列S，最后一个元素是x （也就是根），如果去掉最后一个元素的序列为T，那么T满足：T可以分成两段，前一段（左子树）小于x，后一段（右子树）大于x，且这两段（子树）都是合法的后序序列。完美的递归定义 : ) 。 123456789101112131415161718192021class Solution &#123;public: bool VerifySquenceOfBST(vector&lt;int&gt; sequence) &#123; if(sequence.size() == 0) return false; return juge(sequence,0,sequence.size()-1); &#125; bool juge(vector&lt;int&gt; sequence,int left,int right)&#123; if(left &gt;= right) return true; //从右向左寻找右子树所对应的序列 int i=right-1; for(;i&gt;=left &amp;&amp; sequence[i]&gt;sequence[right];i--); for(int j=i;j&gt;=left;j--)&#123; //寻找左子树对应的序列 if(sequence[j]&gt;sequence[right]) return false; &#125; //递归判断左子树和右子树是不是都符合条件，注意最后一个参数为right-1 ！！！ return juge(sequence,left,i)&amp;&amp;juge(sequence,i+1,right-1); &#125;&#125;; 二叉搜索树与双向链表题目描述 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 解题思路： 该结构特点可以类比到双向链表中： 在双向链表中，每个结点也有两个指针，它们分别指向前一个结点和后一个结点。 所以这两种数据结构的结点是一致，二叉搜索树之所以为二叉搜索树，双向链表之所以为双向链表，只是因为两个指针的指向不同而已，通过改变其指针的指向来实现是完全可能的。 具体实现步骤： 原先指向左子结点的指针调整为链表中指向前一个结点的指针，原先指向右子结点的指针调整为链表中指向下一个结点的指针。 具体转换过程：按照中序遍历的方法遍历二叉搜索树，可以将该二叉树分为三个部分：根节点、左子树和右子树，当遍历结点值为4的节点时，将它分为以2为节点的左子树和以6为节点的右子树，并将4的左指针指向值为3的结点，值为3的节点的右指针指向值为4的结点，因为采用的是中序遍历，所以当遍历到根节点的时候，它的左子树已经遍历结束了，所以要对所有的子树采用递归的执行上述操作 12345678910111213141516171819202122232425262728293031323334353637/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: TreeNode* Convert(TreeNode* pRootOfTree) &#123; TreeNode* pre = NULL; Tree2list(pRootOfTree,&amp;pre); //运行完之后pre对应最后一个节点 TreeNode* pHead = pre; while(pHead != NULL &amp;&amp; pHead-&gt;left != NULL) pHead = pHead-&gt;left; return pHead; &#125; void Tree2list(TreeNode* root,TreeNode** pre)&#123; if(root == NULL) return; TreeNode* cur = root; if(cur-&gt;left != NULL) Tree2list(cur-&gt;left,pre); cur-&gt;left = *pre; //当前节点连接前一个节点 if(*pre != NULL) //前一个节点连接当前节点 (*pre)-&gt;right = cur; *pre = cur; //更新当前节点为前一个节点 if(cur-&gt;right != NULL) Tree2list(cur-&gt;right,pre); &#125;&#125;; 二叉树深度题目描述 输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 思路：采用递归的方式 1234567891011121314151617181920/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: int TreeDepth(TreeNode* pRoot) &#123; if(pRoot == NULL) return 0; int lDepth = TreeDepth(pRoot-&gt;left); int rDepth = TreeDepth(pRoot-&gt;right); return lDepth&gt;rDepth?(lDepth+1):(rDepth+1); &#125;&#125;; 判断树是否为平衡二叉树输入一棵二叉树，判断该二叉树是否是平衡二叉树。 平衡二叉树性质：是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 思路： 方法一（不合适，需要重复遍历节点多次，耗时长O(n^2)）） 12345678910bool isBalanced(TreeNode* pRoot)&#123; if(pRoot == NULL) return true; int left = maxDepth(pRoot-&gt;left); int right = maxDepth(pRoot-&gt;right); int diff = left-right; if(diff &lt;-1 || diff &gt;1) return false; return isBalanced(pRoot-&gt;left)&amp;&amp;isBalanced(pRoot-&gt;right);&#125; 方法二： 用后序遍历的方式遍历整棵二叉树。在遍历某节点的左、右子节点之后，我们可以根据它的左、右子节点的深度判断它是不是平衡的，并得到当前节点的深度。当最后遍历到树的根节点的时候，也就判断了整棵二叉树是不是平衡二叉树。 //后续遍历时，遍历到一个节点，其左右子树已经遍历 依次自底向上判断，每个节点只需要遍历一次 123456789101112131415161718192021class Solution &#123;public: bool IsBalanced_Solution(TreeNode* pRoot) &#123; int depth = 0; return isBalanced(pRoot,depth); &#125; bool isBalanced(TreeNode* pRoot,int &amp;depth)&#123; if(pRoot == NULL) return true; int left = 0; int right = 0; if(isBalanced(pRoot-&gt;left,left) &amp;&amp; isBalanced(pRoot-&gt;right,right))&#123; int dif = left-right; if(dif &lt; -1 || dif &gt; 1) return false; depth = left &gt; right?(left+1):(right+1); return true; &#125; return false; &#125;&#125;;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer-数组]]></title>
    <url>%2F2019%2F06%2F18%2F%E5%89%91%E6%8C%87offer-%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[天平与假币有12枚硬币，其中有且只有1枚是假币，其重量与真币不同，但不知是重还是轻。现给定一祭没有砝码的天平，问至少需要多少次称量才能确保找到这枚假币？ 解释： 随机将12枚硬币等分成3份，每份4枚；标记为A、B、C三份。将A放于左侧，B放于右侧，用天平称量A和B，分三种情况：1.天平平衡2.A（左）比B（右）重 3.A（左）比B（右）轻口与2对称，只分析2即可 核心讲解： 理论下界一次天平称量能得到左倾、右倾、平衡3种情况，则把一次称量当成一位编码，该编码是3进制的。问题转换为：需要多少位编码，能够表示12呢？(1)由于12的轻重未知，有两种可能，因此，需要用3进制表示24。 答：假定需要n位，则：3^n &gt;= 24(2)取对数后计算得到n = 2.89，这表示至少3次才能找到该假币。 目录 题目 难度 1.二维数组中的查找(..).note ☆ 从右上角到左下角进行查找 11.旋转数组的最小数字.note ☆☆☆ 采用分治的思想，递归地将数组进行二分区，然后找到最小的数（时间复杂度logn 顺序查找O(n)） 10.斐波那契数列.note ☆ 很简单，考虑节省空间复杂度，用循环代替递归。 21.调整数组顺序使奇数位于偶数前面.note ☆ 用两个指针，一个遍历数组，一个指向存放奇数的位置，都从0开始，偶数暂时放在另一个vector中，先将奇数存放在奇数指针指向的位置，最后再存偶数。 顺时针打印矩阵.note ☆☆ 考虑全面：m×n,m×1,1×n,1×1几种情况都要考虑；流程控制采用top、down、left、right四个变量来控制。 39.数组中出现次数超过一半的数字.note ☆☆ 在遍历数组时保存两个值：一是数组中一个数字，一是次数。遍历下一个数字时，若它与之前保存的数字相同，则次数加1，否则次数减1；若次数为0，则保存下一个数字，并将次数置为1。遍历结束后，所保存的数字即为所求。 40.最小的K个数.note ☆ TOPk问题 52.在排序数组中查找数字.note ☆☆ 考虑查找效率，总体思路是找到第一个K位置和最后一个K的位置，作差加一求出个数。可以采取递归方式二分查找，也可直接通过循环二分查找，不过大神的通过查找K-0.5和K+0.5更加简洁高效。 56.数组中只出现一次的两个数字.note ☆☆ 先将所有数依次异或，结果和两个单一数异或相同，从右开始找到结果中第一个为1的位，以此为标准将数分成两类，再将两类分别异或，得到的就是两个单数。注意大坑！！！ a &amp; flag != 0;和(a &amp; flag) !=0;结果不同。 57(2).和为S的连续正数序列.note ☆☆ 用两个数small和big分别表示序列的最小值和最大值。首先把small初始化为1，big初始化为2。如果从small到big的序列的和大于s，则可以从序列中去掉较小的值，也就是增大small的值。如果从small到big的序列的和小于s，则可以增大big，让这个序列包含更多的数字。因为这个序列至少要有两个数字，我们一直增加small到（1+s）/2为止。 57(1).和为S的两个数字.note ☆☆ 类似与57(2).和为S的连续正数序列.note做法，只不过，只不过本题左指针开始指向数组最左端，右指针指向最右端。 扑克牌顺子.note ☆☆ 第一步：排序；第二步：统计0的个数，统计间隙的个数；第三步:间隙数大于0个数返回false，间隙数小于0的个数，更新0的个数，继续统计后面的数字是否有间隙。同时在此过程中也要统计前后两个数是否有重复情况，重复返回false。 2.数组中重复的数字.note ☆☆ 从头到尾依次扫描数组元素，当扫描到第i个元素m时，当m等于i时，继续遍历下一元素，当不等于i时，则拿他与第m个数n比较，如果m=n，则找到重复元素，返回true,否则交换两元素… 3.构建乘积数组.note ☆☆ 求B[i]的时候分为两步，先求左侧所有的A相乘，再求右侧的所有的A相乘，最终将两者相乘即得相应的B。具体通过两次循环，累乘得到不同的B[i] 二维数组中的查找题目描述 在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 解题思路： 首先选取数组中右上角的数字， 【1】如果该数字等于要查的数字，则查找结束； 【2】如果该数字大于要查找的数字，则剔除该数字所在的列,如(a)； 【3】如果该数字小于要查找的数字，则剔除该数字所在的行，如(c) 代码实现如下： 123456789101112131415161718192021class Solution &#123;public: bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123; int row = array.size(); int col = array[0].size(); int i = 0; int j = col-1; while(i &lt; row &amp;&amp; j &gt;= 0)&#123; if(target &lt; array[i][j])&#123; j--; &#125; else if(target &gt; array[i][j])&#123; i++; &#125; else&#123; return true; &#125; &#125; return false; &#125;&#125;; 旋转数组的最小数字题目描述 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 思路： 正常情况： 特殊情况： （1）数组为排序好的数组，发现arry[left] &lt; arry[right]则认为是排序好的数组，去首元素返回； （2）arry[left] = arry[right] = arry[mid]时，用顺序遍历查找，如下 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123; int n = rotateArray.size(); if(n == 0)&#123; return 0; &#125; else if(n == 1)&#123; return rotateArray[0]; &#125; int left = 0; int right = n-1; int mid = 0; //用于特殊情况1：将排序好的数组前面0个元素旋转到后面 while(rotateArray[left] &gt;= rotateArray[right])&#123; if(right - left ==1)&#123; mid = right; break; &#125; mid = (left + right)/2; //特殊情况2：首尾中三个元素大小相等，只能采用顺序查找，如｛1，0，1，1，1｝ 和 ｛1，1， 1，0，1｝ if(rotateArray[left] == rotateArray[right] &amp;&amp; rotateArray[left] == rotateArray[mid]) return minInorder(rotateArray,left,right); if(rotateArray[mid] &gt;= rotateArray[left]) left = mid; else if(rotateArray[mid] &lt;= rotateArray[right]) right = mid; &#125; return rotateArray[mid]; &#125; int minInorder(vector&lt;int&gt; rotateArray,int left,int right)&#123; int result = rotateArray[left]; for(int i=left + 1;i&lt;=right;i++)&#123; if(result &gt; rotateArray[i]) result = rotateArray[i]; &#125; return result; &#125;&#125;; 斐波那契数列题目描述 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39 思路： 用非递归的方式解题 1234567891011121314151617181920class Solution &#123;public: int Fibonacci(int n) &#123; int last2 = 0; int last1 = 1; int cur; if(n == 0) return 0; else if(n == 1) return 1; else&#123; for(int i=n;i&gt;=2;i--)&#123; cur = last1 + last2; last2 = last1; last1 = cur; &#125; return cur; &#125; &#125;&#125;; 调整数组顺序使奇数位于偶数前面题目描述 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。（书上的方法是顺序可变） 思路： 顺序遍历vector,将偶数放在一个queue里面，遇到奇数按顺序覆盖之前的vector，待vector遍历完了，将queue中的数再放到vector的后面。 1234567891011121314151617181920212223242526#include &lt;queue&gt;class Solution &#123;public: void reOrderArray(vector&lt;int&gt; &amp;array) &#123; queue&lt;int&gt; evenQueue; int n = array.size(); if(n == 0||n==1) return; int oddIndex = 0; for(int i=0;i&lt;n;i++)&#123; if(isEven(array[i]))&#123; evenQueue.push(array[i]); &#125; else&#123; array[oddIndex++] = array[i]; &#125; &#125; while(oddIndex &lt; n)&#123; array[oddIndex++] = evenQueue.front(); evenQueue.pop(); &#125; &#125; bool isEven(int number)&#123; return (number &amp; 1) == 0; &#125;&#125;; 顺时针打印矩阵题目描述 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: vector&lt;int&gt; printMatrix(vector&lt;vector&lt;int&gt; &gt; matrix) &#123; vector&lt;int&gt; result; int row = matrix.size(); if(row == 0) return result; int col = matrix[0].size(); int top = 0; int down = row-1; int left = 0; int right = col-1; while(top &lt;= down &amp;&amp; left &lt;= right)&#123; for(int i=left;i&lt;=right;i++) result.push_back(matrix[top][i]); top++; if(top &gt; down || left &gt; right) break; for(int i=top;i&lt;=down;i++) result.push_back(matrix[i][right]); right--; if(top &gt; down || left &gt; right) break; for(int i=right;i&gt;=left;i--) result.push_back(matrix[down][i]); down--; if(top &gt; down || left &gt; right) break; for(int i=down;i&gt;=top;i--) result.push_back(matrix[i][left]); left++; if(top &gt; down || left &gt; right) break; &#125; return result; &#125;&#125;; 数组中出现次数超过一半的数字题目描述 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 分析： 如果将这个数组排序，那么中位数一定是要求得这数； 思路： 方法一：用sort先排序，然后中间数即为所求；时间复杂度O(nlogn) 方法二：采用用户“分形叶”思路（注意到目标数 超过数组长度的一半，对数组同时去掉两个不同的数字，到最后剩下的一个数就是该数字。如果剩下两个，那么这两个也是一样的，就是结果），在其基础上把最后剩下的一个数字或者两个回到原来数组中，将数组遍历一遍统计一下数字出现次数进行最终判断。 方法三：借鉴快排思想，用时间复杂度为O(n)的partition()函数实现，但是总体的复杂度可能最差时候达到O(n^2) （剑指offer的方法） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Solution &#123;public: int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123; if (numbers.size() &lt;= 0) return 0; int midIndex = numbers.size() &gt;&gt;1; int index = 0; int start = 0; int end = numbers.size() - 1; index = partition(numbers, start, end); while (index != midIndex) &#123; if (index &lt; midIndex) &#123; start = index + 1; index = partition(numbers,start,end); &#125; else&#123; end = end - 1; index = partition(numbers, start, end); &#125; &#125; int result = numbers[midIndex]; if (!isMoreThanHalf(numbers, result)) return 0; return result; &#125; //快排中用于找分界点的函数 int partition(vector&lt;int&gt; numbers, int left, int right)&#123; int pivot = numbers[left]; int start = left; int end = right; while (start != end)&#123; while (start &lt; end &amp;&amp; numbers[end] &gt; pivot) end--; while (start &lt; end &amp;&amp; numbers[start] &lt;= pivot) start++; if (start &lt; end) swap(numbers[start], numbers[end]); &#125; swap(numbers[left], numbers[start]); return start; &#125; void swap(int &amp;a, int &amp;b)&#123; int temp = a; a = b; b = temp; &#125; //检测数组中数是否满足题目中交代的"数组中有一个数字出现的次数超过数组长度的一半"条件 bool isMoreThanHalf(vector&lt;int&gt; numbers, int num)&#123; int times = 0; bool isMoreThanHalf = true; for (int i = 0; i &lt; numbers.size(); i++)&#123; if (numbers[i] == num) times++; &#125; if (times * 2 &lt;= numbers.size())&#123; isMoreThanHalf = false; &#125; return isMoreThanHalf; &#125;&#125;; 方法四：如果有符合条件的数字，则它出现的次数比其他所有数字出现的次数和还要多。在遍历数组时保存两个值：一是数组中一个数字，一是次数。遍历下一个数字时，若它与之前保存的数字相同，则次数加1，否则次数减1；若次数为0，则保存下一个数字，并将次数置为1。遍历结束后，所保存的数字即为所求。然后再判断它是否符合条件即可。 12345678910111213141516171819202122232425262728293031class Solution &#123;public: int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123; if(numbers.empty()) return 0; // 遍历每个元素，并记录次数；若与前一个元素相同，则次数加1，否则次数减1 int result = numbers[0]; int times = 1; // 次数 for(int i=1;i&lt;numbers.size();++i) &#123; if(times == 0) //每次加减times之前都要判断下是否在遍历上一个元素的时候置为0 &#123; result = numbers[i]; times = 1; continue; &#125; if(numbers[i] == result) ++times; // 相同则加1 else --times; // 不同则减1 &#125; // 检测所给的数组是否存在这样一个数 times = 0; for(int i=0;i&lt;numbers.size();++i) &#123; if(numbers[i] == result) ++times; &#125; return (times &gt; numbers.size()/2) ? result : 0; &#125;&#125;; 最小的K个数题目描述 输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。 思路： 可以采用快速排序，也可以采用堆排序(尤其适合动态的排序和海量数据排序) 下面提供堆排序代码，采用STL中的堆排序，可参考：10.堆heap.note 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123; int len = input.size(); if(len &lt;=0 || k&gt;len) return vector&lt;int&gt;(); vector&lt;int&gt; res(k+1); /*将input中元素全部拷贝到res开始的位置中,注意拷贝的区间为input.begin() ~ input.end()的左闭右开的区间*/ res.assign(input.begin(),input.begin()+k); //实际编程需要包含头文件&lt;algorithm&gt;建堆,默认创建的是最大堆，堆顶为首元素，若要创建最小堆，第三个参数为greater&lt;int&gt;() make_heap(res.begin(),res.end()); for(int i=k;i&lt;len;i++)&#123; if(input[i]&lt;res[0])&#123; res.push_back(input[i]); push_heap(res.begin(),res.end()); pop_heap(res.begin(),res.end()); res.pop_back(); &#125; &#125; return res; &#125;&#125;; 或者直接采用priority_queue 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123; int len = input.size(); if(len &lt;=0 ||k&lt;=0 || k &gt; len) //注意K的范围，之前一直编译不过，就是因为漏掉了k&lt;=0 return vector&lt;int&gt;(); priority_queue&lt;int&gt; heap; for(int i=0;i&lt;k;i++) heap.push(input[i]); for(int i=k;i&lt;len;i++)&#123; if(input[i] &lt; heap.top())&#123; heap.pop(); heap.push(input[i]); &#125; &#125; vector&lt;int&gt; result(k); for(int i=k-1;i&gt;=0;i--)&#123; result[i] = heap.top(); heap.pop(); &#125; return result; &#125;&#125;; 在排序数组中查找数字题目描述 统计一个数字在排序数组中出现的次数。 思路1：直接用二分法找出要找的数字K，然后通过两个while()循环，分别朝前和后扫描，得到K的个数； 但是当K的个数较多时，前后扫描相当于顺序查找，时间复杂度仍然很高。 思路二：用二分法，采用递归的方式，分别找到第一个K的下标和，最后一个K的下标，然后根据两个下标的差得出K的个数，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;public: int GetNumberOfK(vector&lt;int&gt; data ,int k) &#123; int count =0; if(data.size() &lt;=0) return 0; int first = getFirstK(data,k,0,data.size()-1); int last = getLastK(data,k,0,data.size()-1); if(first==-1 || last==-1) return 0; return last-first+1; &#125; int getFirstK(vector&lt;int&gt; data,int k,int start,int end)&#123; if (start &gt; end) return -1; //数组中不包含数字，返回-1 int mid = (start+end)&gt;&gt;1; if(data[mid]==k)&#123; if((mid&gt;0 &amp;&amp; data[mid-1] != k)||mid==0) return mid; else end = mid - 1; &#125; else if(data[mid]&gt;k) end = mid-1; else start = mid+1; return getFirstK(data,k,start,end); &#125; int getLastK(vector&lt;int&gt; data,int k,int start,int end)&#123; if (start &gt; end) return -1; //数组中不包含数字，返回-1 int mid = (start+end)&gt;&gt;1; if(data[mid]==k)&#123; if((mid &lt; data.size()-1 &amp;&amp; data[mid+1] != k)||mid==data.size()-1) return mid; else start = mid + 1; &#125; else if(data[mid]&gt;k) end = mid-1; else start = mid+1; return getLastK(data,k,start,end); &#125;&#125;; 思路三：和思路二类似，不采用递归的方式，直接用二分法，注意易错点！！！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123;public: int GetNumberOfK(vector&lt;int&gt; data ,int k) &#123; if(data.size() == 0) return 0; int left = firstk(data,k); int right = lastk(data,k); if(left == -1 || right == -1) return 0; return right-left+1; &#125; int firstk(vector&lt;int&gt; data,int k)&#123; int left = 0; int right = data.size()-1; int mid = (left+right)/2; while(left &lt;= right)&#123; if(data[mid] == k)&#123; if((mid-1&gt;=left &amp;&amp; data[mid-1]!= k) || mid==left) return mid;//！！！！犯错处，当mid位和mid-1位均等于k，取right=mid-1,不然可能出现死循环。 right = mid-1; &#125; else if(data[mid] &lt;k) left = mid+1; else right = mid-1; mid = (left+right)/2; &#125; return -1; &#125; int lastk(vector&lt;int&gt; data,int k)&#123; int left = 0; int right = data.size()-1; int mid = (left+right)/2; while(left &lt;= right)&#123; if(data[mid] == k)&#123; if((mid+1&lt;=right &amp;&amp; data[mid+1]!=k) || mid==right) return mid;//！！！！犯错处，当mid位和mid+1位均等于k，取left=mid+1,不然可能出现死循环。 left = mid+1; &#125; else if(data[mid] &lt;k) left = mid+1; else right = mid-1; mid = (left+right)/2; &#125; return -1; &#125;&#125;; 思路四：(大神思路) 由于data中都是整数，所以可以稍微变一下，不是搜索k的两个位置，而是搜索k-0.5和k+0.5 //这两个数应该插入的位置，然后相减即可。 123456789101112131415161718class Solution &#123;public: int GetNumberOfK(vector&lt;int&gt; data ,int k) &#123; return biSearch(data, k+0.5) - biSearch(data, k-0.5) ; &#125;private: int biSearch(const vector&lt;int&gt; &amp; data, double num)&#123; int s = 0, e = data.size()-1; while(s &lt;= e)&#123; int mid = (e - s)/2 + s; if(data[mid] &lt; num) s = mid + 1; else if(data[mid] &gt; num) e = mid - 1; &#125; return s; &#125;&#125;; 数组中只出现一次的两个数字题目描述 一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。 知识补充： 异或的性质及运用 异或是一种基于二进制的位运算，用符号XOR或者 ^ 表示，其运算法则是对运算符两侧数的每一个二进制位，同值取0，异值取1。它与布尔运算的区别在于，当运算符两侧均为1时，布尔运算的结果为1，异或运算的结果为0。 简单理解就是不进位加法，如1+1=0，,0+0=0,1+0=1。 性质 1、交换律 2、**结合律（即(a^b)^c == a^(b^c)） 重点！！！** 3、对于任何数x，都有x^x=0，x^0=x 4、**自反性 A XOR B XOR B = A xor 0 = A** 思路： 要求时间复杂度是O(n)，空间复杂度是O(1)。 大家首先想到的是顺序扫描法，但是这种方法的时间复杂度是O（n^2）。接着大家又会考虑用哈希表的方法，但是空间复杂度不是O（1）。 我们知道异或的一个性质是：任何一个数字异或它自己都等于0。也就是说，如果我们从头到尾依次异或数组中的每一个数字，那么最终的结果刚好是那个只出现一次的数字。比如数组{4,5,5}，我们先用数组中的第一个元素4（二进制形式：0100）和数组中的第二个元素5（二进制形式：0101）进行异或操作，0100和0101异或得到0001，用这个得到的元素与数组中的三个元素5（二进制形式：0101）进行异或操作，0001和0101异或得到0100，正好是结果数字4。这是因为数组中相同的元素异或是为0的，因此就只剩下那个不成对的孤苦伶仃元素。 现在好了，我们已经知道了如何找到一个数组中找到一个只出现一次的数字，那么我们如何在一个数组中找到两个只出现一次的数字呢？如果，我们可以将原始数组分成两个子数组，使得每个子数组包含一个只出现一次的数字，而其他数字都成对出现。这样，我们就可以用上述方法找到那个孤苦伶仃的元素。 我们还是从头到尾一次异或数组中的每一个数字，那么最终得到的结果就是两个只出现一次的数组的异或结果。因为其他数字都出现了两次，在异或中全部抵消了。由于两个数字肯定不一样，那么异或的结果肯定不为0，也就是说这个结果数组的二进制表示至少有一个位为1。我们在结果数组中找到第一个为1的位的位置，记为第n位。现在我们以第n位是不是1为标准把元数组中的数字分成两个子数组，第一个子数组中每个数字的第n位都是1，而第二个子数组中每个数字的第n位都是0。 举例：{2,4,3,6,3,2,5,5} 我们依次对数组中的每个数字做异或运行之后，得到的结果用二进制表示是0010。异或得到结果中的倒数第二位是1，于是我们根据数字的倒数第二位是不是1分为两个子数组。第一个子数组{2,3,6,3,2}中所有数字的倒数第二位都是1，而第二个子数组{4,5,5}中所有数字的倒数第二位都是0。接下来只要分别两个子数组求异或，就能找到第一个子数组中只出现一次的数字是6，而第二个子数组中只出现一次的数字是4。 思路总结： 本文思路有两大亮点：【1】一个整数数组中如果除了其中一个数以外，其他数都出现了两次，将这些数相异或得到的是这个单一的数。【2】如何将两个单一的数字分到两批数中，将所有数异或，得到的结果其实就是两个单一数字的异或结果，根据其中某一位是否为1将两个数字分开，其他数字也根据这个标准分成了两批。 最终分成的两批数字中，每一批数字中，只有一个单一数字。 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: void FindNumsAppearOnce(vector&lt;int&gt; data,int* num1,int *num2) &#123; int len = data.size(); if(len &lt; 2) return; //对原始数组每个元素依次求异或(异或为位运算) int temp=0; for(int i=0;i&lt;len;i++) temp ^= data[i]; int indexOf1 = rfindFirst1(temp); *num1 =0; *num2 =0; for(int i=0;i&lt;len;i++)&#123; if(isBit1(data[i],indexOf1)) *num1 ^=data[i]; else *num2 ^=data[i]; &#125; &#125;private: //从右找到某个数二进制形式下第一次出现1的下标 int rfindFirst1(int num)&#123; int bit1 = 1; int index =0; while((num &amp; bit1)== 0 &amp;&amp; (index &lt; 8*sizeof(int)))&#123; bit1 = bit1&lt;&lt;1; index++; &#125; return index; &#125; //判断某个数index位是否为1 bool isBit1(int num,int index)&#123; num = num&gt;&gt;index; return (num &amp; 1); &#125;&#125;; 二刷的时候，最终对每个数移位的时候不是通过对该数移动、位之后再判断其是否为1，而是直接通过位与，直接判断相应位是否为1，但是遇见了个大坑！！！ 直接写 a &amp; flag != 0;会判断错误 经验教训！！！，该多加个括号的时候不要吝啬！！！！ 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: void FindNumsAppearOnce(vector&lt;int&gt; data, int* num1, int *num2) &#123; int len = data.size(); if (len &lt; 2) return; int temp = 0; for (int i = 0; i &lt; len; i++) &#123; temp ^= data[i]; &#125; int flag = 1; while ((temp &amp; flag) == 0) &#123; flag = flag &lt;&lt; 1; &#125; *num1 = 0; *num2 = 0; for (int i = 0; i &lt; len; i++) &#123; //bool aa = isfalag1(data[i], flag); if (isfalag1(data[i], flag)) &#123; *num1 ^= data[i]; cout &lt;&lt; "第1组" &lt;&lt; data[i] &lt;&lt; endl; &#125; else &#123; *num2 ^= data[i]; cout &lt;&lt; "第2组" &lt;&lt; data[i] &lt;&lt; endl; &#125; &#125; &#125; //通过与flag相位与，判断每个数相对于temp中从右到左的第一个为1的位是否为1 bool isfalag1(int a, int flag) &#123; if ((a &amp; flag) != 0) //大坑！！！直接写 a &amp; flag != 0;会判断错误 return true; else return false; &#125;&#125;; 和为S的连续正数序列题目描述 小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck! 输出描述: 输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序 有了解决前面问题的经验，我们也考虑用两个数small和big分别表示序列的最小值和最大值。首先把small初始化为1，big初始化为2。如果从small到big的序列的和大于s，则可以从序列中去掉较小的值，也就是增大small的值。如果从small到big的序列的和小于s，则可以增大big，让这个序列包含更多的数字。因为这个序列至少要有两个数字，我们一直增加small到（1+s）/2为止。 {asset_img 05.png} 12345678910111213141516171819202122232425262728293031class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) &#123; vector&lt;vector&lt;int&gt; &gt; result; if(sum &lt;3) return result; int left = 1; int right = 2; int mid = (1+sum)/2; while(left &lt; mid)&#123; if(sum == calculate(left,right))&#123; vector&lt;int&gt; temp; for(int i=left;i&lt;=right;i++) temp.push_back(i); result.push_back(temp); right++; &#125; else if(sum &gt; calculate(left,right)) right++; else left++; &#125; return result; &#125; long calculate(int a,int b)&#123; long sum=0; for(int i=a;i&lt;=b;i++) sum += i; return sum; &#125;&#125;; 和为S的两个数字题目描述 输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 输出描述: 对应每个测试案例，输出两个数，小的先输出。 思路： 方法1：(耗时长)这个问题，很多人都能立即想到O（n2）的方法，也就是先在数组中固定一个数字，再依次判断数组中其余的n-1个数字与它的和是不是等于s。 方法2：我们以数组{1，2，4，7，11，15}及期待的和15为例详细分析一下这个过程。首先定义两个指针，第一个指针指向数组的第一个（最小的）数字1，第二个指针指向数组的最后一个（最大的）数字15。这两个数字的和16大于15，因此我们把第二个指针向前移动一个数字，让它指向11。这时候两个数字1与11的和是12，小于15。接下来我们把第一个指针向后移动一个数字指向2，此时两个数字2与11的和是13，还是小于15。我们再次向后移动第一个指针，让它指向数字4。数字4与11的和是15，正是我们期待的结果。表6.1总结了在数组{1，2，4，7，11，15}中查找和为15的数对的过程。 {asset_img 06.png} 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array,int sum) &#123; int len = array.size(); vector&lt;int&gt; result; if(len &lt;2) return result; int left = 0; int right = len-1; long minMulti = array[right]*array[right]; while(left &lt; right)&#123; if(array[left]+array[right]==sum)&#123; if(array[left] * array[right] &lt; minMulti)&#123; minMulti = array[left] * array[right]; if(result.size() == 0)&#123; result.push_back(array[left]); result.push_back(array[right]); &#125; else&#123; result.pop_back(); result.pop_back(); result.push_back(array[left]); result.push_back(array[right]); &#125; &#125; left++; right--; &#125; else if(array[left]+array[right] &lt; sum) left++; else if(array[left]+array[right] &gt; sum) right--; &#125; return result; &#125;&#125;; 扑克牌顺子题目： 从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2~10为数字本身，A为1，J为11，Q为12，K为13，而大、小王可以看成任意数字。在本题中看作0。 思路： 判断5个数字是不是连续的。 第一步：排序； 第二步：统计0的个数，统计间隙的个数，注意：统计间隙的时候不能和0作运算，非0数字不能重复； 第三步:间隙数大于0个数返回false，间隙数小于等于0的个数返回true。 1234567891011121314151617181920212223242526class Solution &#123;public: bool IsContinuous( vector&lt;int&gt; numbers ) &#123; int len = numbers.size(); if(len != 5) return false; sort(numbers.begin(),numbers.end()); int zeronum = 0; for(int i=0;i&lt;len;i++)&#123; //统计0的个数 if(numbers[i]==0) zeronum++; &#125; int pre=numbers[0]; int diffCount = 0; for(int i=1;i&lt;len;i++)&#123; int cur = numbers[i]; if(cur != 0&amp;&amp; pre !=0)&#123; //要考虑，计算间隙的时候，不能和0作运算，如[3,0,2,6,4] if(cur == pre) //要考虑数相等的情况，如[1,0,0,1,0] return false; diffCount += (cur-pre-1); &#125; pre = cur; &#125; return zeronum&gt;=diffCount; &#125;&#125;; 数组中重复的数字题目描述(数组) 在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。 一、可以改变数组 【方法1】先把输入的数组排序(sort())，然后遍历数组，找出重复元素，时间复杂度为O(nlogn); 【方法2】时间复杂度为O(n),空间复杂度为O(1) 思路：从头到尾依次扫描数组元素，当扫描到第i个元素m时，当m等于i时，继续遍历下一元素，当不等于i时，则拿他与第m个数n比较，如果m=n，则找到重复元素，返回true,否则交换两元素… 1234567891011121314151617181920212223242526272829class Solution &#123;public: bool duplicate(int numbers[], int length, int* duplication) &#123; //如果数组为空，或者输入的长度小于等于0 if(numbers == nullptr||length &lt;= 0)&#123; return false; &#125; //确保数组中每个数在0~length-1之间 for(int i=0;i&lt;length;i++)&#123; if(numbers[i]&lt;0 || numbers[i] &gt; length-1) return false; &#125; for(int i = 0; i &lt; length; i++)&#123; while(i != numbers[i]) &#123; if(numbers[i] == numbers[numbers[i]]) &#123; *duplication = numbers[i]; return true; &#125; //交换第i和第numbers[i]个数 int temp = numbers[i]; numbers[i] = numbers[temp]; numbers[temp] = temp;//注意该句千万不要写成numbers[numbers[i]] = temp; &#125; &#125; return false; &#125;&#125;; 二、不能改变数组 【方法1】创建一个长度为length的辅助数组，然后逐一把原数组的每一个数字复制到辅助数组，这样很容易找到重复数字，时间复杂度O(N),空间复杂度O(N)。 【方法2】用STL中的set,将数组中的数，插入set,当set的大小不变的时候，所插入的数字即为重复数字。 构建乘积数组题目描述 给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]A[i+1]…A[n-1]。不能使用除法。 思路： 求B[i]的时候分为两步，先求左侧所有的A相乘，再求右侧的所有的A相乘，最终将两者相乘即得相应的B。具体通过两次循环，累乘得到不同的B[i]，代码如下： 1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; multiply(const vector&lt;int&gt;&amp; A) &#123; int len = A.size(); vector&lt;int&gt; B(len); if(len == 0) return B;//总结：第0位和第n-1位为特殊情况，其对应左侧和右侧乘积均当做1，for循环都从第二位和倒数第二位起 B[0] = 1;//此处的B[0]代表第0位前A[i]的乘积，初始化为1 for(int i=1;i&lt;len;i++)&#123; //累乘求第1位到第n-1位前面所有A[i]的乘积 B[i] = B[i-1]*A[i-1]; &#125; int temp = 1; //此处的temp代表最后1位后面A[i]的乘积，对应的是最后一位，所以初始化为1 for(int i=len-2;i&gt;=0;i--)&#123;//累乘求第n-2位到第0位前面所有A[i]的乘积 temp *=A[i+1]; B[i] *= temp; &#125; return B; &#125;&#125;;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[socket编程(Windows下实现)]]></title>
    <url>%2F2019%2F05%2F18%2Fsocket%E7%BC%96%E7%A8%8B-Windows%E4%B8%8B%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[服务器端代码 server.cpp： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;winsock2.h&gt;#pragma comment (lib, "ws2_32.lib") //加载 ws2_32.dllint main()&#123; //初始化 DLL WSADATA wsaData; WSAStartup( MAKEWORD(2, 2), &amp;wsaData); //创建套接字 SOCKET servSock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); //绑定套接字 sockaddr_in sockAddr; memset(&amp;sockAddr, 0, sizeof(sockAddr)); //每个字节都用0填充 sockAddr.sin_family = PF_INET; //使用IPv4地址 sockAddr.sin_addr.s_addr = inet_addr("127.0.0.1"); //具体的IP地址 sockAddr.sin_port = htons(1234); //端口 bind(servSock, (SOCKADDR*)&amp;sockAddr, sizeof(SOCKADDR)); //进入监听状态 listen(servSock, 20); //接收客户端请求 SOCKADDR clntAddr; int nSize = sizeof(SOCKADDR); SOCKET clntSock = accept(servSock, (SOCKADDR*)&amp;clntAddr, &amp;nSize); //向客户端发送数据 char *str = "Hello World!"; send(clntSock, str, strlen(str)+sizeof(char), NULL); //关闭套接字 closesocket(clntSock); closesocket(servSock); //终止 DLL 的使用 WSACleanup(); return 0;&#125; 客户端代码 client.cpp： 12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;WinSock2.h&gt;#pragma comment(lib, "ws2_32.lib") //加载 ws2_32.dllint main()&#123; //初始化DLL WSADATA wsaData; WSAStartup(MAKEWORD(2, 2), &amp;wsaData); //创建套接字 SOCKET sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); //向服务器发起请求 sockaddr_in sockAddr; memset(&amp;sockAddr, 0, sizeof(sockAddr)); //每个字节都用0填充 sockAddr.sin_family = PF_INET; sockAddr.sin_addr.s_addr = inet_addr("127.0.0.1"); sockAddr.sin_port = htons(1234); connect(sock, (SOCKADDR*)&amp;sockAddr, sizeof(SOCKADDR)); //接收服务器传回的数据 char szBuffer[MAXBYTE] = &#123;0&#125;; recv(sock, szBuffer, MAXBYTE, NULL); //输出接收到的数据 printf("Message form server: %s\n", szBuffer); //关闭套接字 closesocket(sock); //终止使用 DLL WSACleanup(); system("pause"); return 0;&#125; Windows 下的 socket 程序和 Linux 思路相同，但细节有所差别：1) Windows 下的 socket 程序依赖 Winsock.dll 或 ws2_32.dll，必须提前加载。DLL 有两种加载方式，请查看：动态链接库DLL的加载 2) Linux 使用“文件描述符”的概念，而 Windows 使用“文件句柄”的概念；Linux 不区分 socket 文件和普通文件，而 Windows 区分；Linux 下 socket() 函数的返回值为 int 类型，而 Windows 下为 SOCKET 类型，也就是句柄。 3) Linux 下使用 read() / write() 函数读写，而 Windows 下使用 recv() / send() 函数发送和接收。 4) 关闭 socket 时，Linux 使用 close() 函数，而 Windows 使用 closesocket() 函数。]]></content>
      <categories>
        <category>计算机网络</category>
        <category>socket编程</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>socket编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[socket编程(Linux下实现)]]></title>
    <url>%2F2019%2F05%2F17%2Fsocket%E7%BC%96%E7%A8%8B-Linux%E4%B8%8B%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[Linux 下的代码，server.cpp 是服务器端代码，client.cpp 是客户端代码，要实现的功能是：客户端从服务器读取一个字符串并打印出来。 服务器端代码 server.cpp： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;int main()&#123; //创建套接字 int serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); //将套接字和IP、端口绑定 struct sockaddr_in serv_addr; memset(&amp;serv_addr, 0, sizeof(serv_addr)); //每个字节都用0填充 serv_addr.sin_family = AF_INET; //使用IPv4地址 serv_addr.sin_addr.s_addr = inet_addr("127.0.0.1"); //具体的IP地址 serv_addr.sin_port = htons(1234); //端口 bind(serv_sock, (struct sockaddr*)&amp;serv_addr, sizeof(serv_addr)); //进入监听状态，等待用户发起请求 listen(serv_sock, 20); //接收客户端请求 struct sockaddr_in clnt_addr; socklen_t clnt_addr_size = sizeof(clnt_addr); int clnt_sock = accept(serv_sock, (struct sockaddr*)&amp;clnt_addr, &amp;clnt_addr_size); //向客户端发送数据 char str[] = "Hello World!"; write(clnt_sock, str, sizeof(str)); //关闭套接字 close(clnt_sock); close(serv_sock); return 0;&#125; 客户端代码 client.cpp： 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/socket.h&gt;int main()&#123; //创建套接字 int sock = socket(AF_INET, SOCK_STREAM, 0); //向服务器（特定的IP和端口）发起请求 struct sockaddr_in serv_addr; memset(&amp;serv_addr, 0, sizeof(serv_addr)); //每个字节都用0填充 serv_addr.sin_family = AF_INET; //使用IPv4地址 serv_addr.sin_addr.s_addr = inet_addr("127.0.0.1"); //具体的IP地址 serv_addr.sin_port = htons(1234); //端口 connect(sock, (struct sockaddr*)&amp;serv_addr, sizeof(serv_addr)); //读取服务器传回的数据 char buffer[40]; read(sock, buffer, sizeof(buffer)-1); printf("Message form server: %s\n", buffer); //关闭套接字 close(sock); return 0;&#125; 先编译 server.cpp 并运行： 12[admin@localhost ~]$ g++ server.cpp -o server[admin@localhost ~]$ ./server 正常情况下，程序运行到 accept() 函数就会被阻塞，等待客户端发起请求。 //////////////////////////////////////////////////////////////////////// 接下来编译 client.cpp 并运行： 123[admin@localhost ~]$ g++ client.cpp -o client[admin@localhost ~]$ ./clientMessage form server: Hello World! client 运行后，通过 connect() 函数向 server 发起请求，处于监听状态的 server 被激活，执行 accept() 函数，接受客户端的请求，然后执行 write() 函数向 client 传回数据。client 接收到传回的数据后，connect() 就运行结束了，然后使用 read() 将数据读取出来。]]></content>
      <categories>
        <category>计算机网络</category>
        <category>socket编程</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>socket编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++面试题(1)]]></title>
    <url>%2F2019%2F04%2F03%2FC-%E9%9D%A2%E8%AF%95%E9%A2%981%2F</url>
    <content type="text"><![CDATA[为什么标准头文件都有类似以下的结构？12345678910#ifndef __INCvxWorksh#define __INCvxWorksh #ifdef __cplusplusextern "C" &#123;#endif /*...*/ #ifdef __cplusplus&#125;#endif #endif /* __INCvxWorksh */ 头文件中的编译宏 ifndef INCvxWorkshdefine __INCvxWorkshendif的作用是防止被重复引用。 后的str仍然为NULL；1：传入形参并不能真正改变形参的值，执行完之后为空；2：在函数GetMemory中和Test中没有malloc对应的free，造成内存泄露 Linux内存分区(常见两种分法)判断是大端存储还是小端存储【解答】 123456789int checkCPU()&#123; union w&#123; int a; char b; &#125; c; c.a = 1; return (c.b == 1);&#125; 【剖析】嵌入式系统开发者应该对Little-endian和Big-endian模式非常了解。采用Little-endian模式的CPU对操作数的存放方式是从低字节到高字节，而Big-endian模式对操作数的存放方式是从高字节到低字节。 32bit宽的数0x12345678在Little-endian模式CPU内存中的存放方式（假设从地址0x4000开始存放）为： 内存地址 存放内容 0x4000 0x78 0x4001 0x56 0x4002 0x34 0x4003 0x12 结构体和共用体的区别在于：结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。 结构体占用的内存大于等于所有成员占用的内存的总和（成员之间可能会存在缝隙），共用体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。 分析：共用体的各个成员是共用一段内存的。1 是数据的低位，如果 1 被存储在 data 的低字节，就是小端模式，这个时候 data.ch 的值也是 1。如果 1 被存储在 data 的高字节，就是大端模式，这个时候 data.ch 的值就是 0。 说一下C++和C的区别参考回答: 设计思想上：C++是面向对象的语言，而C是面向过程的结构化编程语言 语法上： C++具有封装、继承和多态三种特性 C++相比C，增加多许多类型安全的功能，比如强制类型转换、 C++支持范式编程，比如模板类、函数模板等 说一说c++中四种cast转换参考1 参考2 static_cast转换 1.基本用法：static_cast expression 2.使用场景： a、用于类层次结构中基类和派生类之间指针或引用的转换(不一定构成多态) 上行转换（派生类——&gt;基类）是安全的； 下行转换（基类——&gt;派生类）由于没有动态类型检查，所以是不安全的。 b、用于基本数据类型之间的转换，如把int转换为char，这种带来安全性问题由程序员来保证 c、把空指针转换成目标类型的空指针 d、把任何类型的表达式转为void类型 3.使用特点 a、主要执行非多态的转换操作，用于代替C中通常的转换操作 b、隐式转换都建议使用static_cast进行标明和替换 dynamic_cast转换 基本用法：dynamic_cast expression（1）其他三种都是编译时完成的，dynamic_cast是运行时处理的，运行时要进行类型检查。（2）不能用于内置的基本数据类型的强制转换。（3）dynamic_cast转换如果成功的话返回的是指向类的指针或引用，转换失败的话则会返回NULL。（4）使用dynamic_cast进行转换的，基类中一定要有虚函数，否则编译不通过。 需要检测有虚函数的原因：类中存在虚函数，就说明它有想要让基类指针或引用指向派生类对象的情况，此时转换才有意义。 这是由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表（关于虚函数表的概念，详细可见）中， 只有定义了虚函数的类才有虚函数表。（5） 在类的转换时，在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的。在进行下行转换 时，dynamic_cast具有类型检查的功能，比static_cast更安全。向上转换即为指向子类对象的向下转换，即将父类指针转化子类指针。向下转换的成功与否还与将要转换的类型有关，即要转换的指针指向的对象的实际类型与转换以后的对象类型一定要相同，否则转换失败。 const_cast转换 1.基本用法：const_castexpression 2.使用场景：const转非const a、常量指针转换为非常量指针，并且仍然指向原来的对象 b、常量引用被转换为非常量引用，并且仍然指向原来的对象 3.使用特点： a、cosnt_cast是四种类型转换符中唯一可以对常量进行操作的转换符 b、去除常量性是一个危险的动作，尽量避免使用。一个特定的场景是：类通过const提供重载时，一般都是非常量函数调用const_cast将参数转换为常量，然后调用常量函数，然后得到结果再调用const_cast 去除常量性。 reinterpret_cast转换 1.基本用法:reinterpret_castexpression 2.使用场景：不到万不得已，不用使用这个转换符，高危操作 3.使用特点： a、reinterpret_cast是从底层对数据进行重新解释，依赖具体的平台，可移植性差 b、reinterpret_cast可以将整型转换为指针，也可以把指针转换为数组 c、reinterpret_cast可以在指针和引用里进行肆无忌惮的转换 为什么不使用C的强制转换？ C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。 指针和引用的区别？参考回答: 1) 指针是一个实体，需要分配内存空间。引用只是变量的别名，不需要分配内存空间。 2) 引用在定义的时候必须进行初始化，并且不能够改变。指针在定义的时候不一定要初始化，并且指向的空间可变。（注：不能有引用的值不能为NULL） 3) 有多级指针，但是没有多级引用，只能有一级引用。 4) 指针和引用的自增运算结果不一样。（指针是指向下一个空间，引用时引用的变量值加1） 5) sizeof 引用得到的是所指向的变量（对象）的大小，而sizeof 指针得到的是指针本身的大小。 6) 引用访问一个变量是直接访问，而指针访问一个变量是间接访问。 7) 使用指针前最好做类型检查，防止野指针的出现； 8) 引用底层是通过指针实现的； 9）如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。 10) 作为参数时也不同，传指针的实质是传值，传递的值是指针的地址；传引用的实质是传地址，传递的是变量的地址。 指针参数传递和引用参数传递1) 指针参数传递本质上是值传递，它所传递的是一个地址值。值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，会在栈中开辟内存空间以存放由主调函数传递进来的实参值，从而形成了实参的一个副本（替身）。值传递的特点是，被调函数对形式参数的任何操作都是作为局部变量进行的，不会影响主调函数的实参变量的值（形参指针变了，实参指针不会变）。 2) 引用参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参（本体）的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量（根据别名找到主调函数中的本体）。因此，被调函数对形参的任何操作都会影响主调函数中的实参变量。 3) 引用传递和指针传递是不同的，虽然他们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。而对于指针传递的参数，如果改变被调函数中的指针地址，它将应用不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量（地址），那就得使用指向指针的指针或者指针引用。 4)从编译的角度来讲，程序在编译时分别将指针和引用添加到符号表上，符号表中记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值（与实参名字不同，地址相同）。符号表生成之后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改。 函数参数传递种类 形参变量只有在被调用时才分配内存单元，在调用结束时， 即刻释放所分配的内存单元。因此，形参只有在函数内部有效。 函数调用结束返回主调函数后则不能再使用该形参变量。 1) 值传递：有一个形参向函数所属的栈拷贝数据的过程，如果值传递的对象是类对象 或是大的结构体对象，将耗费一定的时间和空间。（传值） 2) 指针传递：同样有一个形参向函数所属的栈拷贝数据的过程，但拷贝的数据是一个固定为4字节的地址。（传值，传递的是地址值） 3) 引用传递：同样有上述的数据拷贝过程，但其是针对地址的，相当于为该数据所在的地址起了一个别名。（传地址） 效率上讲，指针传递和引用传递比值传递效率高。一般主张使用引用传递，代码逻辑上更加紧凑、清晰。 简述智能指针原理参考1 参考2 参考3 【1】为什么提出智能指针 在智能指针出现以前，我们通常使用 new 和 delete 来管理动态分配的内存，但这种方式存在几个常见的问题： (1)忘记 delete 内存：会导致内存泄漏问题，且除非是内存耗尽否则很难检测到这种错误。 (2)使用已经释放掉的对象：如果能够记得在释放掉内存后将指针置空并在下次使用前判空，尚可避免这种错误。 (3)同一块内存释放两次：如果有两个指针指向相同的动态分配对象，则很容易发生这种错误。 (4)发生异常时的内存泄漏：若在 new 和 delete 之间发生异常，则会导致内存泄漏。 【2】智能指针的设计思想 简单的总结下就是：将基本类型指针封装为类对象指针（这个类肯定是个模板，以适应不同基本类型的需求），并在析构函数里编写delete语句删除指针指向的内存空间。 【3】智能指针的使用 C++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且第一个已经被11弃用。 为什么要使用智能指针： 智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。 auto_ptr（c++98的方案，cpp11已经抛弃） 采用所有权模式。 123auto_ptr&lt; string&gt; p1 (new string ("I reigned lonely as a cloud.”));auto_ptr&lt;string&gt; p2;p2 = p1; //auto_ptr不会报错. 此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃问题！ unique_ptr（替换auto_ptr） unique_ptr实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。 采用所有权模式，还是上面那个例子 1`unique_ptr&lt;string&gt; p3 (``new` `string (``"auto"``)); ``//#4``unique_ptr&lt;string&gt; p4； ``//#5``p4 = p3;``//此时会报错！！` 编译器认为p4=p3非法，避免了p3不再指向有效数据的问题。因此，unique_ptr比auto_ptr更安全。 另外unique_ptr还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如： 12345unique_ptr&lt;string&gt; pu1(new string ("hello world"));unique_ptr&lt;string&gt; pu2;pu2 = pu1; // #1 not allowedunique_ptr&lt;string&gt; pu3;pu3 = unique_ptr&lt;string&gt;(new string ("You")); // #2 allowed 其中#1留下悬挂的unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的auto_ptr 。 注：如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个unique_ptr赋给另一个。例如： 12345unique_ptr&lt;string&gt; ps1, ps2;ps1 = demo("hello");ps2 = move(ps1);ps1 = demo("alexia");cout &lt;&lt; *ps2 &lt;&lt; *ps1 &lt;&lt; endl; shared_ptr shared_ptr实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。 shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。 成员函数： use_count 返回引用计数的个数 unique 返回是否是独占所有权( use_count 为 1) swap 交换两个 shared_ptr 对象(即交换所拥有的对象) reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少 get 返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如 shared_ptr sp(new int(1)); sp 与 sp.get()是等价的 weak_ptr（解决shared_ptr循环引用引出的） weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象. 进行该对象的内存管理的是那个强引用的 shared_ptr. weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。weak_ptr是用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。 以下实例为智能指针的循环引用 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;memory&gt;#include &lt;iostream&gt;using namespace std;class B;class A&#123;public: shared_ptr&lt;B&gt; pb_; //只是定义了指针，并没有资源 ~A() &#123; cout &lt;&lt; "A delete\n"; &#125;&#125;;class B&#123;public: shared_ptr&lt;A&gt; pa_; //只是定义了指针，并没有资源 ~B() &#123; cout &lt;&lt; "B delete\n"; &#125;&#125;;void fun()&#123; shared_ptr&lt;B&gt; pb(new B()); cout &lt;&lt; pb.use_count() &lt;&lt; endl; //pb占用了new出来的资源 输出1 cout &lt;&lt; pb-&gt;pa_.use_count() &lt;&lt; endl; //pb-&gt;pa_ 只是定义了指针，并没有资源 输出0 shared_ptr&lt;A&gt; pa(new A()); cout &lt;&lt; pb.use_count() &lt;&lt; endl; //输出1 cout &lt;&lt; pa.use_count() &lt;&lt; endl; //输出1 pb-&gt;pa_ = pa; pa-&gt;pb_ = pb; cout &lt;&lt; pb.use_count() &lt;&lt; endl; //输出2 cout &lt;&lt; pa.use_count() &lt;&lt; endl; //输出2&#125;int main()&#123; fun(); return 0;&#125; 结果：没析构 123456101122 请你回答一下智能指针有没有内存泄露的情况当两个对象相互使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。例如：6中代码 上述代码中，A有一个shared_ptr类型的成员指向B，而B也有一个shared_ptr类型的成员指向A。然后在创建A和B对象时也使用了智能指针pa和pb，随后将pa和pb分别又赋值给B的智能指针成员A和A的智能指针成员B。从而形成了一个循环引用： 如何解决： 为了解决循环引用导致的内存泄漏，引入了weak_ptr弱指针，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。 把类A中的share_ptr改成之后能析构掉资源： 12345678101112B deleteA delete 什么是内存泄漏(memory leak)参考回答: 内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。内存泄漏的分类： 堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak. 系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。 没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。 如何判断内存泄漏？参考回答: 内存泄漏通常是由于调用了malloc/new等内存申请的操作，但是缺少了对应的free/delete。为了判断内存是否泄露，我们一方面可以使用linux环境下的内存泄漏检查工具Valgrind(音标|‘vælgrind|),windows下由MicroSoft公司自己开发的一个工具——LeakDiag，另一方面我们在写代码时可以添加内存申请和释放的统计功能，统计当前申请和释放的内存是否一致，以此来判断内存是否泄露。（即在对象的构造函数,中对全局变量进行+1，在析函数中-1） 数组和指针的区别参考回答: 指针和数组的主要区别如下： 指针 数组 保存数据的地址 保存数据 间接访问数据，首先获得指针的内容，然后将其作为地址，从该地址中提取数据 直接访问数据， 通常用于动态的数据结构 通常用于固定数目且数据类型相同的元素 通过Malloc分配内存，free释放内存 隐式的分配和删除 通常指向匿名数据，操作匿名函数 自身即为数据名 野指针是什么？参考回答: 野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针 引用和指针定义：1、引用： C++是C语言的继承，它可进行过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行以继承和多态为特点的面向对象的程序设计。引用就是C++对C语言的重要扩充。引用就是某一变量的一个别名，对引用的操作与对变量直接操作完全一样。引用的声明方法：类型标识符 &amp;引用名=目标变量名；引用引入了对象的一个同义词。定义引用的表示方法与定义指针相似，只是用&amp;代替了*。 2、指针： 指针利用地址，它的值直接指向存在电脑存储器中另一个地方的值。由于通过地址能找到所需的变量单元，可以说，地址指向该变量单元。因此，将地址形象化的称为“指针”。意思是通过它能找到以它为地址的内存单元。 区别： 1) 指针是一个实体，需要分配内存空间。引用只是变量的别名，不需要分配内存空间。 2) 引用在定义的时候必须进行初始化，并且不能够改变。指针在定义的时候不一定要初始化，并且指向的空间可变。（注：不能有引用的值不能为NULL） 3) 有多级指针，但是没有多级引用，只能有一级引用。 4) 指针和引用的自增运算结果不一样。（指针是指向下一个空间，引用时引用的变量值加1） 5) sizeof 引用得到的是所指向的变量（对象）的大小，而sizeof 指针得到的是指针本身的大小。 6) 引用访问一个变量是直接访问，而指针访问一个变量是间接访问。 7) 使用指针前最好做类型检查，防止野指针的出现； 8) 引用底层是通过指针实现的； 9) 作为参数时也不同，传指针的实质是传值，传递的值是指针的地址；传引用的实质是传地址，传递的是变量的地址。 为什么析构函数必须是虚函数？C++默认的析构函数不是虚函数将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。 C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。 函数指针参考回答: 1、定义函数指针是指向函数的指针变量。 函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数。 C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。 2、用途： 调用函数和做函数的参数，比如回调函数。 3、示例： 1234char * fun(char * p) &#123;…&#125; // 函数funchar * (*pf)(char * p); // 函数指针pfpf = fun; // 函数指针pf指向函数funpf(p); // 通过函数指针pf调用函数fun 15.请你来说一下fork函数 参考回答: Fork：创建一个和当前进程映像一样的进程可以通过fork( )系统调用： 123#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;pid_t fork(void); 成功调用fork( )会创建一个新的进程，它几乎与调用fork( )的进程一模一样，这两个进程都会继续运行。在子进程中，成功的fork( )调用会返回0。在父进程中fork( )返回子进程的pid。如果出现错误，fork( )返回一个负值。 最常见的fork( )用法是创建一个新的进程，然后使用exec( )载入二进制映像，替换当前进程的映像。这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。这种“派生加执行”的方式是很常见的。 在早期的Unix系统中，创建进程比较原始。当调用fork时，内核会把所有的内部数据结构复制一份，复制进程的页表项，然后把父进程的地址空间中的内容逐页的复制到子进程的地址空间中。但从内核角度来说，逐页的复制方式是十分耗时的。现代的Unix系统采取了更多的优化，例如Linux，采用了写时复制的方法，而不是对父进程空间进程整体复制。 map和set有什么区别，分别又是怎么实现的？参考回答: map和set都是C++的关联容器，其底层实现都是红黑树（RB-Tree）。由于 map 和set所开放的各种操作接口，RB-tree 也都提供了，所以几乎所有的 map 和set的操作行为，都只是转调 RB-tree 的操作行为。 map和set区别在于： （1）map中的元素是key-value（关键字—值）对：关键字起到索引的作用，值则表示与索引相关联的数据；Set与之相对就是关键字的简单集合，set中每个元素只包含一个关键字。 （2）set的迭代器是const的，不允许修改元素的值；map允许修改value，但不允许修改key。其原因是因为map和set是根据关键字排序来保证其有序性的，如果允许修改key的话，那么首先需要删除该键，然后调节平衡，再插入修改后的键值，调节平衡，如此一来，严重破坏了map和set的结构，导致iterator失效，不知道应该指向改变前的位置，还是指向改变后的位置。所以STL中将set的迭代器设置成const，不允许修改迭代器的值；而map的迭代器则不允许修改key值，允许修改value值。 （3）map支持下标操作，set不支持下标操作。map可以用key做下标，map的下标运算符[ ]将关键码作为下标去执行查找，如果关键码不存在，则插入一个具有该关键码和mapped_type类型默认值的元素至map中，因此下标运算符[ ]在map应用中需要慎用，const_map不能用，只希望确定某一个关键值是否存在而不希望插入元素时也不应该使用，mapped_type类型没有默认值也不应该使用。如果find能解决需要，尽可能用find。 C++中struct和class的区别在C++中，可以用struct和class定义类，都可以继承。区别在于：structural的默认继承权限和默认访问权限是public，而class的默认继承权限和默认访问权限是private。另外，class还可以定义模板类形参，比如template 。 一个C++源文件从文本到可执行文件经历的过程？对于C++源文件，从文本到可执行文件一般需要四个过程：预处理阶段：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件。 编译阶段：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件 汇编阶段：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件 链接阶段：将多个目标文件及所需要的库连接成最终的可执行目标文件 include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别？Include头文件的顺序：对于include的头文件来说，如果在文件a.h中声明一个在文件b.h中定义的变量，而不引用b.h。那么要在a.c文件中引用b.h文件，并且要先引用b.h，后引用a.h,否则汇报变量类型未声明错误。 双引号和尖括号的区别：编译器预处理阶段查找头文件的路径不一样。 对于使用双引号包含的头文件，查找头文件路径的顺序为： （1）当前头文件目录 （2）编译器设置的头文件路径（编译器可使用-I显式指定搜索路径） （3）系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径 对于使用尖括号包含的头文件，查找头文件的路径顺序为： （1）编译器设置的头文件路径（编译器可使用-I显式指定搜索路径） （2）系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径 malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？Malloc函数用于动态分配内存。为了减少内存碎片和系统调用的开销，malloc其采用内存池的方式，先申请大块内存作为堆区，然后将堆区分为多个内存块，以块作为内存管理的基本单位。当用户申请内存时，直接从堆区分配一块合适的空闲块。Malloc采用隐式链表结构将堆区分成连续的、大小不一的块，包含已分配块和未分配块；同时malloc采用显示链表结构来管理所有的空闲块，即使用一个双向链表将空闲块连接起来，每一个空闲块记录了一个连续的、未分配的地址。 当进行内存分配时，Malloc会通过隐式链表遍历所有的空闲块，选择满足要求的块进行分配；当进行内存合并时，malloc采用边界标记法，根据每个块的前后块是否已经分配来决定是否进行块合并。 Malloc在申请内存时，一般会通过brk或者mmap系统调用进行申请。其中当申请内存小于128K时，会使用系统函数brk在堆区中分配；而当申请内存大于128K时，会使用系统函数mmap在映射区分配。 什么时候会发生段错误段错误通常发生在访问非法内存地址的时候，具体来说分为以下几种情况：使用野指针 试图修改字符串常量的内容 C++中static关键字作用参考 不考虑类，static的作用主要有三条。 【1】隐藏（可以说是最重要的一条，static函数，static变量均可） 当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。 举例来说明。同时编译两个源文件，一个是a.c，另一个是main.c。 12345678910111213//a.cchar a = 'A'; // global variablevoid msg()&#123; printf("Hello\n");&#125; //main.c C中普通函数可以这样不包含头文件就可以调用，但是在C++中要包含，为规范最好都包含int main()&#123; extern char a; // extern variable must be declared before use printf("%c ", a); (void)msg(); return 0;&#125; 程序的运行结果是： A Hello 如果加了static，就会对其它源文件隐藏。例如在a和msg的定义前加上static，main.c就看不到它们了。利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。static可以用作函数和变量的前缀，对于函数来讲，static的作用仅限于隐藏. 【2】保持变量内容的持久（理解！！！static变量中的记忆功能和全局生存期） 存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的。虽然这种用法不常见 PS：如果作为static局部变量在函数内定义，它的生存期为整个源程序，但是其作用域仍与自动变量相同，只能在定义该变量的函数内使用该变量。退出该函数后， 尽管该变量还继续存在，但不能使用它。 12345678910111213＃include &lt;stdio.h&gt;int fun()&#123; static int count = 10; //在第一次进入这个函数的时候，变量a被初始化为10，以后不再执行赋值操作！并接着自减1，以后每次进入该函数，a return count--; //就不会被再次初始化了，仅进行自减1的操作；在static发明前，要达到同样的功能，则只能使用全局变量： &#125; int count = 1;int main(void)&#123; printf("global\t\tlocal static\n"); for(; count &lt;= 10; ++count) printf("%d\t\t%d\n", count, fun()); return 0;&#125; 程序的运行结果是： 1234567891011global local static1 102 93 84 75 66 57 48 39 210 1 —-基于以上两点可以得出一个结论：把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域， 限制了它的使用范围。因此static 这个说明符在不同的地方所起的作用是不同的。 【3】static的第三个作用是默认初始化为0（static变量） 其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。比如初始化一个稀疏矩阵，我们可以一个一个地把所有元素都置0，然后把不是0的几个元素赋值。如果定义成静态的，就省去了一开始置0的操作。再比如要把一个字符数组当字符串来用，但又觉得每次在字符数组末尾加‘\0’;太麻烦。如果把字符串定义成静态的，就省去了这个麻烦，因为那里本来就是‘\0’;不妨做个小实验验证一下。 12345678＃include &lt;stdio.h&gt;int a;int main()&#123; int i; static char str[10]; printf("integer: %d; string: (begin)%s(end)", a, str); return 0;&#125; 程序的运行结果是： 1integer: 0; string: (begin) (end) 最后对static的三条作用做一句话总结。首先static的最主要功能是隐藏，其次因为static变量存放在静态存储区，所以它具备持久性和默认值0. 在考虑类的情况下： 【4】类中的static成员 static成员变量： 1) 一个类中可以有一个或多个静态成员变量，所有的对象都共享这些静态成员变量，都可以引用它。 2) static 成员变量和普通 static 变量一样，都在内存分区中的DATA段（静态区），到程序结束时才释放。这就意味着，static 成员变量不随对象的创建而分配内存，也不随对象的销毁而释放内存。而普通成员变量在对象创建时分配内存，在对象销毁时释放内存。 3) 静态成员变量必须初始化，而且只能在类体外进行。例如： int Student::m_total = 10; 初始化时可以赋初值，也可以不赋值。如果不赋值，那么会被默认初始化为 0。全局数据区的变量都有默认的初始值 0，而动态数据区（堆区、栈区）变量的默认值是不确定的，一般认为是垃圾值。 4) 静态成员变量既可以通过对象名访问，也可以通过类名访问，但要遵循 private、protected 和 public 关键字的访问权限限制。当通过对象名访问时，对于不同的对象，访问的是同一份内存。 static成员函数： 关于静态成员函数，可以总结为以下几点： 1）静态成员之间可以相互访问，包括静态成员函数访问静态成员变量和访问静态成员函数。静态成员函数不能访问非静态成员函数和非静态数据成员，非静态成员函数可以任意地访问静态成员函数和静态数据成员； 原因：由于static修饰的类成员属于类，不属于对象，因此static类成员函数是没有this指针的，this指针是指向本对象的指针。正因为没有this指针，所以static类成员函数不能访问非static的类成员，只能访问 static修饰的类成员。 2）静态成员函数由于不与任何的对象相关联，因此它不具有this指针。因而它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，只能调用其余的静态成员函数与访问静态数据成员。 注意：因为static成员不是任何对象的组成部分，所以static成员函数不能被声明为const。毕竟，将成员函数声明为const就是承诺不会修改该函数所属的对象，而static成员函数不属于任何对象。 最后，static成员函数也不能被声明为虚函数、volatile。举例如下： 12345class base&#123; virtual static void funcl()；//错误 static void func2()const；//错误 static void func3()volatile；//错误&#125;； static成员函数不能被virtual修饰，static成员不属于任何对象或实例，所以加上virtual没有任何实际意义；静态成员函数没有this指针，虚函数的实现是为每一个对象分配一个vptr指针，而vptr是通过this指针调用的，所以不能为virtual；虚函数的调用关系，this-&gt;vfptr-&gt;vtable-&gt;virtual function const作用1) 【定义常量】阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了； 2) 【修饰指针】对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const； 3) 【修饰函数形参】在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值； 4) 【类型转换】const类型变量可以通过类型转换符const_cast将const类型转换为非const类型； 5) 【类的成员变量】const类型变量必须定义的时候进行初始化，因此也导致如果类的成员变量有const类型的变量，那么该变量必须在类的初始化列表中进行初始化； 6)【类的成员函数】const 成员函数可以使用类中的所有成员变量，但是不能修改它们的值，这种措施主要还是为了保护数据而设置的。const 成员函数也称为常成员函数。 需要注意的是，必须在成员函数的声明和定义处同时加上 const 关键字。 7）【常对象】常对象以及常对象指针，它们都只能调用 const 成员变量或函数。 extern用法1) extern修饰变量的声明 如果文件a.c需要引用b.c中变量int v，就可以在a.c中声明extern int v，然后就可以引用变量v。 2) extern修饰函数的声明 如果文件a.c需要引用b.c中的函数，比如在b.c中原型是int fun(int mu)，那么就可以在a.c中声明extern int fun（int mu），然后就能使用fun来做任何事情。 3) extern修饰符可用于指示C或者C＋＋函数的调用规范。 1234567#ifdef __cplusplusextern "C" &#123;#endif /*...*/ #ifdef __cplusplus&#125;#endif 拷贝构造函数、深拷贝、浅拷贝最常见的拷贝构造函数： 123456Student::Student(const Student &amp;stu)&#123; this-&gt;m_name = stu.m_name; this-&gt;m_age = stu.m_age; this-&gt;m_score = stu.m_score; cout&lt;&lt;"Copy constructor was called."&lt;&lt;endl;&#125; 1) 为什么必须是当前类的引用呢？ 如果拷贝构造函数的参数不是当前类的引用，而是当前类的对象，那么在调用拷贝构造函数时，会将另外一个对象直接传递给形参，这本身就是一次拷贝，会再次调用拷贝构造函数，然后又将一个对象直接传递给了形参，将继续调用拷贝构造函数……这个过程会一直持续下去，没有尽头，陷入死循环。 2) 为什么是 const 引用呢？ (a)拷贝构造函数的目的是用其它对象的数据来初始化当前对象，并没有期望更改其它对象的数据，添加 const 限制后，这个含义更加明确了。 (b)另外一个原因是，添加 const 限制后，可以将 const 对象和非 const 对象传递给形参了，因为非 const 类型可以转换为 const 类型。如果没有 const 限制，就不能将 const 对象传递给形参，因为 const 类型不能转换为非 const 类型，这就意味着，不能使用 const 对象来初始化当前对象了。 3)默认拷贝构造函数、浅拷贝、深拷贝 （a）浅拷贝： 浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝。 (b)深拷贝： 深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变，这就是深拷贝。 如果程序员没有显式地定义拷贝构造函数，那么编译器会自动生成一个默认的拷贝构造函数。这个默认的拷贝构造函数属于浅拷贝。 当类持有其它资源时，如动态分配的内存、打开的文件、指向其他数据的指针、网络连接等，默认拷贝构造函数就不能拷贝这些资源，我们必须显式地定义拷贝构造函数，以完整地拷贝对象的所有数据。这种方式为深拷贝。 4）浅拷贝与深拷贝区别分析 参考博客 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt; using namespace std; class Student&#123;private: int num; char *name;public: Student(); ~Student();&#125;; Student::Student()&#123; name = new char(20); cout &lt;&lt; "Student" &lt;&lt; endl; &#125;Student::~Student()&#123; cout &lt;&lt; "~Student " &lt;&lt; (int)name &lt;&lt; endl; delete name; name = NULL;&#125; int main()&#123; &#123;// 花括号让s1和s2变成局部对象，方便测试 Student s1; Student s2(s1);// 复制对象 &#125; system("pause"); return 0;&#125; 123Student~Student 3735080~Student 3735080 执行结果：调用一次构造函数，调用两次析构函数，两个对象的指针成员所指内存相同，这会导致什么问题呢？name指针被分配一次内存，但是程序结束时该内存却被释放了两次，会导致崩溃！ 这是由于编译系统在我们没有自己定义拷贝构造函数时，会在拷贝对象时调用默认拷贝构造函数，进行的是浅拷贝！即对指针name拷贝后会出现两个指针指向同一个内存空间。 所以，在对含有指针成员的对象进行拷贝时，必须要自己定义拷贝构造函数，使拷贝后的对象指针成员有自己的内存空间，即进行深拷贝，这样就避免了内存泄漏发生。 对于成员变量存在指针变量的对象，浅拷贝带来问题的本质在于析构函数释放多次堆内存，使用std::shared_ptr，可以完美解决这个问题。 C++模板函数模板： 123template &lt;typename 类型参数1 , typename 类型参数2 , ...&gt; 返回值类型 函数名(形参列表)&#123; //在函数体中可以使用类型参数&#125; 所谓函数模板，实际上是建立一个通用函数，它所用到的数据的类型（包括返回值类型、形参类型、局部变量类型）可以不具体指定，而是用一个虚拟的类型来代替（实际上是用一个标识符来占位），等发生函数调用时再根据传入的实参来逆推出真正的类型。这个通用函数就称为函数模板（Function Template）。 类模板： 123template&lt;typename 类型参数1 , typename 类型参数2 , …&gt; class 类名&#123; //TODO:&#125;; 类模板在实例化时必须显式地指明数据类型，编译器不能根据给定的数据推演出数据类型。 12Point&lt;float, char*&gt; p3(12.4, "东经180度");Point&lt;char*, char*&gt; *p = new Point&lt;char*, char*&gt;("东经180度", "北纬210度"); C与C++中truct区别，C++中struct与class区别C语言和C++中struct的区别？ struct C语言 C++ 成员 没有函数成员，只有数据 函数和数据都可以有 访问权限 没有访问权限的设定，及对外不隐藏数据 有访问权限的设定private,public,protected 是否可以继承 不可以 有继承关系 C++中struct和class的区别？ C++ struct class 访问默认权限 struct默认是public class默认是private 继承默认权限 struct默认是public class默认是private 定义模板参数 不可以 可以 strcpy、strncpy与memcpy的区别与使用方法函数说明 void memcpy(void s1, const void *s2, size_t n); char strcpy(char s2, const char *s1); char strncpy(char s2, const char *s1, size_t n); 12345678910111213141516//strcpy和strncpy是用在字符数组中，而不是#include &lt;string&gt;using namespace std;int main()&#123; char s1[4] = &#123;'y','u','e','\0'&#125;; char s2[6] = &#123; 'y', 'a', 'n', 'g','y','\0' &#125;; //strcpy(s1,s2); //缓冲溢出 s1数组为 y a n g,无‘\0’ //strcpy(s2, s1); //正常，s2为 y u e '\0' y '\0' //strncpy(s1, s2,5); //当n&gt;s1数组长度时，s1数组为 y a n g,无‘\0’ //strncpy(s1, s2, 2); //当n&lt;s1数组长度时,只拷贝n个字符到s1 strncpy(s2, s1, 5); //如果s1指向的数组是一个比n短的字符串， //则在s2定义的数组后面补空字符，直到写入了n个字符。 return 0;&#125; 注意事项 strcpy 是依据 “\0” 作为结束判断的，如果 s2 的空间不够，则会引起 buffer overflow。 memcpy用来在内存中复制数据，由于字符串是以“\0”结尾的，所以对于在数据中包含“\0”的数据只能用memcpy，如:”hell\0oworld”。 Strncpy和memcpy很相似，只不过它在一个终止的空字符处停止。当n&gt;strlen(s1)时，给s2不够数的空间里填充“\0”；当n&lt;=strlen(s1)时，s2是没有结束符“\0”的。 这里隐藏了一个事实，就是s2指向的内存一定会被写n个字符。 所以总的来说注意： 1、s2指向的空间要足够拷贝；使用strcpy时，s2指向的空间要大于等于s1指向的空间；使用strncpy或memcpy时，s2指向的空间要大于或等于n。 2、使用strncpy或memcpy时，n应该大于strlen(s1)，或者说最好n &gt;= strlen(s1)+1；这个1 就是最后的“\0”。 3、使用strncpy时，确保s2的最后一个字符是“\0”。 右值与右值引用参考 补充1： 12345671 template&lt;typename T&gt;2 void swap(T&amp; a, T&amp; b)3 &#123;4 T t(std::move(a)); // a为空，t占有a的初始数据5 a = std::move(b); // b为空， a占有b的初始数据6 b = std::move(t); // t为空，b占有a的初始数据7 &#125; 补充2： 1) 拷贝构造函数中，对于指针，我们一定要采用深层复制，而移动构造函数中，对于指针，我们采用浅层复制。浅层复制之所以危险，是因为两个指针共同指向一片内存空间，若第一个指针将其释放，另一个指针的指向就不合法了。所以我们只要避免第一个指针释放空间就可以了。避免的方法就是将第一个指针（比如a-&gt;value）置为NULL，这样在调用析构函数的时候，由于有判断是否为NULL的语句，所以析构a的时候并不会回收a-&gt;value指向的空间；2) 移动构造函数的参数是一个右值或者将亡值的引用。也就是说，只用用一个右值，或者将亡值初始化另一个对象的时候，才会调用移动构造函数。而那个move语句，就是将一个左值变成一个将亡值。 构成多态时为什么构造函数不定义为虚函数，析构函数通常定义为虚函数？（1）虚函数表是在编译阶段生成的，里面没有存放虚函数的的实际物理地址，只有运行完构造函数进行初始化了，才能通过虚函数表里面的虚函数入口地址访问虚函数，因此构造函数，定义为虚函数没有意义。 （2）析构函数通常要定义为虚函数，否则当基类指针指向派生类，然后delete基类指针的时候，派生类的析构函数无法执行。 虚函数表属于每一个对象，为什么？虚函数表是在编译阶段生成的，里面没有存放虚函数的的实际物理地址，只有运行完构造函数进行初始化了，才能通过虚函数表里面的虚函数入口地址访问虚函数，因此虚函数表属于对象，而不属于类。他是一种晚绑定机制。 类构造函数的初始化列表1) 必须使用成员初始化的四种情况 ① 当初始化一个引用成员时； ② 当初始化一个常量成员时； ③ 当调用一个基类的构造函数，而它拥有一组参数时； ④ 当调用一个成员类的构造函数，而它拥有一组参数时； 2）为什么用成员初始化列表会快一些？ 列表初始化是给数据成员分配内存空间时就进行初始化，这样可以避免赋值操作而产生的临时对象，临时对象的出现会降低程序的效率。 构造函数和析构函数可以调用虚函数吗，为什么在C++中，提倡不在构造函数和析构函数中调用虚函数；1) 构造函数和析构函数调用虚函数时都不使用动态联编，如果在构造函数或析构函数中调用虚函数，则运行的是为构造函数或析构函数自身类型定义的版本；2) 因为父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化，因此调用子类的虚函数时不安全的，故而C++不会进行动态联编；3) 析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。所以在调用基类的析构函数时，派生类对象的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义。 静态联编：编译阶段就将函数实现与函数调用关联起来；动态连编：在程序执行阶段才将函数实现和调用关联； 注意：动态联编是针对C++的多态，C语言全部都是静态联编； 类的构造函数与析构函数执行顺序1) 构造函数顺序 ① 基类构造函数。 ② 成员类对象构造函数。 ③ 派生类构造函数。 2) 析构函数顺序 ① 调用派生类的析构函数； ② 调用成员类对象的析构函数； ③ 调用基类的析构函数。 什么情况会自动生成默认构造函数？经典参考资料 1) 含有带有默认构造函数的类成员对象；2) 继承带有默认构造函数的基类；3) 有虚函数的类4) 进行虚继承的类 C++里面的多态1）静态多态（重载，模板）是在编译的时候，就确定调用函数的类型。（2）动态多态（覆盖，虚函数实现）在运行的时候，才确定调用的是哪个函数，动态绑定。运行基类指针指向派生类的对象，并调用派生类的函数。 下面是构成运行时多态的条件：必须存在继承关系；继承关系中必须有同名的虚函数，并且它们是遮蔽（覆盖）关系。存在基类的指针，通过该指针调用虚函数。 类什么时候会析构？1) 对象生命周期结束，被销毁时；2) delete指向对象的指针时，或delete指向对象的基类类型指针，而其基类虚构函数是虚函数时；3) 对象i是对象o的成员，o的析构函数被调用时，对象i的析构函数也被调用。 组合与继承优缺点？（1）继承继承的优点是子类可以重写父类的方法来方便地实现对父类的扩展。继承的缺点有以下几点：①：父类的内部细节对子类是可见的。②：子类从父类继承的方法在编译时就确定下来了，所以无法在运行期间改变从父类继承的方法的行为。③：如果对父类的方法做了修改的话（比如增加了一个参数），则子类的方法必须做出相应的修改。所以说子类与父类是一种高耦合，违背了面向对象思想。（2）组合组合也就是设计类的时候把要组合的类的对象加入到该类中作为自己的成员变量。组合的优点：①：当前对象只能通过所包含的那个对象去调用其方法，所以所包含的对象的内部细节对当前对象时不可见的。②：当前对象与包含的对象是一个低耦合关系，如果修改包含对象的类中代码不需要修改当前对象类的代码。③：当前对象可以在运行时动态的绑定所包含的对象。可以通过set方法给所包含对象赋值。组合的缺点：①：容易产生过多的对象。②：为了能组合多个对象，必须仔细对接口进行定义。 补充：组合的构造函数执行顺序为：先调用内嵌对象的构造函数，然后执行组合类构造函数的函数体，析构函数调用顺序相反。 lambda表达式C++之Lambda表达式 c++中lambda表达式的用法 1) 利用lambda表达式可以编写内嵌的匿名函数，用以替换独立函数或者函数对象； 2) lambda表达式的语法定义如下： 1[函数对象参数] (操作符重载函数参数) mutable 或 exception 声明 -&gt; 返回值类型 &#123;函数体&#125; 3) lambda必须使用尾置返回来指定返回类型，可以忽略参数列表和返回值，但必须永远包含捕获列表和函数体； C++重写（覆盖）、重载、重定义1 重载overload 在一个类中，方法名相同而参数不同的几个方法，但是不能靠返回类型来判断。 2 重写（覆盖）override 函数特征相同，但是具体实现不同。 a、最重要的一点，重写是子类与父类之间的。 b、被重写的函数不能是 static 的。 c、函数三要素（函数名、函数参数、函数返回类型）完全一样 d、如果父类中有virtual关键字，这种父子之间的关系叫做虚函数重写 3 重定义redefining 子类重新定义父类中有相同名称的非虚函数 ( 参数列表可以不同 ) volatile作用1&gt; 告诉compiler 不能做任何优化2&gt; 用volatile 定义的变量会在程序外被改变,每次都必须从内存中读取，而不能重复使用放在cache或寄存器中的备份。 什么时候编译器产生默认构造函数 那么到底什么时候编译器会为我们产生nontrivial default constructor(有用的默认构造函数)呢?有下面四中情况: ​ ①如果一个类里面某个成员对象有默认构造函数,编译器就会为我们的类产生默认构造函数。 ​ 原因：编译器需要显式的来调用这个类成员对象的默认构造函数。 ​ 编译器合成的nontrivial default constructor仅仅调用类成员对象的默认构造函数,而不对我们类里面的其它变量做任何初始化操作。 ​ ②如果一个派生类的基类有默认构造函数,那么编译器会为派生类合成一个默认构造函数。 ​ 原因:因为派生类被合成时需要显式调用基类的默认构造函数。 ​ ③类中有虚函数 ​ 编译器必须自己产生一个默认构造函数来完成虚函数表的初始化操作。 ​ ④如果一个类虚继承于其它类。 ​ 编译器必须自己产生一个默认构造函数来完成虚基类表的初始化操作。 C++函数对象如果一个类将()运算符重载为成员函数，这个类就称为函数对象类，这个类的对象就是函数对象。函数对象是一个对象，但是使用的形式看起来像函数调用，实际上也执行了函数调用，因而得名。 下面是一个函数对象的例子。 12345678910111213141516#include &lt;iostream&gt;using namespace std;class CAverage&#123;public: double operator()(int a1, int a2, int a3) &#123; //重载()运算符 return (double)(a1 + a2 + a3) / 3; &#125;&#125;;int main()&#123; CAverage average; //能够求三个整数平均数的函数对象 cout &lt;&lt; average(3, 2, 3); //等价于 cout &lt;&lt; average.operator(3, 2, 3); return 0;&#125; 输出： 12. 66667 虚继承及其内存模型参考 为了解决多继承时的命名冲突和冗余数据问题，C++ 提出了虚继承，使得在派生类中只保留一份间接基类的成员。 普通的继承内存模型如下：B继承A，C继承B，D继承C 假设 A 是 B 的虚基类，B 又是 C 的虚基类，那么各个对象的内存模型如下图所示： VC对于虚继承，对象内存的设计： VC 引入了虚基类表，如果某个派生类有一个或多个虚基类，编译器就会在派生类对象中安插一个指针，指向虚基类表。虚基类表其实就是一个数组，数组中的元素存放的是各个虚基类的偏移。 假设 A 是 B 的虚基类，同时 B 又是 C 的虚基类 假设 A、B、C、D 类的继承关系为： 内存模型如下图所示： 总结：每多一层虚继承，对象里面多一个指向虚基类表的指针。 虚函数表参考1：单继承虚函数表 参考2：多继承虚函数表 虚函数： 注意：可以只将基类中的函数声明为虚函数，这样所有派生类中具有遮蔽（覆盖）关系的同名函数都将自动成为虚函数。 构成多态条件： 单继承虚函数表： 虚函数表是一个指针数组，每个元素对应一个虚函数的函数指针，普通的函数即非虚函数，其调用不需要经过虚表。 基类如果有 虚函数，几重继承就有几个虚函数表，如果子类对父类的虚函数重写了，虚函数表中对应位置指针则指向子类重写的虚函数。 123456789101112131415161718192021222324252627class A &#123;public: virtual void vfunc1(); virtual void vfunc2(); void func1(); void func2(); virtual ~A();private: int m_data1, m_data2;&#125;; class B : A &#123;public: virtual void vfunc1();; void func2(); virtual ~B();private: int m_data3;&#125;;class C : B &#123;public: virtual void vfunc1(); void func();private: int m_data1, m_data4;&#125;; 多继承虚函数表： 例如：class Derive : public Base1, public Base2 Base1，Base2中有虚函数，则Derive 的对象有两个指向虚函数表的指针，分别指向Base1和Base2的虚函数表。]]></content>
      <categories>
        <category>C++基础</category>
      </categories>
      <tags>
        <tag>C++基础</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2-QT中互斥与信号量]]></title>
    <url>%2F2019%2F04%2F03%2F2-QT%E4%B8%AD%E4%BA%92%E6%96%A5%E4%B8%8E%E4%BF%A1%E5%8F%B7%E9%87%8F%2F</url>
    <content type="text"><![CDATA[1.QMutex类QMutex的目的是保护对象、数据结构或代码段，以便一次只有一个线程可以访问它(这类似于Java synchronized关键字)。通常最好将互斥锁与QMutexLocker一起使用，因为这样可以很容易地确保一致地执行锁定和解锁。 12345678910111213int number = 6;void method1()&#123; number *= 5; number /= 4;&#125;void method2()&#123; number *= 3; number /= 2;&#125; 缺陷：如中代码中间退出，比如有多个if条件里面有return，则导致无法ulock,造成死锁。 解决方法：在每个return之前注意添加unlock，或者用更加方便的 2.QMutexLocker类使用方法： （1）先定义一个QMutex类的变量 （2）在需要上锁的地方定义一个QMutexLocker类的变量 1234567891011121314151617#include &lt;QMutex&gt;QMutex qMutex; //线程槽函数void WorkThread::startThreadSlot()&#123; QMutexLocker m_lock(&amp;qMutex); while(true) &#123; if(isStop) return; for(int n=0;n&lt;10;n++) qDebug()&lt;&lt;n&lt;&lt;n&lt;&lt;n&lt;&lt;n&lt;&lt;n&lt;&lt;n&lt;&lt;n&lt;&lt;n; QThread::sleep(1); &#125; &#125; 3.信号量QSemaphore类信号量可以理解为对互斥量功能的扩展，互斥量只能锁定一次而信号量可以获取多次，它可以用来保存一定数量的同种资源。 以下以单个生产者和单个消费者模型举例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;QCoreApplication&gt;#include &lt;QSemaphore&gt;#include &lt;QThread&gt;#include &lt;stdio.h&gt; const int DataSize=1000;const int BufferSize=80;int buffer[BufferSize];//缓存数据QSemaphore freeBytes(BufferSize);//freeBytes信号量控制可被生产者填充的缓冲部分QSemaphore usedBytes(0);//usedBytes信号量控制可被消费者读取的缓冲区部分 class Producer : public QThread&#123;public: Producer(); void run();&#125;; Producer::Producer()&#123;&#125; void Producer::run()&#123; for(int i=0;i&lt;DataSize;i++) &#123; freeBytes.acquire();//生产者线程首先获取一个空闲单元，如果此时缓冲区培被消费者尚未读取的数据填满，对 //此函数的调用就会阻塞，直到消费者读取了这些数据为止 buffer[i%BufferSize]=(i%BufferSize);//一旦生成者获取了某个空闲单元，就使当前的缓存单元序号填写这个缓冲区单元 usedBytes.release();//调用该函数将可用资源加1，表示消费者此时可以读取这个刚刚填写的单元 &#125;&#125;//Consumer继承QThread类class Consumer : public QThread&#123;public: Consumer(); void run();&#125;; Consumer::Consumer()&#123;&#125; void Consumer::run()&#123; for(int i=0;i&lt;DataSize;i++) &#123; usedBytes.acquire();//消费者线程首先获取一个可被读取的单元，如果缓冲区中没有包含任何可以读取的数据，对此函数的调用就会阻塞，直到生产者生产了一些数据为止 fprintf(stderr,"%d",buffer[i%BufferSize]);//一旦消费者读取了这个单元，会将这个单元的内容打印出来 if(i%16==0&amp;&amp;i!=0) fprintf(stderr,"\n"); freeBytes.release();//调用该函数使得这个单元变为空闲，已被生产者下次填充 &#125; fprintf(stderr,"\n");&#125; int main(int argc, char *argv[])&#123; QCoreApplication a(argc, argv); Producer producer; Consumer consumer; producer.start(); consumer.start(); producer.wait(); consumer.wait(); return a.exec();&#125; 互斥量可以锁定一次，而信号量可以在设置上限大小的情况下，获取多次，可以用来保护一定数量的同种资源。在使用acquire函数跨线程获取n个资源。release(n)可以释放n个资源。当没有足够的资源时，调用者将被阻塞直到有足够的资源可用。 一个生产者与多个消费者： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;QCoreApplication&gt;#include &lt;QSemaphore&gt;#include &lt;QThread&gt;#include &lt;QMutex&gt;#include &lt;iostream&gt; using namespace std;QSemaphore vacancy(10); //资源上限QSemaphore produce(0); //产品数量QMutex mutex; //互斥锁int buffer[5]; //缓冲区可以放5个产品int numtaken=30;int takei=0; class Producer:public QThread&#123; public: void run();&#125;;//生产者线程void Producer::run()&#123; for(int i=0;i&lt;30;i++) //生产30次产品 &#123; vacancy.acquire(); buffer[i%5]=i; printf("produced %d\n",i); produce.release(); &#125;&#125;class Consumer:public QThread&#123; public: void run();&#125;;void Consumer::run() //消费者线程&#123; while(numtaken&gt;1) &#123; produce.acquire(); mutex.lock(); //从缓冲区取出一个产品,多个消费者,不能同时取出,故用了互斥锁 printf("thread %ul take %d from buffer[%d] \n",currentThreadId(),buffer[takei%5],takei%5); takei++; numtaken--; mutex.unlock(); vacancy.release(); &#125;&#125;int main(int argc, char *argv[])&#123; QCoreApplication a(argc, argv); Producer producer; Consumer consumerA; Consumer consumerB; Consumer consumerC; producer.start(); consumerA.start(); consumerB.start(); consumerC.start(); producer.wait(); consumerA.wait(); consumerB.wait(); consumerC.wait(); return 0;&#125; 执行结果如图1所示：]]></content>
      <categories>
        <category>C++基础</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>C++基础</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++手写代码]]></title>
    <url>%2F2019%2F04%2F02%2FC-%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[1.手写简单的string类String.h 12345678910class String&#123;public: String(const char *str = NULL);// 普通构造函数 String(const String &amp;other);// 拷贝构造函数 ~String(void);// 析构函数 String &amp; operator = (const String &amp;other);// 赋值函数 private: char *m_data;// 用于保存字符串 &#125;; String.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243#include "String.h"//普通构造函数 String::String(const char *str)&#123; if (str == NULL) &#123; m_data = new char[1];// 得分点：对空字符串自动申请存放结束标志'\0'的，加分点：对m_data加NULL判断 *m_data = '\0'; &#125; else &#123; int length = strlen(str); m_data = new char[length + 1];// 若能加 NULL 判断则更好 strcpy(m_data, str); &#125;&#125;// String的析构函数 String::~String(void)&#123; delete[] m_data; // 或delete m_data; &#125;//拷贝构造函数 String::String(const String &amp;other)// 得分点：输入参数为const型 &#123; int length = strlen(other.m_data); m_data = new char[length + 1];// 若能加 NULL 判断则更好 strcpy(m_data, other.m_data);&#125;//赋值函数 String &amp; String::operator = (const String &amp;other) // 得分点：输入参数为const型 &#123; if (this == &amp;other)//得分点：检查自赋值 return *this; if (m_data) delete[] m_data;//得分点：释放原有的内存资源 int length = strlen(other.m_data); m_data = new char[length + 1];//加分点：对m_data加NULL判断 strcpy(m_data, other.m_data); return *this;//得分点：返回本对象的引用 &#125; 测试结果： 12345678910111213141516#include &lt;stdio.h&gt;#include "String.h"using namespace std;int main()&#123;//【赋值方法1】 String str1("ab");//【赋值方法2】 String str2; str2 = "abc";//【赋值方法3】 String str3 = str2;//【赋值方法4】 String str4(str3); printf("%s,%s,%s,%s", str1,str2,str3,str4); return 0;&#125;]]></content>
      <categories>
        <category>C++基础</category>
      </categories>
      <tags>
        <tag>C++基础</tag>
        <tag>手写代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码改错]]></title>
    <url>%2F2019%2F04%2F01%2F%E4%BB%A3%E7%A0%81%E6%94%B9%E9%94%99%2F</url>
    <content type="text"><![CDATA[1.分析下面代码有什么问题？123456void test1()&#123; char string[10]; char* str1 = "0123456789"; strcpy( string, str1 );&#125; 字符串str1需要11个字节才能存放下（包括末尾的’\0’），而string只有10个字节的空间，strcpy会导致数组越界； 2.分析下面代码有什么问题？12345678910void test2()&#123; char string[10], str1[10]; int i; for(i=0; i&lt;10; i++) &#123; str1 = 'a'; &#125;strcpy( string, str1 );&#125; 首先，代码根本不能通过编译。因为数组名str1为 char const类型的右值类型，根本不能赋值。再者，即使想对数组的第一个元素赋值，也要使用 str1 = ‘a’;其次，对字符数组赋值后，使用库函数strcpy进行拷贝操作，strcpy会从源地址一直往后拷贝，直到遇到’\0’为止。所以拷贝的长度是不定的。如果一直没有遇到’\0’导致越界访问非法内存，程序就崩了。完美修改方案为： 1234567891011void test2()&#123; char string[10], str1[10]; int i; for(i=0; i&lt;9; i++) &#123; str1[i] = 'a'; &#125; str1[9] = '\0'; strcpy( string, str1 );&#125; 3.指出下面代码有什么问题？ 1234567891011void test3(char* str1)&#123; if(str1 == NULL)&#123; return ; &#125; char string[10]; if( strlen( str1 ) &lt;= 10 ) &#123; strcpy( string, str1 ); &#125;&#125; if(strlen(str1) &lt;= 10)应改为if(strlen(str1) &lt; 10)，因为strlen的结果未统计’\0’所占用的1个字节。 4.写出完整版的strcpy函数如果编写一个标准strcpy函数的总分值为10，下面给出几个不同得分的答案： 2分 1234void strcpy( char *strDest, char *strSrc )&#123; while( (*strDest++ = * strSrc++) != ‘\0’ );&#125; 4分 12345void strcpy( char *strDest, const char *strSrc ) //将源字符串加const，表明其为输入参数，加2分&#123; while( (*strDest++ = * strSrc++) != ‘\0’ );&#125; 7分 123456void strcpy(char *strDest, const char *strSrc) &#123; //对源地址和目的地址加非0断言，加3分 assert( (strDest != NULL) &amp;&amp; (strSrc != NULL) ); while( (*strDest++ = * strSrc++) != ‘\0’ );&#125; 10分 //为了实现链式操作，将目的地址返回，加3分！ 1234567char * strcpy( char *strDest, const char *strSrc ) &#123; assert( (strDest != NULL) &amp;&amp; (strSrc != NULL) ); char *address = strDest; while( (*strDest++ = * strSrc++) != ‘\0’ ); return address;&#125; 5.检查下面代码有什么问题？1234567891011void GetMemory( char *p )&#123; p = (char *) malloc( 100 );&#125;void Test( void ) &#123; char *str = NULL; GetMemory( str ); strcpy( str, "hello world" ); printf( str );&#125; 传入中GetMemory( char *p )函数的形参为字符串指针，在函数内部修改形参并不能真正的改变传入形参的实参值，执行完 12char *str = NULL;GetMemory( str ); 后的str仍然为NULL；1：传入形参并不能真正改变形参的值，执行完之后为空；2：在函数GetMemory中和Test中没有malloc对应的free，造成内存泄露 6.下面代码会出现什么问题？1234567891011char *GetMemory( void )&#123; char p[] = "hello world"; return p; &#125;void Test( void )&#123; char *str = NULL; str = GetMemory(); printf( str ); &#125; 12char p[] = "hello world"; return p; 的p[]数组为函数内的局部自动变量，在函数返回后，内存已经被释放。这是许多程序员常犯的错误，其根源在于不理解变量的生存期。 7.下面代码会出现什么问题？1234567891011void GetMemory( char **p, int num )&#123; *p = (char *) malloc( num );&#125;void Test( void )&#123; char *str = NULL; GetMemory( &amp;str, 100 ); strcpy( str, "hello" ); printf( str ); &#125; 传入GetMemory的参数为字符串指针的指针，但是在GetMemory中执行申请内存及赋值语句p = (char ) malloc( num );后未判断内存是否申请成功，应加上： 12345if ( *p == NULL )&#123; ...//进行申请内存失败处理&#125;同时应考虑num&gt;0； 未释放堆内存 动态分配的内存在程序结束之前没有释放，应该调用free, 把malloc生成的内存释放掉 printf(str) 改为 printf(“%s”,str),否则可使用格式化 字符串攻击 8.下面代码会出现什么问题？1234567void Test( void )&#123; char *str = (char *) malloc( 100 ); strcpy( str, "hello" ); free( str ); ... //省略的其它语句&#125; 在执行char str = (char ) malloc(100);后未进行内存是否申请成功的判断；另外，在free(str)后未置str为空，导致可能变成一个“野”指针，应加上：str = NULL;试题6的Test函数中也未对malloc的内存进行释放。 9.看看下面的一段程序有什么错误?1234567swap( int* p1,int* p2 )&#123; int *p; *p = *p1; *p1 = *p2; *p2 = *p;&#125; 1.需要一个返回值void2在swap函数中，p是一个“野”指针，有可能指向系统区，导致程序运行的崩溃。在VC++中DEBUG运行时提示错误“Access Violation”。该程序应该改为： 1234567void swap( int* p1,int* p2 )&#123; int p; p = *p1; *p1 = *p2; *p2 = p;&#125; 10.float 与“零值”比较的 if 语句float型变量：const float EPSINON = 0.00001;if ((x &gt;= - EPSINON) &amp;&amp; (x &lt;= EPSINON) 11.以下为Windows NT下的32位C++程序，请计算sizeof的值123456789101112131415#include &lt;iostream&gt;using namespace std;void Func(char str[100])&#123; cout &lt;&lt; sizeof(str) &lt;&lt; endl;&#125;int main()&#123; char a[100] = &#123; 0 &#125;; Func(a); cout &lt;&lt; sizeof(a) &lt;&lt; endl; void *p = malloc(100); cout &lt;&lt; sizeof(p) &lt;&lt; endl; return 0;&#125; 输出结果： 12341004 【剖析】Func ( char str[100] )函数中数组名作为函数形参时，在函数体内，数组名失去了本身的内涵，仅仅只是一个指针；在失去其内涵的同时，它还失去了其常量特性，可以作自增、自减等操作，可以被修改。(但是上例中的数组元素无法传入函数)数组名的本质如下：（1）数组名指代一种数据结构，这种数据结构就是数组；例如：char str[10];cout ＜＜ sizeof(str) ＜＜ endl;输出结果为10，str指代数据结构char[10]。（2）数组名可以转换为指向其指代实体的指针，而且是一个指针常量，不能作自增、自减等操作，不能被修改；char str[10];str++; //编译出错，提示str不是左值（3）数组名作为函数形参时，沦为普通指针。Windows NT 32位平台下，指针的长度（占用内存的大小）为4字节，故sizeof( str ) 、sizeof ( p ) 都为4。 12.写一个“标准”宏MIN这个宏输入两个参数并返回较小的一个。另外，当你写下面的代码时会发生什么事？least = MIN(*p++, b); 解答： define MIN(A,B) ((A) &lt;= (B) ? (A) : (B))MIN(p++, b)会产生宏的副作用 剖析：这个面试题主要考查面试者对宏定义的使用，宏定义可以实现类似于函数的功能，但是它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，在宏展开的时候对“参数”进行的是一对一的替换。程序员对宏定义的使用要非常小心，特别要注意两个问题：（1）谨慎地将宏定义中的“参数”和整个宏用用括弧括起来。所以，严格地讲，下述解答： define MIN(A,B) (A) &lt;= (B) ? (A) : (B)define MIN(A,B) (A &lt;= B ? A : B )都应判0分；（2）防止宏的副作用。宏定义#define MIN(A,B) ((A) &lt;= (B) ? (A) : (B))对MIN(p++, b)的作用结果是：((p++) &lt;= (b) ? (p++) : (b))*这个表达式会产生副作用，指针p会作2次++自增操作。除此之外，另一个应该判0分的解答是： define MIN(A,B) ((A) &lt;= (B) ? (A) : (B));这个解答在宏定义的后面加“;”，显示编写者对宏的概念模糊不清]]></content>
      <categories>
        <category>C++基础</category>
      </categories>
      <tags>
        <tag>C++基础</tag>
        <tag>代码改错</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[海量数据处理-6]]></title>
    <url>%2F2019%2F03%2F29%2F%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95-6%2F</url>
    <content type="text"><![CDATA[密匙六、分布式处理之Mapreduce​ MapReduce是一种计算模型，简单的说就是将大批量的工作（数据）分解（MAP）执行，然后再将结果合并成最终结果（REDUCE）。这样做的好处是可以在任务被分解后，可以通过大量机器进行并行计算，减少整个操作的时间。但如果你要我再通俗点介绍，那么，说白了，Mapreduce的原理就是一个归并排序。 适用范围：数据量大，但是数据种类小可以放入内存基本原理及要点：将数据交给不同的机器去处理，数据划分，结果归约。问题实例： The canonical example application of MapReduce is a process to count the appearances of each different word in a set of documents: 海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。 一共有N个机器，每个机器上有N个数。每个机器最多存O(N)个数并对它们操作。如何找到N^2个数的中数(median)？]]></content>
      <categories>
        <category>海量数据处理</category>
      </categories>
      <tags>
        <tag>海量数据处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[海量数据处理-5]]></title>
    <url>%2F2019%2F03%2F29%2F%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95-5%2F</url>
    <content type="text"><![CDATA[密匙五、外排序 适用范围：大数据的排序，去重 基本原理及要点：外排序的归并方法，置换选择败者树原理，最优归并树问题实例： 1).有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16个字节，内存限制大小是1M。返回频数最高的100个词。 这个数据具有很明显的特点，词的大小为16个字节，但是内存只有1M做hash明显不够，所以可以用来排序。内存可以当输入缓冲区使用。 ​ 关于多路归并算法及外排序的具体应用场景，请参见blog内此文： 第十章、如何给10^7个数据量的磁盘文件排序]]></content>
      <categories>
        <category>海量数据处理</category>
      </categories>
      <tags>
        <tag>海量数据处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[海量数据处理-4]]></title>
    <url>%2F2019%2F03%2F28%2F%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95-4%2F</url>
    <content type="text"><![CDATA[密匙四、Trie树/数据库/倒排索引Trie树 适用范围：数据量大，重复多，但是数据种类小可以放入内存 基本原理及要点：实现方式，节点孩子的表示方式 扩展：压缩实现。 问题实例： 上面的第2题：寻找热门查询：查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个，每个不超过255字节。 上面的第5题：有10个文件，每个文件1G，每个文件的每一行都存放的是用户的query，每个文件的query都可能重复。要你按照query的频度排序。 1000万字符串，其中有些是相同的(重复),需要把重复的全部去掉，保留没有重复的字符串。请问怎么设计和实现？ 上面的第8题：一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词。其解决方法是：用trie树统计每个词出现的次数，时间复杂度是O(n*le)（le表示单词的平准长度），然后是找出出现最频繁的前10个词。 ​ 更多有关Trie树的介绍，请参见此文：从Trie树（字典树）谈到后缀树。 数据库索引 适用范围：大数据量的增删改查 基本原理及要点：利用数据的设计实现方法，对海量数据的增删改查进行处理。 关于数据库索引及其优化，更多可参见此文：http://www.cnblogs.com/pkuoliver/archive/2011/08/17/mass-data-topic-7-index-and-optimize.html； 关于MySQL索引背后的数据结构及算法原理，这里还有一篇很好的文章：http://blog.codinglabs.org/articles/theory-of-mysql-index.html； 关于B 树、B+ 树、B* 树及R 树，本blog内有篇绝佳文章：http://blog.csdn.net/v_JULY_v/article/details/6530142。 倒排索引(Inverted index) 适用范围：搜索引擎，关键字查询 基本原理及要点：为何叫倒排索引？一种索引方法，被用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射。 以英文为例，下面是要被索引的文本： T0 = “it is what it is” T1 = “what is it” T2 = “it is a banana” 我们就能得到下面的反向文件索引： “a”: {2} “banana”: {2} “is”: {0, 1, 2} “it”: {0, 1, 2} “what”: {0, 1} 检索的条件”what”,”is”和”it”将对应集合的交集。 正向索引开发出来用来存储每个文档的单词的列表。正向索引的查询往往满足每个文档有序频繁的全文查询和每个单词在校验文档中的验证这样的查询。在正向索引中，文档占据了中心的位置，每个文档指向了一个它所包含的索引项的序列。也就是说文档指向了它包含的那些单词，而反向索引则是单词指向了包含它的文档，很容易看到这个反向的关系。 扩展： 问题实例：文档检索系统，查询那些文件包含了某单词，比如常见的学术论文的关键字搜索。 ​ 关于倒排索引的应用，更多请参见： 第二十三、四章：杨氏矩阵查找，倒排索引关键词Hash不重复编码实践， 第二十六章：基于给定的文档生成倒排索引的编码与实践。]]></content>
      <categories>
        <category>海量数据处理</category>
      </categories>
      <tags>
        <tag>海量数据处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[海量数据处理-3]]></title>
    <url>%2F2019%2F03%2F27%2F%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95-3%2F</url>
    <content type="text"><![CDATA[密匙三：Bloom filter/BitmapBloom filter关于什么是Bloom filter，请参看blog内此文： 海量数据处理之Bloom Filter详解 适用范围：可以用来实现数据字典，进行数据的判重，或者集合求交集 基本原理及要点： 对于原理来说很简单，位数组+k个独立hash函数。将hash函数对应的值的位数组置1，查找时如果发现所有hash函数对应位都是1说明存在，很明显这个过程并不保证查找的结果是100%正确的。同时也不支持删除一个已经插入的关键字，因为该关键字对应的位会牵动到其他的关键字。所以一个简单的改进就是 counting Bloom filter，用一个counter数组代替位数组，就可以支持删除了。 还有一个比较重要的问题，如何根据输入元素个数n，确定位数组m的大小及hash函数个数。当hash函数个数k=(ln2)(m/n)时错误率最小。在错误率不大于E的情况下，m至少要等于nlg(1/E)才能表示任意n个元素的集合。但m还应该更大些，因为还要保证bit数组里至少一半为0，则m应该&gt;=nlg(1/E)*lge 大概就是nlg(1/E)1.44倍(lg表示以2为底的对数)。 举个例子我们假设错误率为0.01，则此时m应大概是n的13倍。这样k大概是8个。 注意这里m与n的单位不同，m是bit为单位，而n则是以元素个数为单位(准确的说是不同元素的个数)。通常单个元素的长度都是有很多bit的。所以使用bloom filter内存上通常都是节省的。 扩展： Bloom filter将集合中的元素映射到位数组中，用k（k为哈希函数个数）个映射位是否全1表示元素在不在这个集合中。Counting bloom filter（CBF）将位数组中的每一位扩展为一个counter，从而支持了元素的删除操作。Spectral Bloom Filter（SBF）将其与集合元素的出现次数关联。SBF采用counter中的最小值来近似表示元素的出现频率。 可以看下上文中的第6题： “6、给你A,B两个文件，各存放50亿条URL，每条URL占用64字节，内存限制是4G，让你找出A,B文件共同的URL。如果是三个乃至n个文件呢？ 根据这个问题我们来计算下内存的占用，4G=2^32大概是40亿*8大概是340亿，n=50亿，如果按出错率0.01算需要的大概是650亿个bit。现在可用的是340亿，相差并不多，这样可能会使出错率上升些。另外如果这些urlip是一一对应的，就可以转换成ip，则大大简单了。 ​ 同时，上文的第5题：给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？如果允许有一定的错误率，可以使用Bloom filter，4G内存大概可以表示340亿bit。将其中一个文件中的url使用Bloom filter映射为这340亿bit，然后挨个读取另外一个文件的url，检查是否与Bloom filter，如果是，那么该url应该是共同的url（注意会有一定的错误率）。” Bitmap 关于什么是Bitmap，请看blog内此文第二部分：http://blog.csdn.net/v_july_v/article/details/6685962。 ​ 下面关于Bitmap的应用，可以看下上文中的第13题，以及另外一道新题： “13、在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。 ​ 方案1：采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存2^32 2 bit=1 GB内存，还可以接受。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。​ 方案2：也可采用与第1题类似的方法，进行划分小文件的方法。然后在小文件中找出不重复的整数，并排序。然后再进行归并，注意去除重复的元素。*” 15、给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？ 方案1：frome oo，用位图/Bitmap的方法，申请512M的内存，一个bit位代表一个unsigned int值。读入40亿个数，设置相应的bit位，读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在。]]></content>
      <categories>
        <category>海量数据处理</category>
      </categories>
      <tags>
        <tag>海量数据处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[海量数据处理-2]]></title>
    <url>%2F2019%2F03%2F26%2F%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95-2%2F</url>
    <content type="text"><![CDATA[密匙二、多层划分多层划分——其实本质上还是分而治之的思想，重在“分”的技巧上！ 适用范围：第k大，中位数，不重复或重复的数字 基本原理及要点：因为元素范围很大，不能利用直接寻址表，所以通过多次划分，逐步确定范围，然后最后在一个可以接受的范围内进行。 问题实例： 13、2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。​ 有点像鸽巢原理，整数个数为2^32,也就是，我们可以将这2^32个数，划分为2^8个区域(比如用单个文件代表一个区域)，然后将数据分离到不同的区域，然后不同的区域在利用bitmap就可以直接解决了。也就是说只要有足够的磁盘空间，就可以很方便的解决。 14、5亿个int找它们的中位数。 思路一：这个例子比上面那个更明显。首先我们将int划分为2^16个区域，然后读取数据统计落到各个区域里的数的个数，之后我们根据统计结果就可以判断中位数落到那个区域，同时知道这个区域中的第几大数刚好是中位数。然后第二次扫描我们只统计落在这个区域中的那些数就可以了。实际上，如果不是int是int64，我们可以经过3次这样的划分即可降低到可以接受的程度。即可以先将int64分成2^24个区域，然后确定区域的第几大数，在将该区域分成2^20个子区域，然后确定是子区域的第几大数，然后子区域里的数的个数只有2^20，就可以直接利用direct addr table进行统计了。 思路二@绿色夹克衫：同样需要做两遍统计，如果数据存在硬盘上，就需要读取2次。方法同基数排序有些像，开一个大小为65536的Int数组，第一遍读取，统计Int32的高16位的情况，也就是0-65535，都算作0,65536 - 131071都算作1。就相当于用该数除以65536。Int32 除以 65536的结果不会超过65536种情况，因此开一个长度为65536的数组计数就可以。每读取一个数，数组中对应的计数+1，考虑有负数的情况，需要将结果加32768后，记录在相应的数组内。第一遍统计之后，遍历数组，逐个累加统计，看中位数处于哪个区间，比如处于区间k，那么0- k-1的区间里数字的数量sum应该&lt;n/2（2.5亿）。而k+1 - 65535的计数和也&lt;n/2，第二遍统计同上面的方法类似，但这次只统计处于区间k的情况，也就是说(x / 65536) + 32768 = k。统计只统计低16位的情况。并且利用刚才统计的sum，比如sum = 2.49亿，那么现在就是要在低16位里面找100万个数(2.5亿-2.49亿)。这次计数之后，再统计一下，看中位数所处的区间，最后将高位和低位组合一下就是结果了。]]></content>
      <categories>
        <category>海量数据处理</category>
      </categories>
      <tags>
        <tag>海量数据处理</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F03%2F25%2F%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95-1%2F</url>
    <content type="text"><![CDATA[密匙一、分而治之/Hash映射 + Hash_map统计 + 堆/快速/归并排序1、海量日志数据，提取出某日访问百度次数最多的那个IP。既然是海量数据处理，那么可想而知，给我们的数据那就一定是海量的。针对这个数据的海量，我们如何着手呢?对的，无非就是分而治之/hash映射 + hash统计 + 堆/快速/归并排序，说白了，就是先映射，而后统计，最后排序： 分而治之/hash映射：针对数据太大，内存受限，只能是：把大文件化成(取模映射)小文件，即16字方针：大而化小，各个击破，缩小规模，逐个解决 hash_map统计：当大文件转化了小文件，那么我们便可以采用常规的hash_map(ip，value)来进行频率统计。 堆/快速排序：统计完了之后，便进行排序(可采取堆排序)，得到次数最多的IP。 具体而论，则是： “首先是这一天，并且是访问百度的日志中的IP取出来，逐个写入到一个大文件中。注意到IP是32位的，最多有个2^32个IP。同样可以采用映射的方法，比如%1000，把整个大文件映射为1000个小文件，再找出每个小文中出现频率最大的IP（可以采用hash_map对那1000个文件中的所有IP进行频率统计，然后依次找出各个文件中频率最大的那个IP）及相应的频率。然后再在这1000个最大的IP中，找出那个频率最大的IP，即为所求。”—十道海量数据处理面试题与十个方法大总结。 ​ 关于本题，还有几个问题，如下： ​ 1、Hash取模是一种等价映射，不会存在同一个元素分散到不同小文件中的情况，即这里采用的是mod1000算法，那么相同的IP在hash取模后，只可能落在同一个文件中，不可能被分散的。因为如果两个IP相等，那么经过Hash(IP)之后的哈希值是相同的，将此哈希值取模（如模1000），必定仍然相等。​ 2、那到底什么是hash映射呢？简单来说，就是为了便于计算机在有限的内存中处理big数据，从而通过一种映射散列的方式让数据均匀分布在对应的内存位置(如大数据通过取余的方式映射成小树存放在内存中，或大文件映射成多个小文件)，而这个映射散列方式便是我们通常所说的hash函数，设计的好的hash函数能让数据均匀分布而减少冲突。尽管数据映射到了另外一些不同的位置，但数据还是原来的数据，只是代替和表示这些原始数据的形式发生了变化而已。 ​ OK，有兴趣的，还可以再了解下一致性hash算法，见blog内此文第五部分：http://blog.csdn.net/v_july_v/article/details/6879101。 2、寻找热门查询，300万个查询字符串中统计最热门的10个查询​ 原题：搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门），请你统计最热门的10个查询串，要求使用的内存不能超过1G。 ​ 解答：由上面第1题，我们知道，数据大则划为小的，如如一亿个Ip求Top 10，可先%1000将ip分到1000个小文件中去，并保证一种ip只出现在一个文件中，再对每个小文件中的ip进行hashmap计数统计并按数量排序，最后归并或者最小堆依次处理每个小文件的top10以得到最后的结。 ​ 但如果数据规模比较小，能一次性装入内存呢?比如这第2题，虽然有一千万个Query，但是由于重复度比较高，因此事实上只有300万的Query，每个Query255Byte，因此我们可以考虑把他们都放进内存中去（300万个字符串假设没有重复，都是最大长度，那么最多占用内存3M*1K/4=0.75G。所以可以将所有字符串都存放在内存中进行处理），而现在只是需要一个合适的数据结构，在这里，HashTable绝对是我们优先的选择。 ​ 所以我们放弃分而治之/hash映射的步骤，直接上hash统计，然后排序。So，针对此类典型的TOP K问题，采取的对策往往是：hashmap + 堆。如下所示： hash_map统计：先对这批海量数据预处理。具体方法是：维护一个Key为Query字串，Value为该Query出现次数的HashTable，即hash_map(Query，Value)，每次读取一个Query，如果该字串不在Table中，那么加入该字串，并且将Value值设为1；如果该字串在Table中，那么将该字串的计数加一即可。最终我们在O(N)的时间复杂度内用Hash表完成了统计； 堆排序：第二步、借助堆这个数据结构，找出Top K，时间复杂度为N‘logK。即借助堆结构，我们可以在log量级的时间内查找和调整/移动。因此，维护一个K(该题目中是10)大小的小根堆，然后遍历300万的Query，分别和根元素进行对比。所以，我们最终的时间复杂度是：O（N） + N’ * O（logK），（N为1000万，N’为300万）。 ​ 别忘了这篇文章中所述的堆排序思路：“维护k个元素的最小堆，即用容量为k的最小堆存储最先遍历到的k个数，并假设它们即是最大的k个数，建堆费时O（k），并调整堆(费时O（logk）)后，有k1&gt;k2&gt;…kmin（kmin设为小顶堆中最小元素）。继续遍历数列，每次遍历一个元素x，与堆顶元素比较，若x&gt;kmin，则更新堆（x入堆，用时logk），否则不更新堆。这样下来，总费时O（klogk+（n-k）logk）=O（n*logk）。此方法得益于在堆中，查找等各项操作时间复杂度均为logk。”—第三章续、Top K算法问题的实现。​ 当然，你也可以采用trie树，关键字域存该查询串出现的次数，没有出现为0。最后用10个元素的最小推来对出现频率进行排序。 3、有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。​ 由上面那两个例题，分而治之 + hash统计 + 堆/快速排序这个套路，我们已经开始有了屡试不爽的感觉。下面，再拿几道再多多验证下。请看此第3题：又是文件很大，又是内存受限，咋办?还能怎么办呢?无非还是： 分而治之/hash映射：顺序读文件中，对于每个词x，取hash(x)%5000，然后按照该值存到5000个小文件（记为x0,x1,…x4999）中。这样每个文件大概是200k左右。如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M。 hash_map统计：对每个小文件，采用trie树/hash_map等统计每个文件中出现的词以及相应的频率。 堆/归并排序：取出出现频率最大的100个词（可以用含100个结点的最小堆）后，再把100个词及相应的频率存入文件，这样又得到了5000个文件。最后就是把这5000个文件进行归并（类似于归并排序）的过程了。 4、海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。 ​ 如果每个数据元素只出现一次，而且只出现在某一台机器中，那么可以采取以下步骤统计出现次数TOP10的数据元素： 堆排序：在每台电脑上求出TOP10，可以采用包含10个元素的堆完成（TOP10小，用最大堆，TOP10大，用最小堆，比如求TOP10大，我们首先取前10个元素调整成最小堆，如果发现，然后扫描后面的数据，并与堆顶元素比较，如果比堆顶元素大，那么用该元素替换堆顶，然后再调整为最小堆。最后堆中的元素就是TOP10大）。 求出每台电脑上的TOP10后，然后把这100台电脑上的TOP10组合起来，共1000个数据，再利用上面类似的方法求出TOP10就可以了。 ​ 但如果同一个元素重复出现在不同的电脑中呢，如下例子所述： ​ 这个时候，你可以有两种方法： 遍历一遍所有数据，重新hash取摸，如此使得同一个元素只出现在单独的一台电脑中，然后采用上面所说的方法，统计每台电脑中各个元素的出现次数找出TOP10，继而组合100台电脑上的TOP10，找出最终的TOP10。 或者，暴力求解：直接统计统计每台电脑中各个元素的出现次数，然后把同一个元素在不同机器中的出现次数相加，最终从所有数据中找出TOP10。 5、有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。 方案1：直接上： hash映射：顺序读取10个文件，按照hash(query)%10的结果将query写入到另外10个文件（记为a0,a1,..a9）中。这样新生成的文件每个的大小大约也1G（假设hash函数是随机的）。 hash_map统计：找一台内存在2G左右的机器，依次对用hash_map(query, query_count)来统计每个query出现的次数。注：hash_map(query,query_count)是用来统计每个query的出现次数，不是存储他们的值，出现一次，则count+1。 堆/快速/归并排序：利用快速/堆/归并排序按照出现次数进行排序，将排序好的query和对应的query_cout输出到文件中，这样得到了10个排好序的文件（记为）。最后，对这10个文件进行归并排序（内排序与外排序相结合）。根据此方案1，这里有一份实现：https://github.com/ooooola/sortquery/blob/master/querysort.py。 ​ 除此之外，此题还有以下两个方法：​ 方案2：一般query的总量是有限的，只是重复的次数比较多而已，可能对于所有的query，一次性就可以加入到内存了。这样，我们就可以采用trie树/hash_map等直接来统计每个query出现的次数，然后按出现次数做快速/堆/归并排序就可以了。 ​ 方案3：与方案1类似，但在做完hash，分成多个文件后，可以交给多个文件来处理，采用分布式的架构来处理（比如MapReduce），最后再进行合并。 6、 给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？​ 可以估计每个文件安的大小为5G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。 分而治之/hash映射：遍历文件a，对每个url求取，然后根据所取得的值将url分别存储到1000个小文件（记为，这里漏写个了a1）中。这样每个小文件的大约为300M。遍历文件b，采取和a相同的方式将url分别存储到1000小文件中（记为）。这样处理后，所有可能相同的url都在对应的小文件（）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。 hash_set统计：求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。 ​ OK，此第一种方法：分而治之/hash映射 + hash统计 + 堆/快速/归并排序，再看最后4道题，如下： 7、怎么在海量数据中找出重复次数最多的一个？​ 方案：先做hash，然后求模映射为小文件，求出每个小文件中重复次数最多的一个，并记录重复次数。然后找出上一步求出的数据中重复次数最多的一个就是所求（具体参考前面的题）。 8、上千万或上亿数据（有重复），统计其中出现次数最多的前N个数据。​ 方案：上千万或上亿的数据，现在的机器的内存应该能存下。所以考虑采用hash_map/搜索二叉树/红黑树等来进行统计次数。然后利用堆取出前N个出现次数最多的数据。 9、一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。​ 方案1：如果文件比较大，无法一次性读入内存，可以采用hash取模的方法，将大文件分解为多个小文件，对于单个小文件利用hash_map统计出每个小文件中10个最常出现的词，然后再进行归并处理，找出最终的10个最常出现的词。​ 方案2：通过hash取模将大文件分解为多个小文件后，除了可以用hash_map统计出每个小文件中10个最常出现的词，也可以用trie树统计每个词出现的次数，时间复杂度是O(nle)（le表示单词的平准长度），最终同样找出出现最频繁的前10个词（可用堆来实现），时间复杂度是O(nlg10)。 10. 1000万字符串，其中有些是重复的，需要把重复的全部去掉，保留没有重复的字符串。请怎么设计和实现？ 方案1：这题用trie树比较合适，hash_map也行。 方案2：from xjbzju:，1000w的数据规模插入操作完全不现实，以前试过在stl下100w元素插入set中已经慢得不能忍受，觉得基于hash的实现不会比红黑树好太多，使用vector+sort+unique都要可行许多，建议还是先hash成小文件分开处理再综合。 ​ 上述方案2中读者xbzju的方法让我想到了一些问题，即是set/map，与hash_set/hash_map的性能比较?共计3个问题，如下： 1、hash_set在千万级数据下，insert操作优于set? 这位blog：http://t.cn/zOibP7t 给的实践数据可靠不? 2、那map和hash_map的性能比较呢? 谁做过相关实验? 3、那查询操作呢，如下段文字所述? ​ 或者小数据量时用map，构造快，大数据量时用hash_map? rbtree PK hashtable ​ 据朋友№邦卡猫№的做的红黑树和hash table的性能测试中发现：当数据量基本上int型key时，hash table是rbtree的3-4倍，但hash table一般会浪费大概一半内存。 ​ 因为hash table所做的运算就是个%，而rbtree要比较很多，比如rbtree要看value的数据 ，每个节点要多出3个指针（或者偏移量） 如果需要其他功能，比如，统计某个范围内的key的数量，就需要加一个计数成员。 ​ 且1s rbtree能进行大概50w+次插入，hash table大概是差不多200w次。不过很多的时候，其速度可以忍了，例如倒排索引差不多也是这个速度，而且单线程，且倒排表的拉链长度不会太大。正因为基于树的实现其实不比hashtable慢到哪里去，所以数据库的索引一般都是用的B/B+树，而且B+树还对磁盘友好(B树能有效降低它的高度，所以减少磁盘交互次数)。比如现在非常流行的NoSQL数据库，像MongoDB也是采用的B树索引。关于B树系列，请参考本blog内此篇文章：从B树、B+树、B*树谈到R 树。更多请待后续实验论证。 11. 一个文本文件，找出前10个经常出现的词，但这次文件比较长，说是上亿行或十亿行，总之无法一次读入内存，问最优解。​ 方案1：首先根据用hash并求模，将文件分解为多个小文件，对于单个文件利用上题的方法求出每个文件件中10个最常出现的词。然后再进行归并处理，找出最终的10个最常出现的词。 12. 100w个数中找出最大的100个数。​ 方案1：采用局部淘汰法。选取前100个元素，并排序，记为序列L。然后一次扫描剩余的元素x，与排好序的100个元素中最小的元素比，如果比这个最小的要大，那么把这个最小的元素删除，并把x利用插入排序的思想，插入到序列L中。依次循环，知道扫描了所有的元素。复杂度为O(100w100)。​ 方案2：采用快速排序的思想，每次分割之后只考虑比轴大的一部分，知道比轴大的一部分在比100多的时候，采用传统排序算法排序，取前100个。复杂度为O(100w100)。​ 方案3：在前面的题中，我们已经提到了，用一个含100个元素的最小堆完成。复杂度为O(100w*lg100)。 ​ 接下来，咱们来看第二种方法，双层捅划分。]]></content>
      <categories>
        <category>海量数据处理</category>
      </categories>
      <tags>
        <tag>海量数据处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[海量数据处理概述]]></title>
    <url>%2F2019%2F03%2F24%2F%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[什么是海量数据处理 所谓海量数据处理，无非就是基于海量数据上的存储、处理、操作。何谓海量，就是数据量太大，所以导致要么是无法在较短时间内迅速解决，要么是数据太大，导致无法一次性装入内存。 ​ 那解决办法呢?针对时间，我们可以采用巧妙的算法搭配合适的数据结构，如Bloom filter/Hash/bit-map/堆/数据库或倒排索引/trie树，针对空间，无非就一个办法：大而化小，分而治之（hash映射），你不是说规模太大嘛，那简单啊，就把规模大化为规模小的，各个击破不就完了嘛。 ​ 至于所谓的单机及集群问题，通俗点来讲，单机就是处理装载数据的机器有限(只要考虑cpu，内存，硬盘的数据交互)，而集群，机器有多辆，适合分布式处理，并行计算(更多考虑节点和节点间的数据交互)。 ​ 再者，通过本blog内的有关海量数据处理的文章：Big Data Processing，我们已经大致知道，处理海量数据问题，无非就是： 分而治之/hash映射 + hash统计 + 堆/快速/归并排序； 双层桶划分 Bloom filter/Bitmap； Trie树/数据库/倒排索引； 外排序； 分布式处理之Hadoop/Mapreduce。 从set/map谈到hashtable/hash_map/hash_set​ 稍后本文第二部分中将多次提到hash_map/hash_set，下面稍稍介绍下这些容器，以作为基础准备。一般来说，STL容器分两种， 序列式容器(vector/list/deque/stack/queue/heap)， 关联式容器。关联式容器又分为set(集合)和map(映射表)两大类，以及这两大类的衍生体multiset(多键集合)和multimap(多键映射表)，这些容器均以RB-tree完成。此外，还有第3类关联式容器，如hashtable(散列表)，以及以hashtable为底层机制完成的hash_set(散列集合)/hash_map(散列映射表)/hash_multiset(散列多键集合)/hash_multimap(散列多键映射表)。也就是说，set/map/multiset/multimap都内含一个RB-tree，而hash_set/hash_map/hash_multiset/hash_multimap都内含一个hashtable。 ​ 所谓关联式容器，类似关联式数据库，每笔数据或每个元素都有一个键值(key)和一个实值(value)，即所谓的Key-Value(键-值对)。当元素被插入到关联式容器中时，容器内部结构(RB-tree/hashtable)便依照其键值大小，以某种特定规则将这个元素放置于适当位置。 ​ 包括在非关联式数据库中，比如，在MongoDB内，文档(document)是最基本的数据组织形式，每个文档也是以Key-Value（键-值对）的方式组织起来。一个文档可以有多个Key-Value组合，每个Value可以是不同的类型，比如String、Integer、List等等。{ “name” : “July”, “sex” : “male”,​ “age” : 23 } set/map/multiset/multimap ​ set，同map一样，所有元素都会根据元素的键值自动被排序，因为set/map两者的所有各种操作，都只是转而调用RB-tree的操作行为，不过，值得注意的是，两者都不允许两个元素有相同的键值。​ 不同的是：set的元素不像map那样可以同时拥有实值(value)和键值(key)，set元素的键值就是实值，实值就是键值，而map的所有元素都是pair，同时拥有实值(value)和键值(key)，pair的第一个元素被视为键值，第二个元素被视为实值。​ 至于multiset/multimap，他们的特性及用法和set/map完全相同，唯一的差别就在于它们允许键值重复，即所有的插入操作基于RB-tree的insert_equal()而非insert_unique()。 hash_set/hash_map/hash_multiset/hash_multimap ​ hash_set/hash_map，两者的一切操作都是基于hashtable之上。不同的是，hash_set同set一样，同时拥有实值和键值，且实质就是键值，键值就是实值，而hash_map同map一样，每一个元素同时拥有一个实值(value)和一个键值(key)，所以其使用方式，和上面的map基本相同。但由于hash_set/hash_map都是基于hashtable之上，所以不具备自动排序功能。为什么?因为hashtable没有自动排序功能。​ 至于hash_multiset/hash_multimap的特性与上面的multiset/multimap完全相同，唯一的差别就是它们hash_multiset/hash_multimap的底层实现机制是hashtable（而multiset/multimap，上面说了，底层实现机制是RB-tree），所以它们的元素都不会被自动排序，不过也都允许键值重复。 ​ 所以，综上，说白了，什么样的结构决定其什么样的性质，因为set/map/multiset/multimap都是基于RB-tree之上，所以有自动排序功能，而hash_set/hash_map/hash_multiset/hash_multimap都是基于hashtable之上，所以不含有自动排序功能，至于加个前缀multi_无非就是允许键值重复而已。]]></content>
      <categories>
        <category>海量数据处理</category>
      </categories>
      <tags>
        <tag>海量数据处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统-内存管理]]></title>
    <url>%2F2019%2F03%2F22%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[★★★ 虚拟内存的作用，分页系统实现虚拟内存原理。★★★ 页面置换算法的原理，特别是 LRU 的实现原理，最好能手写，再说明它在 Redis 等作为缓存置换算法。★★★ 比较分页与分段的区别。 ★★★ 分析静态链接的不足，以及动态链接的特点。 2.1逻辑地址空间与物理地址空间Eg：编译时只需确定变量x存放的相对地址是100（也就是说相对于进程在内存中的起始地址而言的地址）。CPU想要找到x在内存中的实际存放位置，只需要用进程的起始地址+100即可。 相对地址又称逻辑地址，绝对地址又称物理地址。 2.2内存分配管理方式包括连续分配管理方式与非连续分配管理方式。 连续分配方式，是指为一个用户程序分配一个连续的内存空间。它主要包括单一连续分配、固定分区分配和动态分区分配。 非连续分配管理方式允许一个程序分散地装入到不相邻的内存分区中，根据分区的大小是否固定分为分页存储管理方式和分段存储管理方式。分页存储管理方式中，又根据运行作业时是否要把作业的所有页面都装入内存才能运行分为基本分页存储管理方式和请求分页存储管理方式。 2.2.1基本分页存储管理方式固定分区会产生内部碎片，动态分区会产生外部碎片，这两种技术对内存的利用率都比较低。我们希望内存的使用能尽量避免碎片的产生，这就引入了分页的思想：把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。每个进程也以块为单位进行划分，进程在执行时，以块为单位逐个申请主存中的块空间。 分页的方法从形式上看，像分区相等的固定分区技术，分页管理不会产生外部碎片。但它又有本质的不同点：块的大小相对分区要小很多，而且进程也按照块进行划分，进程运行时按块申请主存可用空间并执行。这样，进程只会在为最后一个不完整的块申请一个主存块空间时，才产生主存碎片，所以尽管会产生内部碎片，但是这种碎片相对于进程来说也是很小的，每个进程平均只产生半个块大小的内部碎片（也称页内碎片）。 1）分页存储的几个基本概念 ①页面和页面大小。进程中的块称为页（Page），内存中的块称为页框（Page Frame，或页帧）。外存也以同样的单位进行划分，称为块（Block）。进程在执行时需要申请主存空间，就是要为每个页面分配主存中的可用页框，这就产生了页和页框的一一对应。 为方便地址转换，页面大小应是2的整数幂。同时页面大小应该适中，如果页面太小，会使进程的页面数过多，这样页表就过长，占用大量内存，而且也会增加硬件地址转换的开销，降低页面换/ 换出的效率；页面过大又会使页面内碎片增大，降低内存的利用率。所以页面的大小应该适中，考虑到空间效率和时间效率的权衡。 ②地址结构。分页存储管理的逻辑地址结构如下图所示： 地址结构包含两部分：前一部分为页号P，后一部分为页内偏移量M。地址长度为32位，其中0～11位为页内地址，即每页大小为4KB；12~31位为页号，地址空间最多允许有2^20页。 ③页表。为了便于在内存中找到进程的每个页面所对应的物理块，系统为每个进程建立一张页表，记录页面在内存中对应的物理块号，页表一般存放在内存中。在配置了页表后，进程执行时，通过查找该表，即可找到每页在内存中的物理块号。可见，页表的作用是实现从页号到物理块号的地址映射。 如何计算(以手动计算为例)： 页号=逻辑地址/页面长度（取除法的整数部分） 页内偏移量=逻辑地址%页面长度（取除法的余数部分） 页面在内存中的起始位置：操作系统需要用某种数据结构记录进程各个页面的起始位置。 存在页表中 页号=80/50=1 页内偏移量=80%50=3 01号页在内存中存放的起始位置450 物理地址为450+3=453 2.2.2基本分段存储管理方式段式管理方式按照用户进程中的自然段划分逻辑空间。例如，用户进程由主程序、两个子程序、栈和一段数据组成，于是可以把这个用户进程划分为5个段，每段从0开始编址，并分配一段连续的地址空间（段内要求连续，段间不要求连续，因此整个作业的地址空间是二维的）。其逻辑地址由段号S与段内偏移量W两部分组成。 在下图中，段号为16位，段内偏移量为16位，则一个作业最多可有216-65536个段，最大段长为64KB。 在页式系统中，逻辑地址的页号和页内偏移量对用户是透明的，但在段式系统中，段号和段内偏移量必须由用户显示提供，在高级程序设计语言中，这个工作由编译程序完成。 2.2.3段页式管理方式 例1：关于段页式管理中，地址映像表是（）。 A.每个进程一张段表，一张页表B.进程的每个段一张段表，一张页表C.每个进程一张段表，每个段一张页表D.每个进程一张页表，每个段一张段表解答：C。 2.3虚拟内存管理上一节所讨论的各种内存管理策略都是为了同时将多个进程保存在内存中以便允许多道程序设计。它们都具有以下两个共同的特征：作业必须一次性全部装入内存后，方能开始运行；驻留性：作业被装入内存后，就一直驻留在内存中，其任何部分都不会被换出，直至作业运行结束。 由以上分析可知，许多在程序运行中不用或暂时不用的程序（数据）占据了大量的内存空间，而一些需要运行的作业又无法装入运行，显然浪费了宝贵的内存资源。 2.3.1虚拟存储器的定义和特征基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其余部分留在外存，就可以启动程序执行。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换出到外存上，从而腾出空间存放将要调入内存的信息。这样，系统好像为用户提供了一个比实际内存大得多的存储器，称为虚拟存储器。 之所以将其称为虚拟存储器，是因为这种存储器实际上并不存在，只是由于系统提供了部分装入、请求调入和置换功能后（对用户完全透明），给用户的感觉是好像存在一个比实际物理内存大得多的存储器。 虚拟内存的实现有以下三种方式： 1）请求分页存储管理。 2）请求分段存储管理。 3）请求段页式存储管理。 不管哪种方式，都需要有一定的硬件支持。一般需要的支持有以下几个方面： 1）一定容量的内存和外存。 2）页表机制（或段表机制），作为主要的数据结构。 3）中断机构，当用户程序要访问的部分尚未调入内存，则产生缺页中断。 4）地址变换机构，逻辑地址到物理地址的变换。 例1：段页式虚拟存储管理方案的特点是（）。（2012·腾讯） A.空间浪费大、存储共享不易，存储保护容易、不能动态链接 B.空间浪费小、存储共享容易、存储保护不易、不能动态链接 C.空间浪费大、存储共享不易、存储保护容易、能动态链接 D.空间浪费小、存储共享容易、存储保护容易、能动态链接 解答：D。为了能够同时获得段式虚拟存储器在程序模块化方面的优点和页式虚拟存储器在管理主存和辅存物理空间方面的优点，把两种虚拟存储器结合起来就成为段页式虚拟存储器。其基本思想是对用户原来编写程序的虚拟存储空间采用分段的方法管理，而对主存储器的物理空间采用分页的方法管理。 段页式虚拟存储器一方面具有段式虚拟存储器的主要优点。例如，用户程序可以模块化编写，程序段的共享和信息的保护都比较方便，程序可以在执行时再动态链接等。 另一方面也具有页式虚拟存储器的主要优点。例如：主存储器的利用率比较高，对辅助存储器的管理比较容易等。 2.3.2请求分页管理方式请求分页系统建立在基本分页系统基础之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。 在请求分页系统中，只要求将当前需要的一部分页面装入内存，便可以启动作业运行。在作业执行过程中，当所要访问的页面不在内存时，再通过调页功能将其调入，同时还可以通过置换功能将暂时不用的页面换出到外存上，以便腾出内存空间。 为了实现请求分页，系统必须提供一定的硬件支持。除了需要一定容量的内存及外存的计算机系统，还需要有页表机制(在基本分页的页表基础上对每个页加了状态位、访问字段等，用于判断是否调入内存，以及最近访问的次数等..)、缺页中断机构和地址变换机构。 常见的置换算法有以下三种：最佳置换算法、先进先出（FIFO）页面置换算法、最近最久未使用（LRU）置换算法。 2.4抖动：在页面置换过程中的一种最糟糕的情形是，刚刚换出的页面马上又要换入主存，刚刚换入的页面马上就要换出主存，这种频繁的页面调度行为称为抖动，或颠簸。如果一个进程在换页上用的时间多于执行时间，那么这个进程就在颠簸。 频繁的发生缺页中断，其主要原因是某个进程频繁访问的页面数目高于可用的物理页帧数目。 2.5缺页中断与最近最久未使用置换算法（ LRU）缺页中断:在地址映射过程中，若在页表中发现所要访问的页面不在内存，则产生中断，当发生中断时，系统必须在内存选择一个页面移出内存，以便为调入新的页面让出空间，尽管每次可以随机选选择一个页面置换，但选择不常使用的页面会是系统性能好的多，减少不必要的额外开销，就产生了页面置换算法。 参考leetcode上的解答： LRU缓存机制 运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。 获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。 进阶: 你是否可以在 O(1) 时间复杂度内完成这两种操作？ 示例: 1234567891011LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );cache.put(1, 1);cache.put(2, 2);cache.get(1); // 返回 1cache.put(3, 3); // 该操作会使得密钥 2 作废cache.get(2); // 返回 -1 (未找到)cache.put(4, 4); // 该操作会使得密钥 1 作废cache.get(1); // 返回 -1 (未找到)cache.get(3); // 返回 3cache.get(4); // 返回 4 思路分析： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;map&gt;#include &lt;list&gt;class LRUCache &#123;public: LRUCache(int capacity) &#123; m_capacity = capacity; &#125; int get(int key) &#123; const auto it = cacheMap.find(key); //如果key不存在 if(it == cacheMap.end()) return -1; //如果key存在，将其值（最近操作的）对应的节点移到链表头，O(1)时间 cacheList.splice(cacheList.begin(),cacheList,it-&gt;second); return it-&gt;second-&gt;second; &#125; //put()之前需要检查，key是否已经存在，存在则更新值，存在的话分为两种情况： //第一种：容器已经满，需要先剔除链表尾部元素，第二种：容器未满，正常添加。 void put(int key, int value) &#123; const auto it = cacheMap.find(key); //如果key存在,更新值 if(it != cacheMap.end())&#123; it-&gt;second-&gt;second = value; //如果key存在，将其值（最近操作的）对应的节点移到链表头，O(1)时间 cacheList.splice(cacheList.begin(),cacheList,it-&gt;second); return; &#125; //key不存在情况下，cacheMap已经满了 if(cacheMap.size()==m_capacity)&#123; const auto&amp; node = cacheList.back(); cacheMap.erase(node.first); cacheList.pop_back(); &#125; //key不存在情况下，cacheMap未满，正常插入 cacheList.emplace_front(key,value); //直接插到顺序容器头部，C++11出的新方法 cacheMap[key] = cacheList.begin(); &#125;private: int m_capacity; list&lt;pair&lt;int,int&gt; &gt; cacheList; unordered_map&lt;int,list&lt;pair&lt;int,int&gt; &gt;::iterator&gt; cacheMap; &#125;;/** * Your LRUCache object will be instantiated and called as such: * LRUCache* obj = new LRUCache(capacity); * int param_1 = obj-&gt;get(key); * obj-&gt;put(key,value); */]]></content>
      <categories>
        <category>操作系统</category>
        <category>操作系统概念</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统其他]]></title>
    <url>%2F2019%2F03%2F21%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%B6%E4%BB%96%2F</url>
    <content type="text"><![CDATA[1.静态链接库与动态链接库的优缺点1 静态链接库的优点 (1) 代码装载速度快，执行速度略比动态链接库快； (2) 只需保证在开发者的计算机中有正确的.LIB文件，在以二进制形式发布程序时不需考虑在用户的计算机上.LIB文件是否存在及版本问题，可避免DLL地狱等问题。 2 动态链接库的优点 (1) 更加节省内存并减少页面交换； (2) DLL文件与EXE文件独立，只要输出接口不变（即名称、参数、返回值类型和调用约定不变），更换DLL文件不会对EXE文件造成任何影响，因而极大地提高了可维护性和可扩展性； (3) 不同编程语言编写的程序只要按照函数调用约定就可以调用同一个DLL函数； (4)适用于大规模的软件开发，使开发过程独立、耦合度小，便于不同开发者和开发组织之间进行开发和测试。 3 不足之处 (1) 使用静态链接生成的可执行文件体积较大，包含相同的公共代码，造成浪费； (2) 使用动态链接库的应用程序不是自完备的，它依赖的DLL模块也要存在，如果使用载入时动态链接，程序启动时发现DLL不存在，系统将终止程序并给出错误信息。而使用运行时动态链接，系统不会终止，但由于DLL中的导出函数不可用，程序会加载失败；速度比静态链接慢。当某个模块更新后，如果新模块与旧的模块不兼容，那么那些需要该模块才能运行的软件，统统撕掉。这在早期Windows中很常见。]]></content>
      <categories>
        <category>操作系统</category>
        <category>操作系统概念</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统面试题]]></title>
    <url>%2F2019%2F03%2F21%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[一、操作系统概念1. 操作系统的四大特性并发、共享、虚拟、异步。 共享：指系统中的资源可供内存中多个并发执行的进程共同使用。 异步：多进程时，进程是以人们不可预知的速度向前推进的，此即进程的异步性。 2. 进程与线程的概念进程是程序运行的实体，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发； 线程是进程的子任务，是CPU调度和分派的基本单位，实现进程内部的并发； 线程是操作系统可识别的最小执行和调度单位。每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。每个线程完成不同的任务，但是共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源。 3. 进程与线程的区别可以从资源调度（2、3）、通讯（5）、开销（4、6）、关系（1、7）、应用（8）分析 1.一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。 2.进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。） 3.进程是资源分配的最小单位，线程是CPU调度的最小单位； 4.系统开销： 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／o设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。 5.通信：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预 6.进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。 7.进程间不会相互影响 ；线程一个线程挂掉将导致整个进程挂掉 8.进程适应于多核、多机分布；线程适用于多核 4. 进程状态转换图 1) 新状态：进程已经创建 2) 就绪态：进程做好了准备，准备执行，等待分配处理机 3) 执行态：该进程正在执行； 4) 阻塞态：等待某事件发生才能执行，如等待I/O完成； 5) 终止状态 5.进程间通讯进程间通信主要包括管道、系统IPC（包括消息队列、信号量、信号、共享内存等）、以及套接字socket。 1.管道： 管道主要包括无名管道和命名管道:管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信 1.1 普通管道PIPE： 1)它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端 2)它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间） 3)它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。 1.2 命名管道FIFO： 1)FIFO可以在无关的进程之间交换数据 2)FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。 2.系统IPC： 2.1 消息队列 消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标记。 (消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点)具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息； 特点： 1)消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。 2)消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。 3)消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。 2.2 信号量semaphore 信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。 特点： 1)信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。 2)信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。 3)每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。 4)支持信号量组。 2.3 信号signal 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。 2.4 共享内存（Shared Memory） 它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等 特点： 1)共享内存是最快的一种IPC，因为进程是直接对内存进行存取 2)因为多个进程可以同时操作，所以需要进行同步 3)信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问 3.套接字SOCKET： socket也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机之间的进程通信。 6.线程间通讯临界区：通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问； 互斥量Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问 信号量Semphare：为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。 事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作 6. 进程的创建过程？需要哪些函数？需要哪些数据结构?1) fork函数创造的子进程是父进程的完整副本，复制了父亲进程的资源，包括内存的内容task_struct内容； 2) vfork创建的子进程与父进程共享数据段，而且由vfork创建的子进程将先于父进程运行； 3) linux上创建线程一般使用的是pthread库，实际上linux也给我们提供了创建线程的系统调用，就是clone； 7. 进程创建子进程,fork详解1) 函数原型 pid_t fork(void); //void代表没有任何形式参数 2) 除了0号进程（系统创建的）之外，linux系统中都是由其他进程创建的。创建新进程的进程，即调用fork函数的进程为父进程，新建的进程为子进程。 3) fork**函数不需要任何参数，对于返回值有三种情况：** ① 对于父进程，fork函数返回新建子进程的pid； ② 对于子进程，fork函数返回 0； ③ 如果出错， fork 函数返回 -1。 int pid=fork(); if(pid &lt; 0){ //失败，一般是该用户的进程数达到限制或者内存被用光了 …….. } else if(pid == 0){ //子进程执行的代码 …… } else{ //父进程执行的代码 ……… } 8. 子进程和父进程怎么通信？1) 在Linux系统中实现父子进程的通信可以采用pipe()和fork()函数进行实现； 2) 对于父子进程，在程序运行时首先进入的是父进程，其次是子进程，在此我个人认为，在创建父子进程的时候程序是先运行创建的程序，其次在复制父进程创建子进程。fork()函数主要是以父进程为蓝本复制一个进程，其ID号和父进程的ID号不同。对于结果fork出来的子进程的父进程ID号是执行fork()函数的进程的ID号。 3) 管道：是指用于连接一个读进程和一个写进程，以实现它们之间通信的共享文件，又称pipe文件。 4) 写进程在管道的尾端写入数据，读进程在管道的首端读出数据。 9. 进程和作业的区别？1) 进程是程序的一次动态执行，属于动态概念； 2) 一个进程可以执行一个或几个程序，同一个程序可由几个进程执行； 3) 程序可以作为一种软件资源长期保留，而进程是程序的一次执行； 4) 进程具有并发性，能与其他进程并发执行； 5) 进程是一个独立的运行单位； 10. 死锁是什么？必要条件？如何解决？所谓死锁，是指多个进程循环等待它方占有的资源而无限期地僵持下去的局面。很显然，如果没有外力的作用，那麽死锁涉及到的各个进程都将永远处于封锁状态。当两个或两个以上的进程同时对多个互斥资源提出使用要求时，有可能导致死锁。 〈1〉 互斥条件。即某个资源在一段时间内只能由一个进程占有，不能同时被两个或两个以上的进程占有。这种独占资源如CD-ROM驱动器，打印机等等，必须在占有该资源的进程主动释放它之后，其它进程才能占有该资源。这是由资源本身的属性所决定的。如独木桥就是一种独占资源，两方的人不能同时过桥。 〈2〉 不可抢占条件。进程所获得的资源在未使用完毕之前，资源申请者不能强行地从资源占有者手中夺取资源，而只能由该资源的占有者进程自行释放。如过独木桥的人不能强迫对方后退，也不能非法地将对方推下桥，必须是桥上的人自己过桥后空出桥面（即主动释放占有资源），对方的人才能过桥。 〈3〉 占有且申请条件。进程至少已经占有一个资源，但又申请新的资源；由于该资源已被另外进程占有，此时该进程阻塞；但是，它在等待新资源之时，仍继续占用已占有的资源。还以过独木桥为例，甲乙两人在桥上相遇。甲走过一段桥面（即占有了一些资源），还需要走其余的桥面（申请新的资源），但那部分桥面被乙占有（乙走过一段桥面）。甲过不去，前进不能，又不后退；乙也处于同样的状况。 〈4〉 循环等待条件。存在一个进程等待序列{P1，P2，…，Pn}，其中P1等待P2所占有的某一资源，P2等待P3所占有的某一源，……，而Pn等待P1所占有的的某一资源，形成一个进程循环等待环。就像前面的过独木桥问题，甲等待乙占有的桥面，而乙又等待甲占有的桥面，从而彼此循环等待。 死锁的预防是保证系统不进入死锁状态的一种策略。它的基本思想是要求进程申请资源时遵循某种协议，从而打破产生死锁的四个必要条件中的一个或几个，保证系统不会进入死锁状态。 打破互斥条件。即允许进程同时访问某些资源。但是，有的资源是不允许被同时访问的，像打印机等等，这是由资源本身的属性所决定的。所以，这种办法并无实用价值。 打破不可抢占条件。即允许进程强行从占有者那里夺取某些资源。就是说，当一个进程已占有了某些资源，它又申请新的资源，但不能立即被满足时，它必须释放所占有的全部资源，以后再重新申请。它所释放的资源可以分配给其它进程。这就相当于该进程占有的资源被隐蔽地强占了。这种预防死锁的方法实现起来困难，会降低系统性能。 打破占有且申请条件。可以实行资源预先分配策略。即进程在运行前一次性地向系统申请它所需要的全部资源。如果某个进程所需的全部资源得不到满足，则不分配任何资源，此进程暂不运行。只有当系统能够满足当前进程的全部资源需求时，才一次性地将所申请的资源全部分配给该进程。由于运行的进程已占有了它所需的全部资源，所以不会发生占有资源又申请资源的现象，因此不会发生死锁。 打破循环等待条件，实行资源有序分配策略。采用这种策略，即把资源事先分类编号，按号分配，使进程在申请，占用资源时不会形成环路。所有进程对资源的请求必须严格按资源序号递增的顺序提出。进程占用了小号资源，才能申请大号资源，就不会产生环路，从而预防了死锁 死锁避免：银行家算法 11. 鸵鸟策略假设的前提是，这样的问题出现的概率很低。比如，在操作系统中，为应对死锁问题，可以采用这样的一种办法。当系统发生死锁时不会对用户造成多大影响，或系统很少发生死锁的场合采用允许死锁发生的鸵鸟算法，这样一来可能开销比不允许发生死锁及检测和解除死锁的小。如果死锁很长时间才发生一次，而系统每周都会因硬件故障、编译器错误或操作系统错误而崩溃一次，那么大多数工程师不会以性能损失或者易用性损失的代价来设计较为复杂的死锁解决策略，来消除死锁。鸵鸟策略的实质：出现死锁的概率很小，并且出现之后处理死锁会花费很大的代价，还不如不做处理，OS中这种置之不理的策略称之为鸵鸟策略（也叫鸵鸟算法）。 12. 银行家算法在避免死锁的方法中，所施加的限制条件较弱，有可能获得令人满意的系统性能。在该方法中把系统的状态分为安全状态和不安全状态，只要能使系统始终都处于安全状态，便可以避免发生死锁。 银行家算法的基本思想是分配资源之前，判断系统是否是安全的；若是，才分配。它是最具有代表性的避免死锁的算法。 设进程cusneed提出请求REQUEST [i]，则银行家算法按如下规则进行判断。 (1)如果REQUEST [cusneed] [i]&lt;= NEED[cusneed][i]，则转（2)；否则，出错。 (2)如果REQUEST [cusneed] [i]&lt;= AVAILABLE[i]，则转（3)；否则，等待。 (3)系统试探分配资源，修改相关数据： AVAILABLE[i]-=REQUEST[cusneed][i]; ALLOCATION[cusneed][i]+=REQUEST[cusneed][i]; NEED[cusneed][i]-=REQUEST[cusneed][i]; (4)系统执行安全性检查，如安全，则分配成立；否则试探险性分配作废，系统恢复原状，进程等待。 14. 线程同步的方式？怎么用？1) 线程同步是指多线程通过特定的设置来控制线程之间的执行顺序，也可以说在线程之间通过同步建立起执行顺序的关系； 2) 主要四种方式，临界区、互斥对象、信号量、事件对象；其中临界区和互斥对象主要用于互斥控制，信号量和事件对象主要用于同步控制； 3) 临界区：通过对多线程的串行化来访问公共资源或一段代码，速度快、适合控制数据访问。在任意一个时刻只允许一个线程对共享资源进行访问，如果有多个线程试图访问公共资源，那么在有一个线程进入后，其他试图访问公共资源的线程将被挂起，并一直等到进入临界区的线程离开，临界区在被释放后，其他线程才可以抢占。 4) 互斥对象：互斥对象和临界区很像，采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程同时访问。当前拥有互斥对象的线程处理完任务后必须将线程交出，以便其他线程访问该资源。 5) 信号量：它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。在用CreateSemaphore()创建信号量时即要同时指出允许的最大资源计数和当前可用资源计数。一般是将当前可用资源计数设置为最 大资源计数，每增加一个线程对共享资源的访问，当前可用资源计数就会减1 ，只要当前可用资源计数是大于0 的，就可以发出信号量信号。但是当前可用计数减小 到0 时则说明当前占用资源的线程数已经达到了所允许的最大数目，不能在允许其他线程的进入，此时的信号量信号将无法发出。线程在处理完共享资源后，应在离 开的同时通过ReleaseSemaphore （）函数将当前可用资源计数加1 。在任何时候当前可用资源计数决不可能大于最大资源计数。 6) 事件对象：通过通知操作的方式来保持线程的同步，还可以方便实现对多个线程的优先级比较的操作。 15. 页和段的区别？1) 页是信息的物理单位，分页是由于系统管理的需要。段是信息的逻辑单位，分段是为了满足用户的要求。 2) 页的大小固定且由系统决定，段的长度不固定，决定于用户所编写的程序，通常由编译程序在对源程序紧进行编译时，根据信息的性质来划分。 3) 分页的作业的地址空间是一维的，程序员只需要利用一个记忆符，即可表示一个地址。分段的作业地址空间则是二维的，程序员在标识一个地址时，既需要给出段名，又需要给出段的地址值。 16. 孤儿进程和僵尸进程的区别？怎么避免这两类进程？守护进程？1、 一般情况下，子进程是由父进程创建，而子进程和父进程的退出是无顺序的，两者之间都不知道谁先退出。正常情况下父进程先结束会调用 wait 或者 waitpid 函数等待子进程完成再退出，而一旦父进程不等待直接退出，则剩下的子进程会被init(pid=1)进程接收，成会孤儿进程。（进程树中除了init都会有父进程）。 2、 如果子进程先退出了，父进程还未结束并且没有调用 wait 或者 waitpid 函数获取子进程的状态信息，则子进程残留的状态信息（ task_struct 结构和少量资源信息）会变成僵尸进程。 子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程。 原理是将子进程成为孤儿进程，从而其的父进程变为init进程，通过init进程可以处理僵尸进程。 3、 守护进程（ daemon) 是指在后台运行，没有控制终端与之相连的进程。它独立于控制终端，通常周期性地执行某种任务 。守护进程脱离于终端是为了避免进程在执行过程中的信息在任何终端上显示并且进程也不会被任何终端所产生的终端信息所打断。 17. 守护进程是什么？怎么实现？\1. 守护进程（Daemon）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。守护进程是一种很有用的进程。 \2. 守护进程特点 1) 守护进程最重要的特性是后台运行。 2) 守护进程必须与其运行前的环境隔离开来。这些环境包括未关闭的文件描述符，控制终端，会话和进程组，工作目录以及文件创建掩模等。这些环境通常是守护进程从执行它的父进程（特别是shell）中继承下来的。 3) 守护进程的启动方式有其特殊之处。它可以在Linux系统启动时从启动脚本/etc/rc.d中启动，可以由作业规划进程crond启动，还可以由用户终端（shell）执行。 \3. 实现 1) 在父进程中执行fork并exit推出； 2) 在子进程中调用setsid函数创建新的会话； 3) 在子进程中调用chdir函数，让根目录 ”/” 成为子进程的工作目录； 4) 在子进程中调用umask函数，设置进程的umask为0； 5) 在子进程中关闭任何不需要的文件描述符 18. 线程和进程的区别？线程共享的资源是什么？1) 一个程序至少有一个进程，一个进程至少有一个线程 2) 线程的划分尺度小于进程，使得多线程程序的并发性高 3) 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率 4) 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制 5) 多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配 6) 一个进程中的所有线程共享该进程的地址空间，但它们有各自独立的（/私有的）栈(stack)，Windows线程的缺省堆栈大小为1M。堆(heap)的分配与栈有所不同，一般是一个进程有一个C运行时堆，这个堆为本进程中所有线程共享，windows进程还有所谓进程默认堆，用户也可以创建自己的堆。 线程私有：线程栈，寄存器，程序寄存器 共享：堆，地址空间，全局变量，静态变量 进程私有：地址空间，堆，全局变量，栈，寄存器 共享：代码段，公共数据，进程目录，进程ID 19. 线程比进程具有哪些优势？1) 线程在程序中是独立的，并发的执行流，但是，进程中的线程之间的隔离程度要小； 2) 线程比进程更具有更高的性能，这是由于同一个进程中的线程都有共性：多个线程将共享同一个进程虚拟空间； 3) 当操作系统创建一个进程时，必须为进程分配独立的内存空间，并分配大量相关资源； 20. 什么时候用多进程？什么时候用多线程？1) 需要频繁创建销毁的优先用线程； 2) 需要进行大量计算的优先使用线程； 3) 强相关的处理用线程，弱相关的处理用进程； 4) 可能要扩展到多机分布的用进程，多核分布的用线程； 21. 协程是什么？1) 是一种比线程更加轻量级的存在。正如一个进程可以拥有多个线程一样，一个线程可以拥有多个协程；协程不是被操作系统内核管理，而完全是由程序所控制。 2) 协程的开销远远小于线程； 3) 协程拥有自己寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切换回来的时候，恢复先前保存的寄存器上下文和栈。 4) 每个协程表示一个执行单元，有自己的本地数据，与其他协程共享全局数据和其他资源。 5) 跨平台、跨体系架构、无需线程上下文切换的开销、方便切换控制流，简化编程模型； 6) 协程又称为微线程，协程的完成主要靠yeild关键字，协程执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行； 7) 协程极高的执行效率，和多线程相比，线程数量越多，协程的性能优势就越明显； 8) 不需要多线程的锁机制； 22. 递归锁？1) 线程同步能够保证多个线程安全访问竞争资源，最简单的同步机制是引入互斥锁。互斥锁为资源引入一个状态：锁定/非锁定。某个线程要更改共享数据时，先将其锁定，此时资源的状态为“锁定”，其他线程不能更改；直到该线程释放资源，将资源的状态变成“非锁定”，其他的线程才能再次锁定该资源。互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性。 2) 读写锁从广义的逻辑上讲，也可以认为是一种共享版的互斥锁。如果对一个临界区大部分是读操作而只有少量的写操作，读写锁在一定程度上能够降低线程互斥产生的代价。 3) Mutex可以分为递归锁(recursive mutex)和非递归锁(non-recursive mutex)。可递归锁也可称为可重入锁(reentrant mutex)，非递归锁又叫不可重入锁(non-reentrant mutex)。二者唯一的区别是，同一个线程可以多次获取同一个递归锁，不会产生死锁。而如果一个线程多次获取同一个非递归锁，则会产生死锁。 23. 用户态到内核态的转化原理？1) 系统调用 这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如前例中fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。 2) 异常 当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。 3) 外围设备的中断 当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。 24. 中断的实现与作用，中断的实现过程？① 关中断，进入不可再次响应中断的状态，由硬件实现。 ② 保存断点，为了在中断处理结束后能正确返回到中断点。由硬件实现。 ③ 将中断服务程序入口地址送PC，转向中断服务程序。可由硬件实现，也可由软件实现。 ④ 保护现场、置屏蔽字、开中断，即保护CPU中某些寄存器的内容、设置中断处理次序、允许更高级的中断请求得到响应，实现中断嵌套。由软件实现。 ⑤ 设备服务，实际上有效的中断处理工作是在此程序段中实现的。由软件程序实现 ⑥ 退出中断。在退出时，又应进入不可中断状态，即关中断、恢复屏蔽字、恢复现场、开中断、中断返回。由软件实现。 25. 系统中断是什么，用户态和内核态的区别1) 内核态与用户态是操作系统的两种运行级别,当程序运行在3级特权级上时，就可以称之为运行在用户态，因为这是最低特权级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态；反之，当程序运行在0级特权级上时，就可以称之为运行在内核态。运行在用户态下的程序不能直接访问操作系统内核数据结构和程序。当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态。 2) 这两种状态的主要差别是： 处于用户态执行时，进程所能访问的内存空间和对象受到限制，其所处于占有的处理机是可被抢占的 ； 而处于核心态执行中的进程，则能访问所有的内存空间和对象，且所占有的处理机是不允许被抢占的。 26. CPU中断1) CPU中断是什么 ① 计算机处于执行期间； ② 系统内发生了非寻常或非预期的急需处理事件； ③ CPU暂时中断当前正在执行的程序而转去执行相应的事件处理程序； ④ 处理完毕后返回原来被中断处继续执行； 2) CPU中断的作用 ① 可以使CPU和外设同时工作，使系统可以及时地响应外部事件； ② 可以允许多个外设同时工作，大大提高了CPU的利用率； ③ 可以使CPU及时处理各种软硬件故障。 27. 执行一个系统调用时，OS发生的过程，越详细越好 1．执行用户程序(如:fork)2． 根据glibc中的函数实现，取得系统调用号并执行int $0x80产生中断。 3． 进行地址空间的转换和堆栈的切换，执行SAVE_ALL。（进行内核模式） 4． 进行中断处理，根据系统调用表调用内核函数。 5． 执行内核函数。 6． 执行RESTORE_ALL并返回用户模式 28. 函数调用和系统调用的区别？1) 系统调用 ① 操作系统提供给用户程序调用的一组特殊的接口。用户程序可以通过这组特殊接口来获得操作系统内核提供的服务； ② 系统调用可以用来控制硬件；设置系统状态或读取内核数据；进程管理，系统调用接口用来保证系统中进程能以多任务在虚拟环境下运行； ③ Linux中实现系统调用利用了0x86体系结构中的软件中断； 2) 函数调用 ① 函数调用运行在用户空间； ② 它主要是通过压栈操作来进行函数调用； 3) 区别 29. 经典同步问题解法：生产者与消费者问题，哲学家进餐问题，读者写者问题。30. 虚拟内存？使用虚拟内存的优点？什么是虚拟地址空间？1) 虚拟内存，虚拟内存是一种内存管理技术，它会使程序自己认为自己拥有一块很大且连续的内存，然而，这个程序在内存中不是连续的，并且有些还会在磁盘上，在需要时进行数据交换; 2) 优点：可以弥补物理内存大小的不足；一定程度的提高反应速度；减少对物理内存的读取从而保护内存延长内存使用寿命； 3) 缺点：占用一定的物理硬盘空间；加大了对硬盘的读写；设置不得当会影响整机稳定性与速度。 4) 虚拟地址空间是对于一个单一进程的概念，这个进程看到的将是地址从0000开始的整个内存空间。虚拟存储器是一个抽象概念，它为每一个进程提供了一个假象，好像每一个进程都在独占的使用主存。每个进程看到的存储器都是一致的，称为虚拟地址空间。从最低的地址看起：程序代码和数据，堆，共享库，栈，内核虚拟存储器。大多数计算机的字长都是32位，这就限制了虚拟地址空间为4GB。 31. 线程安全？如何实现？1) 如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。 2) 线程安全问题都是由全局变量及静态变量引起的。 3) 若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。 4) 对于线程不安全的对象我们可以通过如下方法来实现线程安全： ① 加锁 利用Synchronized或者ReenTrantLock来对不安全对象进行加锁，来实现线程执行的串行化，从而保证多线程同时操作对象的安全性，一个是语法层面的互斥锁，一个是API层面的互斥锁. ② 非阻塞同步来实现线程安全。原理就是：通俗点讲，就是先进性操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生冲突，那就再采取其他措施(最常见的措施就是不断地重试，知道成功为止)。这种方法需要硬件的支持，因为我们需要操作和冲突检测这两个步骤具备原子性。通常这种指令包括CAS SC,FAI TAS等。 ③ 线程本地化，一种无同步的方案，就是利用Threadlocal来为每一个线程创造一个共享变量的副本来（副本之间是无关的）避免几个线程同时操作一个对象时发生线程安全问题。 32. linux文件系统\1. 层次分析 1) 用户层，日常使用的各种程序，需要的接口主要是文件的创建、删除、读、写、关闭等； 2) VFS层，文件相关的操作都有对应的System Call函数接口，接口调用VFS对应的函数； 3) 文件系统层，用户的操作通过VFS转到各种文件系统。文件系统把文件读写命令转化为对磁盘LBA的操作，起了一个翻译和磁盘管理的工作； 4) 缓存层； 5) 块设备层，块设备接口Block Device是用来访问磁盘LBA的层级，读写命令组合之后插入到命令队列，磁盘的驱动从队列读命令执行； 6) 磁盘驱动层； 7) 磁盘物理层； \2. 读取文件过程 1) 根据文件所在目录的inode信息，找到目录文件对应数据块； 2) 根据文件名从数据块中找到对应的inode节点信息； 3) 从文件inode节点信息中找到文件内容所在数据块块号； 4) 读取数据块内容 33. 常见的IO模型，五种？异步IO应用场景？有什么缺点？1) 同步 就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。也就是必须一件一件事做*,*等前一件做完了才能做下一件事。就是我调用一个功能，该功能没有结束前，我死等结果。 2) 异步 当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。就是我调用一个功能，不需要知道该功能结果，该功能有结果后通知我（回调通知） 3) 阻塞 阻塞调用是指调用结果返回之前，当前线程会被挂起（线程进入非可执行状态，在这个状态下，cpu不会给线程分配时间片，即线程暂停运行）。函数只有在得到结果之后才会返回。对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回而已。 就是调用我（函数），我（函数）没有接收完数据或者没有得到结果之前，我不会返回。 4) 非阻塞 指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。就是调用我（函数），我（函数）立即返回，通过select通知调用者。 1) 阻塞I/O 应用程序调用一个IO函数，导致应用程序阻塞，等待数据准备好。 如果数据没有准备好，一直等待….数据准备好了，从内核拷贝到用户空间,IO函数返回成功指示。 2) 非阻塞I/O 我们把一个SOCKET接口设置为非阻塞就是告诉内核，当所请求的I/O操作无法完成时，不要将进程睡眠，而是返回一个错误。这样我们的I/O操作函数将不断的测试数据是否已经准备好，如果没有准备好，继续测试，直到数据准备好为止。在这个不断测试的过程中，会大量的占用CPU的时间。 3) I/O复用 I/O复用模型会用到select、poll、epoll函数，这几个函数也会使进程阻塞，但是和阻塞I/O所不同的的，这三个函数可以同时阻塞多个I/O操作。而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写时，才真正调用I/O操作函数。 4) 信号驱动I/O 首先我们允许套接口进行信号驱动I/O,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。 5) 异步I/O 当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者的输入输出操作。 34. IO复用的原理？零拷贝？三个函数？epoll 的 LT 和 ET 模式的理解。1) IO复用是Linux中的IO模型之一，IO复用就是进程预先告诉内核需要监视的IO条件，使得内核一旦发现进程指定的一个或多个IO条件就绪，就通过进程进程处理，从而不会在单个IO上阻塞了。Linux中，提供了select、poll、epoll三种接口函数来实现IO复用。 2) Select select的缺点： ① 单个进程能够监视的文件描述符的数量存在最大限制，通常是1024。由于select采用轮询的方式扫描文件描述符，文件描述符数量越多，性能越差； ② 内核/用户空间内存拷贝问题，select需要大量句柄数据结构，产生巨大开销； ③ Select返回的是含有整个句柄的数组，应用程序需要遍历整个数组才能发现哪些句柄发生事件； ④ Select的触发方式是水平触发，应用程序如果没有完成对一个已经就绪的文件描述符进行IO操作，那么每次select调用还会将这些文件描述符通知进程。 3) Poll 与select相比，poll使用链表保存文件描述符，一你才没有了监视文件数量的限制，但其他三个缺点依然存在 4) Epoll 上面所说的select缺点在epoll上不复存在，epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。Epoll是事件触发的，不是轮询查询的。没有最大的并发连接限制，内存拷贝，利用mmap（）文件映射内存加速与内核空间的消息传递。 区别总结： 1) 支持一个进程所能打开的最大连接数 ① Select最大1024个连接，最大连接数有FD_SETSIZE宏定义，其大小是32位整数表示，可以改变宏定义进行修改，可以重新编译内核，性能可能会影响； ② Poll没有最大连接限制，原因是它是基于链表来存储的； ③ 连接数限数有上限，但是很大； 2) FD剧增后带来的IO效率问题 ① 因为每次进行线性遍历，所以随着FD的增加会造成遍历速度下降，效率降低； ② Poll同上； ③ 因为epool内核中实现是根据每个fd上的callback函数来实现的，只有活跃的socket才会主动调用callback，所以在活跃socket较少的情况下，使用epoll没有前面两者的现象下降的性能问题。 3) 消息传递方式 ① Select内核需要将消息传递到用户空间，都需要内核拷贝； ② Poll同上； ③ Epoll通过内核和用户空间共享来实现的。 epoll 的 LT 和 ET 模式的理解： epoll对文件描述符的操作有两种模式：LT(level trigger)和ET(edge trigger)，LT是默认模式。 ​ 区别： LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。 ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。 35. Linux是如何避免内存碎片的1) 在固定式分区分配中, 为将一个用户作业装入内存, 内存分配程序从系统分区表中找出一个能满足作业要求的空闲分区分配给作业, 由于一个作业的大小并不一定与分区大小相等, 因此, 分区中有一部分存储空间浪费掉了. 由此可知, 固定式分区分配中存在内碎片. 2) 在可变式分区分配中, 为把一个作业装入内存, 应按照一定的分配算法从系统中找出一个能满足作业需求的空闲分区分配给作业, 如果这个空闲分区的容量比作业申请的空间容量要大, 则将该分区一分为二, 一部分分配给作业, 剩下的部分仍然留作系统的空闲分区。由此可知，可变式分区分配中存在外碎片. 3) 伙伴系统 4) 据可移动性组织页避免内存碎片 36. 递归的原理是啥？递归中遇到栈溢出怎么解决1) 基本原理 第一：每一级的函数调用都有它自己的变量。 第二：每一次函数调用都会有一次返回，并且是某一级递归返回到调用它的那一级，而不是直接返回到main()函数中的初始调用部分。 第三：递归函数中，位于递归调用前的语句和各级被调函数具有相同的执行顺序。例如在上面的程序中，打印语句#1位于递归调用语句之前，它按照递归调用的顺序被执行了4次，即依次为第一级、第二级、第三级、第四级。 第四：递归函数中，位于递归调用后的语句的执行顺序和各个被调函数的顺序相反。例如上面程序中，打印语句#2位于递归调用语句之后，其执行顺序依次是：第四级、第三级、第二级、第一级。（递归调用的这种特性在解决涉及到反向顺序的编程问题中很有用，下文会说到） 第五：虽然每一级递归都有自己的变量，但是函数代码不会复制。 第六：递归函数中必须包含终止递归的语句。通常递归函数会使用一个if条件语句或其他类似语句一边当函数参数达到某个特定值时结束递归调用，如上面程序的if(n &gt; 4)。 2) 用递归实现算法时，有两个因素是至关重要的：递归式和递归边界； 3) 函数调用时通过栈（Stack）来实现的，每当调用一个函数，栈就会加一层栈帧，函数返回就减一层栈帧。而栈资源有限，当递归深度达到一定程度后，就会出现意想不到的结果，比如堆栈溢出； 4) 利用循环函数或者栈加while循环来代替递归函数。 37. ++i是否是原子操作i++的操作分三步： （1）栈中取出i （2）i自增1 （3）将i存到栈 所以i++不是原子操作，上面的三个步骤中任何一个步骤同时操作，都可能导致i的值不正确自增 二.++i 在多核的机器上，cpu在读取内存i时也会可能发生同时读取到同一值，这就导致两次自增，实际只增加了一次。 综上，我认为i++和++i都不是原子操作。 38. 缺页中断，页表寻址1) 一个进程对应一个页表，分页存储机制，一个进程对应很多页，执行进程时并不是所有页装入内存中，部分装入内存，当需要的那页不存在内存中，将发生缺页中断，将需要的那页从外存中调入内存中； 2) 页表寻址，页分为页号（从0开始编号）与页内偏移地址，两个寄存器，页表基地址寄存器，页表长度寄存器，块表；页的大小相同，内存中的块与页大小相同，页大小相同，页在逻辑上连续在物理上不连续； 3) 调页算法：先进先出，最佳页面置换算法（OPT），最近最久未使用（NRU），最近最少使用置换算法（LRU），先进先出算法（FIFO）会导致Baley问题；抖动，页面在内存与外存中的频繁调页； 4) 程序局部性原理，时间局部性、空间局部性； 39. LRU的实现1) 用一个数组来存储数据，给每一个数据项标记一个访问时间戳，每次插入新数据项的时候，先把数组中存在的数据的时间戳自增，并将新数据时间戳置为0插入到数组中。每次访问数组中的数据项的时候，将被访问的数据项时间戳置为0。当数组空间已经满时，将时间戳最大的数据项淘汰； 2) 利用一个链表来实现，每次新插入数据的时候将新数据插入到链表头部；每次缓存命中，则将数据移动到链表头部；那么当链表满时，就将链表尾部的数据丢弃； 3) 利用链表和hashmap。当需要插入新的数据项 的时候，如果新数据命中，则把该节点放到链表头部，如果不存在，则将新数据放在链表头部。若缓存满了，则将链表尾部的节点删除。 40. 内存分区1) 固态分区，分区大小固定，但并不一定相同； 2) 可变分区，分区大小动态变化，首先适配、最佳适配、最差适配、下一次适配； 41. 伙伴系统相关1) 伙伴系统是一种经典的内存管理方法。Linux伙伴系统的引入为内核提供了一种用于分配一组连续的页而建立的一种高效的分配策略，并有效的解决了外碎片问题。 2) Linux中的内存管理的“页”大小为4KB。把所有的空闲页分组为11个块链表，每个块链表分别包含大小为1，2，4，8，16，32，64，128，256，512和1024个连续页框的页块。最大可以申请1024个连续页，对应4MB大小的连续内存。每个页块的第一个页的物理地址是该块大小的整数倍。 3) 当向内核请求分配(2^(i-1)，2^i]数目的页块时，按照2^i页块请求处理。如果对应的块链表中没有空闲页块，则在更大的页块链表中找。当分配的页块中有多余的页时，伙伴系统根据多余的页框大小插入到对应的空闲页块链表中。 当释放单页的内存时，内核将其置于CPU高速缓存中，对很可能出现在cache的页，则放到“快表”的列表中。在此过程中，内核先判断CPU高速缓存中的页数是否超过一定“阈值”，如果是，则将一批内存页还给伙伴系统，然后将该页添加到CPU高速缓存中。 当释放多页的块时，内核首先计算出该内存块的伙伴的地址。内核将满足以下条件的三个块称为伙伴：(1)两个块具有相同的大小，记作b。(2)它们的物理地址是连续的。(3)第一块的第一个页的物理地址是2*(2^b)的倍数。如果找到了该内存块的伙伴，确保该伙伴的所有页都是空闲的，以便进行合并。内存继续检查合并后页块的“伙伴”并检查是否可以合并，依次类推。 4) 内核将已分配页分为以下三种不同的类型： 不可移动页：这些页在内存中有固定的位置，不能够移动。 可回收页：这些页不能移动，但可以删除。内核在回收页占据了太多的内存时或者内存短缺时进行页面回收。 可移动页：这些页可以任意移动，用户空间应用程序使用的页都属于该类别。它们是通过页表映射的。当它们移动到新的位置，页表项也会相应的更新。 42. I/O控制方式1) 直接I/O（轮询） 程序查询方式也称为程序轮询方式，该方式采用用户程序直接控制主机与外部设备之间输入/输出操作。CPU必须不停地循环测试I/O设备的状态端口，当发现设备处于准备好(Ready)状态时，CPU就可以与I/O设备进行数据存取操作。这种方式下的CPU与I/O设备是串行工作的，输入/输出一般以字节或字为单位进行。这个方式频繁地测试I/O设备，I/O设备的速度相对来说又很慢，极大地降低了CPU的处理效率，并且仅仅依靠测试设备状态位来进行数据传送，不能及时发现传输中的硬件错误。 2) 中断 当I/O设备结束(完成、特殊或异常)时，就会向CPU发出中断请求信号，CPU收到信号就可以采取相应措施。当某个进程要启动某个设备时，CPU就向相应的设备控制器发出一条设备I/O启动指令，然后CPU又返回做原来的工作。CPU与I/O设备可以并行工作，与程序查询方式相比，大大提高了CPU的利用率。但是在中断方式下，同程序查询方式一样，也是以字节或字为单位进行。但是该方法大大降低了CPU的效率，因为当中断发生的非常频繁的时候，系统需要进行频繁的中断源识别、保护现场、中断处理、恢复现场。这种方法对于以“块”为存取单位的块设备，效率是低下的。 3) DMA DMA方式也称为直接主存存取方式，其思想是：允许主存储器和I/O设备之间通过“DMA控制器(DMAC)”直接进行批量数据交换，除了在数据传输开始和结束时，整个过程无须CPU的干预。每传输一个“块”数据只需要占用一个主存周期。 4) 通道 通道(Channel)也称为外围设备处理器、输入输出处理机，是相对于CPU而言的。是一个处理器。也能执行指令和由指令的程序，只不过通道执行的指令是与外部设备相关的指令。是一种实现主存与I/O设备进行直接数据交换的控制方式，与DMA控制方式相比，通道所需要的CPU控制更少，一个通道可以控制多个设备，并且能够一次进行多个不连续的数据块的存取交换，从而大大提高了计算机系统效率。 43. Spooling技术1) 假脱机系统； 在联机的情况下实现的同时外围操作的技术称为SPOOLing技术，或称为假脱机技术。 2) 组成 1. 输入井和输出井:输入井和输出井的存储区域是在磁盘上开辟出来的。输入输出井中的数据一般以文件的形式组织管理，这些文件称之为井文件。一个文件仅存放某一个进程的输入或输出数据，所有进程的数据输入或输出文件链接成为一个输入输出队列。 2. 输入缓冲区和输出缓冲区**:输入缓冲区和输出缓冲区的存储区域是在内存**中开辟出来的。主要用于缓和CPU和磁盘之间速度不匹配的矛盾。输入缓冲区用于暂存有输入设备传送的数据，之后再传送到输入井；输出缓冲区 同理。 3. 输入进程和输出进程:输入进程也称为预输入进程，用于模拟脱机输入时的外围控制机，将用户要求的数据从输入设备传送到输入缓冲区，再存放到输入井。当CPU需要的时候，直接从输入井将数据读入内存。反之，输出的同理。 4. 井管理程序:用于控制作业与磁盘井之间信息的交换。 3) 特点 ① 提高了I/O的速度:,对数据执行的I/O操作，已从对低速I/O设备执行的I/O操作演变为对磁盘缓冲区中数据的存取，如同脱机输入输出一样，提高了I/O速度，缓和了CPU和低速的I/Os设备之间速度的不匹配的矛盾。 ② 将独占设备改造成了共享设备:因为在假脱机打印机系统中，实际上并没有为任何进程分配设备，而只是在磁盘缓冲区中为进程分配了一个空闲盘块和建立了一张I/O请求表。 ③ 实现了虚拟设备功能:宏观上，对于每一个进程而言，它们认为是自己独占了一个设备，即使实际上是多个进程在同时使用一台独占设备。也可以说，假脱机系统，实现了将独占设备变换为若干台对应的逻辑设备的功能。 44. 通道技术1) 通道是独立于CPU，专门用来负责数据输入/输出传输工作的处理机，对外部设备实现统一管理，代替CPU对输入/输出操作进行控制，从而使输入，输出操作可与CPU并行操作。 2) 引入通道的目的 为了使CPU从I/O事务中解脱出来，同时为了提高CPU与设备，设备与设备之间的并行工作能力 45. 共享内存的实现1) 两个不同进程A、B共享内存的意思是，同一块物理内存被映射到进程A、B各自的进程地址空间。进程A可以即时看到进程B对共享内存中数据的更新，反之亦然。由于多个进程共享同一块内存区域，必然需要某种同步机制，互斥锁和信号量都可以。 2) 共享内存是通过把同一块内存分别映射到不同的进程空间中实现进程间通信。而共享内存本身不带任何互斥与同步机制，但当多个进程同时对同一内存进行读写操作时会破坏该内存的内容，所以，在实际中，同步与互斥机制需要用户来完成。 3) （1）共享内存就是允许两个不想关的进程访问同一个内存 （2）共享内存是两个正在运行的进程之间共享和传递数据的最有效的方式 （3）不同进程之间共享的内存通常安排为同一段物理内存 （4）共享内存不提供任何互斥和同步机制，一般用信号量对临界资源进行保护。 （5）接口简单 46. 计一个线程池，内存池1) 为什么需要线程池 大多数的网络服务器，包括Web服务器都具有一个特点，就是单位时间内必须处理数目巨大的连接请求，但是处理时间却是比较短的。在传统的多线程服务器模型中是这样实现的：一旦有个请求到达，就创建一个新的线程，由该线程执行任务，任务执行完毕之后，线程就退出。这就是”即时创建，即时销毁”的策略。尽管与创建进程相比，创建线程的时间已经大大的缩短，但是如果提交给线程的任务是执行时间较短，而且执行次数非常频繁，那么服务器就将处于一个不停的创建线程和销毁线程的状态。这笔开销是不可忽略的，尤其是线程执行的时间非常非常短的情况。 2) 线程池原理 在应用程序启动之后，就马上创建一定数量的线程，放入空闲的队列中。这些线程都是处于阻塞状态，这些线程只占一点内存，不占用CPU。当任务到来后，线程池将选择一个空闲的线程，将任务传入此线程中运行。当所有的线程都处在处理任务的时候，线程池将自动创建一定的数量的新线程，用于处理更多的任务。执行任务完成之后线程并不退出，而是继续在线程池中等待下一次任务。当大部分线程处于阻塞状态时，线程池将自动销毁一部分的线程，回收系统资源。 3) 线程池的作用 需要大量的线程来完成任务，且完成任务的时间比较短；对性能要求苛刻的应用；对性能要求苛刻的应用 4) 内存池的原理 在软件开发中，有些对象使用非常频繁，那么我们可以预先在堆中实例化一些对象，我们把维护这些对象的结构叫“内存池”。在需要用的时候，直接从内存池中拿，而不用从新实例化，在要销毁的时候，不是直接free/delete，而是返还给内存池。把那些常用的对象存在内存池中，就不用频繁的分配/回收内存，可以相对减少内存碎片，更重要的是实例化这样的对象更快，回收也更快。当内存池中的对象不够用的时候就扩容。 5) 内存池的优缺点 内存池对象不是线程安全的，在多线程编程中，创建一个对象时必须加锁。 二、Linux1. Inode节点1) Linux操作系统引进了一个非常重要的概念inode，中文名为索引结点，引进索引接点是为了在物理内存上找到文件块，所以inode中包含文件的相关基本信息，比如文件位置、文件创建者、创建日期、文件大小等待，输入stat指令可以查看某个文件的inode信息； 2) 硬盘格式化的时候，操作系统自动将硬盘分成两个区域，一个是数据区，一个是inode区，存放inode所包含的信息，查看每个硬盘分区的inode总数和已经使用的数量，可以用df命令； 3) 在linux系统中，系统内部并不是采用文件名查找文件，而是使用inode编号来识别文件。查找文件分为三个过程：系统找到这个文件名对应的inode号码，通过inode号码获得inode信息，根据inode信息找到文件数据所在的block读取数据； 4) 除了文件名之外的所有文件信息，都存储在inode之中。 2. Linux软连接、硬链接，删除了软连接的源文件软连接可用？1) 软链接可以看作是Windows中的快捷方式，可以让你快速链接到目标档案或目录。硬链接则透过文件系统的inode来产生新档名，而不是产生新档案。 2) 软链接（符号链接） ln -s source target 硬链接 （实体链接）ln source target 3) 硬链接(hard link)：A是B的硬链接（A和B都是文件名），则A的目录项中的inode节点号与B的目录项中的inode节点号相同，即一个inode节点对应两个不同的文件名，两个文件名指向同一个文件，A和B对文件系统来说是完全平等的。如果删除了其中一个，对另外一个没有影响。每增加一个文件名，inode节点上的链接数增加一，每删除一个对应的文件名，inode节点上的链接数减一，直到为0，inode节点和对应的数据块被回收。注：文件和文件名是不同的东西，rm A删除的只是A这个文件名，而A对应的数据块（文件）只有在inode节点链接数减少为0的时候才会被系统回收。 4) 软链接(soft link)：A是B的软链接（A和B都是文件名），A的目录项中的inode节点号与B的目录项中的inode节点号不相同，A和B指向的是两个不同的inode，继而指向两块不同的数据块。但是A的数据块中存放的只是B的路径名（可以根据这个找到B的目录项）。A和B之间是“主从”关系，如果B被删除了，A仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。 5) 硬链接 不能对目录创建硬链接；不能对不同的文件系统创建硬链接；不能对不存在的文件创建硬链接； 6) 软连接 可以对目录创建软连接；可以跨文件系统；可以对不存在的文件创建软连接； 7) 因为链接文件包含有原文件的路径信息，所以当原文件从一个目录下移到其他目录中，再访问链接文件，系统就找不到了，而硬链接就没有这个缺陷，你想怎么移就怎么移；还有它要系统分配额外的空间用于建立新的索引节点和保存原文件的路径。 3. Linux系统应用程序的内存空间是怎么分配的,用户空间多大，内核空间多大？1) Linux内核将这4G字节的空间分为两部分。将最高的 1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为“内核空间”。而将较低的3G字节（从虚拟地址 0x00000000到0xBFFFFFFF），供各个进程使用，称为“用户空间“。因为每个进程可以通过系统调用进入内核，因此，Linux内核由系统 内的所有进程共享。于是，从具体进程的角度来看，每个进程可以拥有4G字节的虚拟空间。 4. Linux的共享内存如何实现1) 管道只能在具有亲缘关系的进程间进行通信；通过文件共享，在处理效率上又差一些，而且访问文件描述符不如访问内存地址方便； 2) mmap内存共享映射，mmap本来是存储映射功能，它可以将一个文件映射到内存中，在程序里就可以直接使用内存地址对文件内容进行访问；Linux的mmap实现了一种可以在父子进程之间共享内存地址的方式； 3) XSI共享内存，XSI是X/Open组织对UNIX定义的一套接口标准（X/Open System Interface）。XSI共享内存在Linux底层的实现实际上跟mmap没有什么本质不同，只是在使用方法上有所区别。 4) POSIX共享内存，Linux提供的POSIX共享内存，实际上就是在/dev/shm下创建一个文件，并将其mmap之后映射其内存地址即可。 5. 文件处理grep,awk,sed这三个命令必知必会1) grep grep (global search regular expression(RE) and print out the line,全面搜索正则表达式并把行打印出来)是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。常用来在结果中搜索特定的内容。 2) awk awk是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件(或其他方式的输入流, 如重定向输入)逐行的读入（看作一个记录集）, 把每一行看作一条记录，以空格(或\t,或用户自己指定的分隔符)为默认分隔符将每行切片（类似字段），切开的部分再进行各种分析处理。 3) sed sed更侧重对搜索文本的处理，如修改、删除、替换等等。sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。 6. 查询进程占用CPU的命令1) top top命令可以实时动态地查看系统的整体运行情况，是一个综合了多方信息监测系统性能和运行信息的实用工具。 2) ps ps命令就是最基本进程查看命令。使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵尸、哪些进程占用了过多的资源等等.总之大部分信息都是可以通过执行该命令得到。ps是显示瞬间进程的状态，并不动态连续；如果想对进程进行实时监控应该用top命令。 7. 一个程序从开始运行到结束的完整过程1) 预处理，主要处理源代码中的预处理指令，引入头文件，去除注释，处理所有的条件编译指令，宏替换，添加行号。经过预处理指令后生成一个.i文件； 2) 编译，编译过程所进行的是对预处理后的文件进行语法分析、词法分析、符号汇总，然后生成汇编代码。生成.s文件； 3) 汇编，将汇编文件转换成二进制文件，二进制文件就可以让机器来读取。生成.o文件； 4) 链接，由汇编程序生成的目标文件并不能立即就被执行，其中可能还有许多没有解决的问题。 8. 一般情况下在Linux/windows平台下栈空间的大小windows是编译器决定栈的大小，记录在可执行文件中，默认是1M。linux是操作系统来决定的，在系统环境变量中设置， ulimit -s 字节数 命令查看修改，但是linux默认栈大小为10M;vs编译器设置：属性—&gt;设置à链接à输出à栈分配à重新设置； 9. Linux重定向1 重定向符号 &gt;输出重定向到一个文件或设备 覆盖原来的文件 !输出重定向到一个文件或设备 强制覆盖原来的文件 &gt;输出重定向到一个文件或设备 追加原来的文件 &lt;输入重定向到一个程序 2标准错误重定向符号 2&gt;将一个标准错误输出重定向到一个文件或设备 覆盖原来的文件 b-shell 2&gt;&gt;将一个标准错误输出重定向到一个文件或设备 追加到原来的文件 2&gt;&amp;1将一个标准错误输出重定向到标准输出 注释:1 可能就是代表 标准输出 &amp;将一个标准错误输出重定向到一个文件或设备 覆盖原来的文件 c-shell |&amp;将一个标准错误 管道 输送 到另一个命令作为输入 3命令重导向示例 在 bash 命令执行的过程中，主要有三种输出入的状况，分别是： 标准输入；代码为 0 ；或称为 stdin ；使用的方式为 &lt; 标准输出：代码为 1 ；或称为 stdout；使用的方式为 1&gt; 错误输出：代码为 2 ；或称为 stderr；使用的方式为 2&gt; 10. Linux常用命令1) ls命令，不仅可以查看linux文件包含的文件，而且可以查看文件权限； 2) cd命令，切换当前目录到dirName 3) pwd命令，查看当前工作目录路径； 4) mkdir命令，创建文件夹 5) rm命令，删除一个目录中的一个或多个文件或目录 6) rmdir命令，从一个目录中删除一个或多个子目录项， 7) mv命令，移动文件或修改文件名 8) cp命令，将源文件复制至目标文件，或将多个源文件复制至目标目录 9) cat命令，显示文件内容； 10) touch命令，创建一个文件 11) vim命令， 12) which命令查看可执行文件的位置，whereis查看文件的位置，find实际搜寻硬盘查询文件名称； 13) chmod命令，用于改变linux系统文件或目录的访问权限，421，ewr 14) tar命令，用来压缩和解压文件。tar本身不具有压缩功能，只具有打包功能，有关压缩及解压是调用其它的功能来完成。 15) chown命令，将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户ID; 16) ln命令； 17) grep命令，强大的文本搜索命令，grep全局正则表达式搜素； 18) ps命令，用来查看当前运行的进程状态，一次性查看，如果需要动态连续结果使用top; 19) top命令，显示当前系统正在执行的进程的相关信息，包括进程ID、内存占用率、CPU占用率等； 20) kill命令，发送指定的信号到相应进程。不指定型号将发送SIGTERM（15）终止指定进程。]]></content>
      <categories>
        <category>操作系统</category>
        <category>操作系统面试题</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>操作系统面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统-死锁]]></title>
    <url>%2F2019%2F03%2F21%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81%2F</url>
    <content type="text"><![CDATA[★★★ 死锁必要条件、解决死锁策略，能写出和分析死锁的代码，能说明在数据库管理系统或者 Java 中如何解决死锁。 所谓死锁是指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都** 将无法向前推进。现实生活中简单的例子：交通阻塞，两股相向而行的车流都想通过已被对方占用的道路，结果双方都不能前进。 1.死锁产生的原因1）系统资源的竞争 2）进程推进顺序非法 2.死锁产生的必要条件产生死锁必须同时满足以下四个条件，只要其中任一条件不成立，死锁就不会发生。 互斥条件：进程要求对所分配的资源进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。 不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放。 请求和保持条件：又称为部分分配条件。进程每次申请它所需要的一部分资源，在等待新资源的同时，进程继续占有已分配到的资源。 循环等待条件：存在一种进程资源的循环等待链，链中每个进程已获得的资源同时被链中下一个进程所请求。即存在一个处于等待状态的进程集合{P1，P2，P3，…，Pa}，其中P，等待的资源被P1（i-0，1，…，n-1）占有，Pn等待资源被P0占有。 例1：产生死锁的必要条件有（）。（2013·腾讯、2012·百度简答题） A.互斥条件 B.请求和保持条件 C.不可剥夺条件 D.循环等待条件 解答：ABCD。 例2：若系统中有6个队列，有多个进程均需要使用其中的3个，规定每个进程一次只允许申请一个队列，那么最多允许（）进程参与竞争，才不会造成死锁？（2012·淘宝） A.1个 B.2个 C.3个 D.4个 解答：B。设想如果有3个进程参与竞争，刚好每个进程都持有2个队列，这样系统中所有队列就全部被使用，3个进程都缺少一个队列完成任务，因而都无法继续进行下去，发生了死锁。 3.死锁处理策略1）预防死锁：设置某些限制条件，破坏产生死锁的四个必要条件中的一个或几个。 2）避免死锁：在资源的动态分配过程中，用某种方法防止系统进入不安全状态。银行家算法是著名的死锁避免算法。 3）死锁的检测及解除：无须采取任何限制性措施，允许进程在运行过程中发生死锁，通过系统的检测机制及时地检测出死锁的发生，然后采取某种措施解除死锁。死锁的检测可利用资源分配图来描述。死锁的解除主要方法如下： （1）资源剥夺法。 （2）撤销进程法。 （3）进程回退法。 例1：避免死锁的一个著名的算法是（）。（2012·腾讯） A.先入先出法 B.银行家算法 C.优先级算法 D.资源按序分配法 解答：B。 死锁代码分析]]></content>
      <categories>
        <category>操作系统</category>
        <category>操作系统概念</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux]]></title>
    <url>%2F2019%2F03%2F20%2FLinux%2F</url>
    <content type="text"><![CDATA[一 从认识操作系统开始1.1 操作系统简介我通过以下四点介绍什么操作系统： 操作系统（Operation System，简称OS）是管理计算机硬件与软件资源的程序，是计算机系统的内核与基石； 操作系统本质上是运行在计算机上的软件程序 ； 为用户提供一个与系统交互的操作界面 ； 操作系统分内核与外壳（我们可以把外壳理解成围绕着内核的应用程序，而内核就是能操作硬件的程序）。 1.2 操作系统简单分类 Windows: 目前最流行的个人桌面操作系统 ，不做多的介绍，大家都清楚。 Unix： 最早的多用户、多任务操作系统 .按照操作系统的分类，属于分时操作系统。Unix 大多被用在服务器、工作站，现在也有用在个人计算机上。它在创建互联网、计算机网络或客户端/服务器模型方面发挥着非常重要的作用。 Linux: Linux是一套免费使用和自由传播的类Unix操作系统.Linux存在着许多不同的Linux版本，但它们都使用了 Linux内核 。Linux可安装在各种计算机硬件设备中，比如手机、平板电脑、路由器、视频游戏控制台、台式计算机、大型机和超级计算机。严格来讲，Linux这个词本身只表示Linux内核，但实际上人们已经习惯了用Linux来形容整个基于Linux内核，并且使用GNU 工程各种工具和数据库的操作系统。 二 初探Linux2.1 Linux简介我们上面已经介绍到了Linux，我们这里只强调三点。 类Unix系统： Linux是一种自由、开放源码的类似Unix的操作系统 Linux内核： 严格来说，Linux这个词本身只表示Linux内核 Linux之父： 一个编程领域的传奇式人物。他是Linux内核的最早作者，随后发起了这个开源项目，担任Linux内核的首要架构师与项目协调者，是当今世界最著名的电脑程序员、黑客之一。他还发起了Git这个开源项目，并为主要的开发者。 2.2 Linux诞生简介 1991年，芬兰的业余计算机爱好者Linus Torvalds编写了一款类似Minix的系统（基于微内核架构的类Unix操作系统）被ftp管理员命名为Linux 加入到自由软件基金的GNU计划中; Linux以一只可爱的企鹅作为标志，象征着敢作敢为、热爱生活。 2.3 Linux的分类Linux根据原生程度，分为两种： 内核版本： Linux不是一个操作系统，严格来讲，Linux只是一个操作系统中的内核。内核是什么？内核建立了计算机软件与硬件之间通讯的平台，内核提供系统服务，比如文件管理、虚拟内存、设备I/O等； 发行版本： 一些组织或公司在内核版基础上进行二次开发而重新发行的版本。Linux发行版本有很多种（ubuntu和CentOS用的都很多，初学建议选择CentOS），如下图所示： 三 Linux文件系统概览3.1 Linux文件系统简介在Linux操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文件或是目录都被看作是一个文件。 也就是说在LINUX系统中有一个重要的概念：一切都是文件。其实这是UNIX哲学的一个体现，而Linux是重写UNIX而来，所以这个概念也就传承了下来。在UNIX系统中，把一切资源都看作是文件，包括硬件设备。UNIX系统把每个硬件都看成是一个文件，通常称为设备文件，这样用户就可以用读写文件的方式实现对硬件的访问。 3.2 文件类型与目录结构Linux支持5种文件类型 ： Linux的目录结构如下： Linux文件系统的结构层次鲜明，就像一棵倒立的树，最顶层是其根目录： 常见目录说明： /bin： 存放二进制可执行文件(ls、cat、mkdir等)，常用命令一般都在这里； /etc： 存放系统管理和配置文件； /home： 存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示； /usr ： 用于存放系统应用程序； /opt： 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里； /proc： 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息； /root： 超级用户（系统管理员）的主目录（特权阶级^o^）； /sbin: 存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如ifconfig等； /dev： 用于存放设备文件； /mnt： 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统； /boot： 存放用于系统引导时使用的各种文件； /lib ： 存放着和系统运行相关的库文件 ； /tmp： 用于存放各种临时文件，是公用的临时文件存储点； /var： 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等； /lost+found： 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里。 四 Linux基本命令下面只是给出了一些比较常用的命令。推荐一个Linux命令快查网站，非常不错，大家如果遗忘某些命令或者对某些命令不理解都可以在这里得到解决。 Linux命令大全：http://man.linuxde.net/ 4.1 目录切换命令 cd usr： 切换到该目录下usr目录 cd ..（或cd../）： 切换到上一层目录 cd /： 切换到系统根目录 cd ~： 切换到用户主目录 cd -： 切换到上一个操作所在目录 4.2 目录的操作命令(增删改查) mkdir 目录名称： 直接mkdir会在当前文件夹中创建一个文件夹，但是要保证上级文件夹存在，加上参数 -p ，可以连同上级文件夹一起创建： 1mkdir -p /home/yue/a/b/c ls或者ll（ll是ls -l的别名，ll命令可以看到该目录下的所有目录和文件的详细信息）：查看目录信息 2.rm [-rf] 目录`:** 删除目录（删） 注意：rm不仅可以删除目录，也可以删除其他文件或压缩包，但是默认只能删除文件，为了增强大家的记忆， 无论删除任何目录或文件，都直接使用rm -rf 目录/文件/压缩包 1rm -rf /home/yue/a/b #文件夹b和子文件夹c一块儿删除了 3.find 目录 参数`： 寻找目录（查） 示例： 列出当前目录及子目录下所有文件和文件夹: find . 在/home目录下查找以.txt结尾的文件名:find /home -name &quot;*.txt&quot; 同上，但忽略大小写: find /home -iname &quot;*.txt&quot; 当前目录及子目录下查找所有以.txt和.pdf结尾的文件:find . \( -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; \)或find . -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; 4.mv 目录名称 新目录名称： 修改目录的名称 —重命名（改） 1mv /home/test /home/test2 #将test文件夹重命名为test2 注意：mv的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行 重命名的操作。mv命令用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。后面会介绍到mv命令的另一个用法。 mv 目录名称 目录的新位置： 移动目录的位置—-剪切（改） 注意：mv语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作。另外mv与cp的结果不同，mv好像文件“搬家”，文件个数并未增加。而cp对文件进行复制，文件个数增加了。 5.cp 注意：cp命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不 用写-r递归 如将当前目录下的aaa文件复制到/tmp下，并命名为bbb： 1cp ./aaa /tmp/bbb 复制目录要用-r，如复制/etc/这个目录下所有内容到/tem下： 1cp -r /etc/ /tmp 6.rm [-rf] 目录: 删除目录（删） 注意：rm不仅可以删除目录，也可以删除其他文件或压缩包，但是默认只能删除文件，为了增强大家的记忆， 无论删除任何目录或文件，都直接使用rm -rf 目录/文件/压缩包 1rm -rf /home/yue/a/b #文件夹b和子文件夹c一块儿删除了 4.3 文件的操作命令(增删改查) touch 文件名称: 文件的创建（增） cat/more/less/tail 文件名称 文件的查看（查） cat： 查看显示文件内容 more： 可以显示百分比，回车可以向下一行， 空格可以向下一页，q可以退出查看 less： 可以使用键盘上的PgUp和PgDn向上 和向下翻页，q结束查看 tail-10 ： 查看文件的后10行，Ctrl+C结束 注意：命令 tail -f 文件 可以对某个文件进行动态监控，例如tomcat的日志文件， 会随着程序的运行，日志会变化，可以使用tail -f catalina-2016-11-11.log 监控 文 件的变化 vim 文件： 修改文件的内容（改） vim编辑器是Linux中的强大组件，是vi编辑器的加强版，vim编辑器的命令和快捷方式有很多，但此处不一一阐述，大家也无需研究的很透彻，使用vim编辑修改文件的方式基本会使用就可以了。 在实际开发中，使用vim编辑器主要作用就是修改配置文件，下面是一般步骤： vim 文件———&gt;进入文件——-&gt;命令模式———&gt;按i进入编辑模式——-&gt;编辑文件 ———-&gt;按Esc进入底行模式——-&gt;输入：wq/q! （输入wq代表写入内容并退出，即保存；输入q!代表强制退出不保存。） rm -rf 文件： 删除文件（删） 同目录删除：熟记 rm -rf 文件 即可 4.4 压缩文件的操作命令1）打包并压缩文件： Linux中的打包文件一般是以.tar结尾的，压缩的命令一般是以.gz结尾的。 而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。命令：tar -zcvf 打包压缩后的文件名 要打包压缩的文件其中： z：调用gzip压缩命令进行压缩 c：打包文件 v：显示运行过程 f：指定文件名 比如：加入test目录下有三个文件分别是：aaa.txt bbb.txt ccc.txt，如果我们要打包test目录并指定压缩后的压缩包名称为test.tar.gz可以使用命令：tar -zcvf test.tar.gz aaa.txt bbb.txt ccc.txt或：tar -zcvf test.tar.gz /test/ 2）解压压缩包： 命令：tar [-xvf] 压缩文件 其中：x：代表解压 示例： 1 将/test下的test.tar.gz解压到当前目录下可以使用命令：tar -xvf test.tar.gz 2 将/test下的test.tar.gz解压到根目录/usr下:tar -xvf xxx.tar.gz -C /usr（- C代表指定解压的位置） 4.5 Linux的权限命令 操作系统中每个文件都拥有特定的权限、所属用户和所属组。权限是操作系统用来限制资源访问的机制，在Linux中权限一般分为读(readable)、写(writable)和执行(excutable)，分为三组。分别对应文件的属主(owner)，属组(group)和其他用户(other)，通过这样的机制来限制哪些用户、哪些组可以对特定的文件进行什么样的操作。通过 ls -l 命令我们可以 查看某个目录下的文件或目录的权限 示例：在随意某个目录下ls -l 第一列的内容的信息解释如下： 下面将详细讲解文件的类型、Linux中权限以及文件有所有者、所在组、其它组具体是什么？ 文件的类型： d： 代表目录 -： 代表文件 l： 代表软链接（可以认为是window中的快捷方式） Linux中权限分为以下几种： r：代表权限是可读，r也可以用数字4表示 w：代表权限是可写，w也可以用数字2表示 x：代表权限是可执行，x也可以用数字1表示 文件和目录权限的区别： 对文件和目录而言，读写执行表示不同的意义。 对于文件： 权限名称 可执行操作 r 可以使用cat查看文件的内容 w 可以修改文件的内容 x 可以将其运行为二进制文件 对于目录： 权限名称 可执行操作 r 可以查看目录下列表 w 可以创建和删除目录下文件 x 可以使用cd进入目录 需要注意的是超级用户可以无视普通用户的权限，即使文件目录权限是000，依旧可以访问。在linux中的每个用户必须属于一个组，不能独立于组外。在linux中每个文件有所有者、所在组、其它组的概念。 所有者 一般为文件的创建者，谁创建了该文件，就天然的成为该文件的所有者，用ls ‐ahl命令可以看到文件的所有者 也可以使用chown 用户名 文件名来修改文件的所有者 。 文件所在组 当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组 用ls ‐ahl命令可以看到文件的所有组 也可以使用chgrp 组名 文件名来修改文件所在的组。 其它组 除开文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组 我们再来看看如何修改文件/目录的权限。 修改文件/目录的权限的命令：chmod 示例：修改/test下的aaa.txt的权限为属主有全部权限，属主所在的组有读写权限，其他用户只有读的权限 chmod u=rwx,g=rw,o=r aaa.txt 上述示例还可以使用数字表示： chmod 764 aaa.txt 补充一个比较常用的东西: 假如我们装了一个zookeeper，我们每次开机到要求其自动启动该怎么办？ 新建一个脚本zookeeper 为新建的脚本zookeeper添加可执行权限，命令是:chmod +x zookeeper 把zookeeper这个脚本添加到开机启动项里面，命令是：chkconfig --add zookeeper 如果想看看是否添加成功，命令是：chkconfig --list 4.6 Linux 用户管理Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。 用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。 Linux用户管理相关命令: useradd 选项 用户名:添加用户账号 userdel 选项 用户名:删除用户帐号 usermod 选项 用户名:修改帐号 passwd 用户名:更改或创建用户的密码 passwd -S 用户名 :显示用户账号密码信息 passwd -d 用户名: 清除用户密码 useradd命令用于Linux中创建的新的系统用户。useradd可用来建立用户帐号。帐号建好之后，再用passwd设定帐号的密码．而可用userdel删除帐号。使用useradd指令所建立的帐号，实际上是保存在/etc/passwd文本文件中。 passwd命令用于设置用户的认证信息，包括用户密码、密码过期时间等。系统管理者则能用它管理系统用户的密码。只有管理者可以指定用户名称，一般用户只能变更自己的密码。 4.7 Linux系统用户组的管理每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。 用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。 Linux系统用户组的管理相关命令: groupadd 选项 用户组 :增加一个新的用户组 groupdel 用户组:要删除一个已有的用户组 groupmod 选项 用户组 : 修改用户组的属性 4.8 其他常用命令 pwd： 显示当前所在位置 grep 要搜索的字符串 要搜索的文件 --color： 搜索命令，—color代表高亮显示 ps -ef/ps -aux： 这两个命令都是查看当前系统正在运行进程，两者的区别是展示格式不同。如果想要查看特定的进程可以使用这样的格式：ps aux|grep redis （查看包括redis字符串的进程），也可使用 pgrep redis -a。 注意：如果直接用ps（（Process Status））命令，会显示所有进程的状态，通常结合grep命令查看某进程的状态。 kill -9 进程的pid： 杀死进程（-9 表示强制终止。） 先用ps查找进程，然后用kill杀掉 网络通信命令： 查看当前系统的网卡信息：ifconfig 查看与某台机器的连接情况：ping 查看当前系统的端口使用：netstat -an net-tools 和 iproute2 ： net-tools起源于BSD的TCP/IP工具箱，后来成为老版本Linux内核中配置网络功能的工具。但自2001年起，Linux社区已经对其停止维护。同时，一些Linux发行版比如Arch Linux和CentOS/RHEL 7则已经完全抛弃了net-tools，只支持iproute2。linux ip命令类似于ifconfig，但功能更强大，旨在替代它。更多详情请阅读如何在Linux中使用IP命令和示例 shutdown： shutdown -h now： 指定现在立即关机；shutdown +5 &quot;System will shutdown after 5 minutes&quot;：指定5分钟后关机，同时送出警告信息给登入用户。 reboot： reboot： 重开机。reboot -w： 做个重开机的模拟（只有纪录并不会真的重开机）。 四、进程管理查看进程1. ps查看某个时间点的进程信息。信息相对于top较少，且不是动态的 示例一：查看自己的进程 1# ps -l 示例二：查看系统所有进程 1# ps aux 示例三：查看特定的进程 1# ps aux | grep threadx 2. pstree查看进程树。 示例：查看所有进程树 1# pstree -A 3. top（重点）实时显示进程信息。 示例：两秒钟刷新一次 1# top -d 2 可以直接top命令，采用系统默认刷新时间 Linux系统可以通过top命令查看系统的CPU、内存、运行时间、交换分区、执行的线程等信息。通过top命令可以有效的发现系统的缺陷出在哪里。是内存不够、CPU处理能力不够、IO读写过高。 4.df列出文件系统的整体磁盘使用量 5. netstat查看占用端口的进程 示例：查看特定端口的进程 1# netstat -anp | grep port 进程状态 状态 说明 R running or runnable (on run queue)正在执行或者可执行，此时进程位于执行队列中。 D uninterruptible sleep (usually I/O)不可中断阻塞，通常为 IO 阻塞。 S interruptible sleep (waiting for an event to complete) 可中断阻塞，此时进程正在等待某个事件完成。 Z zombie (terminated but not reaped by its parent)僵死，进程已经终止但是尚未被其父进程获取信息。 T stopped (either by a job control signal or because it is being traced) 结束，进程既可以被作业控制信号结束，也可能是正在被追踪。 SIGCHLD当一个子进程改变了它的状态时（停止运行，继续运行或者退出），有两件事会发生在父进程中： 得到 SIGCHLD 信号； waitpid() 或者 wait() 调用会返回。 其中子进程发送的 SIGCHLD 信号包含了子进程的信息，比如进程 ID、进程状态、进程使用 CPU 的时间等。 在子进程退出时，它的进程描述符不会立即释放，这是为了让父进程得到子进程信息，父进程通过 wait() 和 waitpid() 来获得一个已经退出的子进程的信息。 wait()1pid_t wait(int *status) 父进程调用 wait() 会一直阻塞，直到收到一个子进程退出的 SIGCHLD 信号，之后 wait() 函数会销毁子进程并返回。 如果成功，返回被收集的子进程的进程 ID；如果调用进程没有子进程，调用就会失败，此时返回 -1，同时 errno 被置为 ECHILD。 参数 status 用来保存被收集的子进程退出时的一些状态，如果对这个子进程是如何死掉的毫不在意，只想把这个子进程消灭掉，可以设置这个参数为 NULL。 waitpid()1pid_t waitpid(pid_t pid, int *status, int options) 作用和 wait() 完全相同，但是多了两个可由用户控制的参数 pid 和 options。 pid 参数指示一个子进程的 ID，表示只关心这个子进程退出的 SIGCHLD 信号。如果 pid=-1 时，那么和 wait() 作用相同，都是关心所有子进程退出的 SIGCHLD 信号。 options 参数主要有 WNOHANG 和 WUNTRACED 两个选项，WNOHANG 可以使 waitpid() 调用变成非阻塞的，也就是说它会立即返回，父进程可以继续执行其它任务。 孤儿进程一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。 孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。 由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。 僵尸进程一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。 僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）。 系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。 要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 进程所收养，这样 init 进程就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。 参考资料) 五、Linux的锁1.互斥锁（mutex）特点：对于读者和写者来说。只要有一方获取了锁，另一方则不能继续获取，进而执行临界区代码。 创建锁： 有两种方法创建互斥锁，静态方式和动态方式。POSIX定义了一个宏PTHREAD_MUTEX_INITIALIZER 来静态初始化互斥锁， 方法如下： 1pthread_mutex_t mutex=PTHREAD_MUTEX_INITIALIZER; 在LinuxThreads实现中，pthread_mutex_t是一个结构，而PTHREAD_MUTEX_INITIALIZER则是一个结构常量。 动态方式是采用pthread_mutex_init()函数来初始化互斥锁，API定义如下： 1int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t*mutexattr) 其中mutexattr用于指定互斥锁属性（见下），如果为NULL则使用缺省属性。 pthread_mutex_destroy ()用于注销一个互斥锁，API定义如下： 1int pthread_mutex_destroy(pthread_mutex_t *mutex) 锁操作主要包括加锁pthread_mutex_lock()、解锁pthread_mutex_unlock()和测试加锁 pthread_mutex_trylock()三个，不论哪种类型的锁，都不可能被两个不同的线程同时得到， 而必须等待解锁。对于普通锁和适应锁类型，解锁者可以是同进程内任何线程； 而检错锁则必须由加锁者解锁才有效，否则返回EPERM；对于嵌套锁，文档和实现要求必须由 加锁者解锁，但实验结果表明并没有这种限制，这个不同目前还没有得到解释。在同一进程中 的线程，如果加锁后没有解锁，则任何其他线程都无法再获得锁。 123int pthread_mutex_lock(pthread_mutex_t *mutex) int pthread_mutex_unlock(pthread_mutex_t *mutex) int pthread_mutex_trylock(pthread_mutex_t *mutex) pthread_mutex_trylock() 语义与pthread_mutex_lock()类似，不同的是在锁已经被占据时返回 EBUSY而不是挂起等待。 例如：单例模式下，线程安全的加锁： 123456789101112131415161718class SingleTon &#123; public: static SingleTon* getInstance() &#123; pthread_mutex_lock(&amp;mutex); if(mpSingle == NULL) &#123; mpSingleTon = new SingleTon(); &#125; pthread_mutex_unlock(&amp;mutex); return mpSingleTon; &#125; private: SingleTon()&#123;&#125;; ~SingleTon()&#123;pthread_mutex_desttroy(&amp;mutex,NULL);&#125; static pthread_mutex_t mutex; static SingleTon * mpSingleTon; &#125; pthread_mutex_t SingleTon::mutex = PTHREAD_MUTEX_INITIALIZER; SingleTon * SingleTon::mpSingleTon = NULL; 优点： 由一块能够被多个进程共享的内存空间（一个对齐后的整型变量）组成；这个整型变量的值能够通过汇编语言调用CPU提供的原子操作指令来增加或减少，并且一个进程可以等待直到那个值变成正数。 的操作几乎全部在应用程序空间完成；只有当操作结果不 一致从而需要仲裁时，才需要进入操作系统内核空间执行。这种机制允许使用的锁定原语有非常高的执行效率：由于绝大多数 的操作并不需要在多个进程之间进行仲裁，所以绝大多数操作都可以在应用程序空间执行，而不需要使用（相对高代价的）内核系统调 用。 2.读写锁特点：读写锁适合于对数据结构的读次数比写次数多得多的情况.因为,读模式锁定时可以共享,以写 模式锁住时意味着独占,所以读写锁又叫共享-独占锁. 初始化和销毁: 123int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, constpthread_rwlockattr_t *restrict attr); int pthread_rwlock_destroy(pthread_rwlock_t *rwlock); 成功则返回0,出错则返回错误编号. 同互斥量以上,在释放读写锁占用的内存之前,需要先通过 pthread_rwlock_destroy对读写锁进行清理工作, 释放由init分配的资源. 读和写: 123int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock); int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock); int pthread_rwlock_unlock(pthread_rwlock_t *rwlock); 成功则返回0,出错则返回错误编号.这3个函数分别实现获取读锁,获取写锁和释放锁的操作.获 取锁的两个函数是阻塞操作,同样,非阻塞的函数为: 12int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock); int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock); 成功则返回0,出错则返回错误编号.非阻塞的获取锁操作,如果可以获取则返回0,否则返回 错误的EBUSY. 3.自旋锁特点：轮询忙等待。 在单核cpu下不起作用：被自旋锁保护的临界区代码执行时不能进行挂起状态。会造成死锁 自旋锁的初衷就是：在短期间内进行轻量级的锁定。一个被争用的自旋锁使得请求它的线程在等待锁重新可用的期间进行自旋（特别浪费处理器时间），所以自旋锁不应该被持有时间过长。如果需要长时间锁定的话, 最好使用信号量。 API: 4.互斥锁和自旋锁的比较参考 互斥锁的起始原始开销要高于自旋锁，但是基本是一劳永逸，临界区持锁时间的大小并不会对互斥锁的开销造成影响，而自旋锁是死循环检测，加锁全程消耗cpu，起始开销虽然低于互斥锁，但是随着持锁时间，加锁的开销是线性增长。 互斥锁：线程会从sleep（加锁）——&gt;running（解锁），过程中有上下文的切换，cpu的抢占，信号的发送等开销。 自旋锁：线程一直是running(加锁——&gt;解锁)，死循环检测锁的标志位，机制不复杂。 应用： 互斥锁用于临界区持锁时间比较长的操作，比如下面这些情况都可以考虑 1 临界区有IO操作 2 临界区代码复杂或者循环量大 3 临界区竞争非常激烈 4 单核处理器 至于自旋锁就主要用在临界区持锁时间非常短且CPU资源不紧张的情况下，自旋锁一般用于多核的服务器。 六、其他概念进程创建子进程,fork详解经典参考1 1) 函数原型 pid_t fork(void); //void代表没有任何形式参数 2) fork调用的一个奇妙之处就是它仅仅被调用一次，却能够返回两次，它可能有三种不同的返回值： 1）在父进程中，fork返回新创建子进程的进程ID； 2）在子进程中，fork返回0； 3）如果出现错误，fork返回一个负值； 类比理解：其实就相当于链表，进程形成了链表，父进程的fpid(p 意味point)指向子进程的进程id, 因为子进程没有子进程，所以其fpid为0. 123456789101112131415161718#include &lt;unistd.h&gt; #include &lt;stdio.h&gt; int main(void) &#123; int i=0; printf("i son/pa ppid pid fpid/n"); //ppid指当前进程的父进程pid //pid指当前进程的pid, //fpid指fork返回给当前进程的值 for(i=0;i&lt;2;i++)&#123; pid_t fpid=fork(); if(fpid==0) printf("%d child %4d %4d %4d/n",i,getppid(),getpid(),fpid); else printf("%d parent %4d %4d %4d/n",i,getppid(),getpid(),fpid); &#125; return 0; &#125; 运行结果是： 1234567i son/pa ppid pid fpid0 parent 2043 3224 32250 child 3224 3225 01 parent 2043 3224 32261 parent 3224 3225 32271 child 1 3227 01 child 1 3226 0 我们用一个链表来表示这个关系： p2043-&gt;p3224-&gt;p3225 作业和进程的区别与联系（1）联系 一个作业通常包括几个进程，几个进程共同完成一个任务，即作业。用户提交作业以后，当作业被调度，系统会为作业创建进程，一个进程无法完成时，系统会为这个进程创建子进程。 （2）区别 进程是一个程序在一个数据集上的一次执行，而作业是用户提交给系统的一个任务。 Linux里的RcuRCU(Read-Copy Update)，是 Linux 中比较重要的一种同步机制。顾名思义就是“读，拷贝更新”，再直白点是“随意读，但更新数据的时候，需要先复制一份副本，在副本上完成修改，再一次性地替换旧数据”。这是 Linux 内核实现的一种针对“读多写少”的共享数据的同步机制。 Linux 内存的延迟分配Linux内存的延迟分配就是在你未使用内存（均值物理内存）的时候，操作系统是不会真正的分配物理内存的， 比如 1int *p = (int*)malloc(1024 * 1024) 比如我又写下了这样的代码： 12*p = 4; cout &lt;&lt; *p &lt;&lt; endl; 这时候进程占用的内存是多少？不是1M，通常按照页框大小为单位进行分配。]]></content>
      <categories>
        <category>操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统-进程管理]]></title>
    <url>%2F2019%2F03%2F20%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[中断与异常 进程与线程0.重点梳理★★★ 进程与线程的本质区别、以及各自的使用场景。 ★★★ 进程调度算法的特点以及使用场景。 ★★★ 进程通信方法的特点以及使用场景。 ★★☆ 协程的作用。★★☆ 常见进程同步问题。 ★☆☆ 进程状态。 ★☆☆ 线程实现的方式。 1. 进程 解答：D。程序一开始，产生一个进程Pl执行此程序，P1进入程序后，此时i=0，于是进入循环体，fork()产生一个子进程P2，接着Pl执行下一条语句输出一个”-“（其实是放入缓冲区，等合适的时候再输出，我们将此’-‘记为a）； P2成为一个独立的子进程，继承P1的诸如环境变量、PC等环境，P2也执行下一条语句输出一个’-‘（其实是放入缓冲区，等合适的时候再输出，我们将此记为b），同时P2中此时i=1，继续执行for 循环P2先forkO出一个子进程P3，然后P2再执行下一条语句输出一个一（其实是放入缓冲区，等合适的时候再输出，我们将此记为c）。 P3进程为P2的子进程，它会复制其父进程P2的诸如环境变量、PC等环境，它执行下一条语句（输出语句）本应该输出一个，但事实上因为这里P3会继承P2的缓冲区，而P2的缓冲区中有一个（P2调用fork产生P3时缓冲区里有b），所以P3会输出两个。 Pl产生子进程P2后，继续下一轮循环，当i=1时，fork()产生另一个它的子进程P4，同时P1执行输出语句输出一个’-‘。 2. 线程线程是独立调度的基本单位。 例1：同一进程下的线程可以共享（）。（2012·搜狗） A.stack B.data section C.register set D.thread ID 解答：B。B中data section存放全局变量等内容，显然是可以被同一进程下的线程共享的。 例2：线程与进程比较而言，下面论述成立的有（）。（不定项选择）（2007·百度） A.一个线程可以由多个进程组成 B.一个进程可以由多个线程组成 C.相对而言，线程运行需要更多的资源 D.线程比进程运行需要更少的系统资源 解答：BD。 例3：进程和线程的差别有（）。（2010·网易） A.操作系统只调度进程，不调度线程 B.线程共享内存地址空间，进程不共享C.线程可以共享内存数据，但进程不可以 D.进程间可以通过IPC通信，但线程不可以 解答：B。进程之间的地址空间是独享的，而线程共享进程的地址空间。 例4：两个线程： 12345threadl:x=1； r1=y； thread2：y=1； r2=x； x和y初始值为0，两者皆为全局变量，程序运行过后r1和r2的值可能是（）。（2012·微软） A.rl=1，r2=1 B.rl=1，r2=0 C.rl=0，r2=1 D.rl=0，r2=0 解答：ABC。 首先执行x=1，然后中断，执行y=1，r2=x，然后执行rl=y，可得r1=1，r2=1； 首先执行thread1，再执行thread2，可得r1=0，r2=1； 首先执行thread2，再执行thread1，可得r1=1，r2=0。 引入线程主要有以下4个优点： （1）易于调度。 （2）提高并发性。 （3）开销小。 （4）有利于发挥多处理器的功能。 3. 区别Ⅰ 拥有资源 进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。 Ⅱ 调度 线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。 Ⅲ 系统开销 由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。 Ⅳ 通信方面 线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。 进程状态的切换 进程调度算法可以参考大话操作系统之调度算法 重要！！！ 不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。 调度的基本准则包括CPU利用率、系统吞吐量、周转时间、等待时间、响应时间等。 系统吞吐量表示单位时间内CPU完成作业的数量。 周转时间为作业完成时刻减去作业到达的时刻。 等待时间是指进程处于等处理器状态的时间之和，等待时间越长，用户满意度越低。 响应时间是指从用户提交请求到系统首次产生响应所用的时间。 典型调度算法包括：先来先服务算法（FCFS）、短作业优先算法（SJF）、优先级调度算法、高响应比优先调度算法、时间片轮转算法、多级反馈队列调度算法。其中SJF的平均等待时间、平均周转时间最少。 2.练习例1：一种既有利于短作业又兼顾长作业的调度方式是（）。（2012·搜狗） A.先来先服务 B.均衡调度 C.最短作业优先 D.最高响应比优先 解答：D。 例2：假定我们有3个程序，每个程序花费80%的时间进行I/0，20%的时间使用CPU。每个程序启动时间和其需要使用进行计算的分钟数如下，不考虑进程切换时间： 请问，在多线程/进程环境下，系统的总周转时间为（）。（2012·腾讯） A.22.5 B.23.5 C.24.5 D.25.5 解答：B。从0点0分开始到0点10分，系统里只有1个程序，因此属于单道编程状态。单道编程时CPU的利用率为20%，因此第1个程序在该10分钟里总共使用了CPU达2分钟（其他8分钟都用来进行I/0了）。0点10分到0点15分，系统里面有两个程序，因此属于2道编程。2道编程时CPU利用率为36%（两个进程同时不使用CPU的概率是0.8*0.8-0.64），则在5分钟时间内，CPU使用了1.8分钟。假定这两个程序完全平等，则每个程序使用CPU的时间是0.9分钟。至此，程序1总共运行了2.9分钟CPU时间，程序2运行了0.9分钟CPU时间。 从0点15分开始，系统里面有3个程序，因此属于3道编程状态。3道编程时CPU的利用率为48.8%（三个进程同时不使用CPU的概率是0.80.80.8=0.512），同样，假定所有程序完全平等，此时，程序1离结束所需要的CPU时间最短，仅为0.6分钟。而如果程序1想再运行0.6分钟CPU时间，则整个系统需运行时间约为3.7分钟（3.7分钟时间内CPU共被使用1.8分钟，平均每个程序使用CPU时间为0.6分钟），因此在0点18.7分时，第一个程序执行完毕，系统变为2道编程。 2道编程时CPU利用率为36%，此时程序2运行了0.9+0.6-1.5分钟，程序3运行了0.6分钟，此时，程序2离结束所需要的CPU时间最短，仅为0.5分钟。而如果程序2想再运行0.5分钟CPU时间，则整个系统需运行时间约为2.8分钟（2.8分钟时间内CPU共被使用1分钟，平均每个程序使用CPU时间为0.5分钟），因此在0点21.5分时，第二个程序执行完毕，系统变为1道编程。 系统里只有1个程序，因此属于单道编程状态。单道编程时CPU的利用率为20%，此时程序3运行了0.6+0.5=1.1分钟，还需要运行0.4分钟的CPU时间，故整个系统需要2分钟（2分钟内CPU被利用0.4分钟），故程序3在0点23.5分时结束。 进程同步1. 临界区对临界资源进行访问的那段代码称为临界区。 为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。 123// entry section// critical section;// exit section 2. 同步与互斥 同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。 互斥：多个进程在同一时刻只有一个进程能进入临界区。 3. 信号量信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。 down : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0； up ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。 down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。 如果信号量的取值只能为 0 或者 1，那么就成为了 互斥量（Mutex） ，0 表示临界区已经加锁，1 表示临界区解锁。 12345678910111213typedef int semaphore;semaphore mutex = 1;void P1() &#123; down(&amp;mutex); // 临界区 up(&amp;mutex);&#125;void P2() &#123; down(&amp;mutex); // 临界区 up(&amp;mutex);&#125; 使用信号量实现生产者-消费者问题 &lt;/br&gt; 问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。 因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。 为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。 注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。 123456789101112131415161718192021222324252627#define N 100typedef int semaphore;semaphore mutex = 1;semaphore empty = N;semaphore full = 0;void producer() &#123; while(TRUE) &#123; int item = produce_item(); down(&amp;empty); down(&amp;mutex); insert_item(item); up(&amp;mutex); up(&amp;full); &#125;&#125;void consumer() &#123; while(TRUE) &#123; down(&amp;full); down(&amp;mutex); int item = remove_item(); consume_item(item); up(&amp;mutex); up(&amp;empty); &#125;&#125; 4. 管程使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。管程是对信号量更高层次的抽象，用类进行封装。 c 语言不支持管程，下面的示例代码使用了类 Pascal 语言来描述管程。示例代码的管程提供了 insert() 和 remove() 方法，客户端代码通过调用这两个方法来解决生产者-消费者问题。 1234567891011121314monitor ProducerConsumer integer i; condition c; procedure insert(); begin // ... end; procedure remove(); begin // ... end;end monitor; 管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。 管程引入了 条件变量 以及相关的操作：wait() 和 signal() 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。 使用管程实现生产者-消费者问题 123456789101112131415161718192021222324252627282930313233343536373839404142// 管程monitor ProducerConsumer condition full, empty; integer count := 0; condition c; procedure insert(item: integer); begin if count = N then wait(full); insert_item(item); count := count + 1; if count = 1 then signal(empty); end; function remove: integer; begin if count = 0 then wait(empty); remove = remove_item; count := count - 1; if count = N -1 then signal(full); end;end monitor;// 生产者客户端procedure producerbegin while true do begin item = produce_item; ProducerConsumer.insert(item); endend;// 消费者客户端procedure consumerbegin while true do begin item = ProducerConsumer.remove; consume_item(item); endend; 线程同步临界区：通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问； 互斥量Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问 信号量Semphare：为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。 事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作 经典同步问题生产者和消费者问题前面已经讨论过了。 1. 读者-写者问题允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。 一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。 1234567891011121314151617181920212223242526typedef int semaphore;semaphore count_mutex = 1;semaphore data_mutex = 1;int count = 0;void reader() &#123; while(TRUE) &#123; down(&amp;count_mutex); count++; if(count == 1) down(&amp;data_mutex); // 第一个读者需要对数据进行加锁，防止写进程访问 up(&amp;count_mutex); read(); down(&amp;count_mutex); count--; if(count == 0) up(&amp;data_mutex); up(&amp;count_mutex); &#125;&#125;void writer() &#123; while(TRUE) &#123; down(&amp;data_mutex); write(); up(&amp;data_mutex); &#125;&#125; 2. 哲学家进餐问题 五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。 下面是一种错误的解法，考虑到如果所有哲学家同时拿起左手边的筷子，那么就无法拿起右手边的筷子，造成死锁。 123456789101112#define N 5void philosopher(int i) &#123; while(TRUE) &#123; think(); take(i); // 拿起左边的筷子 take((i+1)%N); // 拿起右边的筷子 eat(); put(i); put((i+1)%N); &#125;&#125; 为了防止死锁的发生，可以设置两个条件： 必须同时拿起左右两根筷子； 只有在两个邻居都没有进餐的情况下才允许进餐。 123456789101112131415161718192021222324252627282930313233343536373839404142#define N 5#define LEFT (i + N - 1) % N // 左邻居#define RIGHT (i + 1) % N // 右邻居#define THINKING 0#define HUNGRY 1#define EATING 2typedef int semaphore;int state[N]; // 跟踪每个哲学家的状态semaphore mutex = 1; // 临界区的互斥semaphore s[N]; // 每个哲学家一个信号量void philosopher(int i) &#123; while(TRUE) &#123; think(); take_two(i); eat(); put_two(i); &#125;&#125;void take_two(int i) &#123; down(&amp;mutex); state[i] = HUNGRY; test(i); up(&amp;mutex); down(&amp;s[i]);&#125;void put_two(i) &#123; down(&amp;mutex); state[i] = THINKING; test(LEFT); test(RIGHT); up(&amp;mutex);&#125;void test(i) &#123; // 尝试拿起两把筷子 if(state[i] == HUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] !=EATING) &#123; state[i] = EATING; up(&amp;s[i]); &#125;&#125; 进程通信进程同步与进程通信很容易混淆，它们的区别在于： 进程同步：控制多个进程按一定顺序执行； 进程通信：进程间传输信息。 进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。 1. 管道管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。 12#include &lt;unistd.h&gt;int pipe(int fd[2]); 它具有以下限制： 只支持半双工通信（单向交替传输）； 只能在父子进程或者兄弟进程中使用。 2. FIFO也称为命名管道，去除了管道只能在父子进程中使用的限制。 123#include &lt;sys/stat.h&gt;int mkfifo(const char *path, mode_t mode);int mkfifoat(int fd, const char *path, mode_t mode); FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。 3. 消息队列相比于 FIFO，消息队列具有以下优点： 消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难； 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法； 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。 4. 信号量它是一个计数器，用于为多个进程提供对共享数据对象的访问。 5. 共享存储允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。 需要使用信号量用来同步对共享存储的访问。 多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。 6. 套接字与其它通信机制不同的是，它可用于不同机器间的进程通信。 协程是什么1) 是一种比线程更加轻量级的存在。正如一个进程可以拥有多个线程一样，一个线程可以拥有多个协程；协程不是被操作系统内核管理，而完全是由程序所控制。 2) 协程的开销远远小于线程； 3) 协程拥有自己寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切换回来的时候，恢复先前保存的寄存器上下文和栈。 4) 每个协程表示一个执行单元，有自己的本地数据，与其他协程共享全局数据和其他资源。 5) 跨平台、跨体系架构、无需线程上下文切换的开销、方便切换控制流，简化编程模型； 6) 协程又称为微线程，协程的完成主要靠yeild关键字，协程执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行； 7) 协程极高的执行效率，和多线程相比，线程数量越多，协程的性能优势就越明显； 8) 不需要多线程的锁机制； 孤儿进程和僵尸进程的区别？怎么避免这两类进程？守护进程？1、 一般情况下，子进程是由父进程创建，而子进程和父进程的退出是无顺序的，两者之间都不知道谁先退出。正常情况下父进程先结束会调用 wait 或者 waitpid 函数等待子进程完成再退出，而一旦父进程不等待直接退出，则剩下的子进程会被init(pid=1)进程接收，成会孤儿进程。（进程树中除了init都会有父进程）。 2、 如果子进程先退出了，父进程还未结束并且没有调用 wait 或者 waitpid 函数获取子进程的状态信息，则子进程残留的状态信息（ task_struct 结构和少量资源信息）会变成僵尸进程。 僵尸处理方式： 子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程。 原理是将子进程成为孤儿进程，从而其的父进程变为init进程，通过init进程可以处理僵尸进程。 3、 守护进程（ daemon) 是指在后台运行，没有控制终端与之相连的进程。它独立于控制终端，通常周期性地执行某种任务 。守护进程脱离于终端是为了避免进程在执行过程中的信息在任何终端上显示并且进程也不会被任何终端所产生的终端信息所打断。 参考github资料 进程上下文切换与和线程上下文切换有什么不同？（1）什么是上下文切换？（面试题）上下文切换就是从当前执行任务切换到另一个任务执行的过程。但是，为了确保下次能从正确的位置继续执行，在切换之前，会保存上一个任务的状态。 （2）区别最主要的区别就是线程的切换虚拟空间内存是相同的（因为都是属于自己的进程），但是，进程切换的虚拟空间内存则是不同的。 以下是相同: 同时，这两种上下文切换的处理都是通过操作系统内核来完成的。内核的这种切换过程伴随的最显著的性能损耗是将寄存器中的内容切换出。 函数调用和系统调用的区别？1) 系统调用 ① 操作系统提供给用户程序调用的一组特殊的接口。用户程序可以通过这组特殊接口来获得操作系统内核提供的服务； ② 系统调用可以用来控制硬件；设置系统状态或读取内核数据；进程管理，系统调用接口用来保证系统中进程能以多任务在虚拟环境下运行； ③ Linux中实现系统调用利用了x86体系结构中的软件中断； 2) 函数调用 ① 函数调用运行在用户空间； ② 它主要是通过压栈操作来进行函数调用； 执行一个系统调用时，OS发生的过程(?) 1．执行用户程序(如:fork) 2． 根据glibc中的函数实现，取得系统调用号并执行int $0x80产生中断。 3． 进行地址空间的转换和堆栈的切换，执行SAVE_ALL。（进行内核模式） 4． 进行中断处理，根据系统调用表调用内核函数。 5． 执行内核函数。 6． 执行RESTORE_ALL并返回用户模式 并发和并行的区别并发是多个事件在同一时间段执行，而并行是多个事件在同一时间点执行。 以多核CPU为例： 并发，是在同一个cpu上同时（不是真正的同时，而是看来是同时，因为cpu要在多个程序间切换）运行多个程序。 并行，是每个cpu运行一个程序。 ​]]></content>
      <categories>
        <category>操作系统</category>
        <category>操作系统概念</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell编程四剑客]]></title>
    <url>%2F2019%2F03%2F20%2FShell%E7%BC%96%E7%A8%8B%E5%9B%9B%E5%89%91%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Shell编程四剑客之Find通过如上基础语法的学习，读者对Shell编程有了更近一步的理解，Shell编程不再是简单命令的堆积，而是演变成了各种特殊的语句、各种语法、编程工具、各种命令的集合。 在Shell编程工具中，四剑客工具的使用更加的广泛，Shell编程四剑客包括：find、sed、grep、awk，熟练掌握四剑客会对Shell编程能力极大的提升。 四剑客之Find工具实战，Find工具主要用于操作系统文件、目录的查找，其语法参数格式为： 1find path -option [ -print ] [ -exec -ok command ] &#123; &#125; \； 其option常用参数详解如下：12345-name filename #查找名为filename的文件；-type b/d/c/p/l/f #查是块设备、目录、字符设备、管道、符号链接、普通文件；-size n[c] #查长度为n块[或n字节]的文件；-perm #按执行权限来查找；-user username #按文件属主来查找； Find工具-name参数案列：123find /data/ -name “*.txt” #查找/data/目录以.txt结尾的文件；find /data/ -name “[A-Z]*” #查找/data/目录以大写字母开头的文件；find /data/ -name “test*” #查找/data/目录以test开头的文件； Find工具-type参数案列：12345find /data/ -type d #查找/data/目录下的文件夹；find /data/ ! -type d #查找/data/目录下的非文件夹；find /data/ -type l #查找/data/目录下的链接文件。find /data/ -type d|xargs chmod 755 -R #查目录类型并将权限设置为755；find /data/ -type f|xargs chmod 644 -R #查文件类型并将权限设置为644； Find工具-size参数案列：123find /data/ -size +1M #查文件大小大于1Mb的文件；find /data/ -size 10M #查文件大小为10M的文件；find /data/ -size -1M #查文件大小小于1Mb的文件； Shell编程四剑客之SEDSED是一个非交互式文本编辑器，它可对文本文件和标准输入进行编辑，标准输入可以来自键盘输入、文本重定向、字符串、变量，甚至来自于管道的文本，与VIM编辑器类似，它一次处理一行内容，Sed可以编辑一个或多个文件，简化对文件的反复操作、编写转换程序等。 在处理文本时把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），紧接着用SED命令处理缓冲区中的内容，处理完成后把缓冲区的内容输出至屏幕或者写入文件。 逐行处理直到文件末尾，然而如果打印在屏幕上，实质文件内容并没有改变，除非你使用重定向存储输出或者写入文件。其语法参数格式为： 123456789101112131415sed [-Options] [‘Commands’] filename；sed工具默认处理文本，文本内容输出屏幕已经修改，但是文件内容其实没有修改，需要加-i参数即对文件彻底修改；x #x为指定行号；x,y #指定从x到y的行号范围；/pattern/ #查询包含模式的行；/pattern/pattern/ #查询包含两个模式的行；/pattern/,x #从与pattern的匹配行到x号行之间的行；x,/pattern/ #从x号行到与pattern的匹配行之间的行；x,y! #查询不包括x和y行号的行；r #从另一个文件中读文件；w #将文本写入到一个文件；y #变换字符；q #第一个模式匹配完成后退出；l #显示与八进制ASCII码等价的控制字符； 常用SED工具企业演练案列： 替换jfedu.txt文本中old为new： 1sed ‘s/old/new/g’ jfedu.txt 打印jfedu.txt文本第一行至第三行： 1sed -n ‘1,3p’ jfedu.txt 打印jfedu.txt文本中第一行与最后一行： 1sed -n ‘1p；$p’ jfedu.txt 删除jfedu.txt第一行至第三行、删除匹配行至最后一行： 12sed ‘1,3d’ jfedu.txtsed ‘/jfedu/,$d’ jfedu.txt 删除jfedu.txt最后6行及删除最后一行： 12for i in `seq 1 6`；do sed -i ‘$d’ jfedu.txt ；donesed ‘$d’ jfedu.txt 删除jfedu.txt最后一行： 1sed ‘$d’ jfedu.txt 通常而言，SED将待处理的行读入模式空间，脚本中的命令逐行进行处理，直到脚本执行完毕，然后该行被输出，模式空间请空；然后重复刚才的动作，文件中的新的一行被读入，直到文件处理完备。 如果用户希望在某个条件下脚本中的某个命令被执行，或者希望模式空间得到保留以便下一次的处理，都有可能使得sed在处理文件的时候不按照正常的流程来进行。这时可以使用SED高级语法来满足用户需求。总的来说，SED高级命令可以分为三种功能： N、D、P：处理多行模式空间的问题； H、h、G、g、x：将模式空间的内容放入存储空间以便接下来的编辑； :、b、t：在脚本中实现分支与条件结构。 在jfedu.txt每行后加入空行，也即每行占永两行空间，每一行后边插入一行空行、两行空行及前三行每行后插入空行： 123sed ‘/^$/d；G’ jfedu.txtsed ‘/^$/d；G；G’ jfedu.txtsed ‘/^$/d；1,3G；’ jfedu.txt 将jfedu.txt偶数行删除及隔两行删除一行： 12sed ‘n；d’ jfedu.txtsed ‘n；n；d’ jfedu.txt 在jfedu.txt匹配行前一行、后一行插入空行以及同时在匹配前后插入空行： 123sed ‘/jfedu/&#123;x；p；x；&#125;’ jfedu.txtsed ‘/jfedu/G’ jfedu.txtsed ‘/jfedu/&#123;x；p；x；G；&#125;’ jfedu.txt 在jfedu.txt每行后加入空行，也即每行占永两行空间，每一行后边插入空行： 1sed ‘/^$/d；G’ jfedu.txt 在jfedu.txt每行后加入空行，也即每行占永两行空间，每一行后边插入空行： 1sed ‘/^$/d；G’ jfedu.txt 在jfedu.txt每行前加入顺序数字序号、加上制表符\t及.符号： 123sed = jfedu.txt| sed ‘N；s/\n/ /’sed = jfedu.txt| sed ‘N；s/\n/\t/’sed = jfedu.txt| sed ‘N；s/\n/\./’ 删除jfedu.txt行前和行尾的任意空格： 1sed ‘s/^[ \t]*//；s/[ \t]*$//’ jfedu.txt 打印jfedu.txt关键词old与new之间的内容： 1sed -n ‘/old/,/new/’p jfedu.txt 打印及删除jfedu.txt最后两行： 12sed ‘$!N；$!D’ jfedu.txtsed ‘N；$!P；$!D；$d’ jfedu.txt 合并上下两行，也即两行合并： 12sed ‘$!N；s/\n/ /’ jfedu.txtsed ‘N；s/\n/ /’ jfedu.txt Shell编程四剑客之AWKAWK是一个优良的文本处理工具，Linux及Unix环境中现有的功能最强大的数据处理引擎之一，以Aho、Weinberger、Kernighan三位发明者名字首字母命名为AWK，AWK是一个行级文本高效处理工具，AWK经过改进生成的新的版本有Nawk、Gawk，一般Linux默认为Gawk，Gawk是 AWK的GNU开源免费版本。 AWK基本原理是逐行处理文件中的数据，查找与命令行中所给定内容相匹配的模式，如果发现匹配内容，则进行下一个编程步骤，如果找不到匹配内容，则 继续处理下一行。其语法参数格式为，AWK常用参数、变量、函数详解如下： 1awk ‘pattern + &#123;action&#125;’ file AWK基本语法参数详解： 单引号’ ‘是为了和shell命令区分开； 大括号{ }表示一个命令分组； pattern是一个过滤器，表示匹配pattern条件的行才进行Action处理； action是处理动作，常见动作为Print； 使用#作为注释，pattern和action可以只有其一，但不能两者都没有。 AWK内置变量详解： FS 分隔符，默认是空格； OFS 输出分隔符； NR 当前行数，从1开始； NF 当前记录字段个数； $0 当前记录； $1~$n 当前记录第n个字段（列）。 常用AWK工具企业演练案列： AWK打印硬盘设备名称，默认以空格为分割： 1df -h|awk ‘&#123;print $1&#125;’ AWK以空格、冒号、\t、分号为分割： 1awk -F ‘[ :\t；]’ ‘&#123;print $1&#125;’ jfedu.txt AWK以冒号分割，打印第一列，同时将内容追加到/tmp/awk.log下： 1awk -F: ‘&#123;print $1 &gt;&gt;”/tmp/awk.log”&#125;’ jfedu.txt 打印jfedu.txt文件中的第3行至第5行，NR表示打印行，$0表示文本所有域： 12awk ‘NR==3,NR==5 &#123;print&#125;’ jfedu.txtawk ‘NR==3,NR==5 &#123;print $0&#125;’ jfedu.txt 打印jfedu.txt文件中，长度大于80的行号： 1awk ‘length($0)&gt;80 &#123;print NR&#125;’ jfedu.txt AWK引用Shell变量，使用-v或者双引号+单引号即可： 12awk -v STR=hello ‘&#123;print STR,$NF&#125;’ jfedu.txtSTR=”hello”；echo| awk ‘&#123;print “‘$&#123;STR&#125;'”；&#125;’ Awk统计服务器状态连接数： 12netstat -an | awk ‘/tcp/ &#123;s[$NF]++&#125; END &#123;for(a in s) &#123;print a,s[a]&#125;&#125;’netstat -an | awk ‘/tcp/ &#123;print $NF&#125;’ | sort | uniq -c Shell编程四剑客之GREP(文本搜索)全面搜索正则表达式（Global search regular expression(RE) ，GREP）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。 Unix/Linux的grep家族包括grep、egrep和fgrep，其中egrep和fgrep的命令跟grep有细微的区别，egrep是grep的扩展，支持更多的re元字符， fgrep是fixed grep或fast grep简写，它们把所有的字母都看作单词，正则表达式中的元字符表示其自身的字面意义，不再有其他特殊的含义，一般使用比较少。 目前Linux操作系统默认使用GNU版本的grep。它功能更强，可以通过-G、-E、-F命令行选项来使用egrep和fgrep的功能。其语法格式及常用参数详解如下： 1grep -[acinv] ‘word’ Filename Grep常用参数详解如下： 1234-a 以文本文件方式搜索；-c 计算找到的符合行的次数；-i 忽略大小写；-n 顺便输出行号； 学习Grep时，需要了解通配符、正则表达式两个概念，很多读者容易把彼此搞混淆，通配符主要用在Linux的Shell命令中，常用于文件或者文件名称的操作，而正则表达式用于文本内容中的字符串搜索和替换，常用在AWK、GREP、SED、VIM工具中对文本的操作。 通配符类型详解： 12345* 0个或者多个字符、数字；? 匹配任意一个字符；# 表示注解；| 管道符号；；多个命令连续执行； 正则表达式详解： 12345678* 前一个字符匹配0次或多次；. 匹配除了换行符以外任意一个字符；.* 代表任意字符；^ 匹配行首，即以某个字符开头；$ 匹配行尾，即以某个字符结尾；\(..\) 标记匹配字符；[] 匹配中括号里的任意指定字符，但只匹配一个字符；[^] 匹配除中括号以外的任意一个字符； 常用GREP工具企业演练案列： 12345678grep -c “test” jfedu.txt 统计test字符总行数；grep -i “TEST” jfedu.txt 不区分大小写查找TEST所有的行；grep -n “test” jfedu.txt 打印test的行及行号；grep -v “test” jfedu.txt 不打印test的行；grep “test[53]” jfedu.txt 以字符test开头，接5或者3的行；grep “^[^test]” jfedu.txt 显示输出行首不是test的行；grep “[Mm]ay” jfedu.txt 匹配M或m开头的行；grep “K…D” jfedu.txt 匹配K，三个任意字符，紧接D的行；]]></content>
      <categories>
        <category>操作系统</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell]]></title>
    <url>%2F2019%2F03%2F19%2FShell%2F</url>
    <content type="text"><![CDATA[Shell 编程入门什么是 Shell？简单来说“Shell编程就是对一堆Linux命令的逻辑化处理”。 shell是一个命令解释器，是介于操作系统内核与用户之间的一个绝缘层，如下图所示。 Shell 编程的 Hello World学习任何一门编程语言第一件事就是输出HelloWord了！下面我会从新建文件到shell代码编写来说下Shell 编程如何输出Hello World。 (1)新建一个文件 helloworld.sh :touch helloworld.sh，扩展名为 sh（sh代表Shell）（扩展名并不影响脚本执行，见名知意就好，如果你用 php 写 shell 脚本，扩展名就用 php 好了） (2) 使脚本具有执行权限：chmod +x helloworld.sh (3) 使用 vim 命令修改helloworld.sh文件：vim helloworld.sh(vim 文件———&gt;进入文件——-&gt;命令模式———&gt;按i进入编辑模式——-&gt;编辑文件 ———-&gt;按Esc进入底行模式——-&gt;输入:wq/q! （输入wq代表写入内容并退出，即保存；输入q!代表强制退出不保存。）) helloworld.sh 内容如下： 123#!/bin/bash#第一个shell小程序,echo 是linux中的输出命令。echo "helloworld!" shell中 # 符号表示注释。shell 的第一行比较特殊，一般都会以#!开始来指定使用的 shell 类型。在linux中，除了bash shell以外，还有很多版本的shell， 例如zsh、dash等等…不过bash shell还是我们使用最多的。 (4) 运行脚本:./helloworld.sh 。（注意，一定要写成 ./helloworld.sh ，而不是 helloworld.sh ，运行其它二进制的程序也一样，直接写 helloworld.sh ，linux 系统会去 PATH 里寻找有没有叫 test.sh 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 helloworld.sh 是会找不到命令的，要用./helloworld.sh 告诉系统说，就在当前目录找。） bash执行方式总结： 1234567891011# 使用shell来执行$ sh hello.sh# 使用bash来执行$ bash hello.sh#使用.来执行$ . ./hello.sh#使用source来执行$ source hello.sh#还可以赋予脚本所有者执行权限，允许该用户执行该脚本$ chmod u+rx hello.sh$ ./hello.sh Shell 变量Shell 编程中的变量介绍Shell编程中一般分为三种变量： 我们自己定义的变量（自定义变量）: 仅在当前 Shell 实例中有效，其他 Shell 启动的程序不能访问局部变量。 Linux已定义的环境变量（环境变量， 例如：$PATH, $HOME 等…, 这类变量我们可以直接使用），使用 env 命令可以查看所有的环境变量，而set命令既可以查看环境变量也可以查看自定义变量。 Shell变量 ：Shell变量是由 Shell 程序设置的特殊变量。Shell 变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了 Shell 的正常运行 常用的环境变量: PATH 决定了shell将到哪些目录中寻找命令或程序HOME 当前用户主目录HISTSIZE 历史记录数LOGNAME 当前用户的登录名HOSTNAME 指主机的名称SHELL 当前用户Shell类型LANGUGE 语言相关的环境变量，多语言可以修改此环境变量MAIL 当前用户的邮件存放目录PS1 基本提示符，对于root用户是#，对于普通用户是$ 使用 Linux 已定义的环境变量： 比如我们要看当前用户目录可以使用：echo $HOME命令；如果我们要看当前用户Shell类型 可以使用echo $SHELL命令。可以看出，使用方法非常简单。 使用自己定义的变量： 12345#!/bin/bash#自定义变量hellohello="hello world"echo $helloecho "helloworld!" Shell 编程中的变量名的命名的注意事项： 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头，但是可以使用下划线（_）开头。 中间不能有空格，可以使用下划线（_）。 不能使用标点符号。 不能使用bash里的关键字（可用help命令查看保留关键字）。 Shell 字符串入门字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号。这点和Java中有所不同。 单引号字符串： 1234#!/bin/bashname='SnailClimb'hello='Hello, I am '$name'!'echo $hello 输出内容： 1Hello, I am SnailClimb! 双引号字符串： 1234#!/bin/bashname='SnailClimb'hello="Hello, I am "$name"!"echo $hello 输出内容： 1Hello, I am SnailClimb! Shell 字符串常见操作拼接字符串： 12345678910#!/bin/bashname="SnailClimb"# 使用双引号拼接greeting="hello, "$name" !"greeting_1="hello, $&#123;name&#125; !"echo $greeting $greeting_1# 使用单引号拼接greeting_2='hello, '$name' !'greeting_3='hello, $&#123;name&#125; !'echo $greeting_2 $greeting_3 输出结果： 获取字符串长度： 1234567#!/bin/bash#获取字符串长度name="SnailClimb"# 第一种方式echo $&#123;#name&#125; #输出 10# 第二种方式expr length "$name"; 输出结果:121010 使用 expr 命令时，表达式中的运算符左右必须包含空格，如果不包含空格，将会输出表达式本身: 12expr 5+6 // 直接输出 5+6expr 5 + 6 // 输出 11 对于某些运算符，还需要我们使用符号\进行转义，否则就会提示语法错误。 12expr 5 * 6 // 输出错误expr 5 \* 6 // 输出30 截取子字符串: 简单的字符串截取： 123#从字符串第 1 个字符开始往后截取 10 个字符str="SnailClimb is a great man"echo $&#123;str:0:10&#125; #输出:SnailClimb 根据表达式截取： 12345678910#!bin/bash#author:amauvar="http://www.runoob.com/linux/linux-shell-variable.html"s1=$&#123;var%%t*&#125;#hs2=$&#123;var%t*&#125;#http://www.runoob.com/linux/linux-shell-variable.hs3=$&#123;var%%.*&#125;#http://wwws4=$&#123;var#*/&#125;#/www.runoob.com/linux/linux-shell-variable.htmls5=$&#123;var##*/&#125;#linux-shell-variable.html Shell 数组bash支持一维数组（不支持多维数组），并且没有限定数组的大小。我下面给了大家一个关于数组操作的 Shell 代码示例，通过该示例大家可以知道如何创建数组、获取数组长度、获取/删除特定位置的数组元素、删除整个数组以及遍历数组。 123456789101112131415#!/bin/basharray=(1 2 3 4 5);# 获取数组长度length=$&#123;#array[@]&#125;# 或者length2=$&#123;#array[*]&#125;#输出数组长度echo $length #输出：5echo $length2 #输出：5# 输出数组第三个元素echo $&#123;array[2]&#125; #输出：3unset array[1]# 删除下表为1的元素也就是删除第二个元素for i in $&#123;array[@]&#125;;do echo $i ;done # 遍历数组，输出： 1 3 4 5 unset arr_number; # 删除数组中的所有元素for i in $&#123;array[@]&#125;;do echo $i ;done # 遍历数组，数组元素为空，没有任何输出内容 Shell 基本运算符 说明：图片来自《菜鸟教程》 Shell 编程支持下面几种运算符 算数运算符 关系运算符 布尔运算符 字符串运算符 文件测试运算符 算数运算符 我以加法运算符做一个简单的示例： 12345#!/bin/basha=3;b=3;val=`expr $a + $b`#输出：Total value : 6echo "Total value : $val 关系运算符关系运算符只支持数字，不支持字符串，除非字符串的值是数字。 通过一个简单的示例演示关系运算符的使用，下面shell程序的作用是当score=100的时候输出A否则输出B。 123456789#!/bin/bashscore=90;maxscore=100;if [ $score -eq $maxscore ]then echo "A"else echo "B"fi 输出结果： 1B 逻辑运算符 示例： 1234#!/bin/basha=$(( 1 &amp;&amp; 0))# 输出：0；逻辑与运算只有相与的两边都是1，与的结果才是1；否则与的结果是0echo $a; 布尔运算符 这里就不做演示了，应该挺简单的。 字符串运算符 简单示例： 12345678910#!/bin/basha="abc";b="efg";if [ $a = $b ]then echo "a 等于 b"else echo "a 不等于 b"fi 输出： 1a 不等于 b 文件相关运算符 使用方式很简单，比如我们定义好了一个文件路径file=&quot;/usr/learnshell/test.sh&quot; 如果我们想判断这个文件是否可读，可以这样if [ -r $file ] 如果想判断这个文件是否可写，可以这样-w $file，是不是很简单。 shell流程控制if 条件语句简单的 if else-if else 的条件语句示例 123456789101112#!/bin/basha=3;b=9;if [ $a -eq $b ]then echo "a 等于 b"elif [ $a -gt $b ]then echo "a 大于 b"else echo "a 小于 b"fi 输出结果： 1a 小于 b 相信大家通过上面的示例就已经掌握了 shell 编程中的 if 条件语句。不过，还要提到的一点是，不同于我们常见的 Java 以及 PHP 中的 if 条件语句，shell if 条件语句中不能包含空语句也就是什么都不做的语句。 for 循环语句通过下面三个简单的示例认识 for 循环语句最基本的使用，实际上 for 循环语句的功能比下面你看到的示例展现的要大得多。 输出当前列表中的数据： 1234for loop in 1 2 3 4 5do echo "The value is: $loop"done 产生 10 个随机数： 12345#!/bin/bashfor i in &#123;0..9&#125;;do echo $RANDOM;done 输出1到5: 通常情况下 shell 变量调用需要加 $,但是 for 的 (()) 中不需要,下面来看一个例子： 1234#!/bin/bashfor((i=1;i&lt;=5;i++));do echo $i;done; while 语句基本的 while 循环语句： 1234567#!/bin/bashint=1while(( $int&lt;=5 ))do echo $int let "int++"done while循环可用于读取键盘信息： 123456echo '按下 &lt;CTRL-D&gt; 退出'echo -n '输入你最喜欢的电影: 'while read FILMdo echo "是的！$FILM 是一个好电影"done 输出内容: 123按下 &lt;CTRL-D&gt; 退出输入你最喜欢的电影: 变形金刚是的！变形金刚 是一个好电影 无限循环： 1234while truedo commanddone shell 函数不带参数没有返回值的函数1234567#!/bin/bashhello()&#123; echo "这是我的第一个 shell 函数!"&#125;echo "-----函数开始执行-----"helloecho "-----函数执行完毕-----" 输出结果： 123-----函数开始执行-----这是我的第一个 shell 函数!-----函数执行完毕----- 有返回值的函数输入两个数字之后相加并返回结果： 1234567891011#!/bin/bashfunWithReturn()&#123; echo "输入第一个数字: " read aNum echo "输入第二个数字: " read anotherNum echo "两个数字分别为 $aNum 和 $anotherNum !" return $(($aNum+$anotherNum))&#125;funWithReturnecho "输入的两个数字之和为 $?" 输出结果： 123456输入第一个数字: 1输入第二个数字: 2两个数字分别为 1 和 2 !输入的两个数字之和为 3 带参数的函数1234567891011#!/bin/bashfunWithParam()&#123; echo "第一个参数为 $1 !" echo "第二个参数为 $2 !" echo "第十个参数为 $10 !" echo "第十个参数为 $&#123;10&#125; !" echo "第十一个参数为 $&#123;11&#125; !" echo "参数总数有 $# 个!" echo "作为一个字符串输出所有参数 $* !"&#125;funWithParam 1 2 3 4 5 6 7 8 9 34 73 输出结果： 1234567第一个参数为 1 !第二个参数为 2 !第十个参数为 10 !第十个参数为 34 !第十一个参数为 73 !参数总数有 11 个!作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 ! 引用自：https://github.com/Snailclimb/JavaGuide#%E7%BD%91%E7%BB%9C]]></content>
      <categories>
        <category>操作系统</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络-传输层]]></title>
    <url>%2F2019%2F03%2F19%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82%2F</url>
    <content type="text"><![CDATA[网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。 UDP 和 TCP 的特点 用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。 传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。 区别1)TCP提供面向连接的、可靠的数据流传输，而UDP提供的是非面向连接的、不可靠的数据流传输。2)TCP传输单位称为TCP报文段，UDP传输单位称为用户数据报。 3)每一条 TCP 连接只能是点对点的,UDP支持一对一、一对多、多对一和多对多。 4)TCP注重数据安全性，UDP数据传输快，因为不需要连接等待，少了许多操作，但是其安全性却一般。 UDP 首部格式 首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。 TCP 首部格式 序号 ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。 确认号 ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。 数据偏移 ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。 确认 ACK ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。 同步 SYN ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。 终止 FIN ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。 窗口 ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。 TCP 的三次握手 假设 A 为客户端，B 为服务器端。 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。 A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。 B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。 A 收到 B 的连接确认报文后，还要向 B 发出确认(ACK=1)，确认号为 y+1，序号为 x+1。 B 收到 A 的确认后，连接建立。 三次握手的原因 【原因1】第三次握手是为了防止已经失效的连接请求突然又到达服务器，让服务器错误打开连接。 客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。 【原因2】TCP之所以可靠，是因为它保证了传送数据包的顺序。顺序是用一个序列号来保证的。响应包内也包括一个序列号，表示接收方准备好这个序列号的包。显然两次握手不能做到使客户端的序列号发给服务端，并得到服务端的确认，同时服务端产生一个序列号发给客户端，并得到客户端的确认。 TCP 的四次挥手 以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。 A 发送连接释放报文，FIN=1。 B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。 当 B 不再需要连接时，发送连接释放报文，FIN=1。 A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。 B 收到 A 的确认后释放连接。 四次挥手的原因 客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。 TIME_WAIT 客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由： 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。 TCP 滑动窗口窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。 发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。 接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 32进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。 (累计确认，加快传输速度) TCP 流量控制流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。 TCP 拥塞控制如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。 TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。 发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。 为了便于讨论，做如下假设： 接收方有足够大的接收缓存，因此不会发生流量控制； 虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。 1. 慢开始与拥塞避免发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 … 注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。 如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。 2. 快重传与快恢复在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。 在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。 在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。 慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。 TCP超时与重传机制原理：在发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到发送数据的ACK确认报文，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。 重传计时器： 1.若在计时器截止时间到之前收到了对此特定报文段的确认，则撤销此计时器。 2.若在收到了对此特定报文段的确认之前计时器截止时间到，则重传此报文段，并将计时器复位。 注意：由于不同的网络情况不一样，不可能设置一样的定时器的时间(RTO)，实际中RTO是根据网络中的RTT（传输往返时间）来自适应调整的。 TCP 怎样保证可靠性 序列号，ACK信号：发送方按照顺序给要发送的数据包的每个字节都标上编号。接收方接收到发送方的数据包之后，回传一个ACK信号，标识下一个需求的数据包初始字节编号。 2. 超时重传 3. TCP的连接管理：建立连接的三次握手和断开连接的四次挥手。 4. 以段为单位发送数据包：在建立TCP连接的同时，两端协商发送数据包的单位，称为“最大消息长度”：MSS。 【TCP数据(MSS字节)】【TCP首部(20字节)】【IP首部(20字节)】 5. 滑动窗口； 6. 流量控制； 7. 拥塞控制。 SYN Flood应如何应对1 什么是SYN Flood攻击 在TCP三次握手时，服务器接收客户端的SYN请求，操作系统将为该请求分配一个TCP（Transmission Control Block），服务器返回一个SYN/ACK请求，并将处于SYN_RCVD状态（半开连接状态）。 如果恶意的向某个服务器端口发送大量的SYN包，则可以使服务器打开大量的半开连接，分配TCB，从而消耗大量的服务器资源，同时也使得正常的连接请求无法被相应。而攻击发起方的资源消耗相比较可忽略不计。 SYN Flood是当前最流行的DoS（拒绝服务攻击）与DDoS（分布式拒绝服务攻击）的方式之一。 2 怎样发现自己处于被攻击状态 （1）服务端无法提供正常的TCP服务。连接请求被拒绝或超时； （2）通过 netstat -an 命令检查系统，发现有大量的SYN_RECV连接状态。 3 防御措施 （1）设置SYN Cookie，就是给每一个请求连接的IP地址分配一个Cookie，如果短时间内连续受到某个IP的重复SYN报文，就认定是受到了攻击，以后从这个IP地址来的包会被一概丢弃。 （2）使用SYN Proxy防火墙 Syn Cache技术和Syn Cookie技术总的来说是一种主机保护技术，需要系统的TCP/IP协议栈的支持，而目前并非所有的操作系统支持这些技术。因此很多防火墙中都提供一种 SYN代理的功能，让防火墙先确认有效性。 TCP粘包，拆包及解决方法粘包、拆包表现形式第一种情况，接收端正常收到两个数据包，即没有发生拆包和粘包的现象，此种情况不讨论范。 第二种情况，接收端只收到一个数据包，由于TCP是不会出现丢包的，所以这一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。这种情况由于接收端不知道这两个数据包的界限，所以对于接收端来说很难处理。 第三种情况，这种情况有两种表现形式，如下图。接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。这两种情况如果不加特殊处理，对于接收端同样是不好处理的。 粘包、拆包发生原因发生TCP粘包或拆包有很多原因，现列出常见的几点，可能不全面，1、要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包。2、待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。3、要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包。4、接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。 等等。 粘包、拆包解决办法通过以上分析，我们清楚了粘包或拆包发生的原因，那么如何解决这个问题呢？解决问题的关键在于如何给每个数据包添加边界信息，常用的方法有如下几个：1、发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。2、发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。3、可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。 等等。 TCP端口扫描方式1.connect扫描目标主机的一个端口如果是监听状态（LINSTEN），那么当我connect目标主机时就能成功，否则说明端口是关闭的。 优点： 编程简单，是需要一个API connect(),比较可靠，因为TCP是可靠协议，当丢包的时候，会重传SYN帧。 缺点： 正因为TCP的可靠性，所以当端口不存在的时候，源主机会不断尝试发SYN帧企图得到ack的应答，多次尝试后才会放弃，因此造成了扫描的时间较长。并且，connect的扫描方式可能较容易被目标主机发现。 2.SYN扫描向目标端口发送SUN数据帧，如果源主机收到SYN+ACK数据包，说明此端口开放，如果收到RST说明此端口关闭。由于SYN扫描并不会完成TCP三次握手过程，所以又叫半开放扫描。 优点： 速度快；如果不被防火墙过滤的话，基本都能收到应答包。 缺点： 扫描行为容易被发现；因为是自己攒包发，是在ip层的，因此不可靠，可能会丢包；实现起来比connect稍复杂。 3.FIN扫描根据上述四次挥手过程，主动结束的一方会发送FIN帧。当我们发送FIN帧给一个非监听的端口时，会有RST应答，反之，发给一个正在监听的端口时，不会有任何回应。 优点： 隐蔽性好；速度快。 缺点： 只能用于Linux系统，windows系统下无效，在windows下，无论端口是否监听，都将回应RST帧，造成无法判断；不可靠，当收不到应答包时，不确定是端口在监听，还是丢包了。]]></content>
      <categories>
        <category>计算机网络</category>
        <category>计算机网络理论</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动力节点SQL34题]]></title>
    <url>%2F2019%2F03%2F18%2F%E5%8A%A8%E5%8A%9B%E8%8A%82%E7%82%B9SQL34%E9%A2%98%2F</url>
    <content type="text"><![CDATA[0 练习数据sql脚本文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970drop table if exists dept;drop table if exists salgrade;drop table if exists emp; create table dept( deptno int(10) primary key, dname varchar(14), loc varchar(13) ); create table salgrade( grade int(11), losal int(11), hisal int(11) ); create table emp( empno int(4) primary key, ename varchar(10), job varchar(9), mgr int(4), hiredate date, sal double(7,2), comm double(7,2), deptno int(2) ); insert into dept(deptno,dname,loc) values(10,'ACCOUNTING','NEW YORK');insert into dept(deptno,dname,loc) values(20,'RESEARCHING','DALLAS');insert into dept(deptno,dname,loc) values(30,'SALES','CHICAGO');insert into dept(deptno,dname,loc) values(40,'OPERATIONS','BOSTON'); insert into salgrade(grade,losal,hisal) values(1,700,1200);insert into salgrade(grade,losal,hisal) values(2,1201,1400);insert into salgrade(grade,losal,hisal) values(3,1401,2000);insert into salgrade(grade,losal,hisal) values(4,2001,3000);insert into salgrade(grade,losal,hisal) values(5,3001,5000); insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) values(7369,'SIMITH','CLERK',7902,'1980-12-17',800,null,20);insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) values(7499,'ALLEN','SALESMAN',7698,'1981-02-20',1600,300,30);insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) values(7521,'WARD','SALESMAN',7698,'1981-02-22',1250,500,30);insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) values(7566,'JONES','MANAGER',7839,'1981-04-02',2975,null,20);insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) values(7654,'MARTIN','SALESMAN',7698,'1981-09-28',1250,1400,30);insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) values(7698,'BLAKE','MANAGER',7839,'1981-05-01',2850,null,30);insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) values(7782,'CLARK','MANAGER',7839,'1981-06-09',2450,null,10);insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) values(7788,'SCOTT','ANALYST',7566,'1987-04-19',3000,null,20);insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) values(7839,'KING','PRESIDENT',null,'1981-11-17',5000,null,10);insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) values(7844,'TURNER','SALESMAN',7698,'1981-09-08',1500,null,30);insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) values(7876,'ADAMS','CLERK',7788,'1987-05-23',1100,null,20);insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) values(7900,'JAMES','CLERK',7698,'1981-12-03',950,null,30);insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) values(7902,'FORD','ANALYST',7566,'1981-12-03',3000,null,20);insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) values(7934,'MILLER','CLERK',7782,'1982-01-23',1300,null,10); select * from dept;select * from salgrade;select * from emp; dept表格 123456789mysql&gt; select * from dept;+--------+-------------+----------+| deptno | dname | loc |+--------+-------------+----------+| 10 | ACCOUNTING | NEW YORK || 20 | RESEARCHING | DALLAS || 30 | SALES | CHICAGO || 40 | OPERATIONS | BOSTON |+--------+-------------+----------+ salgrade表格 12345678910mysql&gt; select * from salgrade;+-------+-------+-------+| grade | losal | hisal |+-------+-------+-------+| 1 | 700 | 1200 || 2 | 1201 | 1400 || 3 | 1401 | 2000 || 4 | 2001 | 3000 || 5 | 3001 | 5000 |+-------+-------+-------+ emp表格 12345678910111213141516171819mysql&gt; select * from emp;+-------+--------+-----------+------+------------+---------+---------+--------+| empno | ename | job | mgr | hiredate | sal | comm | deptno |+-------+--------+-----------+------+------------+---------+---------+--------+| 7369 | SIMITH | CLERK | 7902 | 1980-12-17 | 800.00 | NULL | 20 || 7499 | ALLEN | SALESMAN | 7698 | 1981-02-20 | 1600.00 | 300.00 | 30 || 7521 | WARD | SALESMAN | 7698 | 1981-02-22 | 1250.00 | 500.00 | 30 || 7566 | JONES | MANAGER | 7839 | 1981-04-02 | 2975.00 | NULL | 20 || 7654 | MARTIN | SALESMAN | 7698 | 1981-09-28 | 1250.00 | 1400.00 | 30 || 7698 | BLAKE | MANAGER | 7839 | 1981-05-01 | 2850.00 | NULL | 30 || 7782 | CLARK | MANAGER | 7839 | 1981-06-09 | 2450.00 | NULL | 10 || 7788 | SCOTT | ANALYST | 7566 | 1987-04-19 | 3000.00 | NULL | 20 || 7839 | KING | PRESIDENT | NULL | 1981-11-17 | 5000.00 | NULL | 10 || 7844 | TURNER | SALESMAN | 7698 | 1981-09-08 | 1500.00 | NULL | 30 || 7876 | ADAMS | CLERK | 7788 | 1987-05-23 | 1100.00 | NULL | 20 || 7900 | JAMES | CLERK | 7698 | 1981-12-03 | 950.00 | NULL | 30 || 7902 | FORD | ANALYST | 7566 | 1981-12-03 | 3000.00 | NULL | 20 || 7934 | MILLER | CLERK | 7782 | 1982-01-23 | 1300.00 | NULL | 10 |+-------+--------+-----------+------+------------+---------+---------+--------+ 1 取得每个部门最高薪水的人员名称先取得每个部门的最高薪水，然后找出和此薪水和部门编号相同的人。 12345678mysql&gt; select deptno,max(sal) as maxsal from emp group by deptno;+--------+---------+| deptno | maxsal |+--------+---------+| 20 | 3000.00 || 30 | 2850.00 || 10 | 5000.00 |+--------+---------+ 123456789mysql&gt; select a.ename,a.deptno,a.sal from emp a join(select deptno,max(sal) as maxsal from emp group by deptno) b on a.sal=b.maxsal and a.deptno=b.deptno;+-------+--------+---------+| ename | deptno | sal |+-------+--------+---------+| BLAKE | 30 | 2850.00 || SCOTT | 20 | 3000.00 || KING | 10 | 5000.00 || FORD | 20 | 3000.00 |+-------+--------+---------+ 2 哪些人的薪水在部门平均薪水之上先求出每个部门的平均薪水 12345678mysql&gt; select deptno,avg(sal) from emp group by deptno;+--------+-------------+| deptno | avg(sal) |+--------+-------------+| 20 | 2175.000000 || 30 | 1566.666667 || 10 | 2916.666667 |+--------+-------------+ 然后找出部门中大于其平均薪水的人 1234567891011mysql&gt; select a.deptno,a.ename,a.sal,b.avgsal from emp a join (select deptno,avg(sal) as avgsal from emp group by deptno) b on a.sal&gt;b.avgsal and a.deptno=b.deptno;+--------+-------+---------+-------------+| deptno | ename | sal | avgsal |+--------+-------+---------+-------------+| 30 | ALLEN | 1600.00 | 1566.666667 || 20 | JONES | 2975.00 | 2175.000000 || 30 | BLAKE | 2850.00 | 1566.666667 || 20 | SCOTT | 3000.00 | 2175.000000 || 10 | KING | 5000.00 | 2916.666667 || 20 | FORD | 3000.00 | 2175.000000 |+--------+-------+---------+-------------+ 3 取得部门中所有人的平均的薪水等级先计算每个人的薪水等级 12345678910111213141516171819mysql&gt; select a.deptno,a.ename,a.sal,b.grade from emp a join salgrade b on a.sal between b.losal and b.hisal order by a.deptno;+--------+--------+---------+-------+| deptno | ename | sal | grade |+--------+--------+---------+-------+| 10 | MILLER | 1300.00 | 2 || 10 | CLARK | 2450.00 | 4 || 10 | KING | 5000.00 | 5 || 20 | SCOTT | 3000.00 | 4 || 20 | SIMITH | 800.00 | 1 || 20 | ADAMS | 1100.00 | 1 || 20 | JONES | 2975.00 | 4 || 20 | FORD | 3000.00 | 4 || 30 | BLAKE | 2850.00 | 4 || 30 | ALLEN | 1600.00 | 3 || 30 | TURNER | 1500.00 | 3 || 30 | WARD | 1250.00 | 2 || 30 | JAMES | 950.00 | 1 || 30 | MARTIN | 1250.00 | 2 |+--------+--------+---------+-------+ 然后根据部门分组，由于使用了分组函数，所以只能显示参加分组的字段和分组函数 12345678mysql&gt; select a.deptno,avg(grade) as AvgSalGrade from emp a join salgrade b on a.sal between b.losal and b.hisal group by a.deptno;+--------+-------------+| deptno | AvgSalGrade |+--------+-------------+| 20 | 2.8000 || 30 | 2.5000 || 10 | 3.6667 |+--------+-------------+ 4 不准使用组函数Max，给出最高薪水（给出两种解决方案）方案一，按照薪水降序排列，取第一个 123456mysql&gt; select ename,sal from emp order by sal desc limit 1;+-------+---------+| ename | sal |+-------+---------+| KING | 5000.00 |+-------+---------+ 方案二，使用自连接。 1234567mysql&gt; select ename,sal from emp where sal not in (select a.sal from emp a join emp b on a.sal&lt;b.sal);#最大值不小于表中任何一个工资，所以不会出现在此临时表中+-------+---------+| ename | sal |+-------+---------+| KING | 5000.00 |+-------+---------+ 5 取得平均薪水最高的部门和部门编号方案一：先取得每个部门的平均薪水 12345678mysql&gt; select deptno, avg(sal) as avgsal from emp group by deptno;+--------+-------------+| deptno | avgsal |+--------+-------------+| 20 | 2175.000000 || 30 | 1566.666667 || 10 | 2916.666667 |+--------+-------------+ 再取得最高的平均薪水 123456mysql&gt; select avg(sal) as avgsal from emp group by deptno order by avgsal desc limit 1; +-------------+| avgsal |+-------------+| 2916.666667 |+-------------+ 然后取得和最高平均薪水相同的部门（因为可能有多个部门并列最高） 1234567mysql&gt; select deptno,avg(sal) as avgsal from emp group by deptno having avgsal= -&gt; (select avg(sal) as avgsal from emp group by deptno order by avgsal desc limit 1);+--------+-------------+| deptno | avgsal |+--------+-------------+| 10 | 2916.666667 |+--------+-------------+ 方案二：与方案一类似，用max取得最高平均薪水 1234567mysql&gt; select deptno,avg(sal) as avgsal from emp group by deptno having avgsal=(select max(t.avgsal) from (select avg(sal) as avgsal from emp group by deptno) t);+--------+-------------+| deptno | avgsal |+--------+-------------+| 10 | 2916.666667 |+--------+-------------+ 6 取得平均薪水最高的部门名称类似上题 123456SELECT d.dname,t.avgsal FROM dept d JOIN (SELECT deptno,AVG(sal) AS avgsal FROM emp GROUP BY deptno ORDER BY avgsal DESC LIMIT 1) t ON d.deptno=t.deptno;+--------+-------------+| deptno | avgsal |+--------+-------------+| 10 | 2916.666667 |+--------+-------------+ #7 求平均薪水的等级最高的部门的部门名称先求各部门平均薪水的等级 12345678select a.deptno,a.avgsal,b.grade from (select deptno,avg(sal) as avgsal from emp group by deptno) a join salgrade b on avgsal between losal and hisal;+--------+-------------+-------+| deptno | avgsal | grade |+--------+-------------+-------+| 20 | 2175.000000 | 4 || 30 | 1566.666667 | 3 || 10 | 2916.666667 | 4 |+--------+-------------+-------+ 取得最高的等级 123456mysql&gt; select b.grade from (select deptno,avg(sal) as avgsal from emp group by deptno) a join salgrade b on avgsal between losal and hisal order by b.grade desc limit 1;+-------+| grade |+-------+| 4 |+-------+ 显示平均薪水等级等于最高等级的部门名称 123456789101112131415161718192021mysql&gt; select d.dname,c.avgsal,c.gradefrom (select a.deptno,a.avgsal,b.grade from (select deptno,avg(sal) as avgsal from emp group by deptno) a join salgrade b on avgsal between losal and hisal) cjoin dept don c.deptno=d.deptno and c.grade= #最高等级为4 (select b.grade from (select deptno,avg(sal) as avgsal from emp group by deptno) a join salgrade b on avgsal between losal and hisal order by b.grade desc limit 1);+-------------+-------------+-------+| dname | avgsal | grade |+-------------+-------------+-------+| ACCOUNTING | 2916.666667 | 4 || RESEARCHING | 2175.000000 | 4 |+-------------+-------------+-------+ ##8 取得比普通员工（员工代码没在mgr字段出现的）最高薪水更高的领导人姓名先取出普通员工的最高薪水，注意mgr字段里有null，不能直接使用not in 语句 123456mysql&gt; select max(sal) as cmsal from emp where empno not in (select distinct mgr from emp where mgr is not null);+---------+| cmsal |+---------+| 1600.00 |+---------+ 取得所有领导人的姓名和薪水 1234567891011mysql&gt; select ename,sal from emp where empno in (select distinct mgr from emp);+-------+---------+| ename | sal |+-------+---------+| FORD | 3000.00 || BLAKE | 2850.00 || KING | 5000.00 || JONES | 2975.00 || SCOTT | 3000.00 || CLARK | 2450.00 |+-------+---------+ 然后取得结果 1234567891011mysql&gt; select ename,sal from emp where empno in (select distinct mgr from emp) and sal&gt;(select max(sal) as cmsal from emp where empno not in (select distinct mgr from emp where mgr is not null));+-------+---------+| ename | sal |+-------+---------+| JONES | 2975.00 || BLAKE | 2850.00 || CLARK | 2450.00 || SCOTT | 3000.00 || KING | 5000.00 || FORD | 3000.00 |+-------+---------+ ​ 13 面试题三张表： 学生表S：学号SNO，姓名SNAME 课程表C：课号CNO，课程名CNAME，课程老师CTEACHER 选课表SC：学号SNO，课号CNO，分数SCGRADE 1.显示没选”黎明“老师课的学生 123456#”黎明“老师的课号select cno from c where cteacher='黎明';#没选其课学生的学号select distinct sno from sc where sno not in (select cno from c where cteacher='黎明');#没选课学生的姓名select sname from s where sno in (select distinct sno from sc where sno not in (select cno from c where cteacher='黎明')); 2.列出2门以上（含2门）不及格学生姓名及平均成绩 1234567891011#2门及以上不及格学生的学号select sno from sc where scgrade&lt;60 group by sno having count(*)&gt;=2;#不及格学生姓名select sname,sno from s where sno in (select sno from sc where scgrade&lt;60 group by sno having count(*)&gt;=2);#学生的平均成绩select sno,avg(scgrade) avggrade from sc group by sno;#联合姓名和平均成绩select a.sno,a.sname,b.avggrade from (select sname,sno from s where sno in (select sno from sc where scgrade&lt;60 group by sno having count(*)&gt;=2)) a join (select sno,avg(scgrade) avggrade from sc group by sno) b on a.sno=b.sno; 3.学过1号课程和2号课程的所有学生的姓名 1234#选过1号课程和2号课程的学生学号select distinct sno from sc where cno=1 or cno=2;#从s表中取出其姓名select sno,sname from s where sno in (select distinct sno from sc where cno=1 or cno=2); 最后补充根据视频数据编写的sql文件 1234567891011121314151617181920212223242526272829303132333435363738394041create table c( cno int(2) primary key auto_increment, cname varchar(32), cteacher varchar(16) ); create table s( sno int(2) primary key auto_increment, sname varchar(16) );create table sc( sno int(2), cno int(2), scgrade int(3), primary key(sno,cno) ); insert into c(cname,cteacher)values('语文','张老师');insert into c(cname,cteacher)values('政治','王老师');insert into c(cname,cteacher)values('英语','李老师');insert into c(cname,cteacher)values('数学','赵老师');insert into c(cname,cteacher)values('物理','黎明');insert into s(sname)values('学生1');insert into s(sname)values('学生2');insert into s(sname)values('学生3');insert into s(sname)values('学生4');insert into sc(sno,cno,scgrade)values(1,1,40);insert into sc(sno,cno,scgrade)values(1,2,30);insert into sc(sno,cno,scgrade)values(1,3,20);insert into sc(sno,cno,scgrade)values(1,4,80);insert into sc(sno,cno,scgrade)values(1,5,60);insert into sc(sno,cno,scgrade)values(2,1,60);insert into sc(sno,cno,scgrade)values(2,2,60);insert into sc(sno,cno,scgrade)values(2,3,60);insert into sc(sno,cno,scgrade)values(2,4,60);insert into sc(sno,cno,scgrade)values(2,5,40);insert into sc(sno,cno,scgrade)values(3,1,60);insert into sc(sno,cno,scgrade)values(3,2,80); 14 列出所有员工及领导的姓名最高的领导的领导为null，因此需要使用左连接 12345678910111213141516171819mysql&gt; select a.ename as empname,b.ename as leadname from emp a left join emp b on a.mgr=b.empno;+---------+----------+| empname | leadname |+---------+----------+| SIMITH | FORD || ALLEN | BLAKE || WARD | BLAKE || JONES | KING || MARTIN | BLAKE || BLAKE | KING || CLARK | KING || SCOTT | JONES || KING | NULL || TURNER | BLAKE || ADAMS | SCOTT || JAMES | BLAKE || FORD | JONES || MILLER | CLARK |+---------+----------+ 15 列出受雇日期早于其上级的所有员工的编号、姓名、部门名称1234567891011mysql&gt; select e.empno,e.ename,e.hiredate,l.ename,l.hiredate from emp e join emp l on e.mgr=l.empno and e.hiredate&lt;l.hiredate;+-------+--------+------------+-------+------------+| empno | ename | hiredate | ename | hiredate |+-------+--------+------------+-------+------------+| 7369 | SIMITH | 1980-12-17 | FORD | 1981-12-03 || 7499 | ALLEN | 1981-02-20 | BLAKE | 1981-05-01 || 7521 | WARD | 1981-02-22 | BLAKE | 1981-05-01 || 7566 | JONES | 1981-04-02 | KING | 1981-11-17 || 7698 | BLAKE | 1981-05-01 | KING | 1981-11-17 || 7782 | CLARK | 1981-06-09 | KING | 1981-11-17 |+-------+--------+------------+-------+------------+ 16 列出部门名称和这些部门的员工信息，同时列出没有员工的部门有部门没有员工，所以需要使用左连接或右连接 1234567891011121314151617181920mysql&gt; select d.dname,e.* from dept d left join emp e on d.deptno=e.deptno;+-------------+-------+--------+-----------+------+------------+---------+---------+--------+| dname | empno | ename | job | mgr | hiredate | sal | comm | deptno |+-------------+-------+--------+-----------+------+------------+---------+---------+--------+| RESEARCHING | 7369 | SIMITH | CLERK | 7902 | 1980-12-17 | 800.00 | NULL | 20 || SALES | 7499 | ALLEN | SALESMAN | 7698 | 1981-02-20 | 1600.00 | 300.00 | 30 || SALES | 7521 | WARD | SALESMAN | 7698 | 1981-02-22 | 1250.00 | 500.00 | 30 || RESEARCHING | 7566 | JONES | MANAGER | 7839 | 1981-04-02 | 2975.00 | NULL | 20 || SALES | 7654 | MARTIN | SALESMAN | 7698 | 1981-09-28 | 1250.00 | 1400.00 | 30 || SALES | 7698 | BLAKE | MANAGER | 7839 | 1981-05-01 | 2850.00 | NULL | 30 || ACCOUNTING | 7782 | CLARK | MANAGER | 7839 | 1981-06-09 | 2450.00 | NULL | 10 || RESEARCHING | 7788 | SCOTT | ANALYST | 7566 | 1987-04-19 | 3000.00 | NULL | 20 || ACCOUNTING | 7839 | KING | PRESIDENT | NULL | 1981-11-17 | 5000.00 | NULL | 10 || SALES | 7844 | TURNER | SALESMAN | 7698 | 1981-09-08 | 1500.00 | NULL | 30 || RESEARCHING | 7876 | ADAMS | CLERK | 7788 | 1987-05-23 | 1100.00 | NULL | 20 || SALES | 7900 | JAMES | CLERK | 7698 | 1981-12-03 | 950.00 | NULL | 30 || RESEARCHING | 7902 | FORD | ANALYST | 7566 | 1981-12-03 | 3000.00 | NULL | 20 || ACCOUNTING | 7934 | MILLER | CLERK | 7782 | 1982-01-23 | 1300.00 | NULL | 10 || OPERATIONS | NULL | NULL | NULL | NULL | NULL | NULL | NULL | NULL |+-------------+-------+--------+-----------+------+------------+---------+---------+--------+ 17 列出至少有5名员工的所有部门1234567mysql&gt; select d.dname,count(e.empno) as number from dept d join emp e on d.deptno=e.deptno group by d.deptno having number&gt;=5;+-------------+--------+| dname | number |+-------------+--------+| RESEARCHING | 5 || SALES | 6 |+-------------+--------+ 18 列出薪水比simith多的所有员工信息123456789101112131415161718mysql&gt; select * from emp where sal&gt;(select sal from emp where ename='simith');+-------+--------+-----------+------+------------+---------+---------+--------+| empno | ename | job | mgr | hiredate | sal | comm | deptno |+-------+--------+-----------+------+------------+---------+---------+--------+| 7499 | ALLEN | SALESMAN | 7698 | 1981-02-20 | 1600.00 | 300.00 | 30 || 7521 | WARD | SALESMAN | 7698 | 1981-02-22 | 1250.00 | 500.00 | 30 || 7566 | JONES | MANAGER | 7839 | 1981-04-02 | 2975.00 | NULL | 20 || 7654 | MARTIN | SALESMAN | 7698 | 1981-09-28 | 1250.00 | 1400.00 | 30 || 7698 | BLAKE | MANAGER | 7839 | 1981-05-01 | 2850.00 | NULL | 30 || 7782 | CLARK | MANAGER | 7839 | 1981-06-09 | 2450.00 | NULL | 10 || 7788 | SCOTT | ANALYST | 7566 | 1987-04-19 | 3000.00 | NULL | 20 || 7839 | KING | PRESIDENT | NULL | 1981-11-17 | 5000.00 | NULL | 10 || 7844 | TURNER | SALESMAN | 7698 | 1981-09-08 | 1500.00 | NULL | 30 || 7876 | ADAMS | CLERK | 7788 | 1987-05-23 | 1100.00 | NULL | 20 || 7900 | JAMES | CLERK | 7698 | 1981-12-03 | 950.00 | NULL | 30 || 7902 | FORD | ANALYST | 7566 | 1981-12-03 | 3000.00 | NULL | 20 || 7934 | MILLER | CLERK | 7782 | 1982-01-23 | 1300.00 | NULL | 10 |+-------+--------+-----------+------+------------+---------+---------+--------+ ​ 20 列出最低薪水大于1500的各种工作及从事此工作的全部雇员人数12345678SELECT job,COUNT(empno) AS num, MIN(sal) AS minsal FROM emp GROUP BY job HAVING minsal&gt;1500;+-----------+-----+---------+| job | num | minsal |+-----------+-----+---------+| MANAGER | 3 | 2450.00 || ANALYST | 2 | 3000.00 || PRESIDENT | 1 | 5000.00 |+-----------+-----+---------+ 21 列出在部门sales工作的员工的姓名，假定不知道销售部的部门编号1234567891011mysql&gt; select e.ename,d.dname from emp e join dept d on e.deptno=d.deptno and d.dname='sales';+--------+-------+| ename | dname |+--------+-------+| ALLEN | SALES || WARD | SALES || MARTIN | SALES || BLAKE | SALES || TURNER | SALES || JAMES | SALES |+--------+-------+ ##22 列出薪水高于公司平均薪水的所有员工，所在部门，上级领导，薪水等级需要使用多表连接，将三张表连接在一起。 先取出公司平均薪水 123456mysql&gt; select avg(sal) as avgsal from emp;+-------------+| avgsal |+-------------+| 2073.214286 |+-------------+ 然后多表连接 12345678910111213141516SELECT e.ename,e.sal,d.dname,l.ename AS leadername,s.grade FROM emp e JOIN dept d ON e.deptno=d.deptno LEFT JOIN emp l ON e.mgr=l.empno #易错！！！一定要用外连接保证king也能显示出来 JOIN salgrade s ON e.sal BETWEEN s.losal AND s.hisal HAVING sal&gt;(SELECT AVG(sal) AS avgsal FROM emp);+-------+---------+-------------+--------------+-------+| ename | sal | dname | leadername | grade |+-------+---------+-------------+--------------+-------+| JONES | 2975.00 | RESEARCHING | KING | 4 || BLAKE | 2850.00 | SALES | KING | 4 || CLARK | 2450.00 | ACCOUNTING | KING | 4 || SCOTT | 3000.00 | RESEARCHING | JONES | 4 || KING | 5000.00 | ACCOUNTING | (null) | 5 || FORD | 3000.00 | RESEARCHING | JONES | 4 |+-------+---------+-------------+--------------+-------+ #23 列出与scott从事相同工作的所有员工及部门名称先找出scott的岗位 123456mysql&gt; select job from emp where ename='scott';+---------+| job |+---------+| ANALYST |+---------+ 然后找出从事此工作的员工并与部门表连接显示部门名，注意排除scott本人 12345678910SELECT e.ename,d.dname FROM emp e JOIN dept d ON e.deptno=d.deptno AND e.job=(SELECT job FROM emp WHERE ename='scott') AND e.ename!='scott';+-------+-------------+| ename | dname |+-------+-------------+| FORD | RESEARCHING |+-------+-------------+ 24 列出薪水等于部门30中员工的薪水的其他员工的姓名和薪水取出部门30的各个员工的薪水 1234567891011mysql&gt; select sal from emp where deptno=30;+---------+| sal |+---------+| 1600.00 || 1250.00 || 1250.00 || 2850.00 || 1500.00 || 950.00 |+---------+ 然后找出其他部门中是否有员工工资与上表中数据相同 12mysql&gt; select ename,sal from emp where sal in (select sal from emp where deptno=30) and deptno&lt;&gt;30;Empty set (0.00 sec) 25 列出薪水高于部门30的全部员工的员工姓名，薪水，部门名称先取出部门30的最高薪水 123456mysql&gt; select sal from emp where deptno=30 order by sal desc limit 1;+---------+| sal |+---------+| 2850.00 |+---------+ 然后连接员工表和部门表 123456789mysql&gt; select e.ename,e.sal,d.dname from emp e join dept d where e.deptno=d.deptno and e.sal&gt;(select sal from emp where deptno=30 order by sal desc limit 1);+-------+---------+-------------+| ename | sal | dname |+-------+---------+-------------+| JONES | 2975.00 | RESEARCHING || SCOTT | 3000.00 | RESEARCHING || KING | 5000.00 | ACCOUNTING || FORD | 3000.00 | RESEARCHING |+-------+---------+-------------+ #26 列出在每个部门工作的员工数量，平均工资和平均服务期限！！！错误解答,少了没有员工的部门40 1234567891011SELECT deptno,COUNT(empno) AS number,AVG(sal) AS avgsal, IFNULL(AVG((TO_DAYS(NOW())-TO_DAYS(emp.hiredate))/365),0) AS avgtime FROM emp GROUP BY deptno;+--------+--------+-------------+-------------+| deptno | number | avgsal | avgtime |+--------+--------+-------------+-------------+| 20 | 5 | 2175.000000 | 35.57588000 || 30 | 6 | 1566.666667 | 37.84750000 || 10 | 3 | 2916.666667 | 37.54886667 |+--------+--------+-------------+-------------+ 注意：以下select 后第一个字段必须为b.deptno,若为a.deptno则没有deptno为40的信息。 123456789101112SELECT b.deptno,COUNT(a.empno) AS number,AVG(a.sal) AS avgsal,IFNULL(AVG((TO_DAYS(NOW())-TO_DAYS(a.hiredate))/365),0) AS avgtime FROM emp a RIGHT JOIN dept b ON a.deptno=b.deptno GROUP BY a.deptno;+--------+--------+-------------+-------------+| deptno | number | avgsal | avgtime |+--------+--------+-------------+-------------+| 20 | 5 | 2175.000000 | 35.57588000 || 30 | 6 | 1566.666667 | 37.84750000 || 10 | 3 | 2916.666667 | 37.54886667 || 40 | 0 | 0.000000 | 0.00000000 |+--------+--------+-------------+-------------+ 27 列出所有员工的姓名、部门名称、工资12345678910111213141516171819mysql&gt; select e.ename,d.dname,e.sal from emp e join dept d on d.deptno=e.deptno;+--------+-------------+---------+| ename | dname | sal |+--------+-------------+---------+| SIMITH | RESEARCHING | 800.00 || ALLEN | SALES | 1600.00 || WARD | SALES | 1250.00 || JONES | RESEARCHING | 2975.00 || MARTIN | SALES | 1250.00 || BLAKE | SALES | 2850.00 || CLARK | ACCOUNTING | 2450.00 || SCOTT | RESEARCHING | 3000.00 || KING | ACCOUNTING | 5000.00 || TURNER | SALES | 1500.00 || ADAMS | RESEARCHING | 1100.00 || JAMES | SALES | 950.00 || FORD | RESEARCHING | 3000.00 || MILLER | ACCOUNTING | 1300.00 |+--------+-------------+---------+ 28 列出所有部门的详细信息和人数123456789mysql&gt; select d.*,count(e.ename) as totalemp from dept d left join emp e on d.deptno=e.deptno group by d.deptno;+--------+-------------+----------+----------+| deptno | dname | loc | totalemp |+--------+-------------+----------+----------+| 20 | RESEARCHING | DALLAS | 5 || 30 | SALES | CHICAGO | 6 || 10 | ACCOUNTING | NEW YORK | 3 || 40 | OPERATIONS | BOSTON | 0 |+--------+-------------+----------+----------+ 29 列出各种工作的最低工资以及从事此工作的雇员姓名先取出各种工作的最低工资 12345678910mysql&gt; select job,min(sal) as minsal from emp group by job;+-----------+---------+| job | minsal |+-----------+---------+| CLERK | 800.00 || SALESMAN | 1250.00 || MANAGER | 2450.00 || ANALYST | 3000.00 || PRESIDENT | 5000.00 |+-----------+---------+ 然后从员工表emp中找出岗位和工资与上表相同的员工 123456789101112mysql&gt; select e.ename,t.job,t.minsal from emp e join (select job,min(sal) as minsal from emp group by job) t on e.sal=t.minsal and e.job=t.job;+--------+-----------+---------+| ename | job | minsal |+--------+-----------+---------+| SIMITH | CLERK | 800.00 || WARD | SALESMAN | 1250.00 || MARTIN | SALESMAN | 1250.00 || CLARK | MANAGER | 2450.00 || SCOTT | ANALYST | 3000.00 || KING | PRESIDENT | 5000.00 || FORD | ANALYST | 3000.00 |+--------+-----------+---------+ 30 列出各个部门的manager的最低薪水12345678mysql&gt; select min(sal),deptno from emp where job='manager' group by deptno;+----------+--------+| min(sal) | deptno |+----------+--------+| 2975.00 | 20 || 2850.00 | 30 || 2450.00 | 10 |+----------+--------+ 显示姓名和职业的话，可以再与员工表emp进行表连接 1234567891011SELECT e.ename,e.job,t.minsal,t.deptno FROM emp e JOIN (SELECT deptno,MIN(sal) AS minsal FROM emp WHERE job='manager' GROUP BY deptno) t ON e.sal=t.minsal AND e.job = 'manager';+-------+---------+---------+--------+| ename | job | minsal | deptno |+-------+---------+---------+--------+| JONES | MANAGER | 2975.00 | 20 || BLAKE | MANAGER | 2850.00 | 30 || CLARK | MANAGER | 2450.00 | 10 |+-------+---------+---------+--------+ 31 列出员工的年工资，按年薪从高到低排序12345678910111213141516171819mysql&gt; select ename,sal*12 as yearsal from emp order by sal desc;+--------+----------+| ename | yearsal |+--------+----------+| KING | 60000.00 || SCOTT | 36000.00 || FORD | 36000.00 || JONES | 35700.00 || BLAKE | 34200.00 || CLARK | 29400.00 || ALLEN | 19200.00 || TURNER | 18000.00 || MILLER | 15600.00 || WARD | 15000.00 || MARTIN | 15000.00 || ADAMS | 13200.00 || JAMES | 11400.00 || SIMITH | 9600.00 |+--------+----------+ 32 求出员工领导的薪水超过3000的员工姓名和领导姓名12345678mysql&gt; select a.ename empname,b.ename leadname,b.sal from emp a join emp b on a.mgr=b.empno and b.sal&gt;3000;+---------+----------+---------+| empname | leadname | sal |+---------+----------+---------+| JONES | KING | 5000.00 || BLAKE | KING | 5000.00 || CLARK | KING | 5000.00 |+---------+----------+---------+ #33 求出部门名称中，带有‘s’字符的部门员工的工资合计，部门人数解答1: 1234567891011SELECT t.deptno,t.dname,IFNULL(SUM(e.sal),0) AS sumsal,IFNULL(COUNT(e.deptno),0) AS totalemp FROM emp e RIGHT JOIN (SELECT deptno,dname FROM dept WHERE dname LIKE '%s%') t ON e.deptno=t.deptno GROUP BY e.deptno;+--------+-------------+----------+----------+| deptno | dname | sumsal | totalemp |+--------+-------------+----------+----------+| 20 | RESEARCHING | 10875.00 | 5 || 30 | SALES | 9400.00 | 6 || 40 | OPERATIONS | 0.00 | 0 |+--------+-------------+----------+----------+ 解答2： 12345678mysql&gt; select d.deptno,d.dname,ifnull(sum(e.sal),0) as sumsal,ifnull(count(e.ename),0) as totalemp from dept d left join emp e on d.deptno=e.deptno where d.dname like '%s%' group by d.deptno;+--------+-------------+----------+----------+| deptno | dname | sumsal | totalemp |+--------+-------------+----------+----------+| 20 | RESEARCHING | 10875.00 | 5 || 30 | SALES | 9400.00 | 6 || 40 | OPERATIONS | 0.00 | 0 |+--------+-------------+----------+----------+ 34 给任职时间超过30年的员工加薪10%1update emp set sal=sal*1.1 where (to_days(now())-to_days(hiredate))/365&gt;30;]]></content>
      <categories>
        <category>数据库</category>
        <category>数据库刷题</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>数据库刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络-应用层]]></title>
    <url>%2F2019%2F03%2F18%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82%2F</url>
    <content type="text"><![CDATA[域名系统DNSDNS服务作用：负责将域名解析成IP DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。 域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。 DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。在两种情况下会使用 TCP 进行传输： 如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。 区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。 浏览器输入DNS解析过程：1.在浏览器中输入www.baidu.com之后，系统会先检查本地hosts文件是否存在域名映射，如果存在，则域名解析到此完成。 2.如果本地hosts文件不存在映射关系，则会查询本地DNS缓存，如果存在，则域名解析完成。 3.主机向本地域名服务器发起查询，该查询一般都是采用递归查询。 所谓递归查询就是：如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其它根域名服务器继续发出查询请求报文(即替主机继续查询)。 文件传送协议FTPFTP 使用 TCP 进行连接，它需要两个连接来传送一个文件： 控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。 数据连接：用来传送一个文件数据。 动态主机配置协议DHCPDHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。 DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。 DHCP 工作过程如下： 客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。 DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。 如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。 DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。 远程登录协议TELNETTELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。 TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。 电子邮件协议一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。 邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。 1. SMTP(发送)SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。 2. POP3(接收)POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。 3. IMAP(接收)IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。 常用端口 应用 应用层协议 端口号 传输层协议 备注 域名解析 DNS 53 UDP/TCP 长度超过 512 字节时使用 TCP 动态主机配置协议 DHCP 67/68 UDP 简单网络管理协议 SNMP 161/162 UDP 文件传送协议 FTP 20/21 TCP 控制连接 21，数据连接 20 远程终端协议 TELNET 23 TCP 超文本传送协议 HTTP 80 TCP 简单邮件传送协议 SMTP 25 TCP 邮件读取协议 POP3 110 TCP 网际报文存取协议 IMAP 143 TCP 在浏览器地址栏键入URL，按下回车之后会经历以下流程：1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址; 2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接; 3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器; 4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器; 5、释放 TCP连接; 6、浏览器将该 html 文本并显示内容; Web 页面请求详细过程1. DHCP 配置主机信息 假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。 主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。 该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。 该数据报则被放置在 MAC 帧中，该帧具有目的地址 FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备。 连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。 该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。 主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。 2. ARP 解析 MAC 地址 主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。 主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。 该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。 该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。 DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。 主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:FF:FF:FF:FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。 网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。 3. DNS 解析域名 知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。 网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。 因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。 到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。 找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。 4. HTTP 请求页面 有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。 在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。 HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。 连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。 HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。 浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。]]></content>
      <categories>
        <category>计算机网络</category>
        <category>计算机网络理论</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络-物理层]]></title>
    <url>%2F2019%2F03%2F18%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%89%A9%E7%90%86%E5%B1%82%2F</url>
    <content type="text"><![CDATA[物理层的基本功能物理层解决如何在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。 物理层的主要任务描述为：确定传输媒体的接口的一些特性，即： 机械特性：例接口形状，大小，引脚数目 电气特性：例规定电压范围（-5V到+5V） 功能特性：例规定-5V表示0，+5V表示1 过程特性：也称规程特性，规定建立连接时各个相关部件的工作步骤 ==中继器、集线器、网桥、交换机、路由器概念与区别==中继器、集线器、网桥、交换机、路由器概念与区别 1.中继器 中继器，就是简单的信号放大器，使信号能传的更远。 2.集线器 集线器，差不多就是个多端口的中继器，把每个输入端口的信号放大再发到别的端口去，集线器可以实现多台计算机之间的互联，因为它有很多的端口，每个口都能连计算机。 、、、、、、、、、、、、、以上为物理层、、、、、、、、、、、、、、、、、 3.网桥 网桥工作在数据链路层，将两个LAN连起来，根据MAC地址来转发帧，可以看作一个“低层的路由器”。 4.交换机 可以理解为高级的网桥，他有网桥的功能，但性能比网桥强。交换机和网桥的细微差别就在于：交换机常常用来连接独立的计算机**，而网桥连接的目标是LAN，所以交换机的端口较网桥多。** 、、、、、、、、、、、、以上为数据链路层、、、、、、、、、 5.路由器 (网络层) 路由选择与分组转发 6.网关 (网络层) 网关(Gateway)又称网间连接器、协议转换器。网关在网络层以上实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。网关既可以用于广域网互连，也可以用于局域网互连。 网关是一种充当转换重任的计算机系统或设备。使用在不同的通信协议、数据格式或语言，甚至体系结构完全不同的两种系统之间，网关是一个翻译器。与网桥只是简单地传达信息不同，网关对收到的信息要重新打包，以适应目的系统的需求。 网关，从技术角度来解释，就是连接两个不同网络的接口，比如局域网的共享上网服务器就是局域网和广域网的接口。 最后问两个问题： 1.交换机和路由器的区别？ 交换机可以将多台电脑连接起来，与交换机互连的电脑本身则具备了互相通信的功能，组建成了一个内部局域网，但需要访问互联网还需要有网络支持，因此交换机一端需要连接到路由器，路由器即可实现交换功能，还可以拨号，实现宽带连接，并将宽带资源分配个交换机使用，这样就实现了多台电脑共享上网。 ​ 举个例子说明路由器和交换机的配合：我要去找小明借电脑，小明说他不在家，叫我自己去拿吧，同时还告诉我他家的地址是XX路XX小区XX号（好比ip地址），我根据小明告诉我的地址找到了小明的家（路由器的功能，寻找路径）。我进门发现他家居然有10台电脑，哪台是借给我的那台呢？噢，原来小明还告诉我他要借给我的电脑的编号（MAC地址），那样我就可以根据编号找到相应的电脑了。 ​ 在上述的例子中，如果我没有路由器，我就不知道怎么去小明家，更不用说拿到电脑；如果我没有拿到所需的电脑编号，我也拿不到电脑，因为有十台电脑，我不能乱拿；有个特殊情况，如果小明家只有一台电脑呢？那我就不需要编号就可以确定拿哪台电脑，也就是不需要交换机。 2.为什么有时候还要在路由器的后面先接1台交换机再接计算机？ ​ 路由器是可以直接接电脑等终端设备，为什么标准都是路由器接交换机然后再接电脑等终端，是因为路由器本来就是一个路由设备，用来选路的，不适合大量的数据交换，交换机是用来大量数据交换的，终端在内网的性质就是需要使用交换机，所以标准就是路由器地下接交换机的形式。一般是情况就是在路由器下面接交换机，路由器主要起数据转发，也就是寻址、路由的功能，交换机起到用户接入的目的。但是家用的路由器的话直接就接计算机就可以了，而不必考虑再接交换机。 数据通讯的基础知识 半双工和全双工通讯：两者都可发可收，但是半双工不能同时收发，全双工可以。 基带信号和带通信号：基带信号（即基本频带信号）——来自信源的信号。 像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。基带信号就是发出的直接表达了要传输的信息的信号，比如我们说话的声波就是基带信号 带通信号——把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道）。 因此在传输距离较近时，计算机网络都采用基带传输方式由于在近距离范围内基带信号的衰减不大，从而信号内容不会发生变化。因此在传输距离较近时，计算机网络都采用基带传输方式。如从计算机到监视器、打印机等外设的信号就是基带传输的。 对基带数字信号的几种调制方法： 编码方式：** 采用曼切斯特编码，一个时钟周期只可表示一个bit，并且必须通过两次采样才能得到一个bit但它能携带时钟信号，且可表示没有数据传输(没有数据传输就没有电平变化) 差分曼彻斯特编码与曼彻斯特编码相同，但抗干扰性能强于曼彻斯特编码 将1000100111进行曼彻斯特和差分曼彻斯特编码 奈氏准则(没干扰) 1924年，奈奎斯特（Nyquist）就推导出了著名的奈氏准则。他给出了在假定的理想条件下，为了避免码间串扰，码元的传输速率的上限值。 在任何信道中，码元传输的速率是有上限的，否则就会出现码间串扰的问题，使接收端对码元的判决（即识别）成为不可能。如果信道的频带越宽，也就是能够通过的信号高频分量越多，那么就可以用更高的速率传送码元而不出现码间串扰。 香农公式 香农（Shannon）用信息论的理论推导出了带宽受限且有高斯白噪声干扰的信道的极限、无差错的信息传输速率。信道的极限信息传输速率C可表达为 香农公式表明 信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高。 只要信息传输速率低于信道的极限信息传输速率，就一定可以找到某种办法来实现无差错的传输。 若信道带宽W或信噪比S/N没有上限（当然实际信道不可能是这样的），则信道的极限信息传输速率C也就没有上限。 实际信道上能够达到的信息传输速率要比香农的极限传输速率低不少。]]></content>
      <categories>
        <category>计算机网络</category>
        <category>计算机网络理论</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络-网络层]]></title>
    <url>%2F2019%2F03%2F18%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82%2F</url>
    <content type="text"><![CDATA[概述因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。 使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。 与 IP 协议配套使用的还有三个协议： 地址解析协议 ARP（Address Resolution Protocol） 网际控制报文协议 ICMP（Internet Control Message Protocol） 网际组管理协议 IGMP（Internet Group Management Protocol） IP 数据报格式 版本 : 有 4（IPv4）和 6（IPv6）两个值； 首部长度 : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。 区分服务 : 用来获得更好的服务，一般情况下不使用。 总长度 : 包括首部长度和数据部分长度。 生存时间 ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。 协议 ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。 首部检验和 ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。 标识 : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。 片偏移 : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。 ==IP 地址编址方式==IP 地址的编址方式经历了三个历史阶段： 1. 分类由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。 IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;} 2. 子网划分通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。 IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;} 要使用子网，必须配置子网掩码。 注意，外部网络看不到子网的存在。 3. 无分类无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。 IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;} CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。 CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。 一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 构成超网 。 在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。 ==地址解析协议 ARP==网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。 ARP 实现由 IP 地址得到 MAC 地址。 ARP过程（重要）每个主机都有一个 ARP 缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。 主机 A 知道主机 B 的 IP 地址： （1）如果 ARP 缓存中有该 IP 地址到 MAC 地址的映射，直接将IP数据包封装后发出去。 （2）如果 ARP 缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。 ARP欺骗,用于监听(回复解析的MAC，对真实回复的MAC进行覆盖)，用于让目标机无法接受(传个不存在的MAC)(工具：网络执法官，防止：ARP防火墙) ==网际控制报文协议 ICMP==用于实现链路连通性测试和链路追踪，可以实现链路差错报告，属于UDP协议。 ping、tracert 等命令的内部就是用的 icmp 协议。 ==网络组管理协议 IGMP==信道分类 点到点： 广播：目标地址全FF 发一个包，所有的都可以接受 组播=多播： 组播类似于频道，例如开视频会议，总部在北京，领导讲话，上海所有员工需要观看，其他地方员工不用看到。 而IGMP协议是指英文全称（Internet Group Management Protocol），网络组管理协议。主要用于建立和管理多播组，对IP分组广播进行控制。 协议号： ICMP协议号1 IGMP协议2 TCP 6 UDP 17 IPv6 41 0SPF 89 静态路由与动态路由现将静态路由和动态路由进行如下比较： 定义： 静态路由：静态路由是在路由器中设置固定的路由表；除非网络管理员进行干预，否则静态路由表不会发生变化。 动态路由：由网络中的路由器之间相互通信，传递路由信息，利用收到的路由信息更新路由表的路由方式。 优点： 静态路由：简单、高效、可靠、网络安全、转发效率高。 动态路由：灵活，能够适时适应网络结构的变化，无需管理员手工维护，减轻了管理员的工作负担。 缺点： 静态路由：不能灵活的适应网络的动态变化。 动态路由：占用网络带宽（用于传输路由更新信息）。 使用场景： 静态路由：网络规模不大，拓扑结构固定的网络中。 动态路由：网络规模大，网络拓扑机构复杂的网络。]]></content>
      <categories>
        <category>计算机网络</category>
        <category>计算机网络理论</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[socket编程]]></title>
    <url>%2F2019%2F03%2F17%2Fsocket%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[数据传输方式计算机之间有很多数据传输方式，各有优缺点，常用的有两种：SOCK_STREAM 和 SOCK_DGRAM。 1) SOCK_STREAM 表示面向连接的数据传输方式。可靠性高、效率稍低； 2) SOCK_DGRAM 表示无连接的数据传输方式。效率高、小概率情况下会出错。 QQ 视频聊天和语音聊天就使用 SOCK_DGRAM 传输数据，因为首先要保证通信的效率，尽量减小延迟，而数据的正确性是次要的，即使丢失很小的一部分数据，视频和音频也可以正常解析，最多出现噪点或杂音，不会对通信质量有实质的影响。 socket缓冲区每个 socket 被创建后，都会分配两个缓冲区，输入缓冲区和输出缓冲区。 这些I/O缓冲区特性可整理如下： I/O缓冲区在每个TCP套接字中单独存在； I/O缓冲区在创建套接字时自动生成； 即使关闭套接字也会继续传送输出缓冲区中遗留的数据； 关闭套接字将丢失输入缓冲区中的数据。 socket三种通信模型，BIO，NIO，AIOBIO是同步阻塞IO，NIO是同步非阻塞IO，AIO是异步非阻塞IO；三种IO方式相比较而言，BIO是一个客户端对应一个线程，NIO是多个客户端对应一个线程，服务器端和客户端均使用缓冲区的方式进行读写，AIO是简化的NIO； 高并发中的select与epoll(I/O复用)参考网页 select 和 epoll效率差异的原因：select采用轮询方式处理连接，epoll是触发式处理连接。 Select: 1.Socket数量限制：该限制可操作的Socket数由FD_SETSIZE决定，内核默认32*32=1024. 2.操作限制：通过遍历FD_SETSIZE(1024)个Socket来完成调度，不管哪个Socket是活跃的，都遍历一遍。 Epoll 1.Socket数量无限制：该模式下的Socket对应的fd列表由一个数组来保存，大小不限制（默认4k）。 2.操作无限制：基于内核提供的反射模式，有活跃Socket时，内核访问该Socket的callback，不需要遍历轮询。 但当所有的Socket都活跃的时候，所有的callback都被唤醒，会导致资源的竞争。既然都是要处理所有的Socket， 那么遍历是最简单最有效的实现方式。 【例1】关于linux的I/O复用接口select和epoll,下列说法错误的是() A. select调用时会进行线性遍历,epoll采用回调函数机制,不需要线性遍历 B. select的最大连接数为FD_SETSIZE C. select较适合于有大量并发连接,且活跃链接较多的场景 D. epoll较适用于有大量并发连接，但活跃连接不多的场景 E. epoll的效率不随FD数目增加而线性下降 F. epoll通过共享存储实现内核和用户的数据交互 选C 【例2】关于epoll和select的区别，哪些说法是正确的？A. epoll和select都是I/O多路复用的技术，都可以实现同时监听多个I/O事件的状态B. epoll相比select效率更高，主要是基于其操作系统支持的I/O事件通知机制，而select是基于轮询机制C. epoll支持水平触发和边沿触发两种模式D. select能并行支持I/O比较小，且无法修改 选ABC nginx就是采用epoll的方式 epoll使用讲解完了Epoll的机理，我们便能很容易掌握epoll的用法了。一句话描述就是：三步曲。 第一步：epoll_create()系统调用。此调用返回一个句柄，之后所有的使用都依靠这个句柄来标识。 第二步：epoll_ctl()系统调用。通过此调用向epoll对象中添加、删除、修改感兴趣的事件，返回0标识成功，返回-1表示失败。 第三部：epoll_wait()系统调用。通过此调用收集收集在epoll监控中已经发生的事件。]]></content>
      <categories>
        <category>计算机网络</category>
        <category>socket编程</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>socket编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP]]></title>
    <url>%2F2019%2F03%2F17%2FHTTP%2F</url>
    <content type="text"><![CDATA[基础概念HTTP传输特点：1.传输明文内容，安全性比较差； 2.无状态协议。 URIURI 包含 URL 和 URN。 请求和响应报文1. 请求报文 2. 响应报文 HTTP 请求方法 客户端发送的 请求报文 第一行为请求行，包含了方法字段。 GET 获取资源 当前网络请求中，绝大部分使用的是 GET 方法。 HEAD 获取报文首部 和 GET 方法类似，但是不返回报文实体主体部分。 主要用于确认 URL 的有效性以及资源更新的日期时间等。 POST 传输实体主体 POST 主要用来传输数据，而 GET 主要用来获取资源。 更多 POST 与 GET 的比较请见第九章。 PUT 上传文件 由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。 123456PUT /new.html HTTP/1.1Host: example.comContent-type: text/htmlContent-length: 16&lt;p&gt;New File&lt;/p&gt; PATCH 对资源进行部分修改 PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。 1234567PATCH /file.txt HTTP/1.1Host: www.example.comContent-Type: application/exampleIf-Match: "e0023aa4e"Content-Length: 100[description of changes] DELETE 删除文件 与 PUT 功能相反，并且同样不带验证机制。 1DELETE /file.html HTTP/1.1 OPTIONS 查询支持的方法 查询指定的 URL 能够支持的方法。 会返回 Allow: GET, POST, HEAD, OPTIONS 这样的内容。 CONNECT 要求在与代理服务器通信时建立隧道 使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。 1CONNECT www.example.com:443 HTTP/1.1 TRACE 追踪路径 服务器会将通信路径返回给客户端。 发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。 通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。 HTTP 响应状态码服务器返回的 响应报文 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。 状态码 类别 含义 1XX Informational（信息性状态码） 接收的请求正在处理 2XX Success（成功状态码） 请求正常处理完毕 3XX Redirection（重定向状态码） 需要进行附加操作以完成请求 4XX Client Error（客户端错误状态码） 服务器无法处理请求 5XX Server Error（服务器错误状态码） 服务器处理请求出错 1XX 信息 100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。 2XX 成功 200 OK 204 No Content ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。 206 Partial Content ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。 3XX 重定向 301 Moved Permanently ：永久性重定向 302 Found ：临时性重定向 303 See Other ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。 注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。 304 Not Modified ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。 307 Temporary Redirect ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。 4XX 客户端错误 400 Bad Request ：请求报文中存在语法错误。 401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。 403 Forbidden ：请求被拒绝。 404 Not Found 5XX 服务器错误 500 Internal Server Error ：服务器正在执行请求时发生错误。 503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。 HTTP 首部(了解)有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段。 各种首部字段及其含义如下（不需要全记，仅供查阅）： 通用首部字段 首部字段名 说明 Cache-Control 控制缓存的行为 Connection 控制不再转发给代理的首部字段、管理持久连接 Date 创建报文的日期时间 Pragma 报文指令 Trailer 报文末端的首部一览 Transfer-Encoding 指定报文主体的传输编码方式 Upgrade 升级为其他协议 Via 代理服务器的相关信息 Warning 错误通知 请求首部字段 首部字段名 说明 Accept 用户代理可处理的媒体类型 Accept-Charset 优先的字符集 Accept-Encoding 优先的内容编码 Accept-Language 优先的语言（自然语言） Authorization Web 认证信息 Expect 期待服务器的特定行为 From 用户的电子邮箱地址 Host 请求资源所在服务器 If-Match 比较实体标记（ETag） If-Modified-Since 比较资源的更新时间 If-None-Match 比较实体标记（与 If-Match 相反） If-Range 资源未更新时发送实体 Byte 的范围请求 If-Unmodified-Since 比较资源的更新时间（与 If-Modified-Since 相反） Max-Forwards 最大传输逐跳数 Proxy-Authorization 代理服务器要求客户端的认证信息 Range 实体的字节范围请求 Referer 对请求中 URI 的原始获取方 TE 传输编码的优先级 User-Agent HTTP 客户端程序的信息 响应首部字段 首部字段名 说明 Accept-Ranges 是否接受字节范围请求 Age 推算资源创建经过时间 ETag 资源的匹配信息 Location 令客户端重定向至指定 URI Proxy-Authenticate 代理服务器对客户端的认证信息 Retry-After 对再次发起请求的时机要求 Server HTTP 服务器的安装信息 Vary 代理服务器缓存的管理信息 WWW-Authenticate 服务器对客户端的认证信息 实体首部字段 首部字段名 说明 Allow 资源可支持的 HTTP 方法 Content-Encoding 实体主体适用的编码方式 Content-Language 实体主体的自然语言 Content-Length 实体主体的大小 Content-Location 替代对应资源的 URI Content-MD5 实体主体的报文摘要 Content-Range 实体主体的位置范围 Content-Type 实体主体的媒体类型 Expires 实体主体过期的日期时间 Last-Modified 资源的最后修改日期时间 具体应用连接管理 1. 短连接与长连接当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问的 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。 长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。 从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 Connection : close； 在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 Connection : Keep-Alive。 2. 流水线默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。 流水线是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。 CookieHTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。 Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。 Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。 1. 用途 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息） 个性化设置（如用户自定义设置、主题等） 浏览器行为跟踪（如跟踪分析用户行为等） 2. 创建过程服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。 123456HTTP/1.0 200 OKContent-type: text/htmlSet-Cookie: yummy_cookie=chocoSet-Cookie: tasty_cookie=strawberry[page content] 客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。 123GET /sample_page.html HTTP/1.1Host: www.example.orgCookie: yummy_cookie=choco; tasty_cookie=strawberry 3. 分类 会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。 持久性 Cookie：指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。 1Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; 4. 作用域Domain 标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了 Domain，则一般包含子域名。例如，如果设置 Domain=mozilla.org，则 Cookie 也包含在子域名中（如 developer.mozilla.org）。 Path 标识指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。以字符 %x2F (“/“) 作为路径分隔符，子路径也会被匹配。例如，设置 Path=/docs，则以下地址都会匹配： /docs /docs/Web/ /docs/Web/HTTP 5. JavaScript浏览器通过 document.cookie 属性可创建新的 Cookie，也可通过该属性访问非 HttpOnly 标记的 Cookie。 123document.cookie = "yummy_cookie=choco";document.cookie = "tasty_cookie=strawberry";console.log(document.cookie); 6. HttpOnly标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。跨站脚本攻击 (XSS) 常常使用 JavaScript 的 document.cookie API 窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击。 1Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly 7. Secure标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。 8. Session除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。 Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。(比如在海量用户的大型系统中可以存在Redis) 使用 Session 维护用户登录状态的过程如下： 用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中； 服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID； 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中； 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。 应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。 9. 浏览器禁用 Cookie此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。 10. Cookie 与 Session 选择 Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session； Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密； 对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。 注意：Cookie 存储在浏览器中(本地)，Session保存到服务器； Session ID都是服务器分配给每一个访问它的浏览器的。 缓存1. 优点 缓解服务器压力； 降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存服务器在地理位置上也有可能比源服务器来得近，例如浏览器缓存。 2. 实现方法 让代理服务器进行缓存； 让客户端浏览器进行缓存。 3. Cache-ControlHTTP/1.1 通过 Cache-Control 首部字段来控制缓存。 3.1 禁止进行缓存 no-store 指令规定不能对请求或响应的任何一部分进行缓存。 1Cache-Control: no-store 3.2 强制确认缓存 no-cache 指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效时才能使用该缓存对客户端的请求进行响应。 1Cache-Control: no-cache 3.3 私有缓存和公共缓存 private 指令规定了将资源作为私有缓存，只能被单独用户使用，一般存储在用户浏览器中。 1Cache-Control: private public 指令规定了将资源作为公共缓存，可以被多个用户使用，一般存储在代理服务器中。 1Cache-Control: public 3.4 缓存过期机制 max-age 指令出现在请求报文，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。 max-age 指令出现在响应报文，表示缓存资源在缓存服务器中保存的时间。 1Cache-Control: max-age=31536000 Expires 首部字段也可以用于告知缓存服务器该资源什么时候会过期。 1Expires: Wed, 04 Jul 2012 08:26:05 GMT 在 HTTP/1.1 中，会优先处理 max-age 指令； 在 HTTP/1.0 中，max-age 指令会被忽略掉。 4. 缓存验证需要先了解 ETag 首部字段的含义，它是资源的唯一标识。URL 不能唯一表示资源，例如 http://www.google.com/ 有中文和英文两个资源，只有 ETag 才能对这两个资源进行唯一标识。 1ETag: "82e22293907ce725faf67773957acd12" 可以将缓存资源的 ETag 值放入 If-None-Match 首部，服务器收到该请求后，判断缓存资源的 ETag 值和资源的最新 ETag 值是否一致，如果一致则表示缓存资源有效，返回 304 Not Modified。 1If-None-Match: "82e22293907ce725faf67773957acd12" Last-Modified 首部字段也可以用于缓存验证，它包含在源服务器发送的响应报文中，指示源服务器对资源的最后修改时间。但是它是一种弱校验器，因为只能精确到一秒，所以它通常作为 ETag 的备用方案。如果响应首部字段里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 OK。如果请求的资源从那时起未经修改，那么返回一个不带有实体主体的 304 Not Modified 响应报文。 1Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT 1If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT 内容协商通过内容协商返回最合适的内容，例如根据浏览器的默认语言选择返回中文界面还是英文界面。 1. 类型1.1 服务端驱动型 客户端设置特定的 HTTP 首部字段，例如 Accept、Accept-Charset、Accept-Encoding、Accept-Language，服务器根据这些字段返回特定的资源。 它存在以下问题： 服务器很难知道客户端浏览器的全部信息； 客户端提供的信息相当冗长（HTTP/2 协议的首部压缩机制缓解了这个问题），并且存在隐私风险（HTTP 指纹识别技术）； 给定的资源需要返回不同的展现形式，共享缓存的效率会降低，而服务器端的实现会越来越复杂。 1.2 代理驱动型 服务器返回 300 Multiple Choices 或者 406 Not Acceptable，客户端从中选出最合适的那个资源。 2. Vary1Vary: Accept-Language 在使用内容协商的情况下，只有当缓存服务器中的缓存满足内容协商条件时，才能使用该缓存，否则应该向源服务器请求该资源。 例如，一个客户端发送了一个包含 Accept-Language 首部字段的请求之后，源服务器返回的响应包含 Vary: Accept-Language 内容，缓存服务器对这个响应进行缓存之后，在客户端下一次访问同一个 URL 资源，并且 Accept-Language 与缓存中的对应的值相同时才会返回该缓存。 内容编码内容编码将实体主体进行压缩，从而减少传输的数据量。 常用的内容编码有：gzip、compress、deflate、identity。 浏览器发送 Accept-Encoding 首部，其中包含有它所支持的压缩算法，以及各自的优先级。服务器则从中选择一种，使用该算法对响应的消息主体进行压缩，并且发送 Content-Encoding 首部来告知浏览器它选择了哪一种算法。由于该内容协商过程是基于编码类型来选择资源的展现形式的，响应报文的 Vary 首部字段至少要包含 Content-Encoding。 范围请求如果网络出现中断，服务器只发送了一部分数据，范围请求可以使得客户端只请求服务器未发送的那部分数据，从而避免服务器重新发送所有数据。 1. Range在请求报文中添加 Range 首部字段指定请求的范围。 123GET /z4d4kWk.jpg HTTP/1.1Host: i.imgur.comRange: bytes=0-1023 请求成功的话服务器返回的响应包含 206 Partial Content 状态码。 12345HTTP/1.1 206 Partial ContentContent-Range: bytes 0-1023/146515Content-Length: 1024...(binary content) 2. Accept-Ranges响应首部字段 Accept-Ranges 用于告知客户端是否能处理范围请求，可以处理使用 bytes，否则使用 none。 1Accept-Ranges: bytes 3. 响应状态码 在请求成功的情况下，服务器会返回 206 Partial Content 状态码。 在请求的范围越界的情况下，服务器会返回 416 Requested Range Not Satisfiable 状态码。 在不支持范围请求的情况下，服务器会返回 200 OK 状态码。 分块传输编码Chunked Transfer Encoding，可以把数据分割成多块，让浏览器逐步显示页面。 多部分对象集合一份报文主体内可含有多种类型的实体同时发送，每个部分之间用 boundary 字段定义的分隔符进行分隔，每个部分都可以有首部字段。 例如，上传多个表单时可以使用如下方式： 123456789101112Content-Type: multipart/form-data; boundary=AaB03x--AaB03xContent-Disposition: form-data; name="submit-name"Larry--AaB03xContent-Disposition: form-data; name="files"; filename="file1.txt"Content-Type: text/plain... contents of file1.txt ...--AaB03x-- 虚拟主机HTTP/1.1 使用虚拟主机技术，使得一台服务器拥有多个域名，并且在逻辑上可以看成多个服务器。 通信数据转发1. 代理代理服务器接受客户端的请求，并且转发给其它服务器。 使用代理的主要目的是： 缓存 负载均衡 网络访问控制 访问日志记录 代理服务器分为正向代理和反向代理两种： 用户察觉得到正向代理的存在。 而反向代理一般位于内部网络中，用户察觉不到。 2. 网关与代理服务器不同的是，网关服务器会将 HTTP 转化为其它协议进行通信，从而请求其它非 HTTP 服务器的服务。 3. 隧道使用 SSL 等加密手段，在客户端和服务器之间建立一条安全的通信线路。 加密算法加密算法可以归结为三大类：哈希算法、对称加密算法、非对称加密算法。 1.哈希算法从严格意义上来说，哈希算法并不属于加密算法，哈希算法能做什么用呢？其中一个重要的作用就是生成信息摘要，用以验证原信息的完整性和来源的可靠性。 比如下载软件安装包，通常有个MD5码作为信息完整性的验签。 哈希算法包含哪些具体的算法呢？其中最著名的当属MD5算法。后来，人们觉得MD5算法生成的信息摘要太短（128位），不够安全，于是又有了SHA系列算法。 2.对称加密算法哈希算法可以解决验签的问题，却无法解决明文加密的问题。这时候，就需要真正的加密算法出场了。 对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。 优点：运算速度快； 缺点：无法安全地将密钥传输给通信方。 不够安全具体是因为通信双方约定的密钥是相同的，只要密钥本身被任何一方泄露出去，通信的密文就会被破解；此外，在双方建立通信之初，服务端把密钥告诉给客户端的时候，也有被拦截到的危险。 在早期，人们使用DES算法进行加密解密；后来，人们觉得DES不够安全，发明了3DES算法；而如今，最为流行的对称加密算法是AES算法。 3.非对称加密算法在非对称加密中存在一对密钥，其中一个叫做公钥，另一个叫做私钥。在加密解密的过程中，我们既可以使用公钥加密明文，使用私钥解密密文；也可以使用私钥加密明文，使用公钥解密密文。 这样设计有什么好处呢？看看通信的过程就知道了： 1.在双方建立通信的时候，服务端只要把公钥告诉给客户端，自己保留私钥。 2.客户端利用获得的公钥。加密另外一个密钥X（可以是对称加密的密钥），发送给服务端。 3.服务端获得消息后，用自己的私钥解密，得到里面隐含的密钥X。 4.从此以后，双方可以利用密钥X进行对称加密的通信了。 在这个过程中，即使公钥被第三方截获，甚至后续的所有通信都被截获，第三方也无法进行破解。因为第二步利用公钥加密的消息，只有私钥才能解开，所以第三方永远无法知道密钥X是什么。 非对称加密算法的代表有哪些呢？最著名的当属RSA算法。 优点：可以更安全地将公开密钥传输给通信发送方； 缺点：运算速度慢。 HTTPSHTTP 有以下安全性问题： 使用明文进行通信，内容可能会被窃听； 不验证通信方的身份，通信方的身份有可能遭遇伪装； 无法证明报文的完整性，报文有可能遭篡改。 HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。 通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。 HTTPS 采用的加密方式HTTPS 采用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性，之后使用对称密钥加密进行通信来保证通信过程的效率。（下图中的 Session Key 就是对称密钥） 认证通过使用 证书 来对通信方进行认证。 数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。 服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。 进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。 完整性保护SSL 提供报文摘要功能来进行完整性保护。 HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。 HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。 HTTPS 的缺点 因为需要进行加密解密等过程，因此速度会更慢； 需要支付证书授权的高额费用。 HTTP/2.0HTTP/1.x 缺陷HTTP/1.x 实现简单是以牺牲性能为代价的： 客户端需要使用多个连接才能实现并发和缩短延迟； 不会压缩请求和响应首部，从而导致不必要的网络流量； 不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。 二进制分帧层HTTP/2.0 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的。 在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流（Stream）。 一个数据流（Stream）都有一个唯一标识符和可选的优先级信息，用于承载双向信息。 消息（Message）是与逻辑请求或响应对应的完整的一系列帧。 帧（Frame）是最小的通信单位，来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。 服务端推送HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。 首部压缩HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。 HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。 不仅如此，HTTP/2.0 也使用 Huffman 编码对首部字段进行压缩。 HTTP/1.1 新特性详细内容请见上文 默认是长连接 支持流水线 支持同时打开多个 TCP 连接 支持虚拟主机 新增状态码 100 支持分块传输编码 新增缓存处理指令 max-age GET 和 POST 比较作用GET 用于获取资源，而 POST 用于传输实体主体。 参数GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。 因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 中文 会转换为 %E4%B8%AD%E6%96%87，而空格会转换为 %20。POST 参数支持标准字符集。 1GET /test/demo_form.asp?name1=value1&amp;name2=value2 HTTP/1.1 123POST /test/demo_form.asp HTTP/1.1Host: w3schools.comname1=value1&amp;name2=value2 安全安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。 GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。 安全的方法除了 GET 之外还有：HEAD、OPTIONS。 不安全的方法除了 POST 之外还有 PUT、DELETE。 幂等性幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。 所有的安全方法也都是幂等的。 在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。 GET /pageX HTTP/1.1 是幂等的，连续调用多次，客户端接收到的结果都是一样的： 1234GET /pageX HTTP/1.1GET /pageX HTTP/1.1GET /pageX HTTP/1.1GET /pageX HTTP/1.1 POST /add_row HTTP/1.1 不是幂等的，如果调用多次，就会增加多行记录： 123POST /add_row HTTP/1.1 -&gt; Adds a 1nd rowPOST /add_row HTTP/1.1 -&gt; Adds a 2nd rowPOST /add_row HTTP/1.1 -&gt; Adds a 3rd row DELETE /idX/delete HTTP/1.1 是幂等的，即使不同的请求接收到的状态码不一样： 123DELETE /idX/delete HTTP/1.1 -&gt; Returns 200 if idX existsDELETE /idX/delete HTTP/1.1 -&gt; Returns 404 as it just got deletedDELETE /idX/delete HTTP/1.1 -&gt; Returns 404 可缓存如果要对响应进行缓存，需要满足以下条件： 请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。 响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。 响应报文的 Cache-Control 首部字段没有指定不进行缓存。 XMLHttpRequest为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest： XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。 在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。 而 GET 方法 Header 和 Data 会一起发送。]]></content>
      <categories>
        <category>计算机网络</category>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络-链路层]]></title>
    <url>%2F2019%2F03%2F17%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82%2F</url>
    <content type="text"><![CDATA[==数据链路层3个基本功能==封装成帧、透明传输、差错控制 1. 封装成帧将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。 2. 透明传输透明表示一个实际存在的事物看起来好像不存在一样。 数据链路层通过控制字符进行帧定界 ==若传输的数据是ASC码中“可打印字符（共95个）”集时，一切正常。若传输的数据不是仅由“可打印字符”组成时，就会出问题，如下图。== 用字节填充法解决透明传输的问题发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”（其十六进制编码是1B）。 字节填充（byte stuffing）或字符填充（（characterstuffing）——接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。 如果转义字符也出现数据当中，那么应在转义字符前插入一个转义字符。当接收端收到连续的两个转义字符时，就删除其中前面的一个。 3. 差错检测目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。 信道分类1. 点对点信道一对一通信。 因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。 2. 广播信道一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。 所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。 主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 CSMA/CD 协议。 3.组播==MAC 地址==MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。 一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。 在局域网中，硬件地址又称为物理地址，或MAC地址。 IEEE的注册管理机构RA负责向厂家分配地址字段的前三个字节（即高位24位）。 前高24位为厂家代号，低24位厂家自行指定 查看电脑的MAC地址： ipconfig /all 修改MAC地址： 打来【网络连接】-【属性】-【高级】-设定指定值 局域网局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。 主要有以太网、令牌环网、FDDI 和 ATM 等局域网技术，目前以太网占领着有线局域网市场。 可以按照网络拓扑结构对局域网进行分类： 以太网以太网是一种星型拓扑结构局域网。 早期使用集线器进行连接，集线器是一种物理层设备， 作用于比特而不是帧，当一个比特到达接口时，集线器重新生成这个比特，并将其能量强度放大，从而扩大网络的传输距离，之后再将这个比特发送到其它所有接口。如果集线器同时收到两个不同接口的帧，那么就发生了碰撞。 目前以太网使用交换机替代了集线器，交换机是一种链路层设备，它不会发生碰撞，能根据 MAC 地址进行存储转发。 以太网帧格式： 类型 ：标记上层使用的协议； 数据 ：长度在 46-1500 之间，如果太小则需要填充； FCS ：帧检验序列，使用的是 CRC 检验方法； 交换机交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。 正是由于这种自学习能力，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容。 下图中，交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中。为了发送数据帧到 B，先查交换表，此时没有主机 B 的表项，那么主机 A 就发送广播帧，主机 C 和主机 D 会丢弃该帧，主机 B 回应该帧向主机 A 发送数据包时，交换机查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 2 的映射。 虚拟局域网虚拟局域网可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到链路层广播信息。 例如下图中 (A1, A2, A3, A4) 属于一个虚拟局域网，A1 发送的广播会被 A2、A3、A4 收到，而其它站点收不到。 使用 VLAN 干线连接来建立虚拟局域网，每台交换机上的一个特殊接口被设置为干线接口，以互连 VLAN 交换机。IEEE 定义了一种扩展的以太网帧格式 802.1Q，它在标准以太网帧上加进了 4 字节首部 VLAN 标签，用于表示该帧属于哪一个虚拟局域网。 ==CSMA/CD 协议(广播信道，一般用于局域网)==CSMA/CD 表示载波监听多点接入 / 碰撞检测。 局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。 主要有以太网、令牌环网、FDDI 和 ATM 等局域网技术，目前以太网占领着有线局域网市场。 可以按照网络拓扑结构对局域网进行分类： 多点接入：随机接入，现在以太网采用 多点接入 ：说明这是总线型网络，许多主机以多点的方式连接到总线上。 载波监听 ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。 碰撞检测 ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。 记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为 争用期 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。 当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 截断二进制指数退避算法 来确定。从离散的整数集合 {0, 1, .., (2k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。 ==PPP 协议(点到点信道，一般用于广域网)==互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。 PPP 的帧格式： F 字段为帧的定界符 A 和 C 字段暂时没有意义 FCS 字段是使用 CRC 的检验序列 信息部分的长度不超过 1500]]></content>
      <categories>
        <category>计算机网络</category>
        <category>计算机网络理论</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库原理]]></title>
    <url>%2F2019%2F03%2F17%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[一、数据库常见分类与特点（1） 关系型和非关系型数据库的区别（各自优点） 数据库类型 特性 优点 缺点 关系型数据库SQLite、Oracle、mysql 1、关系型数据库，是指采用了关系模型来组织数据的数据库；2、关系型数据库的最大特点就是事务的一致性；3、简单来说，关系模型指的就是二维表格模型，而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织。 1、容易理解：二维表结构是非常贴近逻辑世界一个概念，关系模型相对网状、层次等其他模型来说更容易理解；2、使用方便：通用的SQL语言使得操作关系型数据库非常方便；3、易于维护：丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率；4、支持SQL，可用于复杂的查询。 1、为了维护一致性所付出的巨大代价就是其读写性能比较差；2、固定的表结构；3、高并发读写需求；4、海量数据的高效率读写； 非关系型数据库MongoDb、redis、HBase 1、使用键值对存储数据；2、分布式；3、一般不支持ACID特性；4、非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合。 1、无需经过sql层的解析，读写性能很高；2、基于键值对，数据没有耦合性，容易扩展；3、存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，文档形式、图片形式等等，而关系型数据库则只支持基础类型。 1、不提供sql支持，学习和使用成本较高；2、无事务处理，附加功能bi和报表等支持也不好； 注1：数据库事务必须具备ACID特性，ACID是Atomic原子性，Consistency一致性，Isolation隔离性，Durability持久性。 注2：数据的持久存储，尤其是海量数据的持久存储，还是需要一种关系数据库。 二、事务概念及ACID事务可以保证多个操作原子性，要么全成功，要么全失败。对于数据库来说事务保证批量的DML要么全成功，要么全失败。事务具有四个特征ACID a) 原子性（Atomicity） ​ 整个事务中的所有操作，必须作为一个单元全部完成（或全部取消）。 b) 一致性（Consistency） ​ 在事务开始之前与结束之后，数据库都保持一致状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。 c) 隔离性(Isolation) ​ 一个事务不会影响其他事务的运行。 d) 持久性(Durability) ​ 在事务完成以后，该事务对数据库所作的更改将持久地保存在数据库之中，并不会被回滚。 事务中存在一些概念： a) 事务（Transaction）：一批操作（一组DML） b) 开启事务（Start Transaction） c) 回滚事务（rollback） d) 提交事务（commit） e) SET AUTOCOMMIT：禁用或启用事务的自动提交模式 注意：rollback，或者commit后事务就结束了。 三、事务的隔离性• 事务的隔离级别决定了事务之间可见的级别。 一致性问题：• 当多个客户端并发地访问同一个表时，可能出现下面的一致性问题： – 脏读（Dirty Read） ​ 一个事务开始读取了某行数据，但是另外一个事务已经更新了此数据但没有能够及时提交(最终可能提交也可能回滚)，这就出现了脏读取。 – 不可重复读（Non-repeatable Read） ​ 在同一个事务中，同一个读操作对同一个数据的前后两次读取产生了不同的结果，这就是不可重复读。 例如： 在事务A中，读取到张三的工资为5000，操作没有完成，事务还没提交。与此同时，事务B把张三的工资改为8000，并提交了事务。随后，在事务A中，再次读取张三的工资，此时工资变为8000。在一个事务中前后两次读取的结果并不致，导致了不可重复读。 – 幻读（Phantom Read） ​ 幻像读是指在同一个事务中以前没有的行，由于其他事务的提交而出现的新行。 例如: 目前工资为5000的员工有10人，事务A读取所有工资为5000的人数为10人。此时，事务B插入一条工资也为5000的记录。这是，事务A再次读取工资为5000的员工，记录为11人。此时产生了幻读。 四个隔离级别：InnoDB 实现了四个隔离级别，用以控制事务所做的修改，并将修改通告至其它并发的事务： – 读未提交（READ UMCOMMITTED） ​ 允许一个事务可以看到其他事务未提交的修改。 – 读已提交（READ COMMITTED） ​ 允许一个事务只能看到其他事务已经提交的修改，未提交的修改是不可见的。 – 可重复读（REPEATABLE READ） ​ 确保如果在一个事务中执行两次相同的SELECT语句，都能得到相同的结果，不管其他事务是否提交这些修改。 （银行总账） ​ 该隔离级别为InnoDB的缺省设置。 – 串行化（SERIALIZABLE） 【序列化】 ​ 将一个事务与其他事务完全地隔离。 例:A可以开启事物,B也可以开启事物 A在事物中执行DML语句时,未提交 B不以执行DML,DQL语句 隔离级别与一致性问题的关系： 隔离级别 脏读 不可重复读 幻影读 未提交读 √ √ √ 提交读 × √ √ 可重复读 × × √ 可串行化 × × × 三、范式【1】第一范式属性(字段)不可分割。(例如某个字段存放的地址，不能单独存放地址，应该是拆分了存储。) 【2】第二范式(确保表中的每列都和主键相关)【符合第一范式，同时非主属性完全依赖于主键】 说明：表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。 订单信息表： 这样就产生一个问题：这个表中是以订单编号和商品编号作为联合主键。这样在该表中商品名称、单位、商品价格等信息不与该表的主键相关，而仅仅是与商品编号相关。所以在这里违反了第二范式的设计原则。 而如果把这个订单信息表进行拆分，把商品信息分离到另一个表中，把订单项目表也分离到另一个表中，就非常完美了。如下所示。 【3】第三范式(确保每列都和主键列直接相关,而不是间接相关)【符合2NF，并且消除传递依赖】 比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。如下面这两个表所示的设计就是一个满足第三范式的数据库表。 这样在查询订单信息的时候，就可以使用客户编号来引用客户信息表中的记录，也不必在订单信息表中多次输入客户信息的内容，减小了数据冗余。 四、锁锁粒度MySQL 中提供了两种封锁粒度：行级锁以及表级锁。 应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。 但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。 在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。 锁类型1. 读写锁 排它锁（Exclusive），简写为 X 锁，又称写锁。 共享锁（Shared），简写为 S 锁，又称读锁。 有以下两个规定： 一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。 一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。 锁的兼容关系如下： - X S X × × S × √ 2. 意向锁使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。 在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。 意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定： 一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁； 一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。 通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。 各种锁的兼容关系如下： - X IX S IS X × × × × IX × √ × √ S × × √ √ IS × √ √ √ 解释如下： 任意 IS/IX 锁之间都是兼容的，因为它们只是表示想要对表加锁，而不是真正加锁； S 锁只与 S 锁和 IS 锁兼容，也就是说事务 T 想要对数据行加 S 锁，其它事务可以已经获得对表或者表中的行的 S 锁。 锁协议1. 三级封锁协议一级封锁协议 事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。 可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。 T1 T2 lock-x(A) read A=20 lock-x(A) wait write A=19 . commit . unlock-x(A) . obtain read A=19 write A=21 commit unlock-x(A) 二级封锁协议 在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。 可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。 T1 T2 lock-x(A) read A=20 write A=19 lock-s(A) wait rollback . A=20 . unlock-x(A) . obtain read A=20 unlock-s(A) commit 三级封锁协议 在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。 可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。 T1 T2 lock-s(A) read A=20 lock-x(A) wait read A=20 . commit . unlock-s(A) . obtain read A=20 write A=19 commit unlock-X(A) 2. 两段锁协议加锁和解锁分为两个阶段进行。 可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。 事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。 1lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B) 但不是必要条件，例如以下操作不满足两段锁协议，但是它还是可串行化调度。 1lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C) MySQL 隐式与显示锁定MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。 InnoDB 也可以使用特定的语句进行显示锁定： 12SELECT ... LOCK In SHARE MODE;SELECT ... FOR UPDATE; 五、多版本并发控制多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。 版本号 系统版本号：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。 事务版本号：事务开始时的系统版本号。 隐藏的列MVCC 在每行记录后面都保存着两个隐藏的列，用来存储两个版本号： 创建版本号：指示创建一个数据行的快照时的系统版本号； 删除版本号：如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了。 Undo 日志MVCC 使用到的快照存储在 Undo 日志中，该日志通过回滚指针把一个数据行（Record）的所有快照连接起来。 实现过程以下实现过程针对可重复读隔离级别。 当开始一个事务时，该事务的版本号肯定大于当前所有数据行快照的创建版本号，理解这一点很关键。数据行快照的创建版本号是创建数据行快照时的系统版本号，系统版本号随着创建事务而递增，因此新创建一个事务时，这个事务的系统版本号比之前的系统版本号都大，也就是比所有数据行快照的创建版本号都大。 1. SELECT多个事务必须读取到同一个数据行的快照，并且这个快照是距离现在最近的一个有效快照。但是也有例外，如果有一个事务正在修改该数据行，那么它可以读取事务本身所做的修改，而不用和其它事务的读取结果一致。 把没有对一个数据行做修改的事务称为 T，T 所要读取的数据行快照的创建版本号必须小于 T 的版本号，因为如果大于或者等于 T 的版本号，那么表示该数据行快照是其它事务的最新修改，因此不能去读取它。除此之外，T 所要读取的数据行快照的删除版本号必须大于 T 的版本号，因为如果小于等于 T 的版本号，那么表示该数据行快照是已经被删除的，不应该去读取它。 2. INSERT将当前系统版本号作为数据行快照的创建版本号。 3. DELETE将当前系统版本号作为数据行快照的删除版本号。 4. UPDATE将当前系统版本号作为更新前的数据行快照的删除版本号，并将当前系统版本号作为更新后的数据行快照的创建版本号。可以理解为先执行 DELETE 后执行 INSERT。 快照读与当前读1. 快照读使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销。 1select * from table ...; 2. 当前读读取的是最新的数据，需要加锁。以下第一个语句需要加 S 锁，其它都需要加 X 锁。 12345select * from table where ? lock in share mode;select * from table where ? for update;insert;update;delete; 六、Next-Key LocksNext-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。 MVCC 不能解决幻影读问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。 Record Locks锁定一个记录上的索引，而不是记录本身。 如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。 Gap Locks锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。 1SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE; Next-Key Locks它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间： 12345(-∞, 10](10, 11](11, 13](13, 20](20, +∞) 七、关系数据库设计理论函数依赖记 A-&gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。 如果 {A1，A2，… ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。 对于 A-&gt;B，如果能找到 A 的真子集 A’，使得 A’-&gt; B，那么 A-&gt;B 就是部分函数依赖，否则就是完全函数依赖。 对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个传递函数依赖。 异常以下的学生课程关系的函数依赖为 {Sno, Cname} -&gt; {Sname, Sdept, Mname, Grade}，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。 Sno Sname Sdept Mname Cname Grade 1 学生-1 学院-1 院长-1 课程-1 90 2 学生-2 学院-2 院长-2 课程-2 80 2 学生-2 学院-2 院长-2 课程-1 100 3 学生-3 学院-2 院长-2 课程-2 95 不符合范式的关系，会产生很多异常，主要有以下四种异常： 冗余数据：例如 学生-2 出现了两次。 修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。 删除异常：删除一个信息，那么也会丢失其它信息。例如删除了 课程-1 需要删除第一行和第三行，那么 学生-1 的信息就会丢失。 插入异常：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。 八、ER 图Entity-Relationship，有三个组成部分：实体、属性、联系。 用来进行关系型数据库系统的概念设计。 实体的三种联系包含一对一，一对多，多对多三种。 如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B； 如果是一对一，画两个带箭头的线段； 如果是多对多，画两个不带箭头的线段。 下图的 Course 和 Student 是一对多的关系。 表示出现多次的关系一个实体在联系出现几次，就要用几条线连接。 下图表示一个课程的先修关系，先修关系出现两个 Course 实体，第一个是先修课程，后一个是后修课程，因此需要用两条线来表示这种关系。 联系的多向性虽然老师可以开设多门课，并且可以教授多名学生，但是对于特定的学生和课程，只有一个老师教授，这就构成了一个三元联系。 表示子类用一个三角形和两条线来连接类和子类，与子类有关的属性和联系都连到子类上，而与父类和子类都有关的连到父类上。 参考资料 AbrahamSilberschatz, HenryF.Korth, S.Sudarshan, 等. 数据库系统概念 [M]. 机械工业出版社, 2006.]]></content>
      <categories>
        <category>数据库</category>
        <category>数据库原理</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL语句]]></title>
    <url>%2F2019%2F03%2F17%2FSQL%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[●基础1.连接数据库 1mysql -uroot -p 然后输入密码 2。创建“bjpowernode”数据库 1mysql&gt; create database bjpowernode; 3.选择数据库 1mysql&gt; use bjpowernode; 4.导入数据 1mysql&gt;source D:\ bjpowernode.sql 删除数据库 1mysql&gt; drop database bjpowernode; ● 常用SQL语句（DDL,DML,DCL,TCL）数据查询语言(DQL-Data Query Language) 代表关键字:select 数据操纵语言(DML-Data Manipulation Language) 增删改，针对表的数据 代表关键字:insert,delete,update 数据定义语言(DDL-Data Definition Language) 增删改，针对表的结构 代表关键字:create ,drop,alter, 事务控制语言(TCL-Transactional Control Language) 提交，回滚 代表关键字:commit ,rollback; 数据控制语言(DCL-Data Control Language) 代表关键字:grant,revoke. ●数据定义语句(create、drop、alter)1.定义基本表 SQL 语言使用CREATETABLE语句定义基本表，其基本格式如下： 建立一个“学生信息”表Student： 2.修改基本表 随着应用环境和应用需求的变化，有时需要修改已建立好的基本表，SQL 语言用ALTER TABLE语句修改基本表，其一般格式为： 其中，&lt;表名&gt;是要修改的表，ADD子句用于增加新列和新的完整性约束条件，DROP子句用于删除指定的完整性约束条件，MODIFY COLUMN子句用于修改原有的列定义，包括修改列名和数据类型。 例1：向Student表增加“入学时间”列，其数据类型为日期型。 1ALTER TABLE Student ADD S entrance DATE； 上述代码不论基本表中原来是否已有数据，新增加的列一律为空值。 例2：要求将年龄的数据类型由字符型（假设原来的数据类型是字符型）改为整数。 1ALTER TABLE Student MODIFY COLUMN Sage INT； 例3：增加Student表Sname必须取唯一值的约束条件： 1ALTER TABLE Student ADD UNIQUE（Sname）； 3.删除基本表 当某个基本表不再需要时，可以使用DROPTABLE语句删除它。其一般格式为： 1DROP TABLE&lt;表名&gt; [RESTRICT ICASCADE]； 若选择RESTRICT，则该表的删除是有限制条件的：欲删除的基本表不能被其他表的约束所引用（如check，foreign key等约束），不能有视图，不能有触发器，不能有存储过程或函数等。如果存在这些依赖该表的对象，则此表不能被删除。 若选择CASCADE，则该表的删除没有限制条件。在删除该表的同时，相关的依赖对象，例如视图，都将被一起删除。删除Student表： 1DROP TABLE Student CASCADE； ●数据查询(select)一个完整的select语句格式如下: 123456select #字段from #表名where # …….group by #……..having #……. (就是为了过滤分组后的数据而存在的—不可以单独的出现)order by #…….. 以上语句的执行顺序 首先执行where语句过滤原始数据 执行group by进行分组 执行having对分组数据进行操作 执行select选出数据 执行order by排序 原则：能在where中过滤的数据，尽量在where中过滤，效率较高。having的过滤是专门对分组之后的数据进行过滤的。 1.简单查询 假设在表Student（1.2.1节中已定义）中，查询名为BilGates的学生信息，你可以使用下面的查询： 1SELECT*from Student WHERE Sname='Bill Gates'； 假设在表Student中，查询名字中有Bill的学生信息，你可以使用下面的查询： 1SELECT*from Student WHERE Sname like'$Bill%'； 上述%是通配符，代表任意长度（可为0）的字符串。例如a%b表示以a开头，以b结尾的任意长度的字符串。除此之外，（下画线）代表任意单词字符。 假设在表Student中查询年龄在20~23岁（包括20岁与23岁）之间的学生的信息： 1SELECT*FROM Student WHERE Sage BETWEEN 20 AND 23； 与BETWEEN…AND…相对的谓词是NOT BETWEEN·…AND…。 假设在表Student中查询计算机系（CS）、信息系（MA）和数学系（IS）学生的姓名和性别： 1SELECT Sname，Ssex FROM Student WHERE Sdept IN（'CS'，'IS'，'MA'）； 与IN相对的谓词是NOTIN，用于查找属性值不属于指定集合的元组。 假设在表Student中查询没有年龄信息的学生： 1SELECT * FROM Student WHERE Sage IS NULL； 注意这里的“IS”不能被等号代替。 2.分组函数/聚合函数/多行处理函数 count 取得记录数 sum 求和 avg 取平均 max 取最大的数 min 取最小的数 注意：分组函数自动忽略空值，不需要手动的加where**条件排除空值。** select count(*) from emp where xxx; 符合条件的所有记录总数。 select count(comm) from emp; comm**这个字段中不为空的元素总数。** 注意：分组函数不能直接使用在where关键字后面。 12mysql&gt; select ename,sal from emp where sal &gt; avg(sal);ERROR 1111 (HY000): Invalid use of group function 例1：在SQL中，用于聚集查询的函数有哪些？（2012·搜狗） 解答：count，sum，avg，max，min。 3.分组查询3.1 group by GROUP BY子句根据一个或多个属性的值来对元组进行分组，值相等的为一组。 对查询结果分组的目的是为了细化聚集函数的作用对象，分组后聚集函数将作用于每一个组，即每一组都有一个函数值，如下列语句为查询Student 表中具有相同年龄的每个组的人数： 1select Sage，count（*）from Student group by Sage； 如果使用了order by，order by必须放到group by后面 易错注意：！！！ 123456789mysql&gt; select empno,deptno,avg(sal) from emp group by deptno;+-------+--------+-------------+| empno | deptno | avg(sal) |+-------+--------+-------------+| 7782 | 10 | 2916.666667 || 7369 | 20 | 2175.000000 || 7499 | 30 | 1566.666667 |+-------+--------+-------------+ 以上SQL语句在Oracle数据库中无法执行，执行报错。 以上SQL语句在Mysql数据库中可以执行，但是执行结果矛盾。 在SQL语句中若有group by 语句，那么在select语句后面只能跟分组函数（分组函数参数不一定是参与分组的字段）+参与分组的字段。 3.2 having 如果想对分组数据再进行过滤需要使用having子句，例如： 1select Sage，count（*）from Student group by Sage having count（*）&gt;1； 4.ORDER BY子句用户可以用order by子句对查询的结果按照一个或多个属性列的升序（ASC）或降序（DESC）排列，默认值为升序。 例如在表Student中，按学生的年龄值升序检索出全部学生的信息： 1SELECT * FROM Student ORDER BY Sage； 在表Student中，先按专业升序排序，然后同一专业的学生再按年龄降序排序，并输出全部学生信息： 1SELECT * FROM Student ORDER BY Sdept，Sage desc； 5.LIMIT子句LIMIT主要是用于查询之后要显示返回的前几条或者中间某几行数据。 1SELECT * FROM table LIMIT[offset，]rows I rows OFFSET offset LIMIT子句可以被用于强制SELECT 语句返回指定的记录数。LIMIT接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。初始记录行的偏移量是0（而不是1）。如： 1SELECT * FROM Student LIMIT 5，10；//检索记录行6-15 如果只给定一个参数，它表示返回最前面的记录行数目： 1SELECT*FROM Student LIMIT 5；//检索前5个记录行 换句话说，LIMITn等价于LIMIT0，n。 例1：如下SQL语句是需要列出一个论坛版面第一页（每页显示20个）的帖子（post）标题（title），并按照发布时间（create_time）降序排列：（2012·腾讯） 1SELECT title FROM post ? create_time DESC ? 0，20； 解答：order by，limit。 6.数据处理函数/单行处理函数 Lower 转换小写 upper 转换大写 substr 取子串（substr(**被截取的字符串,起始位置（从1开始）,**截取的长度)） length 取长度 trim 去空格 str_to_date 将字符串转换成日期 date_format 格式化日期 format 设置千分位 round 四舍五入 rand() 生成随机数 Ifnull 可以将null转换成一个具体值 substr 查询姓名以M开头所有的员工 1select * from emp where substr(ename, 1, 1)=upper('m'); trim trim会去首尾空格，不会去除中间的空格 取得工作岗位为manager的所有员工 1select * from emp where job=trim(upper('manager ')); 7.连接查询连接查询：也可以叫跨表查询，需要关联多个表进行查询： 内连接： 1SELECT Student.*，SC.* FROM Student，SC WHERE Student.Sno=SC.Sno； 在以上的连接操作中，只有满足条件的元组才能作为结果输出。若表Student中某些学生没有选课，则在SC表中没有相应的元组，造成最终结果中舍弃掉了这些学生的信息。 上述连接称为自然连接、内连接。 外连接： 有时想以Student表为主体列出每个学生的基本情况及其选课情况。若某个学生没有选课，依然将其保存到结果中（在SC表的属性上填空值），这时就需要使用外连接。 1SELECT Student.*，SC.* FROM Student LEFT JOIN SC ON（Student.Sno=SC.Sno）; 以上是左外连接，左外连接列出左边表（本例为Student表）中的所有元组，右外连接列出右表关系中所有的元组。 ●数据操纵(insert,delete,update)数据操纵操作有3种：向表中添加若干行数据、修改表中的数据和删除表中的若干行数据。 1.插入元组 插入元组的INSERT语句的格式为： 12INSERT INTO tablel（fieldl，field2..） VALUES（value1，value2..）; 其功能是将新元组插入到指定表中。其中新元组的fieldl的值为valuel，field2的值为value2… 如果INTO语句中没有指定任何属性列名，则新插入的元组必须在每个属性列上均有值。 将一个新学生元组（学号：201009013；姓名：王明；性别：男；所在系：CS；年龄：23）插入到Student表中的语句为： 12INSERT INTO Student（Sno，Sname，Ssex，Sdept，Sage） VALUES（'201009013'，'王明’，‘M'，'CS'，23）； 2.修改数据 修改数据又称为更新操作，其语句的一般格式为： 123UPDATE table1 SET fieldl=valuel，field2=value2 WHERE范围； 其功能是修改指定表中满足WHERE子句条件的元组。其中SET子句给出的value值用于取代相应的属性列值。如果省略WHERE子句，则表示要修改表中的所有元组。 将学生201009013的年龄改为22岁： 123UPDATE Student SET Sage=22 WHERE Sno='201009013'； 3.删除数据 删除语句的一般格式为： 123DELETE FROM table1 WHERE范围； DELETE语句的功能是从指定表中删除满足WHERE子句条件的所有元组。如果省略 WHERE子句，表示删除表中全部元组，但表仍存在。删除学号为201009013的学生记录： 123DELETE FROM Student WHERE Sno='201009013'； ●SQL编程（触发器、游标等）●触发器应用场合（1）当向一张表中添加或删除记录时，需要在相关表中进行同步操作。比如，当一个订单产生时，订单所购的商品的库存量相应减少。（2）当表上某列数据的值与其他表中的数据有联系时。比如，当某客户进行欠款消费，可以在生成订单时通过设计触发器判断该客户的累计欠款是否超出了最大限度。（3）当需要对某张表进行跟踪时。比如，当有新订单产生时，需要及时通知相关人员进行处理；此时可以在订单表上设计添加触发器加以实现。 触发器创建语法之4要素监视地点 table 监视事件 insert/update/delete触发时间 after/before触发事件 insert/update/delete 触发器创建123456789·创建触发器的语法create trigger 触发器名称after/befor（触发时间）insert/update/delete（监视事件）on 表名（监视地址）for each row beginsql1；sqlN；end 12查看已有triggers: show triggers;删除已有triggers:drop trigger triggername; 举例： 需求：当下1个订单时，对应的商品要相应减少（买几个商品就少几个库存）商品表：goods 订单表：ord 分析：监视谁：ord 监视动作：insert 触发时间：after 触发事件：update 实例： 第一步：新建goods表、orde表，在goods表中插入数据 1234567891011121314create table goods( gid int, gname varchar(20), num smallint);create table orde( oid int, gid int, much smallint);insert into goods values(1,'cat',34),(2,'dog',65),(3,'pig',21); 12345678mysql&gt; select * from goods;+------+-------+------+| gid | gname | num |+------+-------+------+| 1 | cat | 34 || 2 | dog | 65 || 3 | pig | 21 |+------+-------+------+ 第二步：创建一个触发器后，在orde表中插入一行数据 12345create trigger t1after inserton ordefor each rowupdate goods set num = num-1 where gid=1; 1insert into orde values (1,1,5); 1234567891011121314151617mysql&gt; select * from goods;+------+-------+------+| gid | gname | num |+------+-------+------+| 1 | cat | 33 || 2 | dog | 65 || 3 | pig | 21 |+------+-------+------+3 rows in set (0.00 sec)mysql&gt; select * from orde;+------+------+------+| oid | gid | much |+------+------+------+| 1 | 1 | 5 |+------+------+------+1 row in set (0.00 sec) 可以观察到，执行插入操作后，自动执行了触发器定义的内容。 思考一：若想引用被监视的语句，怎么做？ 1234567891011121314151617181920#在插入订单操作中，new代表orde中插入的一行create trigger t_insertafter inserton ordefor each rowupdate goods set num = num-new.much where gid=new.gid;#在删除订单操作中，old代表orde中删除的一行create trigger t_deleteafter deleteon ordefor each rowupdate goods set num = num+old.much where gid=old.gid;#在修改订单操作中，old代表之前的，new代表之后create trigger t_updatebefore updateon ordefor each rowupdate goods set num = num+old.much-new.much where gid=new.gid; 插入操作 123456789101112131415161718192021mysql&gt; insert into orde values (2,2,5);Query OK, 1 row affected (0.01 sec)mysql&gt; select * from goods;+------+-------+------+| gid | gname | num |+------+-------+------+| 1 | cat | 33 || 2 | dog | 60 || 3 | pig | 21 |+------+-------+------+3 rows in set (0.00 sec)mysql&gt; select * from orde;+------+------+------+| oid | gid | much |+------+------+------+| 1 | 1 | 5 || 2 | 2 | 5 |+------+------+------+2 rows in set (0.00 sec) 删除操作 1234567891011121314151617181920mysql&gt; delete from orde where oid=2;Query OK, 1 row affected (0.01 sec)mysql&gt; select * from orde;+------+------+------+| oid | gid | much |+------+------+------+| 1 | 1 | 5 |+------+------+------+1 row in set (0.00 sec)mysql&gt; select * from goods;+------+-------+------+| gid | gname | num |+------+-------+------+| 1 | cat | 33 || 2 | dog | 65 || 3 | pig | 21 |+------+-------+------+3 rows in set (0.00 sec) 更改操作： 123456789101112131415161718192021mysql&gt; update orde set much=2 where oid=1;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; select * from orde;+------+------+------+| oid | gid | much |+------+------+------+| 1 | 1 | 2 |+------+------+------+1 row in set (0.00 sec)mysql&gt; select * from goods;+------+-------+------+| gid | gname | num |+------+-------+------+| 1 | cat | 36 || 2 | dog | 65 || 3 | pig | 21 |+------+-------+------+3 rows in set (0.00 sec) 思考二：before目前似乎没有看出和after的区别？ 再思考：如果剩余3头猪，但客户买了10头猪，发生什么情况？ 能否预防能否在购买量much&gt;库存量num时，把much自动改为num 提示：before适合 123456789101112131415delimiter $#在t2的基础上，完成much与num的判断create trigger t5after inserton orde for each row begin declare rnum int;select num into rnum from goods where gid=new.gid;if new.much &gt;rnum then set new.much=rnum; #此处更新new有问题end if; update goods set num=num-new.much where gid=new.gid;end$delimiter ; 报如下错误：ERROR 1362（HY000）：Updating of NEW row is not allowed in after trigger 原因：insert之后，new行已经插入到表中，成为事实，改new已经晚了. 123456789101112131415delimiter $#在t2的基础上，完成much与num的判断create trigger t6before inserton orde for each row begin declare rnum int;select num into rnum from goods where gid=new.gid;if new.much &gt;rnum then set new.much=rnum; #此处更新new有问题end if;update goods set num=num-new.much where gid=new.gid;end;delimiter ; 要改变new的值，用before,before适合用于这种爆仓的问题。 总结：使用before的情况下，触发器里面的命令在DML修改数据之前执行，一般需要更改要操作的数据时使用before。如果记录日志要使用after。只有使用了after才能确保DML语句成功执行，这样记录日志才有意义。 行级触发器与语句级触发器每一行受影响，触发器都执行，叫做行级触发器. 在oracle中for each row如果不写，无论update语句一次影响了多少行，都只执行1次。比如：1人下了订单，买了5件商品，insert 5次，可以用行级触发器，修改5次库存用语句级触发，insert一条发货提醒。遗憾的是—-mysq1目前不支持语句级触发器. ●存储过程—存储过程是可以编程的，—意味着可以使用变量，表达式，控制结构—来完成复杂的功能 123456789存储过程的创建语法：create procedure procedureName（）begin --sq1语句；end$查看已有的procedure show procedure status；调用存储过程call procedure(); ●引入变量—在存储过程中，用declare声明变量—格式 declare 变量名 变量类型 [default 默认值] 定义变量 12345678delimiter $create procedure p2（）begin declare age int default 90; declare height int default 175; select concat（'年龄'，age，'身高'，height）from dual;end$delimiter ; 变量运算： 123456create procedure p3（）begin declare age int default 18； set age :=age+20； select concat（'20年后年龄是'，age）；end$ ●控制流程1234567891011--p4引入表达式create procedure p4（）begin declare age tinyint unsigned default 9e; declare height tinyint unsigned default 175; if age&gt;70 then select '古稀之年' from dual; else select '风华正茂' from dual; end if;end$ 12345678910111213-p5给存储过程传参--存储过程的括号里，可以声明参数，语法是[in/out/inout]参数名参数类型本*/create procedure p5（width int，height int）begin select concat（'你的面积是'，width*height）as area; if width&gt;height then select '你挺胖'; elseif width&lt; height then select '你挺瘦'; else select '你挺方';end if;end$ 1234567891011121314151617181920212223242526272829303132--the "in"代表输入--p7求1~N的和create procedure p7(in n int)begin declare total int default 0; declare num int default e; while num&lt;n do --add num to total,adn incr the value of num set num:=num+1; set total:=total+num; end while; select total;end$--调用 call p7(100);--代表输出参数 create procedure p8(in n int,out total int)begin declare num int default e; set total:=0; while num&lt;n do set num:=num+1; set total:=total+num; end while; end$--调用 call p8(100,@sum); select sum;create procedure p9(inout age int)begin set age:=age+20; end$--调用时，set @currage = 18; call p9(@currage); select @currage … ●游标12345678910111213141516171819--在mysql cursor中，可以declare continue handler来操作1个越界标识--declare continue handler for NOT FOUND statement；create procedure p15（）begin declare row gid int； declare row_num int； declare row_name varchar（20）； declare you int default 1； declare getgoods cursor for select gid，num，name from goods； --declare continue handler for NOT FOUND set you :=0； --采用continue将多去处一行数 declare exit handler for NOT FOUND set you :=0； open getgoods； repeat fetch getgoods into row_gid，row_num，row_name； select row_num，row_name； until you=0 end repeat； close getgoods；end$ —除continue，exit外，还有一种undo handler，—continue是触发后，后面的语句继续执行—exit是触发后，后面的语句不再执行—undo是触发后，前面的语句撤消（但是，目前mysq1还不支持undo）]]></content>
      <categories>
        <category>数据库</category>
        <category>SQL语句</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>SQL语句</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode数据库题解]]></title>
    <url>%2F2019%2F03%2F17%2FLeetcode-Database%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[595. Big Countrieshttps://leetcode.com/problems/big-countries/description/ Description123456789+-----------------+------------+------------+--------------+---------------+| name | continent | area | population | gdp |+-----------------+------------+------------+--------------+---------------+| Afghanistan | Asia | 652230 | 25500100 | 20343000 || Albania | Europe | 28748 | 2831741 | 12960000 || Algeria | Africa | 2381741 | 37100000 | 188681000 || Andorra | Europe | 468 | 78115 | 3712000 || Angola | Africa | 1246700 | 20609294 | 100990000 |+-----------------+------------+------------+--------------+---------------+ 查找面积超过 3,000,000 或者人口数超过 25,000,000 的国家。 123456+--------------+-------------+--------------+| name | population | area |+--------------+-------------+--------------+| Afghanistan | 25500100 | 652230 || Algeria | 37100000 | 2381741 |+--------------+-------------+--------------+ SQL SchemaSQL Schema 用于在本地环境下创建表结构并导入数据，从而方便在本地环境解答。 1234567891011DROP TABLEIF EXISTS World;CREATE TABLE World ( NAME VARCHAR ( 255 ), continent VARCHAR ( 255 ), area INT, population INT, gdp INT );INSERT INTO World ( NAME, continent, area, population, gdp )VALUES ( 'Afghanistan', 'Asia', '652230', '25500100', '203430000' ), ( 'Albania', 'Europe', '28748', '2831741', '129600000' ), ( 'Algeria', 'Africa', '2381741', '37100000', '1886810000' ), ( 'Andorra', 'Europe', '468', '78115', '37120000' ), ( 'Angola', 'Africa', '1246700', '20609294', '1009900000' ); Solution12345678SELECT name, population, areaFROM WorldWHERE area &gt; 3000000 OR population &gt; 25000000; 627. Swap Salaryhttps://leetcode.com/problems/swap-salary/description/ Description123456| id | name | sex | salary ||----|------|-----|--------|| 1 | A | m | 2500 || 2 | B | f | 1500 || 3 | C | m | 5500 || 4 | D | f | 500 | 只用一个 SQL 查询，将 sex 字段反转。 123456| id | name | sex | salary ||----|------|-----|--------|| 1 | A | f | 2500 || 2 | B | m | 1500 || 3 | C | f | 5500 || 4 | D | m | 500 | SQL Schema12345678910DROP TABLEIF EXISTS salary;CREATE TABLE salary ( id INT, NAME VARCHAR ( 100 ), sex CHAR ( 1 ), salary INT );INSERT INTO salary ( id, NAME, sex, salary )VALUES ( '1', 'A', 'm', '2500' ), ( '2', 'B', 'f', '1500' ), ( '3', 'C', 'm', '5500' ), ( '4', 'D', 'f', '500' ); Solution使用异或操作，两个相等的数异或的结果为 0，而 0 与任何一个数异或的结果为这个数。 12&apos;f&apos; ^ &apos;m&apos; ^ &apos;f&apos; = &apos;m&apos;&apos;m&apos; ^ &apos;m&apos; ^ &apos;f&apos; = &apos;f&apos; 12UPDATE salarySET sex = CHAR ( ASCII(sex) ^ ASCII( 'm' ) ^ ASCII( 'f' ) ); 620. Not Boring Movieshttps://leetcode.com/problems/not-boring-movies/description/ Description123456789+---------+-----------+--------------+-----------+| id | movie | description | rating |+---------+-----------+--------------+-----------+| 1 | War | great 3D | 8.9 || 2 | Science | fiction | 8.5 || 3 | irish | boring | 6.2 || 4 | Ice song | Fantacy | 8.6 || 5 | House card| Interesting| 9.1 |+---------+-----------+--------------+-----------+ 查找 id 为奇数，并且 description 不是 boring 的电影，按 rating 降序。 123456+---------+-----------+--------------+-----------+| id | movie | description | rating |+---------+-----------+--------------+-----------+| 5 | House card| Interesting| 9.1 || 1 | War | great 3D | 8.9 |+---------+-----------+--------------+-----------+ SQL Schema1234567891011DROP TABLEIF EXISTS cinema;CREATE TABLE cinema ( id INT, movie VARCHAR ( 255 ), description VARCHAR ( 255 ), rating FLOAT ( 2, 1 ) );INSERT INTO cinema ( id, movie, description, rating )VALUES ( 1, 'War', 'great 3D', 8.9 ), ( 2, 'Science', 'fiction', 8.5 ), ( 3, 'irish', 'boring', 6.2 ), ( 4, 'Ice song', 'Fantacy', 8.6 ), ( 5, 'House card', 'Interesting', 9.1 ); Solution123456789SELECT *FROM cinemaWHERE id % 2 = 1 AND description != 'boring'ORDER BY rating DESC; 596. Classes More Than 5 Studentshttps://leetcode.com/problems/classes-more-than-5-students/description/ Description12345678910111213+---------+------------+| student | class |+---------+------------+| A | Math || B | English || C | Math || D | Biology || E | Math || F | Computer || G | Math || H | Math || I | Math |+---------+------------+ 查找有五名及以上 student 的 class。 12345+---------+| class |+---------+| Math |+---------+ SQL Schema123456789101112131415DROP TABLEIF EXISTS courses;CREATE TABLE courses ( student VARCHAR ( 255 ), class VARCHAR ( 255 ) );INSERT INTO courses ( student, class )VALUES ( 'A', 'Math' ), ( 'B', 'English' ), ( 'C', 'Math' ), ( 'D', 'Biology' ), ( 'E', 'Math' ), ( 'F', 'Computer' ), ( 'G', 'Math' ), ( 'H', 'Math' ), ( 'I', 'Math' ); Solution对 class 列进行分组之后，再使用 count 汇总函数统计数量，统计之后使用 having 进行过滤。 12345678SELECT classFROM coursesGROUP BY classHAVING count( DISTINCT student ) &gt;= 5; 182. Duplicate Emailshttps://leetcode.com/problems/duplicate-emails/description/ Description邮件地址表： 1234567+----+---------+| Id | Email |+----+---------+| 1 | a@b.com || 2 | c@d.com || 3 | a@b.com |+----+---------+ 查找重复的邮件地址： 12345+---------+| Email |+---------+| a@b.com |+---------+ SQL Schema123456789DROP TABLEIF EXISTS Person;CREATE TABLE Person ( Id INT, Email VARCHAR ( 255 ) );INSERT INTO Person ( Id, Email )VALUES ( 1, 'a@b.com' ), ( 2, 'c@d.com' ), ( 3, 'a@b.com' ); Solution对 Email 进行分组，如果相同 Email 的数量大于等于 2，则表示该 Email 重复。 12345678SELECT EmailFROM PersonGROUP BY EmailHAVING COUNT( * ) &gt;= 2; 196. Delete Duplicate Emailshttps://leetcode.com/problems/delete-duplicate-emails/description/ Description邮件地址表： 1234567+----+---------+| Id | Email |+----+---------+| 1 | john@example.com || 2 | bob@example.com || 3 | john@example.com |+----+---------+ 删除重复的邮件地址： 123456+----+------------------+| Id | Email |+----+------------------+| 1 | john@example.com || 2 | bob@example.com |+----+------------------+ SQL Schema与 182 相同。 Solution只保留相同 Email 中 Id 最小的那一个，然后删除其它的。 连接： 1234567DELETE p1FROM Person p1, Person p2WHERE p1.Email = p2.Email AND p1.Id &gt; p2.Id 子查询： 12345DELETEFROM PersonWHERE id NOT IN ( SELECT id FROM ( SELECT min( id ) AS id FROM Person GROUP BY email ) AS m ); 应该注意的是上述解法额外嵌套了一个 SELECT 语句，如果不这么做，会出现错误：You can’t specify target table ‘Person’ for update in FROM clause。以下演示了这种错误解法。 12345DELETEFROM PersonWHERE id NOT IN ( SELECT min( id ) AS id FROM Person GROUP BY email ); 参考：pMySQL Error 1093 - Can’t specify target table for update in FROM clause 175. Combine Two Tableshttps://leetcode.com/problems/combine-two-tables/description/ DescriptionPerson 表： 12345678+-------------+---------+| Column Name | Type |+-------------+---------+| PersonId | int || FirstName | varchar || LastName | varchar |+-------------+---------+PersonId is the primary key column for this table. Address 表： 123456789+-------------+---------+| Column Name | Type |+-------------+---------+| AddressId | int || PersonId | int || City | varchar || State | varchar |+-------------+---------+AddressId is the primary key column for this table. 查找 FirstName, LastName, City, State 数据，而不管一个用户有没有填地址信息。 SQL Schema1234567891011121314DROP TABLEIF EXISTS Person;CREATE TABLE Person ( PersonId INT, FirstName VARCHAR ( 255 ), LastName VARCHAR ( 255 ) );DROP TABLEIF EXISTS Address;CREATE TABLE Address ( AddressId INT, PersonId INT, City VARCHAR ( 255 ), State VARCHAR ( 255 ) );INSERT INTO Person ( PersonId, LastName, FirstName )VALUES ( 1, 'Wang', 'Allen' );INSERT INTO Address ( AddressId, PersonId, City, State )VALUES ( 1, 2, 'New York City', 'New York' ); Solution涉及到 Person 和 Address 两个表，在对这两个表执行连接操作时，因为要保留 Person 表中的信息，即使在 Address 表中没有关联的信息也要保留。此时可以用左外连接，将 Person 表放在 LEFT JOIN 的左边。 123456789SELECT FirstName, LastName, City, StateFROM Person P LEFT JOIN Address A ON P.PersonId = A.PersonId; 181. Employees Earning More Than Their Managershttps://leetcode.com/problems/employees-earning-more-than-their-managers/description/ DescriptionEmployee 表： 12345678+----+-------+--------+-----------+| Id | Name | Salary | ManagerId |+----+-------+--------+-----------+| 1 | Joe | 70000 | 3 || 2 | Henry | 80000 | 4 || 3 | Sam | 60000 | NULL || 4 | Max | 90000 | NULL |+----+-------+--------+-----------+ 查找薪资大于其经理薪资的员工信息。 SQL Schema12345678910DROP TABLEIF EXISTS Employee;CREATE TABLE Employee ( Id INT, NAME VARCHAR ( 255 ), Salary INT, ManagerId INT );INSERT INTO Employee ( Id, NAME, Salary, ManagerId )VALUES ( 1, 'Joe', 70000, 3 ), ( 2, 'Henry', 80000, 4 ), ( 3, 'Sam', 60000, NULL ), ( 4, 'Max', 90000, NULL ); Solution1234567SELECT E1.NAME AS EmployeeFROM Employee E1 INNER JOIN Employee E2 ON E1.ManagerId = E2.Id AND E1.Salary &gt; E2.Salary; 183. Customers Who Never Orderhttps://leetcode.com/problems/customers-who-never-order/description/ DescriptionCustomers 表： 12345678+----+-------+| Id | Name |+----+-------+| 1 | Joe || 2 | Henry || 3 | Sam || 4 | Max |+----+-------+ Orders 表： 123456+----+------------+| Id | CustomerId |+----+------------+| 1 | 3 || 2 | 1 |+----+------------+ 查找没有订单的顾客信息： 123456+-----------+| Customers |+-----------+| Henry || Max |+-----------+ SQL Schema123456789101112131415161718DROP TABLEIF EXISTS Customers;CREATE TABLE Customers ( Id INT, NAME VARCHAR ( 255 ) );DROP TABLEIF EXISTS Orders;CREATE TABLE Orders ( Id INT, CustomerId INT );INSERT INTO Customers ( Id, NAME )VALUES ( 1, 'Joe' ), ( 2, 'Henry' ), ( 3, 'Sam' ), ( 4, 'Max' );INSERT INTO Orders ( Id, CustomerId )VALUES ( 1, 3 ), ( 2, 1 ); Solution左外链接 12345678SELECT C.Name AS CustomersFROM Customers C LEFT JOIN Orders O ON C.Id = O.CustomerIdWHERE O.CustomerId IS NULL; 子查询 123456SELECT Name AS CustomersFROM CustomersWHERE Id NOT IN ( SELECT CustomerId FROM Orders ); 184. Department Highest Salaryhttps://leetcode.com/problems/department-highest-salary/description/ DescriptionEmployee 表： 12345678+----+-------+--------+--------------+| Id | Name | Salary | DepartmentId |+----+-------+--------+--------------+| 1 | Joe | 70000 | 1 || 2 | Henry | 80000 | 2 || 3 | Sam | 60000 | 2 || 4 | Max | 90000 | 1 |+----+-------+--------+--------------+ Department 表： 123456+----+----------+| Id | Name |+----+----------+| 1 | IT || 2 | Sales |+----+----------+ 查找一个 Department 中收入最高者的信息： 123456+------------+----------+--------+| Department | Employee | Salary |+------------+----------+--------+| IT | Max | 90000 || Sales | Henry | 80000 |+------------+----------+--------+ SQL Schema1234567891011121314DROP TABLE IF EXISTS Employee;CREATE TABLE Employee ( Id INT, NAME VARCHAR ( 255 ), Salary INT, DepartmentId INT );DROP TABLE IF EXISTS Department;CREATE TABLE Department ( Id INT, NAME VARCHAR ( 255 ) );INSERT INTO Employee ( Id, NAME, Salary, DepartmentId )VALUES ( 1, 'Joe', 70000, 1 ), ( 2, 'Henry', 80000, 2 ), ( 3, 'Sam', 60000, 2 ), ( 4, 'Max', 90000, 1 );INSERT INTO Department ( Id, NAME )VALUES ( 1, 'IT' ), ( 2, 'Sales' ); Solution创建一个临时表，包含了部门员工的最大薪资。可以对部门进行分组，然后使用 MAX() 汇总函数取得最大薪资。 之后使用连接找到一个部门中薪资等于临时表中最大薪资的员工。 123456789101112SELECT D.NAME Department, E.NAME Employee, E.SalaryFROM Employee E, Department D, ( SELECT DepartmentId, MAX( Salary ) Salary FROM Employee GROUP BY DepartmentId ) MWHERE E.DepartmentId = D.Id AND E.DepartmentId = M.DepartmentId AND E.Salary = M.Salary; 176. Second Highest Salaryhttps://leetcode.com/problems/second-highest-salary/description/ Description1234567+----+--------+| Id | Salary |+----+--------+| 1 | 100 || 2 | 200 || 3 | 300 |+----+--------+ 查找工资第二高的员工。 12345+---------------------+| SecondHighestSalary |+---------------------+| 200 |+---------------------+ 没有找到返回 null 而不是不返回数据。 SQL Schema123456789DROP TABLEIF EXISTS Employee;CREATE TABLE Employee ( Id INT, Salary INT );INSERT INTO Employee ( Id, Salary )VALUES ( 1, 100 ), ( 2, 200 ), ( 3, 300 ); Solution为了在没有查找到数据时返回 null，需要在查询结果外面再套一层 SELECT。 12SELECT ( SELECT DISTINCT Salary FROM Employee ORDER BY Salary DESC LIMIT 1, 1 ) SecondHighestSalary; 177. Nth Highest SalaryDescription查找工资第 N 高的员工。 SQL Schema同 176。 Solution123456CREATE FUNCTION getNthHighestSalary ( N INT ) RETURNS INT BEGINSET N = N - 1;RETURN ( SELECT ( SELECT DISTINCT Salary FROM Employee ORDER BY Salary DESC LIMIT N, 1 ) );END 178. Rank Scoreshttps://leetcode.com/problems/rank-scores/description/ Description得分表： 12345678910+----+-------+| Id | Score |+----+-------+| 1 | 3.50 || 2 | 3.65 || 3 | 4.00 || 4 | 3.85 || 5 | 4.00 || 6 | 3.65 |+----+-------+ 将得分排序，并统计排名。 12345678910+-------+------+| Score | Rank |+-------+------+| 4.00 | 1 || 4.00 | 1 || 3.85 | 2 || 3.65 | 3 || 3.65 | 3 || 3.50 | 4 |+-------+------+ SQL Schema123456789101112DROP TABLEIF EXISTS Scores;CREATE TABLE Scores ( Id INT, Score DECIMAL ( 3, 2 ) );INSERT INTO Scores ( Id, Score )VALUES ( 1, 3.5 ), ( 2, 3.65 ), ( 3, 4.0 ), ( 4, 3.85 ), ( 5, 4.0 ), ( 6, 3.65 ); Solution要统计某个 score 的排名，只要统计大于该 score 的 score 数量，然后加 1。 score 大于该 score 的 score 数量 排名 4.1 2 3 4.2 1 2 4.3 0 1 但是在本题中，相同的 score 只算一个排名： score 排名 4.1 3 4.1 3 4.2 2 4.2 2 4.3 1 4.3 1 可以按 score 进行分组，将同一个分组中的 score 只当成一个。 但是如果分组字段只有 score 的话，那么相同的 score 最后的结果只会有一个，例如上面的 6 个记录最后只取出 3 个。 score 排名 4.1 3 4.2 2 4.3 1 所以在分组中需要加入 Id，每个记录显示一个结果。综上，需要使用 score 和 id 两个分组字段。 在下面的实现中，首先将 Scores 表根据 score 字段进行自连接，得到一个新表，然后在新表上对 id 和 score 进行分组。 1234567891011SELECT S1.score 'Score', COUNT( DISTINCT S2.score ) 'Rank'FROM Scores S1 INNER JOIN Scores S2 ON S1.score &lt;= S2.scoreGROUP BY S1.id, S1.scoreORDER BY S1.score DESC; 180. Consecutive Numbershttps://leetcode.com/problems/consecutive-numbers/description/ Description数字表： 1234567891011+----+-----+| Id | Num |+----+-----+| 1 | 1 || 2 | 1 || 3 | 1 || 4 | 2 || 5 | 1 || 6 | 2 || 7 | 2 |+----+-----+ 查找连续出现三次的数字。 12345+-----------------+| ConsecutiveNums |+-----------------+| 1 |+-----------------+ SQL Schema12345678910111213DROP TABLEIF EXISTS LOGS;CREATE TABLE LOGS ( Id INT, Num INT );INSERT INTO LOGS ( Id, Num )VALUES ( 1, 1 ), ( 2, 1 ), ( 3, 1 ), ( 4, 2 ), ( 5, 1 ), ( 6, 2 ), ( 7, 2 ); Solution12345678910SELECT DISTINCT L1.num ConsecutiveNumsFROM Logs L1, Logs L2, Logs L3WHERE L1.id = l2.id - 1 AND L2.id = L3.id - 1 AND L1.num = L2.num AND l2.num = l3.num; 626. Exchange Seatshttps://leetcode.com/problems/exchange-seats/description/ Descriptionseat 表存储着座位对应的学生。 123456789+---------+---------+| id | student |+---------+---------+| 1 | Abbot || 2 | Doris || 3 | Emerson || 4 | Green || 5 | Jeames |+---------+---------+ 要求交换相邻座位的两个学生，如果最后一个座位是奇数，那么不交换这个座位上的学生。 123456789+---------+---------+| id | student |+---------+---------+| 1 | Doris || 2 | Abbot || 3 | Green || 4 | Emerson || 5 | Jeames |+---------+---------+ SQL Schema1234567891011DROP TABLEIF EXISTS seat;CREATE TABLE seat ( id INT, student VARCHAR ( 255 ) );INSERT INTO seat ( id, student )VALUES ( '1', 'Abbot' ), ( '2', 'Doris' ), ( '3', 'Emerson' ), ( '4', 'Green' ), ( '5', 'Jeames' ); Solution使用多个 union。 123456789101112131415161718192021222324252627282930# 处理偶数 id，让 id 减 1# 例如 2,4,6,... 变成 1,3,5,...SELECT s1.id - 1 AS id, s1.studentFROM seat s1WHERE s1.id MOD 2 = 0 UNION# 处理奇数 id，让 id 加 1。但是如果最大的 id 为奇数，则不做处理# 例如 1,3,5,... 变成 2,4,6,...SELECT s2.id + 1 AS id, s2.studentFROM seat s2WHERE s2.id MOD 2 = 1 AND s2.id != ( SELECT max( s3.id ) FROM seat s3 ) UNION# 如果最大的 id 为奇数，单独取出这个数SELECT s4.id AS id, s4.studentFROM seat s4WHERE s4.id MOD 2 = 1 AND s4.id = ( SELECT max( s5.id ) FROM seat s5 )ORDER BY id;]]></content>
      <categories>
        <category>数据库</category>
        <category>数据库刷题</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>数据库刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络-概述]]></title>
    <url>%2F2019%2F03%2F17%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[网络的网络网络把主机连接起来，而互联网是把多种不同的网络连接起来，因此互联网是网络的网络。 ISP互联网服务提供商 ISP 可以从互联网管理机构获得许多 IP 地址，同时拥有通信线路以及路由器等联网设备，个人或机构向 ISP 缴纳一定的费用就可以接入互联网。 目前的互联网是一种多层次 ISP 结构，ISP 根据覆盖面积的大小分为第一层 ISP、区域 ISP 和接入 ISP。互联网交换点 IXP 允许两个 ISP 直接相连而不用经过第三个 ISP。 主机之间的通信方式 客户-服务器（C/S）：客户是服务的请求方，服务器是服务的提供方。 对等（P2P）：不区分客户和服务器。 ==网络参考模型== 注意：TCP/IP 协议实际用的是4层，5层和7层一般用来教学。 OSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。TCP/IP分层（4层）：网络接口层、 网际层、运输层、 应用层。五层协议 （5层）：物理层、数据链路层、网络层、运输层、 应用层。 每一层的协议如下： 物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器） 数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机） 网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器） 传输层：TCP、UDP、SPX 会话层：NFS、SQL、NETBIOS、RPC 表示层：JPEG、MPEG、ASII 应用层：FTP、DNS、Telnet、SMTP、HTTP 物理层：激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性。该层为上层协议提供了一个传输数据的物理媒体。两个重要的设备名称，中继器（Repeater，也叫放大器）和集线器。 数据链路层 ：数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。 数据链路层为网络层提供可靠的数据传输；基本数据单位为帧；主要的协议：以太网协议；两个重要设备名称：网桥和交换机。 网络层 ：**网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能。**基本数据单位为IP数据报； 包含的主要协议：IP协议（Internet Protocol，因特网互联协议）;ICMP协议（Internet Control Message Protocol，因特网控制报文协议）;ARP协议（Address Resolution Protocol，地址解析协议）;RARP协议（Reverse Address Resolution Protocol，逆地址解析协议）。重要的设备：路由器。 传输层 ：第一个端到端，即主机到主机的层次。传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层还要处理端到端的差错控制和流量控制问题。包含的主要协议：TCP协议（Transmission Control Protocol，传输控制协议）、UDP协议（User Datagram Protocol，用户数据报协议）；重要设备：网关。 会话层 ：会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。 表示层 ：表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。 应用层 ：为操作系统或网络应用程序提供访问网络服务的接口。 会话层、表示层和应用层重点： 数据传输基本单位为报文；包含的主要协议：FTP（文件传送协议）、Telnet（远程登录协议）、DNS（域名解析协议）、SMTP（邮件传送协议），POP3协议（邮局协议），HTTP协议（Hyper Text Transfer Protocol）。 数据封装： 计算机网络性能参数【1】速率 连接在计算机网络上的主机在数字信道上传送数据位数的速率也称为 data rate或 bit rate。 单位是b/s,kbs,Mb/s,Gb/s 【2】带宽 数据通信领域中,数字信道所能传送的最高数据率，单位是b/s,kbs,Mb/s,Gb/s 【3】吞吐量(即总的速率) 即在单位时间内通过某个网络的数据量单位b/s,Mb/s。 【4】时延 【5】时延带宽积 【6】往返时间RTT 从发送方发送数据开始到发送方收到接收方确认 【7】网络利用率]]></content>
      <categories>
        <category>计算机网络</category>
        <category>计算机网络理论</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2019%2F03%2F17%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1.设计模式概述历史性著作《设计模式：可复用面向对象软件的基础》一书中描述了23种经典面向对象设计模式，创立了模式在软件设计中的地位。 什么是好的软件设计？软件设计的金科玉律：复用！变化是复用的天敌！面向对象设计最大的优势在于：抵御变化！ 重新认识面向对象>理解隔离变化·从宏观层面来看，面向对象的构建方式更能适应软件的变化，能将变化所带来的影响减为最小 &gt;各司其职·从微观层面来看，面向对象的方式更强调各个类的“责任”·由于需求变化导致的新增类型不应该影响原来类型的实现——是所谓各负其责(比如，line类draw()负责画线,rect类draw()负责画矩形..) &gt;对象是什么？ ·从语言实现层面来看，对象封装了代码和数据。 ·从规格层面讲，对象是一系列可被使用的公共接口。 ·从概念层面讲，对象是某种拥有责任的抽象。 面向对象设计原则1.依赖倒置原则（DIP） 高层模块(稳定)不应该依赖于低层模块(变化)，二者都应该依赖于抽象(稳定) 。 抽象(稳定)不应该依赖于实现细节(变化) ，实现细节应该依赖于抽象(稳定)。 上面第二种方式隔离了变化。 2.开放封闭原则（OCP） 对扩展开放，对更改封闭。 类模块应该是可扩展的，但是不可修改。 3单一职责原则（SRP） 一个类应该仅有一个引起它变化的原因。 变化的方向隐含着类的责任。 4.Liskov 替换原则（LSP） 子类必须能够替换它们的基类(IS-A)。 继承表达类型抽象。 5.接口隔离原则（ISP） 不应该强迫客户程序依赖它们不用的方法。 接口应该小而完备。 6.优先使用对象组合，而不是类继承 类继承通常为“白箱复用”，对象组合通常为“黑箱复用” 。 继承在某种程度上破坏了封装性，子类父类耦合度高。 而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。 7.封装变化点 使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。 8.针对接口编程，而不是针对实现编程 不将变量类型声明为某个特定的具体类，而是声明为某个接口。 客户程序无需获知对象的具体类型，只需要知道对象所具有的接口。 减少系统中各部分的依赖关系，从而实现“高内聚、松耦合”的类型设计方案。 从封装变化角度对模式分类组件协作： Template Method（模板模式） Observer/Event（观察者模式） Strategy（策略模式） 单一职责： Decorator（装饰模式） Bridge（桥模式） 对象创建: Factory Method（工厂模式） Abstract Factory（抽象工厂） Prototype（原型模式） Builder（构建器） 对象性能： Singleton（单例模式） Flyweight(享元模式) 接口隔离: Façade(门面模式) Proxy（代理模式） Mediator(中介者) Adapter（适配器） 状态变化： Memento(中介者模式) State（状态模式） 数据结构： Composite(组合模式) Iterator（迭代器） Chain of Resposibility(职责链) 行为变化： Command（命令模式） Visitor（访问器） 领域问题： Interpreter（解析器） 总结 现代较少用的模式 Builder Mediator Memento Iterator Chain of Resposibility Command Visitor Interpreter 重构关键技法>静态 &gt; 动态 >早绑定 &gt; 晚绑定 >继承 &gt; 组合 >编译时依赖 &gt; 运行时依赖 >紧耦合 &gt; 松耦合 2.Template Method（模板模式）动机（Motivation）在软件构建过程中，对于某一项任务，它常常有稳定的整体操作结构，但各个子步骤却有很多改变的需求，或者由于固有的原因（比如框架与应用之间的关系）而无法 和任务的整体结构同时实现。 如何在确定稳定操作结构的前提下，来灵活应对各个子步骤的变化或者晚期实现需求？ 例如如下的结构化设计流程： template1_lib.cpp 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;//程序库开发人员class Library&#123;public: void Step1() //稳定 &#123; cout &lt;&lt; "Step1" &lt;&lt; endl; &#125; void Step3() //稳定 &#123; cout &lt;&lt; "Step3" &lt;&lt; endl; &#125; void Step5() //稳定 &#123; cout &lt;&lt; "Step5" &lt;&lt; endl; &#125;&#125;; template1_app.cpp 1234567891011121314151617181920212223242526272829303132333435#include "template1_lib.cpp"//应用程序开发人员class Application&#123; public: bool Step2() //变化 &#123; cout &lt;&lt; "myStep2" &lt;&lt; endl; return true; &#125; void Step4() //变化 &#123; cout &lt;&lt; "myStep4" &lt;&lt; endl; &#125;&#125;;int main()&#123; Library lib; Application app; ////////////写程序主流程start/////////////////// lib.Step1(); if (app.Step2()) &#123; lib.Step3(); &#125; for (int i = 0; i &lt; 4; i++) &#123; app.Step4(); &#125; lib.Step5(); ////////////写程序主流程end/////////////////// return 0;&#125; template2_lib.cpp 12]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL]]></title>
    <url>%2F2019%2F03%2F15%2FMySQL%2F</url>
    <content type="text"><![CDATA[MySql常用数据类型 类型 描述 Char(长度) 定长字符串，存储空间大小固定，适合作为主键或外键 Varchar(长度) 变长字符串，存储空间等于实际数据空间 double(有效数字位数，小数位) 数值型 Float(有效数字位数，小数位) 数值型 Int(长度) 整型 bigint(长度) 长整型 Date 日期型 BLOB Binary Large OBject（二进制大对象） CLOB Character Large OBject（字符大对象） 其它………………… 一条SQL查询语句是如何执行的？ 第二步：查询缓存；MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式。但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。（因为只要表做了更新，查询缓存就会清空，对更新频繁的数据库来说，查询缓存命中率低。因此查询缓存适合业务是静态表，或者很长时间才更新） 需要注意的是，MySQL 8.0 版本直接将查询缓存的整块功能删掉了，也就是说 8.0 开始彻底没有这个功能了。 优化器：优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。 一条SQL更新语句是如何执行的？例如执行以下更新语句： 1mysql&gt; update T set c=c+1 where ID=2; 与查询语句的不同：（1）在一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会把表 T 上所有缓存结果都清空。这也就是我们一般不建议使用查询缓存的原因； （2）更新流程还涉及两个重要的日志模块，它们正是我们今天要讨论的主角：redo log（重做日志）和 binlog（归档日志）。 存储引擎MyISAM、InnoDB、MEMORYMyISAM:它不支持事务，也不支持外键，尤其是访问速度快，对事务完整性没有要求或者以SELECT、INSERT为主的应用基本都可以使用这个引擎来创建表。 InnoDB:InnoDB是一个健壮的事务型存储引擎,他引入了行级锁和外键约束。一般来说，如果需要事务支持，并且有较高的并发读取频率，InnoDB是不错的选择。 MEMORY：使用MySQL Memory存储引擎的出发点是速度。为得到最快的响应时间，采用的逻辑存储介质是系统内存。 一般在以下几种情况下使用Memory存储引擎：1.目标数据较小，而且被非常频繁地访问。2.如果数据是临时的，而且要求必须立即可用，那么就可以存放在内存表中。3.存储在Memory表中的数据如果突然丢失，不会对应用服务产生实质的负面影响。 查询性能优化使用 Explain 进行分析Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。 比较重要的字段有： select_type : 查询类型，有简单查询、联合查询、子查询等 key : 使用的索引 rows : 扫描的行数 优化数据访问1. 减少请求的数据量 只返回必要的列：最好不要使用 SELECT * 语句。 只返回必要的行：使用 LIMIT 语句来限制返回的数据。 缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。 2. 减少服务器端扫描的行数最有效的方式是使用索引来覆盖查询。 重构查询方式1. 切分大查询一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。 1DELETE FROM messages WHERE create &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH); 12345rows_affected = 0do &#123; rows_affected = do_query( "DELETE FROM messages WHERE create &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000")&#125; while rows_affected &gt; 0 2. 分解大连接查询将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有： 让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。 分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。 减少锁竞争； 在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。 查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。 1234SELECT * FROM tabJOIN tag_post ON tag_post.tag_id=tag.idJOIN post ON tag_post.post_id=post.idWHERE tag.tag='mysql'; 123SELECT * FROM tag WHERE tag='mysql';SELECT * FROM tag_post WHERE tag_id=1234;SELECT * FROM post WHERE post.id IN (123,456,567,9098,8904); 切分水平切分水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。 当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。 垂直切分垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。 在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。 Sharding 策略 哈希取模：hash(key) % N； 范围：可以是 ID 范围也可以是时间范围； 映射表：使用单独的一个数据库来存储映射关系。 Sharding 存在的问题1. 事务问题使用分布式事务来解决，比如 XA 接口。 2. 连接可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接。 3. ID 唯一性 使用全局唯一 ID（GUID） 为每个分片指定一个 ID 范围 分布式 ID 生成器 (如 Twitter 的 Snowflake 算法) 复制主从复制主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。 binlog 线程 ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。 I/O 线程 ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。 SQL 线程 ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。 读写分离主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。 读写分离能提高性能的原因在于： 主从服务器负责各自的读和写，极大程度缓解了锁的争用； 从服务器可以使用 MyISAM，提升查询性能以及节约系统开销； 增加冗余，提高可用性。 读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。 锁按锁的粒度分类：Mysql为了解决并发、数据安全的问题，使用了锁机制。 可以按照锁的粒度把数据库锁分为表级锁和行级锁。 表级锁 Mysql中锁定 粒度最大 的一种锁，对当前操作的整张表加锁，实现简单 ，资源消耗也比较少，加锁快，不会出现死锁 。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。 行级锁 Mysql中锁定 粒度最小 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。 InnoDB支持的行级锁，包括如下几种。 Record Lock: 对索引项加锁，锁定符合条件的行。其他事务不能修改和删除加锁项；Gap Lock: 对索引项之间的“间隙”加锁，锁定记录的范围（对第一条记录前的间隙或最后一条将记录后的间隙加锁），不包含索引项本身。其他事务不能在锁范围内插入数据，这样就防止了别的事务新增幻影行。Next-key Lock： 锁定索引项本身和索引范围。即Record Lock和Gap Lock的结合。可解决幻读问题。 虽然使用行级索具有粒度小、并发度高等特点，但是表级锁有时候也是非常必要的： 事务更新大表中的大部分数据直接使用表级锁效率更高； 事务比较复杂，使用行级索很可能引起死锁导致回滚。 按锁的操作类型分类：a.读锁（共享锁）：对同一个数据（衣服），多个读操作可以同时进行，互不干扰。 b.写锁（互斥锁）：如果当前写操作没有完毕（买衣服的一系列操作），则无法进行其他的读操作； 12345678910create table tablelock(id int primary key auto_increment, name varchar(20)) engine myisam; insert into tablelock(name)values('al');insert into tablelock(name)values('a2');insert into tablelock(name)values('a3');insert into tablelock(name)values('a4');insert into tablelock(name)values('a5'); commit; 增加锁的语法：lock table 表1 read/write，表2 read/write，.…查看加锁的表：show open tables； 表锁介绍：加读锁实验： 会话：session：每一个访问数据的dos命令行、数据库客户端工具都是一个会话加读锁： 会话0： 123456lock table tablelock read；select * from tablelock；--读（查），可以delete from tablelock where id=1；--写（增删改），不可以select * from emp；--读，不可以delete from tablelock where eno=1；--写，不可以 总结：如果给A表加了读锁，则当前会话只能对A表进行读操作，对其他表也不能进行读写操作。 会话1（其他会话）： 1234select * from tablelock；--读（查），可以delete from tablelock where id =1；-写，会“等待”会话0将锁释放select*from emp；-—读（查），可以delete from emp where eno=1；--写，可以 总结：会话0给A表加了锁；其他会话的操作： a.可以对其他表（A表以外的表）进行读、写操作 b.对A表：读-可以；写-需要等待释放锁。 释放锁的语句：unlock tables; 加写锁实验：会话0：lock table tablelock write； 当前会话（会话0）可以对加了写锁的表进行任何操作（增删改查）：但是不能操作其他表。 会话1（其他会话）： 对会话0中加写锁的表可以进行增删改查的前提是：等待会话0释放写锁 MySQL表级锁的锁模式MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁， 在执行更新操作（DML）前，会自动给涉及的表加写锁。 所以对MyISAM表进行操作，会有以下情况：a、对MyISAM表的读操作（加读锁），不会阻塞其他进程（会话）对同一表的读请求，但会阻塞对同一表的写请求。只有当读锁释放后，才会执行其它进程的写操作。b、对MyISAM表的写操作（加写锁），会阻塞其他进程（会话）对同一表的读和写操作，只有当写锁释放后，才会执行其它进程的读写操作。 分析表锁定：查看哪些表加了锁：show open tables；1代表被加了锁分析表锁定的严重程度：show status like ‘table%’； Table locks immediate：即可能获取到的锁数Tablelocks waited：需要等待的表锁数（如果该值越大，说明存在越大的锁竞争） 一般建议：Tablelocks immediate/Table locks waited&gt;5000，建议采用InnoDB引擎，否则MyISAM引擎 行锁介绍：1234567891011create table linelock( id int(5) primary key auto_increment, name varchar(20))engine=innodb; insert into linelock(name)values'1');insert into linelock(name)values('2');insert into linelock(name)values('3');insert into linelock(name)values('4');insert into linelock(name)values('5'); --对于插入语句mysq1默认自动commit；oracle默认不会自动commit--为了研究行锁，暂时将自动commit关闭；set autocommt=0；以后需要通过commit 行锁，分析操作同一条数据：（有影响） 会话0：写操作insert into linelock values（’a6’）； 会话1：写操作同样的数据update linelock set name=’ax’ where id=6； 对行锁情况：1.如果会话x对某条数据a进行DML(增删改)操作（研究时：关闭了自动commit的情况下），则其他会话必须等待（会产生阻塞）会话x结束事务（commit/ro1lback）后才能对数据a进行操作。2.表锁是通过unlock tables，也可以通过事务解锁；行锁是通过事务解锁。 行锁，操作不同数据（无影响）：会话0：写操作insert into linelock walues（8，’a8’）； 会话1：写操作，不同的数据 update linelock set name=’ax’ where id=5； 行锁，一次锁一行数据；因此如果操作的是不同数据，则不干扰。 行锁的注意事项：【1】如果没有索引，则行锁会转为表锁show index from linelock； alter table linelock add index idx_linelock_name（name）； —将name新增为一个索引 会话0：写操作 ​ update linelock set name=’ai’where name=’3’； 会话1：写操作，不同的数据 update linelock set name=’aiX’where name=’4’； 以上可以正常操作 会话0：写操作 update linelock set name=’ai’where name=3； 会话1：写操作，不同的数据 update linelock set name=’aiX’where name=4；—可以发现，数据被阻塞了（加锁）—原因：如果索引类发生了类型转换，则索引失效。因此此次操作，会从行锁转为表锁。 注意：如果使用针对InnoDB的表使用行锁，被锁定字段不是主键，也没有针对它建立索引的话。行锁锁定的也是整张表。锁整张表会造成程序的执行效率会很低。 补充：当你创建或设置主键的时候，mysql会自动添加一个与主键对应的唯一索引，不需要再做额外的添加。 【2】行锁的一种特殊情况：间隙锁： 值在范围内，但却不存在—此时linelock表中没有id=7的数据 update linelock set name =’x’where id&gt;1 and id&lt;9；—即在此where范围中，没有id=7的数间隙：Mysq1会自动给间隙加索-〉间隙锁。即本题会自动给id=7的数据加间隙锁（行锁）。 行锁：如果有where，则实际加索的范围就是where后面的范围（不是实际的值） InnoDB默认采用行锁； 缺点：比表锁性能损耗大。 优点：并发能力强，效率高。因此建议，高并发用InnoDB，否则用MyISAM。 行锁分析：show status like ‘%innodb_row_lock%’Innodb row_lock_current_waits：当前正在等待锁的数量 Innodb row_lock_time：等待总时长。从系统启到现在一共等待的时间 Innodb row lock time avg：平均等待时长。从系统启到现在平均等待的时间 Innodb row locktime max：最大等待时长。从系统启到现在最大一次等待的时间Innodb_row_lock_waits：等待次数。从系统启到现在一共等待的次数 如果仅仅是查询数据，能否加锁？ 可以for update研究学习时，将自动提交关闭： 手动开启事务的三种方式： 123set autocommit=0；start transaction；begin； 1select*from linelock where id=2 for update；--通过for update对queFy语句进行加锁。 参考资料 BaronScbwartz, PeterZaitsev, VadimTkacbenko, 等. 高性能 MySQL[M]. 电子工业出版社, 2013. 一条SQL语句在MySQL中如何执行的一条SQL语句在MySQL中如何执行的 一条SQL语句执行得很慢的原因有哪些？腾讯面试：一条SQL语句执行得很慢的原因有哪些？—-不看后悔系列]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis]]></title>
    <url>%2F2019%2F03%2F15%2FRedis%2F</url>
    <content type="text"><![CDATA[一、概述Redis 是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和五种不同类型的值之间的映射。 键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。 Redis 支持很多特性，例如将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片来扩展写性能。 二、数据类型 数据类型 可以存储的值 操作 STRING 字符串、整数或者浮点数 对整个字符串或者字符串的其中一部分执行操作&lt;/br&gt; 对整数和浮点数执行自增或者自减操作 LIST 列表 从两端压入或者弹出元素 &lt;/br&gt; 对单个或者多个元素进行修剪，&lt;/br&gt; 只保留一个范围内的元素 SET 无序集合 添加、获取、移除单个元素&lt;/br&gt; 检查一个元素是否存在于集合中&lt;/br&gt; 计算交集、并集、差集&lt;/br&gt; 从集合里面随机获取元素 HASH 包含键值对的无序散列表 添加、获取、移除单个键值对&lt;/br&gt; 获取所有键值对&lt;/br&gt; 检查某个键是否存在 ZSET 有序集合 添加、获取、删除元素&lt;/br&gt; 根据分值范围或者成员来获取元素&lt;/br&gt; 计算一个键的排名 What Redis data structures look like STRING 12345678&gt; set hello worldOK&gt; get hello"world"&gt; del hello(integer) 1&gt; get hello(nil) LIST 123456789101112131415161718192021&gt; rpush list-key item(integer) 1&gt; rpush list-key item2(integer) 2&gt; rpush list-key item(integer) 3&gt; lrange list-key 0 -11) "item"2) "item2"3) "item"&gt; lindex list-key 1"item2"&gt; lpop list-key"item"&gt; lrange list-key 0 -11) "item2"2) "item" SET 123456789101112131415161718192021222324252627&gt; sadd set-key item(integer) 1&gt; sadd set-key item2(integer) 1&gt; sadd set-key item3(integer) 1&gt; sadd set-key item(integer) 0&gt; smembers set-key1) "item"2) "item2"3) "item3"&gt; sismember set-key item4(integer) 0&gt; sismember set-key item(integer) 1&gt; srem set-key item2(integer) 1&gt; srem set-key item2(integer) 0&gt; smembers set-key1) "item"2) "item3" HASH 123456789101112131415161718192021222324&gt; hset hash-key sub-key1 value1(integer) 1&gt; hset hash-key sub-key2 value2(integer) 1&gt; hset hash-key sub-key1 value1(integer) 0&gt; hgetall hash-key1) "sub-key1"2) "value1"3) "sub-key2"4) "value2"&gt; hdel hash-key sub-key2(integer) 1&gt; hdel hash-key sub-key2(integer) 0&gt; hget hash-key sub-key1"value1"&gt; hgetall hash-key1) "sub-key1"2) "value1" ZSET 12345678910111213141516171819202122232425&gt; zadd zset-key 728 member1(integer) 1&gt; zadd zset-key 982 member0(integer) 1&gt; zadd zset-key 982 member0(integer) 0&gt; zrange zset-key 0 -1 withscores1) "member1"2) "728"3) "member0"4) "982"&gt; zrangebyscore zset-key 0 800 withscores1) "member1"2) "728"&gt; zrem zset-key member1(integer) 1&gt; zrem zset-key member1(integer) 0&gt; zrange zset-key 0 -1 withscores1) "member0"2) "982" 三、数据结构字典dictht 是一个散列表结构，使用拉链法解决哈希冲突。 12345678/* This is our hash table structure. Every dictionary has two of this as we * implement incremental rehashing, for the old to the new table. */typedef struct dictht &#123; dictEntry **table; unsigned long size; unsigned long sizemask; unsigned long used;&#125; dictht; 12345678910typedef struct dictEntry &#123; void *key; union &#123; void *val; uint64_t u64; int64_t s64; double d; &#125; v; struct dictEntry *next;&#125; dictEntry; Redis 的字典 dict 中包含两个哈希表 dictht，这是为了方便进行 rehash 操作。在扩容时，将其中一个 dictht 上的键值对 rehash 到另一个 dictht 上面，完成之后释放空间并交换两个 dictht 的角色。 1234567typedef struct dict &#123; dictType *type; void *privdata; dictht ht[2]; long rehashidx; /* rehashing not in progress if rehashidx == -1 */ unsigned long iterators; /* number of iterators currently running */&#125; dict; rehash 操作不是一次性完成，而是采用渐进方式，这是为了避免一次性执行过多的 rehash 操作给服务器带来过大的负担。 渐进式 rehash 通过记录 dict 的 rehashidx 完成，它从 0 开始，然后每执行一次 rehash 都会递增。例如在一次 rehash 中，要把 dict[0] rehash 到 dict[1]，这一次会把 dict[0] 上 table[rehashidx] 的键值对 rehash 到 dict[1] 上，dict[0] 的 table[rehashidx] 指向 null，并令 rehashidx++。 在 rehash 期间，每次对字典执行添加、删除、查找或者更新操作时，都会执行一次渐进式 rehash。 采用渐进式 rehash 会导致字典中的数据分散在两个 dictht 上，因此对字典的查找操作也需要到对应的 dictht 去执行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* Performs N steps of incremental rehashing. Returns 1 if there are still * keys to move from the old to the new hash table, otherwise 0 is returned. * * Note that a rehashing step consists in moving a bucket (that may have more * than one key as we use chaining) from the old to the new hash table, however * since part of the hash table may be composed of empty spaces, it is not * guaranteed that this function will rehash even a single bucket, since it * will visit at max N*10 empty buckets in total, otherwise the amount of * work it does would be unbound and the function may block for a long time. */int dictRehash(dict *d, int n) &#123; int empty_visits = n * 10; /* Max number of empty buckets to visit. */ if (!dictIsRehashing(d)) return 0; while (n-- &amp;&amp; d-&gt;ht[0].used != 0) &#123; dictEntry *de, *nextde; /* Note that rehashidx can't overflow as we are sure there are more * elements because ht[0].used != 0 */ assert(d-&gt;ht[0].size &gt; (unsigned long) d-&gt;rehashidx); while (d-&gt;ht[0].table[d-&gt;rehashidx] == NULL) &#123; d-&gt;rehashidx++; if (--empty_visits == 0) return 1; &#125; de = d-&gt;ht[0].table[d-&gt;rehashidx]; /* Move all the keys in this bucket from the old to the new hash HT */ while (de) &#123; uint64_t h; nextde = de-&gt;next; /* Get the index in the new hash table */ h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[1].sizemask; de-&gt;next = d-&gt;ht[1].table[h]; d-&gt;ht[1].table[h] = de; d-&gt;ht[0].used--; d-&gt;ht[1].used++; de = nextde; &#125; d-&gt;ht[0].table[d-&gt;rehashidx] = NULL; d-&gt;rehashidx++; &#125; /* Check if we already rehashed the whole table... */ if (d-&gt;ht[0].used == 0) &#123; zfree(d-&gt;ht[0].table); d-&gt;ht[0] = d-&gt;ht[1]; _dictReset(&amp;d-&gt;ht[1]); d-&gt;rehashidx = -1; return 0; &#125; /* More to rehash... */ return 1;&#125; 跳跃表是有序集合的底层实现之一。 跳跃表是基于多指针有序链表实现的，可以看成多个有序链表。 在查找时，从上层指针开始查找，找到对应的区间之后再到下一层去查找。下图演示了查找 22 的过程。 与红黑树等平衡树相比，跳跃表具有以下优点： 插入速度非常快速，因为不需要进行旋转等操作来维护平衡性； 更容易实现； 支持无锁操作。 四、使用场景计数器可以对 String 进行自增自减运算，从而实现计数器功能。 Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。 缓存将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。 查找表例如 DNS 记录就很适合使用 Redis 进行存储。 查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。 消息队列List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息 不过最好使用 Kafka、RabbitMQ 等消息中间件。 会话缓存可以使用 Redis 来统一存储多台应用服务器的会话信息。 当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。 分布式锁实现在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。 可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。 其它Set 可以实现交集、并集等操作，从而实现共同好友等功能。 ZSet 可以实现有序性操作，从而实现排行榜等功能。 五、Redis 与 Memcached两者都是非关系型内存键值数据库，主要有以下不同： 数据类型Memcached 仅支持字符串类型，而 Redis 支持五种不同的数据类型，可以更灵活地解决问题。 数据持久化Redis 支持两种持久化策略：RDB 快照和 AOF 日志，而 Memcached 不支持持久化。 分布式Memcached 不支持分布式，只能通过在客户端使用一致性哈希来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。 Redis Cluster 实现了分布式的支持。 内存管理机制 在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘，而 Memcached 的数据则会一直在内存中。 Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。 六、键的过期时间Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键。 对于散列表这种容器，只能为整个键设置过期时间（整个散列表），而不能为键里面的单个元素设置过期时间。 七、数据淘汰策略可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。 Redis 具体有 6 种淘汰策略： 策略 描述 volatile-lru 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰 volatile-ttl 从已设置过期时间的数据集中挑选将要过期的数据淘汰 volatile-random 从已设置过期时间的数据集中任意选择数据淘汰 allkeys-lru 从所有数据集中挑选最近最少使用的数据淘汰 allkeys-random 从所有数据集中任意选择数据进行淘汰 noeviction 禁止驱逐数据 作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 key，而是抽样一小部分并且从中选出被淘汰的 key。 使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。 Redis 4.0 引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰。 八、持久化Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。 RDB 持久化将某个时间点的所有数据都存放到硬盘上。 可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。 如果系统发生故障，将会丢失最后一次创建快照之后的数据。 如果数据量很大，保存快照的时间会很长。 AOF 持久化将写命令添加到 AOF 文件（Append Only File）的末尾。 使用 AOF 持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。有以下同步选项： 选项 同步频率 always 每个写命令都同步 everysec 每秒同步一次 no 让操作系统来决定何时同步 always 选项会严重减低服务器的性能； everysec 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响； no 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量。 随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。 九、事务一个事务包含了多个命令，服务器在执行事务期间，不会改去执行其它客户端的命令请求。 事务中的多个命令被一次性发送给服务器，而不是一条一条发送，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。 Redis 最简单的事务实现方式是使用 MULTI 和 EXEC 命令将事务操作包围起来。 十、事件Redis 服务器是一个事件驱动程序。 文件事件服务器通过套接字与客户端或者其它服务器进行通信，文件事件就是对套接字操作的抽象。 Redis 基于 Reactor 模式开发了自己的网络事件处理器，使用 I/O 多路复用程序来同时监听多个套接字，并将到达的事件传送给文件事件分派器，分派器会根据套接字产生的事件类型调用相应的事件处理器。 时间事件服务器有一些操作需要在给定的时间点执行，时间事件是对这类定时操作的抽象。 时间事件又分为： 定时事件：是让一段程序在指定的时间之内执行一次； 周期性事件：是让一段程序每隔指定时间就执行一次。 Redis 将所有时间事件都放在一个无序链表中，通过遍历整个链表查找出已到达的时间事件，并调用相应的事件处理器。 事件的调度与执行服务器需要不断监听文件事件的套接字才能得到待处理的文件事件，但是不能一直监听，否则时间事件无法在规定的时间内执行，因此监听时间应该根据距离现在最近的时间事件来决定。 事件调度与执行由 aeProcessEvents 函数负责，伪代码如下： 12345678910111213141516def aeProcessEvents(): # 获取到达时间离当前时间最接近的时间事件 time_event = aeSearchNearestTimer() # 计算最接近的时间事件距离到达还有多少毫秒 remaind_ms = time_event.when - unix_ts_now() # 如果事件已到达，那么 remaind_ms 的值可能为负数，将它设为 0 if remaind_ms &lt; 0: remaind_ms = 0 # 根据 remaind_ms 的值，创建 timeval timeval = create_timeval_with_ms(remaind_ms) # 阻塞并等待文件事件产生，最大阻塞时间由传入的 timeval 决定 aeApiPoll(timeval) # 处理所有已产生的文件事件 procesFileEvents() # 处理所有已到达的时间事件 processTimeEvents() 将 aeProcessEvents 函数置于一个循环里面，加上初始化和清理函数，就构成了 Redis 服务器的主函数，伪代码如下： 12345678def main(): # 初始化服务器 init_server() # 一直处理事件，直到服务器关闭为止 while server_is_not_shutdown(): aeProcessEvents() # 服务器关闭，执行清理操作 clean_server() 从事件处理的角度来看，服务器运行流程如下： 十一、复制通过使用 slaveof host port 命令来让一个服务器成为另一个服务器的从服务器。 一个从服务器只能有一个主服务器，并且不支持主主复制。 连接过程 主服务器创建快照文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始向从服务器发送存储在缓冲区中的写命令； 从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令； 主服务器每执行一次写命令，就向从服务器发送相同的写命令。 主从链随着负载不断上升，主服务器可能无法很快地更新所有从服务器，或者重新连接和重新同步从服务器将导致系统超载。为了解决这个问题，可以创建一个中间层来分担主服务器的复制工作。中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器。 十二、SentinelSentinel（哨兵）可以监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。 十三、分片分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面，这种方法在解决某些问题时可以获得线性级别的性能提升。 假设有 4 个 Redis 实例 R0，R1，R2，R3，还有很多表示用户的键 user:1，user:2，… ，有不同的方式来选择一个指定的键存储在哪个实例中。 最简单的方式是范围分片，例如用户 id 从 0~1000 的存储到实例 R0 中，用户 id 从 1001~2000 的存储到实例 R1 中，等等。但是这样需要维护一张映射范围表，维护操作代价很高。 还有一种方式是哈希分片，使用 CRC32 哈希函数将键转换为一个数字，再对实例数量求模就能知道应该存储的实例。 根据执行分片的位置，可以分为三种分片方式： 客户端分片：客户端使用一致性哈希等算法决定键应当分布到哪个节点。 代理分片：将客户端请求发送到代理上，由代理转发请求到正确的节点上。 服务器分片：Redis Cluster。 十四、一个简单的论坛系统分析该论坛系统功能如下： 可以发布文章； 可以对文章进行点赞； 在首页可以按文章的发布时间或者文章的点赞数进行排序显示。 文章信息文章包括标题、作者、赞数等信息，在关系型数据库中很容易构建一张表来存储这些信息，在 Redis 中可以使用 HASH 来存储每种信息以及其对应的值的映射。 Redis 没有关系型数据库中的表这一概念来将同种类型的数据存放在一起，而是使用命名空间的方式来实现这一功能。键名的前面部分存储命名空间，后面部分的内容存储 ID，通常使用 : 来进行分隔。例如下面的 HASH 的键名为 article:92617，其中 article 为命名空间，ID 为 92617。 点赞功能当有用户为一篇文章点赞时，除了要对该文章的 votes 字段进行加 1 操作，还必须记录该用户已经对该文章进行了点赞，防止用户点赞次数超过 1。可以建立文章的已投票用户集合来进行记录。 为了节约内存，规定一篇文章发布满一周之后，就不能再对它进行投票，而文章的已投票集合也会被删除，可以为文章的已投票集合设置一个一周的过期时间就能实现这个规定。 对文章进行排序为了按发布时间和点赞数进行排序，可以建立一个文章发布时间的有序集合和一个文章点赞数的有序集合。（下图中的 score 就是这里所说的点赞数；下面所示的有序集合分值并不直接是时间和点赞数，而是根据时间和点赞数间接计算出来的）]]></content>
      <categories>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis指令及部分基础]]></title>
    <url>%2F2019%2F03%2F15%2Fredis%E6%8C%87%E4%BB%A4%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96%2F</url>
    <content type="text"><![CDATA[一、Redis1.什么是Redis？Redis 是Remote Dictionary Server（远程数据服务）的缩写由意大利人antirez（Salvatore Sanfilippo）开发的一款内存高速缓存数据库该软件使用C语言编写，它的数据模型为key-value，它支持丰富的数据结构（类型），比如String list hash set sorted set。可持久化，保证了数据安全。 使用缓存减轻数据库的负载。 在开发网站的时候如果有一些数据在短时间之内不会发生变化，而它们还要被频繁访问，为了提高用户的请求速度和降低网站的负载，就把这些数据放到一个读取速度更快的介质上（或者是通过较少的计算量就可以获得该数据），该行为就称作对该数据的缓存。 该介质可以是文件、数据库、内存，内存经常用于数据缓存。 缓存有两种类型：数据缓存，页面缓存。 举例： 新闻页面(内容单一，集中)，适合用页面缓存； 商品页面的组成部分根据业务特点，各个部分数据比较独立，适合分别做“数据缓存”。 2.redis 和memcache比较 (1)、存储方式 Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。 Redis有部份存在硬盘上，这样能保证数据的持久性。 (2)、数据支持类型 Memcache对数据类型支持相对简单。 Redis有复杂的数据类型。 (3)、使用底层模型不同 它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。 Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。 3.安装Redis 安装Redis 前端启动redis服务 安装成功后，后台启动redis 接着启动 redis-cli即可使用 4.Redis与Memcached的选择终极策略： 使用Redis的String类型做的事，都可以用Memcached替换，以此换取更好的性能提升； 除此以外，优先考虑Redis； 5.使用redis有哪些好处？(1) 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1) (2)支持丰富数据类型，支持string，list，set，sorted set，hash (3) 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行 (4) 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除 二、redis的具体使用 redis中的五种常用类型分别是string,Hash,List,Set,ZSet。 类型 特点 使用场景 string 简单的key-value类型，value其实不仅是String，也可以是数字 定时持久化，操作日志，常规计数， 微博数, 粉丝数等功能 hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象 存储部分变更数据，如用户信息等 list 有序可重复的列表 twitter的关注列表，粉丝列表，最新消息排行，消息队列 set 无序不可重复的列表 在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis还为集合提供了求交集、并集、差集等操作，可以非常方便的实现如共同关注、共同喜好、二度好友等功能 Sorted set 带有score的Set 排行榜 Redis支持的数据类型 Keys 给存储在redis内存中的数据起的变量名字。 注意: (1)key的命名规则不同于一般语言，键盘上除了空格、n换行外其他的大部分字符都可以使用。 像“my key和“mykey\n”这样包含空格和换行的key是不允许的。 (2)我们在使用的时候可以自己定义一个Key的格式。●例如 1object-type :id:field (3)Key不要太长。占内存，查询慢。 (4)Key不要太短。像u：1000：pwd就不如user：1000；password可读性好 Redis keys 命令 下表给出了与 Redis 键相关的基本命令： 12345678910111213// keys键操作exists key //测试指定key是否存在del key1 key2----keyN //删除给定keytype key //返回给定key的value类型keys pattern //返回匹配指定模式的所有keyrename oldkey neukey //改名字dbsize //返回当前数据的key数量expire key seconds //为key 指定过期时间tt1 key //返回key的剩余过期秒数select db-index //选择数据库move key db-index //将key 从当前数据库移动到指定数据库flushdb //删除当前数据库中所有keyf1ushall //删除所有数据库中的所有key keys pattern: 首先创建一些 key，并赋上对应值： 123456redis 127.0.0.1:6379&gt; SET runoob1 redisOKredis 127.0.0.1:6379&gt; SET runoob2 mysqlOKredis 127.0.0.1:6379&gt; SET runoob3 mongodbOK 查找以 runoob 为开头的 key： 1234redis 127.0.0.1:6379&gt; KEYS runoob*1) &quot;runoob3&quot;2) &quot;runoob1&quot;3) &quot;runoob2&quot; 获取 redis 中所有的 key 可用使用 * 1redis 127.0.0.1:6379&gt; KEYS * 不同redis数据库切换 select db-index: 12select 10OK Values Strings（Binary-safe strings） Lists（Lists of binary-safe strings） Sets（Sets of binary-safe strings） Sorted sets（Sorted sets of binary-safe strings） Hash 1.String类型操作string是redis最基本的类型 redis的string 可以包含任何数据。包括ipg.图片或者序列化的对象。 单个value值最大上限是1G字节。 如果只用string类型，redis 就可以被看作加上持久化特性的memcache 12345678910//string类型操作set key value //设置key对应的值为string类型的valuemset key1 value1.…keyN valueN //—次设置多个key的值mget key1 key2.……keyN //一次获取多个key的值incr key //对key的值做加加操作，并返回新的值decr key //同上，但是做的是减减操作incrby key integer //同incr，加指定值decrby key integer //同decr，减指定值append key value //给指定key的字符串值追加valuesubstr key start end //返回截取过的key的字符串值 2.数据类型List链表list类型其实就是一个双向链表。通过push，pop操作从链表的头部或者尾部添加删除元素。 这使得list既可以用作栈，也可以用作队列。 该list链表类型应用场合： 获得最新的10个登录用户信息：select*from user order by logintime desc limit 10；以上sql语句可以实现用户需求，但是数据多的时候，全部数据都要受到影响，对数据库的负载比较高。必要情况还需要给关键字段（id或logintime）设置索引，索引也比较耗费系统资源 如果通过list链表实现以上功能，可以在ist链表中只保留最新的10个数据，每进来一个新数据进来就删除一个旧数据。每次就可以从链表中直接获得需要的数据。极大节省各方面资源消耗 123456789101112131415127.0.0.1:6379[1]&gt; lpush login marry(integer) 1127.0.0.1:6379[1]&gt; lpush login jack(integer) 2127.0.0.1:6379[1]&gt; lpush login tom(integer) 3127.0.0.1:6379[1]&gt; lpush login jane(integer) 4127.0.0.1:6379[1]&gt; lpush login yue(integer) 5127.0.0.1:6379[1]&gt; lpush login dian(integer) 6127.0.0.1:6379[1]&gt; rpop login&quot;marry&quot;127.0.0.1:6379[1]&gt; list的一些相关操作: 12345678//1ist类型操作lpush key string //在key对应1ist的头部添加字符串元素rpop key //从list 的尾部删删除元素，并返回册删除元素llen key //返回key对应list 的长度，key 不存在返回0，如果key 对应类型不是list 返回错误lrange key start end //返回指定区间内的元素，下标从0开始rpush key string //同上，在尾部添加lpop key //从ist 的头部删除元素，并返回删除元素ltrim key start end //截取1ist，保留指定区间内元素 123456789101112131415127.0.0.1:6379[1]&gt; lrange login 0 1001) &quot;dian&quot;2) &quot;yue&quot;3) &quot;jane&quot;4) &quot;tom&quot;5) &quot;jack&quot;127.0.0.1:6379[1]&gt; llen login(integer) 5127.0.0.1:6379[1]&gt; ltrim login 1 3OK127.0.0.1:6379[1]&gt; lrange login 0 1001) &quot;yue&quot;2) &quot;jane&quot;3) &quot;tom&quot;127.0.0.1:6379[1]&gt; 3.Redis 哈希(Hash)Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。 Redis 中每个 hash 可以存储 232 - 1 键值对（40多亿）。 hash的常见命令： 12345678910111213141516##赋值语法hset key field value //为指定的key,设定field/valuehmset key field value [field1,value1]...同时将多个field-value(阈-值)对设置到哈希表key中。#例如 hmset users uname guo age 20 address &quot;北京市&quot;#取值语法：hget key field //获取存储在HASH中的值，根据FIELD得到VALUEhmget key field[field1] //获取key所有给定字段的值hgetall key //返回hash表中所有的字段和值hkeys key //获取所有哈希表中的字段hlen key //获取哈希表中字段的数量#删除语法：hdel key field1[field2] //删除一个或多个HASH表字段#其他语法：略 相关操作： 123456789101112131415161718192021222324252627127.0.0.1:6379&gt; hset yue job student(integer) 1127.0.0.1:6379&gt; hmset yue home hubei age 25OK127.0.0.1:6379&gt; hget yue age&quot;25&quot;127.0.0.1:6379&gt; hgetall yue1) &quot;job&quot;2) &quot;student&quot;3) &quot;home&quot;4) &quot;hubei&quot;5) &quot;age&quot;6) &quot;25&quot;127.0.0.1:6379&gt; hkeys yue1) &quot;job&quot;2) &quot;home&quot;3) &quot;age&quot;127.0.0.1:6379&gt; hlen yue(integer) 3127.0.0.1:6379&gt; hdel yue age(integer) 1127.0.0.1:6379&gt; hgetall yue1) &quot;job&quot;2) &quot;student&quot;3) &quot;home&quot;4) &quot;hubei&quot;127.0.0.1:6379&gt; 4.set集合类型redis的set是string类型的无序集合。 set元素最大可以包含（2的32次方-1）个元素。 关于set集合类型除了基本的添加删除操作，其他有用的操作还包含集合的取并集（union），交集（intersection），差集（difference）。通过这些操作可以很容易的实现sns.中的好友推荐功能。 注意：每个集合中的各个元素不能重复。 该类型应用场合：qq好友推荐。 tom朋友圈（与某某是好友）：aary jack xiaoming wang5 wang6 linken 朋友圈（与某某是好友）：yuehan daxiong luce wang5 wang6 12345678910//set类型操作sadd key member //添加一个string 元素到key对应的set集合中，成功返回1， //如果元素已经在集合中返回0，key对应的set不存在返回错误srem key member[member]//从key 对应set 中移除给定元素，成功返回1smove p1 p2 //menber从p1对应set 中移除 nenber 并添加到p2对应set中返回set的元素个数sismember key nember //判断 menber是否在set中sinter key1 key2-.-keyN //返回所有给定key的交集sunion key1 key2.--keyN //返回所有给定key 的并集sdiff key1 key2-.-keyN //返回所有给定key的差集smembers key //返回key对应set的所有元素，结果是无序的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455127.0.0.1:6379&gt; select 1OK127.0.0.1:6379[1]&gt; sadd tom marry(integer) 1127.0.0.1:6379[1]&gt; sadd tom jack(integer) 1127.0.0.1:6379[1]&gt; sadd tom wang5(integer) 1127.0.0.1:6379[1]&gt; sadd tom wang6(integer) 1127.0.0.1:6379[1]&gt; sadd tom xiaoming(integer) 1127.0.0.1:6379[1]&gt; smembers tom1) &quot;jack&quot;2) &quot;marry&quot;3) &quot;wang5&quot;4) &quot;wang6&quot;5) &quot;xiaoming&quot;127.0.0.1:6379[1]&gt; sadd linken yuehan(integer) 1127.0.0.1:6379[1]&gt; sadd linken daxiong(integer) 1127.0.0.1:6379[1]&gt; sadd linken luce(integer) 1127.0.0.1:6379[1]&gt; sadd linken wang5(integer) 1127.0.0.1:6379[1]&gt; sadd linken wang6(integer) 1127.0.0.1:6379[1]&gt; smembers linken1) &quot;wang5&quot;2) &quot;luce&quot;3) &quot;daxiong&quot;4) &quot;yuehan&quot;5) &quot;wang6&quot;127.0.0.1:6379[1]&gt; sinter tom linken1) &quot;wang5&quot;2) &quot;wang6&quot;127.0.0.1:6379[1]&gt; sunion tom linken1) &quot;wang6&quot;2) &quot;xiaoming&quot;3) &quot;jack&quot;4) &quot;marry&quot;5) &quot;wang5&quot;6) &quot;luce&quot;7) &quot;daxiong&quot;8) &quot;yuehan&quot;127.0.0.1:6379[1]&gt; sdiff tom linken1) &quot;jack&quot;2) &quot;marry&quot;3) &quot;xiaoming&quot;127.0.0.1:6379[1]&gt; sdiff linken tom1) &quot;luce&quot;2) &quot;daxiong&quot;3) &quot;yuehan&quot;127.0.0.1:6379[1]&gt; 5.Sort Set 排序集合类型和set 一样 sorted set 也是string类型元素的集合，不同的是每个元素都会关联一个权。通过权值可以有序的获取集合中的元素该Sort set 类型适合场合： 获得热门帖子（回复量）信息：select*from message order by backnum desclimit 5； （以上需求可以通过简单sql语句实现，但是sgl语句比较耗费mysql数据库资源） 【案例】利用sort set 实现获取最热门的前5帖子信息 排序集合中的每个元素都是值、权的组合 （之前的set集合类型每个元素就只是一个值） 相关指令： 1234567891011//sorted set排序类型zadd key score member //添加元素到集合，元素在集合中存在则更新对应 scorezrem key nember //除指定元素，1表示成功，如果元素不存在返回0zincrby key incr member //按照incr 幅度增加对应 nember的score值，返回 score值zrank key member //返回指定元素在集合中的排名（下标），集合中元素是按 score从小到大排序的zrevrank key member //同上，但是集合中元素是按 score 从大到小排序zrange key start end //类似irange操作从集合中去指定区间的元素。返回的是有序结果zrevrange key start end //同上，返回结果是按 score逆序的zcard key //返回集合中元素个数zscore key member //返回给定元素对应的 scorezrenrangebyrank key min max //删除集合中排名在给定区间的元素 相关操作： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647127.0.0.1:6379[1]&gt; zadd tiezi 102 11(integer) 1127.0.0.1:6379[1]&gt; zadd tiezi 141 12(integer) 1127.0.0.1:6379[1]&gt; zadd tiezi 159 13(integer) 1127.0.0.1:6379[1]&gt; zadd tiezi 72 14(integer) 1127.0.0.1:6379[1]&gt; zadd tiezi 203 15(integer) 1127.0.0.1:6379[1]&gt; zadd tiezi 189 16(integer) 1127.0.0.1:6379[1]&gt; zadd tiezi 191 17(integer) 1127.0.0.1:6379[1]&gt; zadd tiezi 305 18(integer) 1127.0.0.1:6379[1]&gt; zadd tiezi 184 19(integer) 1127.0.0.1:6379[1]&gt; zrang tiezi 0 100(error) ERR unknown command &apos;zrang&apos;127.0.0.1:6379[1]&gt; zrange tiezi 0 1001) &quot;14&quot;2) &quot;11&quot;3) &quot;12&quot;4) &quot;13&quot;5) &quot;19&quot;6) &quot;16&quot;7) &quot;17&quot;8) &quot;15&quot;9) &quot;18&quot;127.0.0.1:6379[1]&gt; zrevrange tiezi 0 1001) &quot;18&quot;2) &quot;15&quot;3) &quot;17&quot;4) &quot;16&quot;5) &quot;19&quot;6) &quot;13&quot;7) &quot;12&quot;8) &quot;11&quot;9) &quot;14&quot;127.0.0.1:6379[1]&gt; zrank tiezi 13(integer) 3127.0.0.1:6379[1]&gt; zcard tiezi(integer) 9127.0.0.1:6379[1]&gt; zscore tiezi 18&quot;305&quot;127.0.0.1:6379[1]&gt; 三.持久化功能redis为了内部数据的安全考虑，会把本身的数据以文件形式保存到硬盘中一份，在服务器重启之后会自动把硬盘的数据恢复到内存（redis）的里边。 数据保存到硬盘的过程就称为“持久化”效果。 1.snap shotting快照持久化该持久化默认开启，一次性把redis中全部的数据保存一份存储在硬盘中(存储在redis-cli所在的文件夹中，文件名dump.rdb)，如果数据非常多（10-20G）就不适合频繁进行该持久化操作。 自动快照持久化： 打开redis.conf可以看到默认快照持久化的频率如下： 123save 900 1save 300 10save 60 10000 save 900 1 #900秒内如果超过1个key被修改，则发起快照保存 save 300 10 #300秒超过10个key被修改，发起快照 save 60 10000 #60秒超过10000个key被修改， 发起快照以上三个save的意思： 数据修改的频率非常高，备份的频率也高,数据修改的频率低，备份的频率也低。 key的修改包括添加、删除和修改，不包括查询。 手动快照持久化： redis的持久化相关指令 bgsave 异步保存数据到磁盘（快照保存） lastsave 返回上次成功保存到磁盘的unix时间载 shutdown 同步保存到服务器并关闭redis服务器 bgrewriteaof 当日志文件过长时优化AOF日志文件存储 123./redis-cli bgrewriteaof./redis-cli bgsave #手动发起快照./redis-cli-h 127.0.0.1 -p 6379 bgsave #手动发起快照 2.append only file（AOF 持久化）本质：把用户执行的每个“写”指令（添加、修改、删除）都备份到文件中，还原数据的时候就是执行具体写指令而已。 开启AOF持久化（会清空redis之前的数据，因此若要开启，最好安装后开启） （同时可以修改备份文件的名字，默认是appendonly.aof和dump.rdb同级目录下） 打开配置文件redis.conf,将appendonly no改为appendonly yes。 配置文件被修改，需要删除旧进程，再根据新的配置文件启动新进程： AOF追加持久化的备份频率(在redis.conf文件中)： 123#appendfsync always #这种方式每次添加、修改和删除都更新，但性能最低appendfsync everysec #每秒更新一次，性能折衷，推荐#appendfsync no #更新频率看服务器心情，性能富裕更新得快，由OS决定，持久化无保障， AOF持久化文件的优化：压缩appendonly.aof文件，例如incr指令执行过程中的中间变量将被删去，只留新的一个，相当于执行set语句。 redis的持久化相关指令 bgsave 异步保存数据到磁盘（快照保存） lastsave 返回上次成功保存到磁盘的unix时间载 shutdown 同步保存到服务器并关闭redis服务器 bgrewriteaof 当日志文件过长时优化AOF日志文件存储 123./redis-cli bgrewriteaof./redis-cli bgsave #手动发起快照./redis-cli-h 127.0.0.1 -p 6379 bgsave #手动发起快照 四、redis的主从模式 为了降低每个redis服务器的负载，可以多设置几个，并做主从模式一个服务器负载“写”数据，其他服务器负载“读”数据主服务器数据会“自动”同步给从服务器]]></content>
      <categories>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
</search>
