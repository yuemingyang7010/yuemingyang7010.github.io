<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[剑指offer]-圆圈中最后剩下的数]]></title>
    <url>%2F2019%2F06%2F17%2F%E5%89%91%E6%8C%87offer-%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：圆圈中最后剩下的数 题目：0，1，n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。 思路：用约瑟夫环的思想例如，0、1、2、3、4这5个数字组成一个圆圈（如图6.3所示），从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。 可以用模板库中的std:list来模拟一个环形链表。由于std:：list本身并不是一个环形结构，因此每当迭代器（Iterator）扫描到链表末尾的时候，我们要记得把迭代器移到链表的头部。]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[剑指offer]-复杂链表的复制]]></title>
    <url>%2F2019%2F06%2F17%2F%E5%89%91%E6%8C%87offer-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6%2F</url>
    <content type="text"><![CDATA[题目描述输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）思路：(在不借助辅助空间的情况下，实现O(n)的时间效率)分为三步走： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/*struct RandomListNode &#123; int label; struct RandomListNode *next, *random; RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: RandomListNode* Clone(RandomListNode* pHead) &#123; if(pHead == NULL) return NULL; //第一步：遍历链表，复制每个结点，如复制结点A得到A1，将结点A1插到结点A后面； RandomListNode* curNode = pHead; while(curNode != NULL)&#123; RandomListNode* pCloned = new RandomListNode(0); pCloned-&gt;label = curNode-&gt;label; pCloned-&gt;next = curNode-&gt;next; pCloned-&gt;random = NULL; curNode-&gt;next = pCloned; curNode = pCloned-&gt;next; &#125; //第二步：重新遍历链表，复制老结点的随机指针给新结点，如A1.random = A.random.next; curNode = pHead; while(curNode != NULL)&#123; RandomListNode* pCloned = curNode-&gt;next; if(curNode-&gt;random != NULL)&#123; //！！！！很关键的一个判断，不然就出现野指针 pCloned-&gt;random = curNode-&gt;random-&gt;next; &#125; curNode = pCloned-&gt;next; &#125; //第三步：拆分链表，将链表拆分为原链表和复制后的链表 curNode = pHead; RandomListNode* pCloneHead = pHead-&gt;next; while(curNode != NULL)&#123; RandomListNode* pCloneNode = curNode-&gt;next; //临时存放当前节点的下一个指针 curNode-&gt;next = curNode-&gt;next-&gt;next; //原始链表，隔一个节点连接一个 //复制后链表，隔一个节点连接一个，但是要考虑该节点是最后一个的情况 pCloneNode-&gt;next = pCloneNode-&gt;next == NULL?NULL:pCloneNode-&gt;next-&gt;next; curNode = curNode-&gt;next; //移到下一个原始节点 &#125; return pCloneHead; &#125;&#125;;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[剑指offer]-合并两个排序的链表]]></title>
    <url>%2F2019%2F06%2F17%2F%E5%89%91%E6%8C%87offer-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目描述输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 123456789101112131415161718192021222324252627282930313233343536373839/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* Merge(ListNode* pHead1, ListNode* pHead2) &#123; if(pHead1 ==NULL) return pHead2; if(pHead2 == NULL) return pHead1; ListNode* pre_head = new ListNode(0); ListNode* pTemp = pre_head; while(pHead1 !=NULL &amp;&amp; pHead2 != NULL)&#123; if(pHead1-&gt;val &lt; pHead2-&gt;val)&#123; pTemp-&gt;next = pHead1; pHead1 = pHead1-&gt;next; &#125; else&#123; pTemp-&gt;next = pHead2; pHead2 = pHead2-&gt;next; &#125; pTemp = pTemp-&gt;next; &#125; //将比较后某一个原始链表剩余部分直接插到新的链表后方 if(pHead1) pTemp-&gt;next = pHead1; if(pHead2) pTemp-&gt;next = pHead2; ListNode* ans = pre_head-&gt;next; delete pre_head; return ans; &#125;&#125;;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[剑指offer]-链表中倒数第K个节点]]></title>
    <url>%2F2019%2F06%2F17%2F%E5%89%91%E6%8C%87offer-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACK%E4%B8%AA%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目：输入一个链表，输出该链表中倒数第k个结点。 思路：快慢指针 123456789101112131415161718192021222324252627/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) &#123; ListNode* fast = pListHead; ListNode* low = pListHead; while(k &gt; 0)&#123; if(fast == NULL)&#123; return NULL; //防止越界错误！！！要加 &#125; fast = fast-&gt;next; k--; &#125; while(fast != NULL)&#123; fast = fast-&gt;next; low = low-&gt;next; &#125; return low; &#125;&#125;;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[剑指offer]-从尾到头打印链表]]></title>
    <url>%2F2019%2F06%2F17%2F%E5%89%91%E6%8C%87offer-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目描述输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 思路分析：其实本题和链表逆序很类似，链表逆序要求改变链表，采用头插法。此题逆序打印链表，一般理解为不改变链表结构，因此采用栈的结构。 1234567891011121314151617181920212223242526272829/*** struct ListNode &#123;* int val;* struct ListNode *next;* ListNode(int x) :* val(x), next(NULL) &#123;* &#125;* &#125;;*/#include &lt;stack&gt;#include &lt;vector&gt;class Solution &#123;public: vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123; std::stack&lt;ListNode*&gt; nodes; vector&lt;int&gt; mVector; ListNode* pNodes = head; while(pNodes != NULL)&#123; nodes.push(pNodes); pNodes = pNodes-&gt;next; &#125; while(!nodes.empty())&#123; pNodes = nodes.top(); mVector.push_back(pNodes-&gt;val); nodes.pop(); &#125; return mVector; &#125;&#125;;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>链表</tag>
      </tags>
  </entry>
</search>
