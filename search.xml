<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[剑指offer]-复杂链表的复制]]></title>
    <url>%2F2019%2F06%2F17%2F%E5%89%91%E6%8C%87offer-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6%2F</url>
    <content type="text"><![CDATA[题目描述输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） 思路：(在不借助辅助空间的情况下，实现O(n)的时间效率)分为三步走： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/*struct RandomListNode &#123; int label; struct RandomListNode *next, *random; RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: RandomListNode* Clone(RandomListNode* pHead) &#123; if(pHead == NULL) return NULL; //第一步：遍历链表，复制每个结点，如复制结点A得到A1，将结点A1插到结点A后面； RandomListNode* curNode = pHead; while(curNode != NULL)&#123; RandomListNode* pCloned = new RandomListNode(0); pCloned-&gt;label = curNode-&gt;label; pCloned-&gt;next = curNode-&gt;next; pCloned-&gt;random = NULL; curNode-&gt;next = pCloned; curNode = pCloned-&gt;next; &#125; //第二步：重新遍历链表，复制老结点的随机指针给新结点，如A1.random = A.random.next; curNode = pHead; while(curNode != NULL)&#123; RandomListNode* pCloned = curNode-&gt;next; if(curNode-&gt;random != NULL)&#123; //！！！！很关键的一个判断，不然就出现野指针 pCloned-&gt;random = curNode-&gt;random-&gt;next; &#125; curNode = pCloned-&gt;next; &#125; //第三步：拆分链表，将链表拆分为原链表和复制后的链表 curNode = pHead; RandomListNode* pCloneHead = pHead-&gt;next; while(curNode != NULL)&#123; RandomListNode* pCloneNode = curNode-&gt;next; //临时存放当前节点的下一个指针 curNode-&gt;next = curNode-&gt;next-&gt;next; //原始链表，隔一个节点连接一个 //复制后链表，隔一个节点连接一个，但是要考虑该节点是最后一个的情况 pCloneNode-&gt;next = pCloneNode-&gt;next == NULL?NULL:pCloneNode-&gt;next-&gt;next; curNode = curNode-&gt;next; //移到下一个原始节点 &#125; return pCloneHead; &#125;&#125;;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[剑指offer]-圆圈中最后剩下的数]]></title>
    <url>%2F2019%2F06%2F17%2F%E5%89%91%E6%8C%87offer-%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：圆圈中最后剩下的数 题目：0，1，n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。 思路：用约瑟夫环的思想例如，0、1、2、3、4这5个数字组成一个圆圈（如图6.3所示），从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。 可以用模板库中的std:list来模拟一个环形链表。由于std:：list本身并不是一个环形结构，因此每当迭代器（Iterator）扫描到链表末尾的时候，我们要记得把迭代器移到链表的头部。 123456789101112131415161718192021222324252627class Solution &#123;public: int LastRemaining_Solution(int n, int m) &#123; if (n &lt; 1 || m &lt; 1) return -1; list&lt;int&gt; mlist; for (int i = 0; i &lt; n; i++) mlist.push_back(i); long count = 0; auto it = mlist.begin(); int k = m - 1; while (mlist.size() &gt; 1) &#123; while (k--) &#123; it++; if (it == mlist.end()) it = mlist.begin(); &#125; it = mlist.erase(it); if (it == mlist.end()) it = mlist.begin(); k = m - 1; &#125; return mlist.front(); &#125;&#125;;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[剑指offer]-合并两个排序的链表]]></title>
    <url>%2F2019%2F06%2F17%2F%E5%89%91%E6%8C%87offer-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目描述输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 123456789101112131415161718192021222324252627282930313233343536373839/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* Merge(ListNode* pHead1, ListNode* pHead2) &#123; if(pHead1 ==NULL) return pHead2; if(pHead2 == NULL) return pHead1; ListNode* pre_head = new ListNode(0); ListNode* pTemp = pre_head; while(pHead1 !=NULL &amp;&amp; pHead2 != NULL)&#123; if(pHead1-&gt;val &lt; pHead2-&gt;val)&#123; pTemp-&gt;next = pHead1; pHead1 = pHead1-&gt;next; &#125; else&#123; pTemp-&gt;next = pHead2; pHead2 = pHead2-&gt;next; &#125; pTemp = pTemp-&gt;next; &#125; //将比较后某一个原始链表剩余部分直接插到新的链表后方 if(pHead1) pTemp-&gt;next = pHead1; if(pHead2) pTemp-&gt;next = pHead2; ListNode* ans = pre_head-&gt;next; delete pre_head; return ans; &#125;&#125;;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[剑指offer]-链表中倒数第K个节点]]></title>
    <url>%2F2019%2F06%2F17%2F%E5%89%91%E6%8C%87offer-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACK%E4%B8%AA%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目：输入一个链表，输出该链表中倒数第k个结点。 思路：快慢指针 123456789101112131415161718192021222324252627/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) &#123; ListNode* fast = pListHead; ListNode* low = pListHead; while(k &gt; 0)&#123; if(fast == NULL)&#123; return NULL; //防止越界错误！！！要加 &#125; fast = fast-&gt;next; k--; &#125; while(fast != NULL)&#123; fast = fast-&gt;next; low = low-&gt;next; &#125; return low; &#125;&#125;;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[剑指offer]-从尾到头打印链表]]></title>
    <url>%2F2019%2F06%2F17%2F%E5%89%91%E6%8C%87offer-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目描述输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 思路分析：其实本题和链表逆序很类似，链表逆序要求改变链表，采用头插法。此题逆序打印链表，一般理解为不改变链表结构，因此采用栈的结构。 1234567891011121314151617181920212223242526272829/*** struct ListNode &#123;* int val;* struct ListNode *next;* ListNode(int x) :* val(x), next(NULL) &#123;* &#125;* &#125;;*/#include &lt;stack&gt;#include &lt;vector&gt;class Solution &#123;public: vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123; std::stack&lt;ListNode*&gt; nodes; vector&lt;int&gt; mVector; ListNode* pNodes = head; while(pNodes != NULL)&#123; nodes.push(pNodes); pNodes = pNodes-&gt;next; &#125; while(!nodes.empty())&#123; pNodes = nodes.top(); mVector.push_back(pNodes-&gt;val); nodes.pop(); &#125; return mVector; &#125;&#125;;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络-概述]]></title>
    <url>%2F2019%2F03%2F17%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[网络的网络网络把主机连接起来，而互联网是把多种不同的网络连接起来，因此互联网是网络的网络。 ISP互联网服务提供商 ISP 可以从互联网管理机构获得许多 IP 地址，同时拥有通信线路以及路由器等联网设备，个人或机构向 ISP 缴纳一定的费用就可以接入互联网。 目前的互联网是一种多层次 ISP 结构，ISP 根据覆盖面积的大小分为第一层 ISP、区域 ISP 和接入 ISP。互联网交换点 IXP 允许两个 ISP 直接相连而不用经过第三个 ISP。 主机之间的通信方式 客户-服务器（C/S）：客户是服务的请求方，服务器是服务的提供方。 对等（P2P）：不区分客户和服务器。 电路交换与分组交换1. 电路交换电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。 2. 分组交换每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。 在一个邮局通信系统中，邮局收到一份邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，这个过程就是存储转发过程，分组交换也使用了存储转发过程。 时延总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延 1. 排队时延分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。 2. 处理时延主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。 3. 传输时延主机或路由器传输数据帧所需要的时间。 其中 l 表示数据帧的长度，v 表示传输速率。 4. 传播时延电磁波在信道中传播所需要花费的时间，电磁波传播的速度接近光速。 其中 l 表示信道长度，v 表示电磁波在信道上的传播速度。 计算机网络体系结构 1. 五层协议 应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。 传输层 ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。 网络层 ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。 数据链路层 ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。 物理层 ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。 2. OSI其中表示层和会话层用途如下： 表示层 ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。 会话层 ：建立及管理会话。 五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。 3. TCP/IP它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。 TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。 4. 数据在各层之间的传递过程在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。 路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
</search>
